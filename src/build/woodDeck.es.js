import * as O from "react";
import Fe, { version as F8, isValidElement as AU, useContext as ni, createContext as hg, useRef as kt, useLayoutEffect as xA, useEffect as In, forwardRef as Al, useMemo as Mr, useState as Lr, Children as U8, createRef as z8, useCallback as Mh, useImperativeHandle as aE, cloneElement as OT, useDebugValue as PT, createElement as B8, memo as H8, useReducer as V8 } from "react";
import * as k8 from "react-dom";
import sx, { createPortal as $8, unstable_batchedUpdates as W8, flushSync as vN } from "react-dom";
function j8(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var OU = { exports: {} }, Vi = OU.exports = {}, tc, nc;
function DT() {
  throw new Error("setTimeout has not been defined");
}
function IT() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? tc = setTimeout : tc = DT;
  } catch {
    tc = DT;
  }
  try {
    typeof clearTimeout == "function" ? nc = clearTimeout : nc = IT;
  } catch {
    nc = IT;
  }
})();
function PU(n) {
  if (tc === setTimeout)
    return setTimeout(n, 0);
  if ((tc === DT || !tc) && setTimeout)
    return tc = setTimeout, setTimeout(n, 0);
  try {
    return tc(n, 0);
  } catch {
    try {
      return tc.call(null, n, 0);
    } catch {
      return tc.call(this, n, 0);
    }
  }
}
function G8(n) {
  if (nc === clearTimeout)
    return clearTimeout(n);
  if ((nc === IT || !nc) && clearTimeout)
    return nc = clearTimeout, clearTimeout(n);
  try {
    return nc(n);
  } catch {
    try {
      return nc.call(null, n);
    } catch {
      return nc.call(this, n);
    }
  }
}
var au = [], qm = !1, oh, W_ = -1;
function X8() {
  !qm || !oh || (qm = !1, oh.length ? au = oh.concat(au) : W_ = -1, au.length && DU());
}
function DU() {
  if (!qm) {
    var n = PU(X8);
    qm = !0;
    for (var e = au.length; e; ) {
      for (oh = au, au = []; ++W_ < e; )
        oh && oh[W_].run();
      W_ = -1, e = au.length;
    }
    oh = null, qm = !1, G8(n);
  }
}
Vi.nextTick = function(n) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
  au.push(new IU(n, e)), au.length === 1 && !qm && PU(DU);
};
function IU(n, e) {
  this.fun = n, this.array = e;
}
IU.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Vi.title = "browser";
Vi.browser = !0;
Vi.env = {};
Vi.argv = [];
Vi.version = "";
Vi.versions = {};
function bu() {
}
Vi.on = bu;
Vi.addListener = bu;
Vi.once = bu;
Vi.off = bu;
Vi.removeListener = bu;
Vi.removeAllListeners = bu;
Vi.emit = bu;
Vi.prependListener = bu;
Vi.prependOnceListener = bu;
Vi.listeners = function(n) {
  return [];
};
Vi.binding = function(n) {
  throw new Error("process.binding is not supported");
};
Vi.cwd = function() {
  return "/";
};
Vi.chdir = function(n) {
  throw new Error("process.chdir is not supported");
};
Vi.umask = function() {
  return 0;
};
var q8 = OU.exports;
const Ee = /* @__PURE__ */ j8(q8);
function y0(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Y8(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
var NT = { exports: {} }, $v = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yN;
function K8() {
  if (yN) return $v;
  yN = 1;
  var n = Fe, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(s, u, d) {
    var f, p = {}, g = null, v = null;
    d !== void 0 && (g = "" + d), u.key !== void 0 && (g = "" + u.key), u.ref !== void 0 && (v = u.ref);
    for (f in u) r.call(u, f) && !a.hasOwnProperty(f) && (p[f] = u[f]);
    if (s && s.defaultProps) for (f in u = s.defaultProps, u) p[f] === void 0 && (p[f] = u[f]);
    return { $$typeof: e, type: s, key: g, ref: v, props: p, _owner: i.current };
  }
  return $v.Fragment = t, $v.jsx = o, $v.jsxs = o, $v;
}
var Wv = {}, bN;
function Z8() {
  return bN || (bN = 1, Ee.env.NODE_ENV !== "production" && function() {
    var n = Fe, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), b = Symbol.iterator, E = "@@iterator";
    function S(ge) {
      if (ge === null || typeof ge != "object")
        return null;
      var it = b && ge[b] || ge[E];
      return typeof it == "function" ? it : null;
    }
    var _ = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(ge) {
      {
        for (var it = arguments.length, yt = new Array(it > 1 ? it - 1 : 0), Kt = 1; Kt < it; Kt++)
          yt[Kt - 1] = arguments[Kt];
        C("error", ge, yt);
      }
    }
    function C(ge, it, yt) {
      {
        var Kt = _.ReactDebugCurrentFrame, Sn = Kt.getStackAddendum();
        Sn !== "" && (it += "%s", yt = yt.concat([Sn]));
        var ee = yt.map(function(_e) {
          return String(_e);
        });
        ee.unshift("Warning: " + it), Function.prototype.apply.call(console[ge], console, ee);
      }
    }
    var R = !1, P = !1, D = !1, I = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function N(ge) {
      return !!(typeof ge == "string" || typeof ge == "function" || ge === r || ge === a || U || ge === i || ge === d || ge === f || I || ge === v || R || P || D || typeof ge == "object" && ge !== null && (ge.$$typeof === g || ge.$$typeof === p || ge.$$typeof === o || ge.$$typeof === s || ge.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ge.$$typeof === L || ge.getModuleId !== void 0));
    }
    function H(ge, it, yt) {
      var Kt = ge.displayName;
      if (Kt)
        return Kt;
      var Sn = it.displayName || it.name || "";
      return Sn !== "" ? yt + "(" + Sn + ")" : yt;
    }
    function j(ge) {
      return ge.displayName || "Context";
    }
    function G(ge) {
      if (ge == null)
        return null;
      if (typeof ge.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ge == "function")
        return ge.displayName || ge.name || null;
      if (typeof ge == "string")
        return ge;
      switch (ge) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case a:
          return "Profiler";
        case i:
          return "StrictMode";
        case d:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof ge == "object")
        switch (ge.$$typeof) {
          case s:
            var it = ge;
            return j(it) + ".Consumer";
          case o:
            var yt = ge;
            return j(yt._context) + ".Provider";
          case u:
            return H(ge, ge.render, "ForwardRef");
          case p:
            var Kt = ge.displayName || null;
            return Kt !== null ? Kt : G(ge.type) || "Memo";
          case g: {
            var Sn = ge, ee = Sn._payload, _e = Sn._init;
            try {
              return G(_e(ee));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var X = Object.assign, ae = 0, Z, K, B, Q, V, q, ne;
    function ce() {
    }
    ce.__reactDisabledLog = !0;
    function ie() {
      {
        if (ae === 0) {
          Z = console.log, K = console.info, B = console.warn, Q = console.error, V = console.group, q = console.groupCollapsed, ne = console.groupEnd;
          var ge = {
            configurable: !0,
            enumerable: !0,
            value: ce,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ge,
            log: ge,
            warn: ge,
            error: ge,
            group: ge,
            groupCollapsed: ge,
            groupEnd: ge
          });
        }
        ae++;
      }
    }
    function oe() {
      {
        if (ae--, ae === 0) {
          var ge = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: X({}, ge, {
              value: Z
            }),
            info: X({}, ge, {
              value: K
            }),
            warn: X({}, ge, {
              value: B
            }),
            error: X({}, ge, {
              value: Q
            }),
            group: X({}, ge, {
              value: V
            }),
            groupCollapsed: X({}, ge, {
              value: q
            }),
            groupEnd: X({}, ge, {
              value: ne
            })
          });
        }
        ae < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var he = _.ReactCurrentDispatcher, le;
    function ve(ge, it, yt) {
      {
        if (le === void 0)
          try {
            throw Error();
          } catch (Sn) {
            var Kt = Sn.stack.trim().match(/\n( *(at )?)/);
            le = Kt && Kt[1] || "";
          }
        return `
` + le + ge;
      }
    }
    var Ne = !1, xe;
    {
      var Me = typeof WeakMap == "function" ? WeakMap : Map;
      xe = new Me();
    }
    function $(ge, it) {
      if (!ge || Ne)
        return "";
      {
        var yt = xe.get(ge);
        if (yt !== void 0)
          return yt;
      }
      var Kt;
      Ne = !0;
      var Sn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ee;
      ee = he.current, he.current = null, ie();
      try {
        if (it) {
          var _e = function() {
            throw Error();
          };
          if (Object.defineProperty(_e.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(_e, []);
            } catch (Ht) {
              Kt = Ht;
            }
            Reflect.construct(ge, [], _e);
          } else {
            try {
              _e.call();
            } catch (Ht) {
              Kt = Ht;
            }
            ge.call(_e.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ht) {
            Kt = Ht;
          }
          ge();
        }
      } catch (Ht) {
        if (Ht && Kt && typeof Ht.stack == "string") {
          for (var Ae = Ht.stack.split(`
`), Ce = Kt.stack.split(`
`), pe = Ae.length - 1, je = Ce.length - 1; pe >= 1 && je >= 0 && Ae[pe] !== Ce[je]; )
            je--;
          for (; pe >= 1 && je >= 0; pe--, je--)
            if (Ae[pe] !== Ce[je]) {
              if (pe !== 1 || je !== 1)
                do
                  if (pe--, je--, je < 0 || Ae[pe] !== Ce[je]) {
                    var bt = `
` + Ae[pe].replace(" at new ", " at ");
                    return ge.displayName && bt.includes("<anonymous>") && (bt = bt.replace("<anonymous>", ge.displayName)), typeof ge == "function" && xe.set(ge, bt), bt;
                  }
                while (pe >= 1 && je >= 0);
              break;
            }
        }
      } finally {
        Ne = !1, he.current = ee, oe(), Error.prepareStackTrace = Sn;
      }
      var It = ge ? ge.displayName || ge.name : "", Lt = It ? ve(It) : "";
      return typeof ge == "function" && xe.set(ge, Lt), Lt;
    }
    function Te(ge, it, yt) {
      return $(ge, !1);
    }
    function se(ge) {
      var it = ge.prototype;
      return !!(it && it.isReactComponent);
    }
    function Ie(ge, it, yt) {
      if (ge == null)
        return "";
      if (typeof ge == "function")
        return $(ge, se(ge));
      if (typeof ge == "string")
        return ve(ge);
      switch (ge) {
        case d:
          return ve("Suspense");
        case f:
          return ve("SuspenseList");
      }
      if (typeof ge == "object")
        switch (ge.$$typeof) {
          case u:
            return Te(ge.render);
          case p:
            return Ie(ge.type, it, yt);
          case g: {
            var Kt = ge, Sn = Kt._payload, ee = Kt._init;
            try {
              return Ie(ee(Sn), it, yt);
            } catch {
            }
          }
        }
      return "";
    }
    var be = Object.prototype.hasOwnProperty, et = {}, Xe = _.ReactDebugCurrentFrame;
    function $e(ge) {
      if (ge) {
        var it = ge._owner, yt = Ie(ge.type, ge._source, it ? it.type : null);
        Xe.setExtraStackFrame(yt);
      } else
        Xe.setExtraStackFrame(null);
    }
    function te(ge, it, yt, Kt, Sn) {
      {
        var ee = Function.call.bind(be);
        for (var _e in ge)
          if (ee(ge, _e)) {
            var Ae = void 0;
            try {
              if (typeof ge[_e] != "function") {
                var Ce = Error((Kt || "React class") + ": " + yt + " type `" + _e + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ge[_e] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ce.name = "Invariant Violation", Ce;
              }
              Ae = ge[_e](it, _e, Kt, yt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (pe) {
              Ae = pe;
            }
            Ae && !(Ae instanceof Error) && ($e(Sn), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Kt || "React class", yt, _e, typeof Ae), $e(null)), Ae instanceof Error && !(Ae.message in et) && (et[Ae.message] = !0, $e(Sn), w("Failed %s type: %s", yt, Ae.message), $e(null));
          }
      }
    }
    var Y = Array.isArray;
    function Se(ge) {
      return Y(ge);
    }
    function Oe(ge) {
      {
        var it = typeof Symbol == "function" && Symbol.toStringTag, yt = it && ge[Symbol.toStringTag] || ge.constructor.name || "Object";
        return yt;
      }
    }
    function Pe(ge) {
      try {
        return Ve(ge), !1;
      } catch {
        return !0;
      }
    }
    function Ve(ge) {
      return "" + ge;
    }
    function Ze(ge) {
      if (Pe(ge))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Oe(ge)), Ve(ge);
    }
    var nt = _.ReactCurrentOwner, ht = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, pt, Be, ye;
    ye = {};
    function Ue(ge) {
      if (be.call(ge, "ref")) {
        var it = Object.getOwnPropertyDescriptor(ge, "ref").get;
        if (it && it.isReactWarning)
          return !1;
      }
      return ge.ref !== void 0;
    }
    function Ye(ge) {
      if (be.call(ge, "key")) {
        var it = Object.getOwnPropertyDescriptor(ge, "key").get;
        if (it && it.isReactWarning)
          return !1;
      }
      return ge.key !== void 0;
    }
    function tt(ge, it) {
      if (typeof ge.ref == "string" && nt.current && it && nt.current.stateNode !== it) {
        var yt = G(nt.current.type);
        ye[yt] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', G(nt.current.type), ge.ref), ye[yt] = !0);
      }
    }
    function st(ge, it) {
      {
        var yt = function() {
          pt || (pt = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", it));
        };
        yt.isReactWarning = !0, Object.defineProperty(ge, "key", {
          get: yt,
          configurable: !0
        });
      }
    }
    function Tt(ge, it) {
      {
        var yt = function() {
          Be || (Be = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", it));
        };
        yt.isReactWarning = !0, Object.defineProperty(ge, "ref", {
          get: yt,
          configurable: !0
        });
      }
    }
    var Rt = function(ge, it, yt, Kt, Sn, ee, _e) {
      var Ae = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: ge,
        key: it,
        ref: yt,
        props: _e,
        // Record the component responsible for creating this element.
        _owner: ee
      };
      return Ae._store = {}, Object.defineProperty(Ae._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ae, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Kt
      }), Object.defineProperty(Ae, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Sn
      }), Object.freeze && (Object.freeze(Ae.props), Object.freeze(Ae)), Ae;
    };
    function ue(ge, it, yt, Kt, Sn) {
      {
        var ee, _e = {}, Ae = null, Ce = null;
        yt !== void 0 && (Ze(yt), Ae = "" + yt), Ye(it) && (Ze(it.key), Ae = "" + it.key), Ue(it) && (Ce = it.ref, tt(it, Sn));
        for (ee in it)
          be.call(it, ee) && !ht.hasOwnProperty(ee) && (_e[ee] = it[ee]);
        if (ge && ge.defaultProps) {
          var pe = ge.defaultProps;
          for (ee in pe)
            _e[ee] === void 0 && (_e[ee] = pe[ee]);
        }
        if (Ae || Ce) {
          var je = typeof ge == "function" ? ge.displayName || ge.name || "Unknown" : ge;
          Ae && st(_e, je), Ce && Tt(_e, je);
        }
        return Rt(ge, Ae, Ce, Sn, Kt, nt.current, _e);
      }
    }
    var De = _.ReactCurrentOwner, Ge = _.ReactDebugCurrentFrame;
    function We(ge) {
      if (ge) {
        var it = ge._owner, yt = Ie(ge.type, ge._source, it ? it.type : null);
        Ge.setExtraStackFrame(yt);
      } else
        Ge.setExtraStackFrame(null);
    }
    var He;
    He = !1;
    function ut(ge) {
      return typeof ge == "object" && ge !== null && ge.$$typeof === e;
    }
    function vt() {
      {
        if (De.current) {
          var ge = G(De.current.type);
          if (ge)
            return `

Check the render method of \`` + ge + "`.";
        }
        return "";
      }
    }
    function _t(ge) {
      return "";
    }
    var Wt = {};
    function lt(ge) {
      {
        var it = vt();
        if (!it) {
          var yt = typeof ge == "string" ? ge : ge.displayName || ge.name;
          yt && (it = `

Check the top-level render call using <` + yt + ">.");
        }
        return it;
      }
    }
    function Ct(ge, it) {
      {
        if (!ge._store || ge._store.validated || ge.key != null)
          return;
        ge._store.validated = !0;
        var yt = lt(it);
        if (Wt[yt])
          return;
        Wt[yt] = !0;
        var Kt = "";
        ge && ge._owner && ge._owner !== De.current && (Kt = " It was passed a child from " + G(ge._owner.type) + "."), We(ge), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', yt, Kt), We(null);
      }
    }
    function un(ge, it) {
      {
        if (typeof ge != "object")
          return;
        if (Se(ge))
          for (var yt = 0; yt < ge.length; yt++) {
            var Kt = ge[yt];
            ut(Kt) && Ct(Kt, it);
          }
        else if (ut(ge))
          ge._store && (ge._store.validated = !0);
        else if (ge) {
          var Sn = S(ge);
          if (typeof Sn == "function" && Sn !== ge.entries)
            for (var ee = Sn.call(ge), _e; !(_e = ee.next()).done; )
              ut(_e.value) && Ct(_e.value, it);
        }
      }
    }
    function Nn(ge) {
      {
        var it = ge.type;
        if (it == null || typeof it == "string")
          return;
        var yt;
        if (typeof it == "function")
          yt = it.propTypes;
        else if (typeof it == "object" && (it.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        it.$$typeof === p))
          yt = it.propTypes;
        else
          return;
        if (yt) {
          var Kt = G(it);
          te(yt, ge.props, "prop", Kt, ge);
        } else if (it.PropTypes !== void 0 && !He) {
          He = !0;
          var Sn = G(it);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Sn || "Unknown");
        }
        typeof it.getDefaultProps == "function" && !it.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function xt(ge) {
      {
        for (var it = Object.keys(ge.props), yt = 0; yt < it.length; yt++) {
          var Kt = it[yt];
          if (Kt !== "children" && Kt !== "key") {
            We(ge), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Kt), We(null);
            break;
          }
        }
        ge.ref !== null && (We(ge), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var Pt = {};
    function Bt(ge, it, yt, Kt, Sn, ee) {
      {
        var _e = N(ge);
        if (!_e) {
          var Ae = "";
          (ge === void 0 || typeof ge == "object" && ge !== null && Object.keys(ge).length === 0) && (Ae += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ce = _t();
          Ce ? Ae += Ce : Ae += vt();
          var pe;
          ge === null ? pe = "null" : Se(ge) ? pe = "array" : ge !== void 0 && ge.$$typeof === e ? (pe = "<" + (G(ge.type) || "Unknown") + " />", Ae = " Did you accidentally export a JSX literal instead of a component?") : pe = typeof ge, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", pe, Ae);
        }
        var je = ue(ge, it, yt, Sn, ee);
        if (je == null)
          return je;
        if (_e) {
          var bt = it.children;
          if (bt !== void 0)
            if (Kt)
              if (Se(bt)) {
                for (var It = 0; It < bt.length; It++)
                  un(bt[It], ge);
                Object.freeze && Object.freeze(bt);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              un(bt, ge);
        }
        if (be.call(it, "key")) {
          var Lt = G(ge), Ht = Object.keys(it).filter(function(Rn) {
            return Rn !== "key";
          }), on = Ht.length > 0 ? "{key: someKey, " + Ht.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Pt[Lt + on]) {
            var sn = Ht.length > 0 ? "{" + Ht.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, on, Lt, sn, Lt), Pt[Lt + on] = !0;
          }
        }
        return ge === r ? xt(je) : Nn(je), je;
      }
    }
    function Qt(ge, it, yt) {
      return Bt(ge, it, yt, !0);
    }
    function vn(ge, it, yt) {
      return Bt(ge, it, yt, !1);
    }
    var Mn = vn, cr = Qt;
    Wv.Fragment = r, Wv.jsx = Mn, Wv.jsxs = cr;
  }()), Wv;
}
Ee.env.NODE_ENV === "production" ? NT.exports = K8() : NT.exports = Z8();
var zt = NT.exports, oE = { exports: {} }, NU = {}, LT = { exports: {} }, xS = { exports: {} }, Ar = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var SN;
function Q8() {
  if (SN) return Ar;
  SN = 1;
  var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, i = n ? Symbol.for("react.strict_mode") : 60108, a = n ? Symbol.for("react.profiler") : 60114, o = n ? Symbol.for("react.provider") : 60109, s = n ? Symbol.for("react.context") : 60110, u = n ? Symbol.for("react.async_mode") : 60111, d = n ? Symbol.for("react.concurrent_mode") : 60111, f = n ? Symbol.for("react.forward_ref") : 60112, p = n ? Symbol.for("react.suspense") : 60113, g = n ? Symbol.for("react.suspense_list") : 60120, v = n ? Symbol.for("react.memo") : 60115, b = n ? Symbol.for("react.lazy") : 60116, E = n ? Symbol.for("react.block") : 60121, S = n ? Symbol.for("react.fundamental") : 60117, _ = n ? Symbol.for("react.responder") : 60118, w = n ? Symbol.for("react.scope") : 60119;
  function C(P) {
    if (typeof P == "object" && P !== null) {
      var D = P.$$typeof;
      switch (D) {
        case e:
          switch (P = P.type, P) {
            case u:
            case d:
            case r:
            case a:
            case i:
            case p:
              return P;
            default:
              switch (P = P && P.$$typeof, P) {
                case s:
                case f:
                case b:
                case v:
                case o:
                  return P;
                default:
                  return D;
              }
          }
        case t:
          return D;
      }
    }
  }
  function R(P) {
    return C(P) === d;
  }
  return Ar.AsyncMode = u, Ar.ConcurrentMode = d, Ar.ContextConsumer = s, Ar.ContextProvider = o, Ar.Element = e, Ar.ForwardRef = f, Ar.Fragment = r, Ar.Lazy = b, Ar.Memo = v, Ar.Portal = t, Ar.Profiler = a, Ar.StrictMode = i, Ar.Suspense = p, Ar.isAsyncMode = function(P) {
    return R(P) || C(P) === u;
  }, Ar.isConcurrentMode = R, Ar.isContextConsumer = function(P) {
    return C(P) === s;
  }, Ar.isContextProvider = function(P) {
    return C(P) === o;
  }, Ar.isElement = function(P) {
    return typeof P == "object" && P !== null && P.$$typeof === e;
  }, Ar.isForwardRef = function(P) {
    return C(P) === f;
  }, Ar.isFragment = function(P) {
    return C(P) === r;
  }, Ar.isLazy = function(P) {
    return C(P) === b;
  }, Ar.isMemo = function(P) {
    return C(P) === v;
  }, Ar.isPortal = function(P) {
    return C(P) === t;
  }, Ar.isProfiler = function(P) {
    return C(P) === a;
  }, Ar.isStrictMode = function(P) {
    return C(P) === i;
  }, Ar.isSuspense = function(P) {
    return C(P) === p;
  }, Ar.isValidElementType = function(P) {
    return typeof P == "string" || typeof P == "function" || P === r || P === d || P === a || P === i || P === p || P === g || typeof P == "object" && P !== null && (P.$$typeof === b || P.$$typeof === v || P.$$typeof === o || P.$$typeof === s || P.$$typeof === f || P.$$typeof === S || P.$$typeof === _ || P.$$typeof === w || P.$$typeof === E);
  }, Ar.typeOf = C, Ar;
}
var Or = {}, _N;
function J8() {
  return _N || (_N = 1, Ee.env.NODE_ENV !== "production" && function() {
    var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, i = n ? Symbol.for("react.strict_mode") : 60108, a = n ? Symbol.for("react.profiler") : 60114, o = n ? Symbol.for("react.provider") : 60109, s = n ? Symbol.for("react.context") : 60110, u = n ? Symbol.for("react.async_mode") : 60111, d = n ? Symbol.for("react.concurrent_mode") : 60111, f = n ? Symbol.for("react.forward_ref") : 60112, p = n ? Symbol.for("react.suspense") : 60113, g = n ? Symbol.for("react.suspense_list") : 60120, v = n ? Symbol.for("react.memo") : 60115, b = n ? Symbol.for("react.lazy") : 60116, E = n ? Symbol.for("react.block") : 60121, S = n ? Symbol.for("react.fundamental") : 60117, _ = n ? Symbol.for("react.responder") : 60118, w = n ? Symbol.for("react.scope") : 60119;
    function C($) {
      return typeof $ == "string" || typeof $ == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      $ === r || $ === d || $ === a || $ === i || $ === p || $ === g || typeof $ == "object" && $ !== null && ($.$$typeof === b || $.$$typeof === v || $.$$typeof === o || $.$$typeof === s || $.$$typeof === f || $.$$typeof === S || $.$$typeof === _ || $.$$typeof === w || $.$$typeof === E);
    }
    function R($) {
      if (typeof $ == "object" && $ !== null) {
        var Te = $.$$typeof;
        switch (Te) {
          case e:
            var se = $.type;
            switch (se) {
              case u:
              case d:
              case r:
              case a:
              case i:
              case p:
                return se;
              default:
                var Ie = se && se.$$typeof;
                switch (Ie) {
                  case s:
                  case f:
                  case b:
                  case v:
                  case o:
                    return Ie;
                  default:
                    return Te;
                }
            }
          case t:
            return Te;
        }
      }
    }
    var P = u, D = d, I = s, U = o, L = e, N = f, H = r, j = b, G = v, X = t, ae = a, Z = i, K = p, B = !1;
    function Q($) {
      return B || (B = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), V($) || R($) === u;
    }
    function V($) {
      return R($) === d;
    }
    function q($) {
      return R($) === s;
    }
    function ne($) {
      return R($) === o;
    }
    function ce($) {
      return typeof $ == "object" && $ !== null && $.$$typeof === e;
    }
    function ie($) {
      return R($) === f;
    }
    function oe($) {
      return R($) === r;
    }
    function he($) {
      return R($) === b;
    }
    function le($) {
      return R($) === v;
    }
    function ve($) {
      return R($) === t;
    }
    function Ne($) {
      return R($) === a;
    }
    function xe($) {
      return R($) === i;
    }
    function Me($) {
      return R($) === p;
    }
    Or.AsyncMode = P, Or.ConcurrentMode = D, Or.ContextConsumer = I, Or.ContextProvider = U, Or.Element = L, Or.ForwardRef = N, Or.Fragment = H, Or.Lazy = j, Or.Memo = G, Or.Portal = X, Or.Profiler = ae, Or.StrictMode = Z, Or.Suspense = K, Or.isAsyncMode = Q, Or.isConcurrentMode = V, Or.isContextConsumer = q, Or.isContextProvider = ne, Or.isElement = ce, Or.isForwardRef = ie, Or.isFragment = oe, Or.isLazy = he, Or.isMemo = le, Or.isPortal = ve, Or.isProfiler = Ne, Or.isStrictMode = xe, Or.isSuspense = Me, Or.isValidElementType = C, Or.typeOf = R;
  }()), Or;
}
var xN;
function LU() {
  return xN || (xN = 1, Ee.env.NODE_ENV === "production" ? xS.exports = Q8() : xS.exports = J8()), xS.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var E1, EN;
function ej() {
  if (EN) return E1;
  EN = 1;
  var n = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;
  function r(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var o = {}, s = 0; s < 10; s++)
        o["_" + String.fromCharCode(s)] = s;
      var u = Object.getOwnPropertyNames(o).map(function(f) {
        return o[f];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var d = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(f) {
        d[f] = f;
      }), Object.keys(Object.assign({}, d)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return E1 = i() ? Object.assign : function(a, o) {
    for (var s, u = r(a), d, f = 1; f < arguments.length; f++) {
      s = Object(arguments[f]);
      for (var p in s)
        e.call(s, p) && (u[p] = s[p]);
      if (n) {
        d = n(s);
        for (var g = 0; g < d.length; g++)
          t.call(s, d[g]) && (u[d[g]] = s[d[g]]);
      }
    }
    return u;
  }, E1;
}
var C1, CN;
function EA() {
  if (CN) return C1;
  CN = 1;
  var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return C1 = n, C1;
}
var w1, wN;
function FU() {
  return wN || (wN = 1, w1 = Function.call.bind(Object.prototype.hasOwnProperty)), w1;
}
var M1, MN;
function tj() {
  if (MN) return M1;
  MN = 1;
  var n = function() {
  };
  if (Ee.env.NODE_ENV !== "production") {
    var e = EA(), t = {}, r = FU();
    n = function(a) {
      var o = "Warning: " + a;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(a, o, s, u, d) {
    if (Ee.env.NODE_ENV !== "production") {
      for (var f in a)
        if (r(a, f)) {
          var p;
          try {
            if (typeof a[f] != "function") {
              var g = Error(
                (u || "React class") + ": " + s + " type `" + f + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[f] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw g.name = "Invariant Violation", g;
            }
            p = a[f](o, f, u, s, null, e);
          } catch (b) {
            p = b;
          }
          if (p && !(p instanceof Error) && n(
            (u || "React class") + ": type specification of " + s + " `" + f + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in t)) {
            t[p.message] = !0;
            var v = d ? d() : "";
            n(
              "Failed " + s + " type: " + p.message + (v ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    Ee.env.NODE_ENV !== "production" && (t = {});
  }, M1 = i, M1;
}
var T1, TN;
function nj() {
  if (TN) return T1;
  TN = 1;
  var n = LU(), e = ej(), t = EA(), r = FU(), i = tj(), a = function() {
  };
  Ee.env.NODE_ENV !== "production" && (a = function(s) {
    var u = "Warning: " + s;
    typeof console < "u" && console.error(u);
    try {
      throw new Error(u);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return T1 = function(s, u) {
    var d = typeof Symbol == "function" && Symbol.iterator, f = "@@iterator";
    function p(V) {
      var q = V && (d && V[d] || V[f]);
      if (typeof q == "function")
        return q;
    }
    var g = "<<anonymous>>", v = {
      array: _("array"),
      bigint: _("bigint"),
      bool: _("boolean"),
      func: _("function"),
      number: _("number"),
      object: _("object"),
      string: _("string"),
      symbol: _("symbol"),
      any: w(),
      arrayOf: C,
      element: R(),
      elementType: P(),
      instanceOf: D,
      node: N(),
      objectOf: U,
      oneOf: I,
      oneOfType: L,
      shape: j,
      exact: G
    };
    function b(V, q) {
      return V === q ? V !== 0 || 1 / V === 1 / q : V !== V && q !== q;
    }
    function E(V, q) {
      this.message = V, this.data = q && typeof q == "object" ? q : {}, this.stack = "";
    }
    E.prototype = Error.prototype;
    function S(V) {
      if (Ee.env.NODE_ENV !== "production")
        var q = {}, ne = 0;
      function ce(oe, he, le, ve, Ne, xe, Me) {
        if (ve = ve || g, xe = xe || le, Me !== t) {
          if (u) {
            var $ = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw $.name = "Invariant Violation", $;
          } else if (Ee.env.NODE_ENV !== "production" && typeof console < "u") {
            var Te = ve + ":" + le;
            !q[Te] && // Avoid spamming the console because they are often not actionable except for lib authors
            ne < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + xe + "` prop on `" + ve + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), q[Te] = !0, ne++);
          }
        }
        return he[le] == null ? oe ? he[le] === null ? new E("The " + Ne + " `" + xe + "` is marked as required " + ("in `" + ve + "`, but its value is `null`.")) : new E("The " + Ne + " `" + xe + "` is marked as required in " + ("`" + ve + "`, but its value is `undefined`.")) : null : V(he, le, ve, Ne, xe);
      }
      var ie = ce.bind(null, !1);
      return ie.isRequired = ce.bind(null, !0), ie;
    }
    function _(V) {
      function q(ne, ce, ie, oe, he, le) {
        var ve = ne[ce], Ne = Z(ve);
        if (Ne !== V) {
          var xe = K(ve);
          return new E(
            "Invalid " + oe + " `" + he + "` of type " + ("`" + xe + "` supplied to `" + ie + "`, expected ") + ("`" + V + "`."),
            { expectedType: V }
          );
        }
        return null;
      }
      return S(q);
    }
    function w() {
      return S(o);
    }
    function C(V) {
      function q(ne, ce, ie, oe, he) {
        if (typeof V != "function")
          return new E("Property `" + he + "` of component `" + ie + "` has invalid PropType notation inside arrayOf.");
        var le = ne[ce];
        if (!Array.isArray(le)) {
          var ve = Z(le);
          return new E("Invalid " + oe + " `" + he + "` of type " + ("`" + ve + "` supplied to `" + ie + "`, expected an array."));
        }
        for (var Ne = 0; Ne < le.length; Ne++) {
          var xe = V(le, Ne, ie, oe, he + "[" + Ne + "]", t);
          if (xe instanceof Error)
            return xe;
        }
        return null;
      }
      return S(q);
    }
    function R() {
      function V(q, ne, ce, ie, oe) {
        var he = q[ne];
        if (!s(he)) {
          var le = Z(he);
          return new E("Invalid " + ie + " `" + oe + "` of type " + ("`" + le + "` supplied to `" + ce + "`, expected a single ReactElement."));
        }
        return null;
      }
      return S(V);
    }
    function P() {
      function V(q, ne, ce, ie, oe) {
        var he = q[ne];
        if (!n.isValidElementType(he)) {
          var le = Z(he);
          return new E("Invalid " + ie + " `" + oe + "` of type " + ("`" + le + "` supplied to `" + ce + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return S(V);
    }
    function D(V) {
      function q(ne, ce, ie, oe, he) {
        if (!(ne[ce] instanceof V)) {
          var le = V.name || g, ve = Q(ne[ce]);
          return new E("Invalid " + oe + " `" + he + "` of type " + ("`" + ve + "` supplied to `" + ie + "`, expected ") + ("instance of `" + le + "`."));
        }
        return null;
      }
      return S(q);
    }
    function I(V) {
      if (!Array.isArray(V))
        return Ee.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), o;
      function q(ne, ce, ie, oe, he) {
        for (var le = ne[ce], ve = 0; ve < V.length; ve++)
          if (b(le, V[ve]))
            return null;
        var Ne = JSON.stringify(V, function(Me, $) {
          var Te = K($);
          return Te === "symbol" ? String($) : $;
        });
        return new E("Invalid " + oe + " `" + he + "` of value `" + String(le) + "` " + ("supplied to `" + ie + "`, expected one of " + Ne + "."));
      }
      return S(q);
    }
    function U(V) {
      function q(ne, ce, ie, oe, he) {
        if (typeof V != "function")
          return new E("Property `" + he + "` of component `" + ie + "` has invalid PropType notation inside objectOf.");
        var le = ne[ce], ve = Z(le);
        if (ve !== "object")
          return new E("Invalid " + oe + " `" + he + "` of type " + ("`" + ve + "` supplied to `" + ie + "`, expected an object."));
        for (var Ne in le)
          if (r(le, Ne)) {
            var xe = V(le, Ne, ie, oe, he + "." + Ne, t);
            if (xe instanceof Error)
              return xe;
          }
        return null;
      }
      return S(q);
    }
    function L(V) {
      if (!Array.isArray(V))
        return Ee.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var q = 0; q < V.length; q++) {
        var ne = V[q];
        if (typeof ne != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + B(ne) + " at index " + q + "."
          ), o;
      }
      function ce(ie, oe, he, le, ve) {
        for (var Ne = [], xe = 0; xe < V.length; xe++) {
          var Me = V[xe], $ = Me(ie, oe, he, le, ve, t);
          if ($ == null)
            return null;
          $.data && r($.data, "expectedType") && Ne.push($.data.expectedType);
        }
        var Te = Ne.length > 0 ? ", expected one of type [" + Ne.join(", ") + "]" : "";
        return new E("Invalid " + le + " `" + ve + "` supplied to " + ("`" + he + "`" + Te + "."));
      }
      return S(ce);
    }
    function N() {
      function V(q, ne, ce, ie, oe) {
        return X(q[ne]) ? null : new E("Invalid " + ie + " `" + oe + "` supplied to " + ("`" + ce + "`, expected a ReactNode."));
      }
      return S(V);
    }
    function H(V, q, ne, ce, ie) {
      return new E(
        (V || "React class") + ": " + q + " type `" + ne + "." + ce + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + ie + "`."
      );
    }
    function j(V) {
      function q(ne, ce, ie, oe, he) {
        var le = ne[ce], ve = Z(le);
        if (ve !== "object")
          return new E("Invalid " + oe + " `" + he + "` of type `" + ve + "` " + ("supplied to `" + ie + "`, expected `object`."));
        for (var Ne in V) {
          var xe = V[Ne];
          if (typeof xe != "function")
            return H(ie, oe, he, Ne, K(xe));
          var Me = xe(le, Ne, ie, oe, he + "." + Ne, t);
          if (Me)
            return Me;
        }
        return null;
      }
      return S(q);
    }
    function G(V) {
      function q(ne, ce, ie, oe, he) {
        var le = ne[ce], ve = Z(le);
        if (ve !== "object")
          return new E("Invalid " + oe + " `" + he + "` of type `" + ve + "` " + ("supplied to `" + ie + "`, expected `object`."));
        var Ne = e({}, ne[ce], V);
        for (var xe in Ne) {
          var Me = V[xe];
          if (r(V, xe) && typeof Me != "function")
            return H(ie, oe, he, xe, K(Me));
          if (!Me)
            return new E(
              "Invalid " + oe + " `" + he + "` key `" + xe + "` supplied to `" + ie + "`.\nBad object: " + JSON.stringify(ne[ce], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(V), null, "  ")
            );
          var $ = Me(le, xe, ie, oe, he + "." + xe, t);
          if ($)
            return $;
        }
        return null;
      }
      return S(q);
    }
    function X(V) {
      switch (typeof V) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !V;
        case "object":
          if (Array.isArray(V))
            return V.every(X);
          if (V === null || s(V))
            return !0;
          var q = p(V);
          if (q) {
            var ne = q.call(V), ce;
            if (q !== V.entries) {
              for (; !(ce = ne.next()).done; )
                if (!X(ce.value))
                  return !1;
            } else
              for (; !(ce = ne.next()).done; ) {
                var ie = ce.value;
                if (ie && !X(ie[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function ae(V, q) {
      return V === "symbol" ? !0 : q ? q["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && q instanceof Symbol : !1;
    }
    function Z(V) {
      var q = typeof V;
      return Array.isArray(V) ? "array" : V instanceof RegExp ? "object" : ae(q, V) ? "symbol" : q;
    }
    function K(V) {
      if (typeof V > "u" || V === null)
        return "" + V;
      var q = Z(V);
      if (q === "object") {
        if (V instanceof Date)
          return "date";
        if (V instanceof RegExp)
          return "regexp";
      }
      return q;
    }
    function B(V) {
      var q = K(V);
      switch (q) {
        case "array":
        case "object":
          return "an " + q;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + q;
        default:
          return q;
      }
    }
    function Q(V) {
      return !V.constructor || !V.constructor.name ? g : V.constructor.name;
    }
    return v.checkPropTypes = i, v.resetWarningCache = i.resetWarningCache, v.PropTypes = v, v;
  }, T1;
}
var R1, RN;
function rj() {
  if (RN) return R1;
  RN = 1;
  var n = EA();
  function e() {
  }
  function t() {
  }
  return t.resetWarningCache = e, R1 = function() {
    function r(o, s, u, d, f, p) {
      if (p !== n) {
        var g = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw g.name = "Invariant Violation", g;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var a = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: t,
      resetWarningCache: e
    };
    return a.PropTypes = a, a;
  }, R1;
}
if (Ee.env.NODE_ENV !== "production") {
  var ij = LU(), aj = !0;
  LT.exports = nj()(ij.isElement, aj);
} else
  LT.exports = rj()();
var UU = LT.exports;
function zU(n) {
  var e, t, r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object") if (Array.isArray(n)) for (e = 0; e < n.length; e++) n[e] && (t = zU(n[e])) && (r && (r += " "), r += t);
  else for (e in n) n[e] && (r && (r += " "), r += e);
  return r;
}
function AN() {
  for (var n, e, t = 0, r = ""; t < arguments.length; ) (n = arguments[t++]) && (e = zU(n)) && (r && (r += " "), r += e);
  return r;
}
const oj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: AN,
  default: AN
}, Symbol.toStringTag, { value: "Module" })), sj = /* @__PURE__ */ Y8(oj);
var Ri = {}, hc = {};
Object.defineProperty(hc, "__esModule", {
  value: !0
});
hc.dontSetMe = fj;
hc.findInArray = lj;
hc.int = dj;
hc.isFunction = cj;
hc.isNum = uj;
function lj(n, e) {
  for (let t = 0, r = n.length; t < r; t++)
    if (e.apply(e, [n[t], t, n])) return n[t];
}
function cj(n) {
  return typeof n == "function" || Object.prototype.toString.call(n) === "[object Function]";
}
function uj(n) {
  return typeof n == "number" && !isNaN(n);
}
function dj(n) {
  return parseInt(n, 10);
}
function fj(n, e, t) {
  if (n[e])
    return new Error("Invalid prop ".concat(e, " passed to ").concat(t, " - do not set this, set it on the child."));
}
var zh = {};
Object.defineProperty(zh, "__esModule", {
  value: !0
});
zh.browserPrefixToKey = HU;
zh.browserPrefixToStyle = hj;
zh.default = void 0;
zh.getPrefix = BU;
const A1 = ["Moz", "Webkit", "O", "ms"];
function BU() {
  var n;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
  if (typeof window > "u") return "";
  const t = (n = window.document) === null || n === void 0 || (n = n.documentElement) === null || n === void 0 ? void 0 : n.style;
  if (!t || e in t) return "";
  for (let r = 0; r < A1.length; r++)
    if (HU(e, A1[r]) in t) return A1[r];
  return "";
}
function HU(n, e) {
  return e ? "".concat(e).concat(pj(n)) : n;
}
function hj(n, e) {
  return e ? "-".concat(e.toLowerCase(), "-").concat(n) : n;
}
function pj(n) {
  let e = "", t = !0;
  for (let r = 0; r < n.length; r++)
    t ? (e += n[r].toUpperCase(), t = !1) : n[r] === "-" ? t = !0 : e += n[r];
  return e;
}
zh.default = BU();
Object.defineProperty(Ri, "__esModule", {
  value: !0
});
Ri.addClassName = $U;
Ri.addEvent = vj;
Ri.addUserSelectStyles = Rj;
Ri.createCSSTransform = Cj;
Ri.createSVGTransform = wj;
Ri.getTouch = Mj;
Ri.getTouchIdentifier = Tj;
Ri.getTranslation = CA;
Ri.innerHeight = _j;
Ri.innerWidth = xj;
Ri.matchesSelector = kU;
Ri.matchesSelectorAndParentsTo = gj;
Ri.offsetXYFromParent = Ej;
Ri.outerHeight = bj;
Ri.outerWidth = Sj;
Ri.removeClassName = WU;
Ri.removeEvent = yj;
Ri.removeUserSelectStyles = Aj;
var hs = hc, ON = mj(zh);
function VU(n) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
  return (VU = function(r) {
    return r ? t : e;
  })(n);
}
function mj(n, e) {
  if (n && n.__esModule)
    return n;
  if (n === null || typeof n != "object" && typeof n != "function")
    return { default: n };
  var t = VU(e);
  if (t && t.has(n))
    return t.get(n);
  var r = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var a in n)
    if (a !== "default" && Object.prototype.hasOwnProperty.call(n, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(n, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(r, a, o) : r[a] = n[a];
    }
  return r.default = n, t && t.set(n, r), r;
}
let ES = "";
function kU(n, e) {
  return ES || (ES = (0, hs.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(t) {
    return (0, hs.isFunction)(n[t]);
  })), (0, hs.isFunction)(n[ES]) ? n[ES](e) : !1;
}
function gj(n, e, t) {
  let r = n;
  do {
    if (kU(r, e)) return !0;
    if (r === t) return !1;
    r = r.parentNode;
  } while (r);
  return !1;
}
function vj(n, e, t, r) {
  if (!n) return;
  const i = {
    capture: !0,
    ...r
  };
  n.addEventListener ? n.addEventListener(e, t, i) : n.attachEvent ? n.attachEvent("on" + e, t) : n["on" + e] = t;
}
function yj(n, e, t, r) {
  if (!n) return;
  const i = {
    capture: !0,
    ...r
  };
  n.removeEventListener ? n.removeEventListener(e, t, i) : n.detachEvent ? n.detachEvent("on" + e, t) : n["on" + e] = null;
}
function bj(n) {
  let e = n.clientHeight;
  const t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e += (0, hs.int)(t.borderTopWidth), e += (0, hs.int)(t.borderBottomWidth), e;
}
function Sj(n) {
  let e = n.clientWidth;
  const t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e += (0, hs.int)(t.borderLeftWidth), e += (0, hs.int)(t.borderRightWidth), e;
}
function _j(n) {
  let e = n.clientHeight;
  const t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e -= (0, hs.int)(t.paddingTop), e -= (0, hs.int)(t.paddingBottom), e;
}
function xj(n) {
  let e = n.clientWidth;
  const t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e -= (0, hs.int)(t.paddingLeft), e -= (0, hs.int)(t.paddingRight), e;
}
function Ej(n, e, t) {
  const i = e === e.ownerDocument.body ? {
    left: 0,
    top: 0
  } : e.getBoundingClientRect(), a = (n.clientX + e.scrollLeft - i.left) / t, o = (n.clientY + e.scrollTop - i.top) / t;
  return {
    x: a,
    y: o
  };
}
function Cj(n, e) {
  const t = CA(n, e, "px");
  return {
    [(0, ON.browserPrefixToKey)("transform", ON.default)]: t
  };
}
function wj(n, e) {
  return CA(n, e, "");
}
function CA(n, e, t) {
  let {
    x: r,
    y: i
  } = n, a = "translate(".concat(r).concat(t, ",").concat(i).concat(t, ")");
  if (e) {
    const o = "".concat(typeof e.x == "string" ? e.x : e.x + t), s = "".concat(typeof e.y == "string" ? e.y : e.y + t);
    a = "translate(".concat(o, ", ").concat(s, ")") + a;
  }
  return a;
}
function Mj(n, e) {
  return n.targetTouches && (0, hs.findInArray)(n.targetTouches, (t) => e === t.identifier) || n.changedTouches && (0, hs.findInArray)(n.changedTouches, (t) => e === t.identifier);
}
function Tj(n) {
  if (n.targetTouches && n.targetTouches[0]) return n.targetTouches[0].identifier;
  if (n.changedTouches && n.changedTouches[0]) return n.changedTouches[0].identifier;
}
function Rj(n) {
  if (!n) return;
  let e = n.getElementById("react-draggable-style-el");
  e || (e = n.createElement("style"), e.type = "text/css", e.id = "react-draggable-style-el", e.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, e.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, n.getElementsByTagName("head")[0].appendChild(e)), n.body && $U(n.body, "react-draggable-transparent-selection");
}
function Aj(n) {
  if (n)
    try {
      if (n.body && WU(n.body, "react-draggable-transparent-selection"), n.selection)
        n.selection.empty();
      else {
        const e = (n.defaultView || window).getSelection();
        e && e.type !== "Caret" && e.removeAllRanges();
      }
    } catch {
    }
}
function $U(n, e) {
  n.classList ? n.classList.add(e) : n.className.match(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"))) || (n.className += " ".concat(e));
}
function WU(n, e) {
  n.classList ? n.classList.remove(e) : n.className = n.className.replace(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"), "g"), "");
}
var pc = {};
Object.defineProperty(pc, "__esModule", {
  value: !0
});
pc.canDragX = Dj;
pc.canDragY = Ij;
pc.createCoreData = Lj;
pc.createDraggableData = Fj;
pc.getBoundPosition = Oj;
pc.getControlPosition = Nj;
pc.snapToGrid = Pj;
var cs = hc, zm = Ri;
function Oj(n, e, t) {
  if (!n.props.bounds) return [e, t];
  let {
    bounds: r
  } = n.props;
  r = typeof r == "string" ? r : Uj(r);
  const i = wA(n);
  if (typeof r == "string") {
    const {
      ownerDocument: a
    } = i, o = a.defaultView;
    let s;
    if (r === "parent" ? s = i.parentNode : s = a.querySelector(r), !(s instanceof o.HTMLElement))
      throw new Error('Bounds selector "' + r + '" could not find an element.');
    const u = s, d = o.getComputedStyle(i), f = o.getComputedStyle(u);
    r = {
      left: -i.offsetLeft + (0, cs.int)(f.paddingLeft) + (0, cs.int)(d.marginLeft),
      top: -i.offsetTop + (0, cs.int)(f.paddingTop) + (0, cs.int)(d.marginTop),
      right: (0, zm.innerWidth)(u) - (0, zm.outerWidth)(i) - i.offsetLeft + (0, cs.int)(f.paddingRight) - (0, cs.int)(d.marginRight),
      bottom: (0, zm.innerHeight)(u) - (0, zm.outerHeight)(i) - i.offsetTop + (0, cs.int)(f.paddingBottom) - (0, cs.int)(d.marginBottom)
    };
  }
  return (0, cs.isNum)(r.right) && (e = Math.min(e, r.right)), (0, cs.isNum)(r.bottom) && (t = Math.min(t, r.bottom)), (0, cs.isNum)(r.left) && (e = Math.max(e, r.left)), (0, cs.isNum)(r.top) && (t = Math.max(t, r.top)), [e, t];
}
function Pj(n, e, t) {
  const r = Math.round(e / n[0]) * n[0], i = Math.round(t / n[1]) * n[1];
  return [r, i];
}
function Dj(n) {
  return n.props.axis === "both" || n.props.axis === "x";
}
function Ij(n) {
  return n.props.axis === "both" || n.props.axis === "y";
}
function Nj(n, e, t) {
  const r = typeof e == "number" ? (0, zm.getTouch)(n, e) : null;
  if (typeof e == "number" && !r) return null;
  const i = wA(t), a = t.props.offsetParent || i.offsetParent || i.ownerDocument.body;
  return (0, zm.offsetXYFromParent)(r || n, a, t.props.scale);
}
function Lj(n, e, t) {
  const r = !(0, cs.isNum)(n.lastX), i = wA(n);
  return r ? {
    node: i,
    deltaX: 0,
    deltaY: 0,
    lastX: e,
    lastY: t,
    x: e,
    y: t
  } : {
    node: i,
    deltaX: e - n.lastX,
    deltaY: t - n.lastY,
    lastX: n.lastX,
    lastY: n.lastY,
    x: e,
    y: t
  };
}
function Fj(n, e) {
  const t = n.props.scale;
  return {
    node: e.node,
    x: n.state.x + e.deltaX / t,
    y: n.state.y + e.deltaY / t,
    deltaX: e.deltaX / t,
    deltaY: e.deltaY / t,
    lastX: n.state.x,
    lastY: n.state.y
  };
}
function Uj(n) {
  return {
    left: n.left,
    top: n.top,
    right: n.right,
    bottom: n.bottom
  };
}
function wA(n) {
  const e = n.findDOMNode();
  if (!e)
    throw new Error("<DraggableCore>: Unmounted during event!");
  return e;
}
var sE = {}, lE = {};
Object.defineProperty(lE, "__esModule", {
  value: !0
});
lE.default = zj;
function zj() {
}
Object.defineProperty(sE, "__esModule", {
  value: !0
});
sE.default = void 0;
var O1 = Hj(Fe), Fo = MA(UU), Bj = MA(sx), $a = Ri, bd = pc, P1 = hc, jv = MA(lE);
function MA(n) {
  return n && n.__esModule ? n : { default: n };
}
function jU(n) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
  return (jU = function(r) {
    return r ? t : e;
  })(n);
}
function Hj(n, e) {
  if (n && n.__esModule)
    return n;
  if (n === null || typeof n != "object" && typeof n != "function")
    return { default: n };
  var t = jU(e);
  if (t && t.has(n))
    return t.get(n);
  var r = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var a in n)
    if (a !== "default" && Object.prototype.hasOwnProperty.call(n, a)) {
      var o = i ? Object.getOwnPropertyDescriptor(n, a) : null;
      o && (o.get || o.set) ? Object.defineProperty(r, a, o) : r[a] = n[a];
    }
  return r.default = n, t && t.set(n, r), r;
}
function co(n, e, t) {
  return e = Vj(e), e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
function Vj(n) {
  var e = kj(n, "string");
  return typeof e == "symbol" ? e : String(e);
}
function kj(n, e) {
  if (typeof n != "object" || n === null) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
const ml = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
};
let Sd = ml.mouse, cE = class extends O1.Component {
  constructor() {
    super(...arguments), co(this, "dragging", !1), co(this, "lastX", NaN), co(this, "lastY", NaN), co(this, "touchIdentifier", null), co(this, "mounted", !1), co(this, "handleDragStart", (e) => {
      if (this.props.onMouseDown(e), !this.props.allowAnyClick && typeof e.button == "number" && e.button !== 0) return !1;
      const t = this.findDOMNode();
      if (!t || !t.ownerDocument || !t.ownerDocument.body)
        throw new Error("<DraggableCore> not mounted on DragStart!");
      const {
        ownerDocument: r
      } = t;
      if (this.props.disabled || !(e.target instanceof r.defaultView.Node) || this.props.handle && !(0, $a.matchesSelectorAndParentsTo)(e.target, this.props.handle, t) || this.props.cancel && (0, $a.matchesSelectorAndParentsTo)(e.target, this.props.cancel, t))
        return;
      e.type === "touchstart" && e.preventDefault();
      const i = (0, $a.getTouchIdentifier)(e);
      this.touchIdentifier = i;
      const a = (0, bd.getControlPosition)(e, i, this);
      if (a == null) return;
      const {
        x: o,
        y: s
      } = a, u = (0, bd.createCoreData)(this, o, s);
      (0, jv.default)("DraggableCore: handleDragStart: %j", u), (0, jv.default)("calling", this.props.onStart), !(this.props.onStart(e, u) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, $a.addUserSelectStyles)(r), this.dragging = !0, this.lastX = o, this.lastY = s, (0, $a.addEvent)(r, Sd.move, this.handleDrag), (0, $a.addEvent)(r, Sd.stop, this.handleDragStop));
    }), co(this, "handleDrag", (e) => {
      const t = (0, bd.getControlPosition)(e, this.touchIdentifier, this);
      if (t == null) return;
      let {
        x: r,
        y: i
      } = t;
      if (Array.isArray(this.props.grid)) {
        let s = r - this.lastX, u = i - this.lastY;
        if ([s, u] = (0, bd.snapToGrid)(this.props.grid, s, u), !s && !u) return;
        r = this.lastX + s, i = this.lastY + u;
      }
      const a = (0, bd.createCoreData)(this, r, i);
      if ((0, jv.default)("DraggableCore: handleDrag: %j", a), this.props.onDrag(e, a) === !1 || this.mounted === !1) {
        try {
          this.handleDragStop(new MouseEvent("mouseup"));
        } catch {
          const u = document.createEvent("MouseEvents");
          u.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(u);
        }
        return;
      }
      this.lastX = r, this.lastY = i;
    }), co(this, "handleDragStop", (e) => {
      if (!this.dragging) return;
      const t = (0, bd.getControlPosition)(e, this.touchIdentifier, this);
      if (t == null) return;
      let {
        x: r,
        y: i
      } = t;
      if (Array.isArray(this.props.grid)) {
        let u = r - this.lastX || 0, d = i - this.lastY || 0;
        [u, d] = (0, bd.snapToGrid)(this.props.grid, u, d), r = this.lastX + u, i = this.lastY + d;
      }
      const a = (0, bd.createCoreData)(this, r, i);
      if (this.props.onStop(e, a) === !1 || this.mounted === !1) return !1;
      const s = this.findDOMNode();
      s && this.props.enableUserSelectHack && (0, $a.removeUserSelectStyles)(s.ownerDocument), (0, jv.default)("DraggableCore: handleDragStop: %j", a), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, s && ((0, jv.default)("DraggableCore: Removing handlers"), (0, $a.removeEvent)(s.ownerDocument, Sd.move, this.handleDrag), (0, $a.removeEvent)(s.ownerDocument, Sd.stop, this.handleDragStop));
    }), co(this, "onMouseDown", (e) => (Sd = ml.mouse, this.handleDragStart(e))), co(this, "onMouseUp", (e) => (Sd = ml.mouse, this.handleDragStop(e))), co(this, "onTouchStart", (e) => (Sd = ml.touch, this.handleDragStart(e))), co(this, "onTouchEnd", (e) => (Sd = ml.touch, this.handleDragStop(e)));
  }
  componentDidMount() {
    this.mounted = !0;
    const e = this.findDOMNode();
    e && (0, $a.addEvent)(e, ml.touch.start, this.onTouchStart, {
      passive: !1
    });
  }
  componentWillUnmount() {
    this.mounted = !1;
    const e = this.findDOMNode();
    if (e) {
      const {
        ownerDocument: t
      } = e;
      (0, $a.removeEvent)(t, ml.mouse.move, this.handleDrag), (0, $a.removeEvent)(t, ml.touch.move, this.handleDrag), (0, $a.removeEvent)(t, ml.mouse.stop, this.handleDragStop), (0, $a.removeEvent)(t, ml.touch.stop, this.handleDragStop), (0, $a.removeEvent)(e, ml.touch.start, this.onTouchStart, {
        passive: !1
      }), this.props.enableUserSelectHack && (0, $a.removeUserSelectStyles)(t);
    }
  }
  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
  // the underlying DOM node ourselves. See the README for more information.
  findDOMNode() {
    var e, t;
    return (e = this.props) !== null && e !== void 0 && e.nodeRef ? (t = this.props) === null || t === void 0 || (t = t.nodeRef) === null || t === void 0 ? void 0 : t.current : Bj.default.findDOMNode(this);
  }
  render() {
    return /* @__PURE__ */ O1.cloneElement(O1.Children.only(this.props.children), {
      // Note: mouseMove handler is attached to document so it will still function
      // when the user drags quickly and leaves the bounds of the element.
      onMouseDown: this.onMouseDown,
      onMouseUp: this.onMouseUp,
      // onTouchStart is added on `componentDidMount` so they can be added with
      // {passive: false}, which allows it to cancel. See
      // https://developers.google.com/web/updates/2017/01/scrolling-intervention
      onTouchEnd: this.onTouchEnd
    });
  }
};
sE.default = cE;
co(cE, "displayName", "DraggableCore");
co(cE, "propTypes", {
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: Fo.default.bool,
  children: Fo.default.node.isRequired,
  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: Fo.default.bool,
  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: Fo.default.bool,
  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: function(n, e) {
    if (n[e] && n[e].nodeType !== 1)
      throw new Error("Draggable's offsetParent must be a DOM Node.");
  },
  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: Fo.default.arrayOf(Fo.default.number),
  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: Fo.default.string,
  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: Fo.default.string,
  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: Fo.default.object,
  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: Fo.default.func,
  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: Fo.default.func,
  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: Fo.default.func,
  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: Fo.default.func,
  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: Fo.default.number,
  /**
   * These properties should be defined on the child, not here.
   */
  className: P1.dontSetMe,
  style: P1.dontSetMe,
  transform: P1.dontSetMe
});
co(cE, "defaultProps", {
  allowAnyClick: !1,
  // by default only accept left click
  disabled: !1,
  enableUserSelectHack: !0,
  onStart: function() {
  },
  onDrag: function() {
  },
  onStop: function() {
  },
  onMouseDown: function() {
  },
  scale: 1
});
(function(n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), Object.defineProperty(n, "DraggableCore", {
    enumerable: !0,
    get: function() {
      return u.default;
    }
  }), n.default = void 0;
  var e = g(Fe), t = f(UU), r = f(sx), i = f(sj), a = Ri, o = pc, s = hc, u = f(sE), d = f(lE);
  function f(w) {
    return w && w.__esModule ? w : { default: w };
  }
  function p(w) {
    if (typeof WeakMap != "function") return null;
    var C = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap();
    return (p = function(P) {
      return P ? R : C;
    })(w);
  }
  function g(w, C) {
    if (w && w.__esModule)
      return w;
    if (w === null || typeof w != "object" && typeof w != "function")
      return { default: w };
    var R = p(C);
    if (R && R.has(w))
      return R.get(w);
    var P = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var I in w)
      if (I !== "default" && Object.prototype.hasOwnProperty.call(w, I)) {
        var U = D ? Object.getOwnPropertyDescriptor(w, I) : null;
        U && (U.get || U.set) ? Object.defineProperty(P, I, U) : P[I] = w[I];
      }
    return P.default = w, R && R.set(w, P), P;
  }
  function v() {
    return v = Object.assign ? Object.assign.bind() : function(w) {
      for (var C = 1; C < arguments.length; C++) {
        var R = arguments[C];
        for (var P in R)
          Object.prototype.hasOwnProperty.call(R, P) && (w[P] = R[P]);
      }
      return w;
    }, v.apply(this, arguments);
  }
  function b(w, C, R) {
    return C = E(C), C in w ? Object.defineProperty(w, C, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : w[C] = R, w;
  }
  function E(w) {
    var C = S(w, "string");
    return typeof C == "symbol" ? C : String(C);
  }
  function S(w, C) {
    if (typeof w != "object" || w === null) return w;
    var R = w[Symbol.toPrimitive];
    if (R !== void 0) {
      var P = R.call(w, C || "default");
      if (typeof P != "object") return P;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (C === "string" ? String : Number)(w);
  }
  class _ extends e.Component {
    // React 16.3+
    // Arity (props, state)
    static getDerivedStateFromProps(C, R) {
      let {
        position: P
      } = C, {
        prevPropsPosition: D
      } = R;
      return P && (!D || P.x !== D.x || P.y !== D.y) ? ((0, d.default)("Draggable: getDerivedStateFromProps %j", {
        position: P,
        prevPropsPosition: D
      }), {
        x: P.x,
        y: P.y,
        prevPropsPosition: {
          ...P
        }
      }) : null;
    }
    constructor(C) {
      super(C), b(this, "onDragStart", (R, P) => {
        if ((0, d.default)("Draggable: onDragStart: %j", P), this.props.onStart(R, (0, o.createDraggableData)(this, P)) === !1) return !1;
        this.setState({
          dragging: !0,
          dragged: !0
        });
      }), b(this, "onDrag", (R, P) => {
        if (!this.state.dragging) return !1;
        (0, d.default)("Draggable: onDrag: %j", P);
        const D = (0, o.createDraggableData)(this, P), I = {
          x: D.x,
          y: D.y,
          slackX: 0,
          slackY: 0
        };
        if (this.props.bounds) {
          const {
            x: L,
            y: N
          } = I;
          I.x += this.state.slackX, I.y += this.state.slackY;
          const [H, j] = (0, o.getBoundPosition)(this, I.x, I.y);
          I.x = H, I.y = j, I.slackX = this.state.slackX + (L - I.x), I.slackY = this.state.slackY + (N - I.y), D.x = I.x, D.y = I.y, D.deltaX = I.x - this.state.x, D.deltaY = I.y - this.state.y;
        }
        if (this.props.onDrag(R, D) === !1) return !1;
        this.setState(I);
      }), b(this, "onDragStop", (R, P) => {
        if (!this.state.dragging || this.props.onStop(R, (0, o.createDraggableData)(this, P)) === !1) return !1;
        (0, d.default)("Draggable: onDragStop: %j", P);
        const I = {
          dragging: !1,
          slackX: 0,
          slackY: 0
        };
        if (!!this.props.position) {
          const {
            x: L,
            y: N
          } = this.props.position;
          I.x = L, I.y = N;
        }
        this.setState(I);
      }), this.state = {
        // Whether or not we are currently dragging.
        dragging: !1,
        // Whether or not we have been dragged before.
        dragged: !1,
        // Current transform x and y.
        x: C.position ? C.position.x : C.defaultPosition.x,
        y: C.position ? C.position.y : C.defaultPosition.y,
        prevPropsPosition: {
          ...C.position
        },
        // Used for compensating for out-of-bounds drags
        slackX: 0,
        slackY: 0,
        // Can only determine if SVG after mounting
        isElementSVG: !1
      }, C.position && !(C.onDrag || C.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
    }
    componentDidMount() {
      typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
        isElementSVG: !0
      });
    }
    componentWillUnmount() {
      this.setState({
        dragging: !1
      });
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var C, R;
      return (C = (R = this.props) === null || R === void 0 || (R = R.nodeRef) === null || R === void 0 ? void 0 : R.current) !== null && C !== void 0 ? C : r.default.findDOMNode(this);
    }
    render() {
      const {
        axis: C,
        bounds: R,
        children: P,
        defaultPosition: D,
        defaultClassName: I,
        defaultClassNameDragging: U,
        defaultClassNameDragged: L,
        position: N,
        positionOffset: H,
        scale: j,
        ...G
      } = this.props;
      let X = {}, ae = null;
      const K = !!!N || this.state.dragging, B = N || D, Q = {
        // Set left if horizontal drag is enabled
        x: (0, o.canDragX)(this) && K ? this.state.x : B.x,
        // Set top if vertical drag is enabled
        y: (0, o.canDragY)(this) && K ? this.state.y : B.y
      };
      this.state.isElementSVG ? ae = (0, a.createSVGTransform)(Q, H) : X = (0, a.createCSSTransform)(Q, H);
      const V = (0, i.default)(P.props.className || "", I, {
        [U]: this.state.dragging,
        [L]: this.state.dragged
      });
      return /* @__PURE__ */ e.createElement(u.default, v({}, G, {
        onStart: this.onDragStart,
        onDrag: this.onDrag,
        onStop: this.onDragStop
      }), /* @__PURE__ */ e.cloneElement(e.Children.only(P), {
        className: V,
        style: {
          ...P.props.style,
          ...X
        },
        transform: ae
      }));
    }
  }
  n.default = _, b(_, "displayName", "Draggable"), b(_, "propTypes", {
    // Accepts all props <DraggableCore> accepts.
    ...u.default.propTypes,
    /**
     * `axis` determines which axis the draggable can move.
     *
     *  Note that all callbacks will still return data as normal. This only
     *  controls flushing to the DOM.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     * 'none' limits all movement.
     *
     * Defaults to 'both'.
     */
    axis: t.default.oneOf(["both", "x", "y", "none"]),
    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: t.default.oneOfType([t.default.shape({
      left: t.default.number,
      right: t.default.number,
      top: t.default.number,
      bottom: t.default.number
    }), t.default.string, t.default.oneOf([!1])]),
    defaultClassName: t.default.string,
    defaultClassNameDragging: t.default.string,
    defaultClassNameDragged: t.default.string,
    /**
     * `defaultPosition` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable defaultPosition={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    defaultPosition: t.default.shape({
      x: t.default.number,
      y: t.default.number
    }),
    positionOffset: t.default.shape({
      x: t.default.oneOfType([t.default.number, t.default.string]),
      y: t.default.oneOfType([t.default.number, t.default.string])
    }),
    /**
     * `position`, if present, defines the current position of the element.
     *
     *  This is similar to how form elements in React work - if no `position` is supplied, the component
     *  is uncontrolled.
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable position={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    position: t.default.shape({
      x: t.default.number,
      y: t.default.number
    }),
    /**
     * These properties should be defined on the child, not here.
     */
    className: s.dontSetMe,
    style: s.dontSetMe,
    transform: s.dontSetMe
  }), b(_, "defaultProps", {
    ...u.default.defaultProps,
    axis: "both",
    bounds: !1,
    defaultClassName: "react-draggable",
    defaultClassNameDragging: "react-draggable-dragging",
    defaultClassNameDragged: "react-draggable-dragged",
    defaultPosition: {
      x: 0,
      y: 0
    },
    scale: 1
  });
})(NU);
const {
  default: GU,
  DraggableCore: $j
} = NU;
oE.exports = GU;
oE.exports.default = GU;
oE.exports.DraggableCore = $j;
var Wj = oE.exports;
const jj = /* @__PURE__ */ y0(Wj);
var XU = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(n) {
  (function() {
    var e = {}.hasOwnProperty;
    function t() {
      for (var a = "", o = 0; o < arguments.length; o++) {
        var s = arguments[o];
        s && (a = i(a, r(s)));
      }
      return a;
    }
    function r(a) {
      if (typeof a == "string" || typeof a == "number")
        return a;
      if (typeof a != "object")
        return "";
      if (Array.isArray(a))
        return t.apply(null, a);
      if (a.toString !== Object.prototype.toString && !a.toString.toString().includes("[native code]"))
        return a.toString();
      var o = "";
      for (var s in a)
        e.call(a, s) && a[s] && (o = i(o, s));
      return o;
    }
    function i(a, o) {
      return o ? a ? a + " " + o : a + o : a;
    }
    n.exports ? (t.default = t, n.exports = t) : window.classNames = t;
  })();
})(XU);
var Gj = XU.exports;
const Et = /* @__PURE__ */ y0(Gj);
function gn() {
  return gn = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, gn.apply(null, arguments);
}
var FT = { exports: {} }, Pr = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PN;
function Xj() {
  if (PN) return Pr;
  PN = 1;
  var n = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), o = Symbol.for("react.context"), s = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), b;
  b = Symbol.for("react.module.reference");
  function E(S) {
    if (typeof S == "object" && S !== null) {
      var _ = S.$$typeof;
      switch (_) {
        case n:
          switch (S = S.type, S) {
            case t:
            case i:
            case r:
            case d:
            case f:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case s:
                case o:
                case u:
                case g:
                case p:
                case a:
                  return S;
                default:
                  return _;
              }
          }
        case e:
          return _;
      }
    }
  }
  return Pr.ContextConsumer = o, Pr.ContextProvider = a, Pr.Element = n, Pr.ForwardRef = u, Pr.Fragment = t, Pr.Lazy = g, Pr.Memo = p, Pr.Portal = e, Pr.Profiler = i, Pr.StrictMode = r, Pr.Suspense = d, Pr.SuspenseList = f, Pr.isAsyncMode = function() {
    return !1;
  }, Pr.isConcurrentMode = function() {
    return !1;
  }, Pr.isContextConsumer = function(S) {
    return E(S) === o;
  }, Pr.isContextProvider = function(S) {
    return E(S) === a;
  }, Pr.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === n;
  }, Pr.isForwardRef = function(S) {
    return E(S) === u;
  }, Pr.isFragment = function(S) {
    return E(S) === t;
  }, Pr.isLazy = function(S) {
    return E(S) === g;
  }, Pr.isMemo = function(S) {
    return E(S) === p;
  }, Pr.isPortal = function(S) {
    return E(S) === e;
  }, Pr.isProfiler = function(S) {
    return E(S) === i;
  }, Pr.isStrictMode = function(S) {
    return E(S) === r;
  }, Pr.isSuspense = function(S) {
    return E(S) === d;
  }, Pr.isSuspenseList = function(S) {
    return E(S) === f;
  }, Pr.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === t || S === i || S === r || S === d || S === f || S === v || typeof S == "object" && S !== null && (S.$$typeof === g || S.$$typeof === p || S.$$typeof === a || S.$$typeof === o || S.$$typeof === u || S.$$typeof === b || S.getModuleId !== void 0);
  }, Pr.typeOf = E, Pr;
}
var Dr = {}, DN;
function qj() {
  return DN || (DN = 1, Ee.env.NODE_ENV !== "production" && function() {
    var n = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), o = Symbol.for("react.context"), s = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), b = !1, E = !1, S = !1, _ = !1, w = !1, C;
    C = Symbol.for("react.module.reference");
    function R(se) {
      return !!(typeof se == "string" || typeof se == "function" || se === t || se === i || w || se === r || se === d || se === f || _ || se === v || b || E || S || typeof se == "object" && se !== null && (se.$$typeof === g || se.$$typeof === p || se.$$typeof === a || se.$$typeof === o || se.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      se.$$typeof === C || se.getModuleId !== void 0));
    }
    function P(se) {
      if (typeof se == "object" && se !== null) {
        var Ie = se.$$typeof;
        switch (Ie) {
          case n:
            var be = se.type;
            switch (be) {
              case t:
              case i:
              case r:
              case d:
              case f:
                return be;
              default:
                var et = be && be.$$typeof;
                switch (et) {
                  case s:
                  case o:
                  case u:
                  case g:
                  case p:
                  case a:
                    return et;
                  default:
                    return Ie;
                }
            }
          case e:
            return Ie;
        }
      }
    }
    var D = o, I = a, U = n, L = u, N = t, H = g, j = p, G = e, X = i, ae = r, Z = d, K = f, B = !1, Q = !1;
    function V(se) {
      return B || (B = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function q(se) {
      return Q || (Q = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function ne(se) {
      return P(se) === o;
    }
    function ce(se) {
      return P(se) === a;
    }
    function ie(se) {
      return typeof se == "object" && se !== null && se.$$typeof === n;
    }
    function oe(se) {
      return P(se) === u;
    }
    function he(se) {
      return P(se) === t;
    }
    function le(se) {
      return P(se) === g;
    }
    function ve(se) {
      return P(se) === p;
    }
    function Ne(se) {
      return P(se) === e;
    }
    function xe(se) {
      return P(se) === i;
    }
    function Me(se) {
      return P(se) === r;
    }
    function $(se) {
      return P(se) === d;
    }
    function Te(se) {
      return P(se) === f;
    }
    Dr.ContextConsumer = D, Dr.ContextProvider = I, Dr.Element = U, Dr.ForwardRef = L, Dr.Fragment = N, Dr.Lazy = H, Dr.Memo = j, Dr.Portal = G, Dr.Profiler = X, Dr.StrictMode = ae, Dr.Suspense = Z, Dr.SuspenseList = K, Dr.isAsyncMode = V, Dr.isConcurrentMode = q, Dr.isContextConsumer = ne, Dr.isContextProvider = ce, Dr.isElement = ie, Dr.isForwardRef = oe, Dr.isFragment = he, Dr.isLazy = le, Dr.isMemo = ve, Dr.isPortal = Ne, Dr.isProfiler = xe, Dr.isStrictMode = Me, Dr.isSuspense = $, Dr.isSuspenseList = Te, Dr.isValidElementType = R, Dr.typeOf = P;
  }()), Dr;
}
Ee.env.NODE_ENV === "production" ? FT.exports = Xj() : FT.exports = qj();
var yy = FT.exports;
function dc(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = [];
  return Fe.Children.forEach(n, function(r) {
    r == null && !e.keepEmpty || (Array.isArray(r) ? t = t.concat(dc(r)) : yy.isFragment(r) && r.props ? t = t.concat(dc(r.props.children, e)) : t.push(r));
  }), t;
}
var UT = {}, TA = [], Yj = function(e) {
  TA.push(e);
};
function Th(n, e) {
  if (Ee.env.NODE_ENV !== "production" && !n && console !== void 0) {
    var t = TA.reduce(function(r, i) {
      return i(r ?? "", "warning");
    }, e);
    t && console.error("Warning: ".concat(t));
  }
}
function Kj(n, e) {
  if (Ee.env.NODE_ENV !== "production" && !n && console !== void 0) {
    var t = TA.reduce(function(r, i) {
      return i(r ?? "", "note");
    }, e);
    t && console.warn("Note: ".concat(t));
  }
}
function qU() {
  UT = {};
}
function YU(n, e, t) {
  !e && !UT[t] && (n(!1, t), UT[t] = !0);
}
function Yn(n, e) {
  YU(Th, n, e);
}
function zT(n, e) {
  YU(Kj, n, e);
}
Yn.preMessage = Yj;
Yn.resetWarned = qU;
Yn.noteOnce = zT;
function bn(n) {
  "@babel/helpers - typeof";
  return bn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, bn(n);
}
function Zj(n, e) {
  if (bn(n) != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (bn(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function KU(n) {
  var e = Zj(n, "string");
  return bn(e) == "symbol" ? e : e + "";
}
function Re(n, e, t) {
  return (e = KU(e)) in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function IN(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function ke(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? IN(Object(t), !0).forEach(function(r) {
      Re(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : IN(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function zy(n) {
  return n instanceof HTMLElement || n instanceof SVGElement;
}
function ZU(n) {
  return n && bn(n) === "object" && zy(n.nativeElement) ? n.nativeElement : zy(n) ? n : null;
}
function by(n) {
  var e = ZU(n);
  if (e)
    return e;
  if (n instanceof Fe.Component) {
    var t;
    return (t = sx.findDOMNode) === null || t === void 0 ? void 0 : t.call(sx, n);
  }
  return null;
}
function uE(n, e, t) {
  var r = O.useRef({});
  return (!("value" in r.current) || t(r.current.condition, e)) && (r.current.value = n(), r.current.condition = e), r.current.value;
}
var RA = function(e, t) {
  typeof e == "function" ? e(t) : bn(e) === "object" && e && "current" in e && (e.current = t);
}, Ol = function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var i = t.filter(Boolean);
  return i.length <= 1 ? i[0] : function(a) {
    t.forEach(function(o) {
      RA(o, a);
    });
  };
}, dE = function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return uE(function() {
    return Ol.apply(void 0, t);
  }, t, function(i, a) {
    return i.length !== a.length || i.every(function(o, s) {
      return o !== a[s];
    });
  });
}, pg = function(e) {
  var t, r, i = yy.isMemo(e) ? e.type.type : e.type;
  return !(typeof i == "function" && !((t = i.prototype) !== null && t !== void 0 && t.render) && i.$$typeof !== yy.ForwardRef || typeof e == "function" && !((r = e.prototype) !== null && r !== void 0 && r.render) && e.$$typeof !== yy.ForwardRef);
};
function NN(n) {
  return /* @__PURE__ */ AU(n) && !yy.isFragment(n);
}
Number(F8.split(".")[0]) >= 19;
var BT = /* @__PURE__ */ O.createContext(null);
function Qj(n) {
  var e = n.children, t = n.onBatchResize, r = O.useRef(0), i = O.useRef([]), a = O.useContext(BT), o = O.useCallback(function(s, u, d) {
    r.current += 1;
    var f = r.current;
    i.current.push({
      size: s,
      element: u,
      data: d
    }), Promise.resolve().then(function() {
      f === r.current && (t == null || t(i.current), i.current = []);
    }), a == null || a(s, u, d);
  }, [t, a]);
  return /* @__PURE__ */ O.createElement(BT.Provider, {
    value: o
  }, e);
}
const mh = globalThis || void 0 || self;
var QU = function() {
  if (typeof Map < "u")
    return Map;
  function n(e, t) {
    var r = -1;
    return e.some(function(i, a) {
      return i[0] === t ? (r = a, !0) : !1;
    }), r;
  }
  return (
    /** @class */
    function() {
      function e() {
        this.__entries__ = [];
      }
      return Object.defineProperty(e.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.get = function(t) {
        var r = n(this.__entries__, t), i = this.__entries__[r];
        return i && i[1];
      }, e.prototype.set = function(t, r) {
        var i = n(this.__entries__, t);
        ~i ? this.__entries__[i][1] = r : this.__entries__.push([t, r]);
      }, e.prototype.delete = function(t) {
        var r = this.__entries__, i = n(r, t);
        ~i && r.splice(i, 1);
      }, e.prototype.has = function(t) {
        return !!~n(this.__entries__, t);
      }, e.prototype.clear = function() {
        this.__entries__.splice(0);
      }, e.prototype.forEach = function(t, r) {
        r === void 0 && (r = null);
        for (var i = 0, a = this.__entries__; i < a.length; i++) {
          var o = a[i];
          t.call(r, o[1], o[0]);
        }
      }, e;
    }()
  );
}(), HT = typeof window < "u" && typeof document < "u" && window.document === document, lx = function() {
  return typeof mh < "u" && mh.Math === Math ? mh : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), Jj = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(lx) : function(n) {
    return setTimeout(function() {
      return n(Date.now());
    }, 1e3 / 60);
  };
}(), eG = 2;
function tG(n, e) {
  var t = !1, r = !1, i = 0;
  function a() {
    t && (t = !1, n()), r && s();
  }
  function o() {
    Jj(a);
  }
  function s() {
    var u = Date.now();
    if (t) {
      if (u - i < eG)
        return;
      r = !0;
    } else
      t = !0, r = !1, setTimeout(o, e);
    i = u;
  }
  return s;
}
var nG = 20, rG = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], iG = typeof MutationObserver < "u", aG = (
  /** @class */
  function() {
    function n() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = tG(this.refresh.bind(this), nG);
    }
    return n.prototype.addObserver = function(e) {
      ~this.observers_.indexOf(e) || this.observers_.push(e), this.connected_ || this.connect_();
    }, n.prototype.removeObserver = function(e) {
      var t = this.observers_, r = t.indexOf(e);
      ~r && t.splice(r, 1), !t.length && this.connected_ && this.disconnect_();
    }, n.prototype.refresh = function() {
      var e = this.updateObservers_();
      e && this.refresh();
    }, n.prototype.updateObservers_ = function() {
      var e = this.observers_.filter(function(t) {
        return t.gatherActive(), t.hasActive();
      });
      return e.forEach(function(t) {
        return t.broadcastActive();
      }), e.length > 0;
    }, n.prototype.connect_ = function() {
      !HT || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), iG ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, n.prototype.disconnect_ = function() {
      !HT || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, n.prototype.onTransitionEnd_ = function(e) {
      var t = e.propertyName, r = t === void 0 ? "" : t, i = rG.some(function(a) {
        return !!~r.indexOf(a);
      });
      i && this.refresh();
    }, n.getInstance = function() {
      return this.instance_ || (this.instance_ = new n()), this.instance_;
    }, n.instance_ = null, n;
  }()
), JU = function(n, e) {
  for (var t = 0, r = Object.keys(e); t < r.length; t++) {
    var i = r[t];
    Object.defineProperty(n, i, {
      value: e[i],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return n;
}, Zm = function(n) {
  var e = n && n.ownerDocument && n.ownerDocument.defaultView;
  return e || lx;
}, ez = fE(0, 0, 0, 0);
function cx(n) {
  return parseFloat(n) || 0;
}
function LN(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return e.reduce(function(r, i) {
    var a = n["border-" + i + "-width"];
    return r + cx(a);
  }, 0);
}
function oG(n) {
  for (var e = ["top", "right", "bottom", "left"], t = {}, r = 0, i = e; r < i.length; r++) {
    var a = i[r], o = n["padding-" + a];
    t[a] = cx(o);
  }
  return t;
}
function sG(n) {
  var e = n.getBBox();
  return fE(0, 0, e.width, e.height);
}
function lG(n) {
  var e = n.clientWidth, t = n.clientHeight;
  if (!e && !t)
    return ez;
  var r = Zm(n).getComputedStyle(n), i = oG(r), a = i.left + i.right, o = i.top + i.bottom, s = cx(r.width), u = cx(r.height);
  if (r.boxSizing === "border-box" && (Math.round(s + a) !== e && (s -= LN(r, "left", "right") + a), Math.round(u + o) !== t && (u -= LN(r, "top", "bottom") + o)), !uG(n)) {
    var d = Math.round(s + a) - e, f = Math.round(u + o) - t;
    Math.abs(d) !== 1 && (s -= d), Math.abs(f) !== 1 && (u -= f);
  }
  return fE(i.left, i.top, s, u);
}
var cG = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(n) {
    return n instanceof Zm(n).SVGGraphicsElement;
  } : function(n) {
    return n instanceof Zm(n).SVGElement && typeof n.getBBox == "function";
  };
}();
function uG(n) {
  return n === Zm(n).document.documentElement;
}
function dG(n) {
  return HT ? cG(n) ? sG(n) : lG(n) : ez;
}
function fG(n) {
  var e = n.x, t = n.y, r = n.width, i = n.height, a = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, o = Object.create(a.prototype);
  return JU(o, {
    x: e,
    y: t,
    width: r,
    height: i,
    top: t,
    right: e + r,
    bottom: i + t,
    left: e
  }), o;
}
function fE(n, e, t, r) {
  return { x: n, y: e, width: t, height: r };
}
var hG = (
  /** @class */
  function() {
    function n(e) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = fE(0, 0, 0, 0), this.target = e;
    }
    return n.prototype.isActive = function() {
      var e = dG(this.target);
      return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight;
    }, n.prototype.broadcastRect = function() {
      var e = this.contentRect_;
      return this.broadcastWidth = e.width, this.broadcastHeight = e.height, e;
    }, n;
  }()
), pG = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e, t) {
      var r = fG(t);
      JU(this, { target: e, contentRect: r });
    }
    return n;
  }()
), mG = (
  /** @class */
  function() {
    function n(e, t, r) {
      if (this.activeObservations_ = [], this.observations_ = new QU(), typeof e != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = e, this.controller_ = t, this.callbackCtx_ = r;
    }
    return n.prototype.observe = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof Zm(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var t = this.observations_;
        t.has(e) || (t.set(e, new hG(e)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, n.prototype.unobserve = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof Zm(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var t = this.observations_;
        t.has(e) && (t.delete(e), t.size || this.controller_.removeObserver(this));
      }
    }, n.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, n.prototype.gatherActive = function() {
      var e = this;
      this.clearActive(), this.observations_.forEach(function(t) {
        t.isActive() && e.activeObservations_.push(t);
      });
    }, n.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var e = this.callbackCtx_, t = this.activeObservations_.map(function(r) {
          return new pG(r.target, r.broadcastRect());
        });
        this.callback_.call(e, t, e), this.clearActive();
      }
    }, n.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, n.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, n;
  }()
), tz = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new QU(), nz = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      if (!(this instanceof n))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var t = aG.getInstance(), r = new mG(e, t, this);
      tz.set(this, r);
    }
    return n;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(n) {
  nz.prototype[n] = function() {
    var e;
    return (e = tz.get(this))[n].apply(e, arguments);
  };
});
var gG = function() {
  return typeof lx.ResizeObserver < "u" ? lx.ResizeObserver : nz;
}(), ou = /* @__PURE__ */ new Map();
function rz(n) {
  n.forEach(function(e) {
    var t, r = e.target;
    (t = ou.get(r)) === null || t === void 0 || t.forEach(function(i) {
      return i(r);
    });
  });
}
var iz = new gG(rz);
Ee.env.NODE_ENV;
Ee.env.NODE_ENV;
function vG(n, e) {
  ou.has(n) || (ou.set(n, /* @__PURE__ */ new Set()), iz.observe(n)), ou.get(n).add(e);
}
function yG(n, e) {
  ou.has(n) && (ou.get(n).delete(e), ou.get(n).size || (iz.unobserve(n), ou.delete(n)));
}
function ki(n, e) {
  if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function FN(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, KU(r.key), r);
  }
}
function $i(n, e, t) {
  return e && FN(n.prototype, e), t && FN(n, t), Object.defineProperty(n, "prototype", {
    writable: !1
  }), n;
}
function By(n, e) {
  return By = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
    return t.__proto__ = r, t;
  }, By(n, e);
}
function Wd(n, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  n.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: n,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(n, "prototype", {
    writable: !1
  }), e && By(n, e);
}
function Hy(n) {
  return Hy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Hy(n);
}
function AA() {
  try {
    var n = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (AA = function() {
    return !!n;
  })();
}
function tr(n) {
  if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function bG(n, e) {
  if (e && (bn(e) == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return tr(n);
}
function jd(n) {
  var e = AA();
  return function() {
    var t, r = Hy(n);
    if (e) {
      var i = Hy(this).constructor;
      t = Reflect.construct(r, arguments, i);
    } else t = r.apply(this, arguments);
    return bG(this, t);
  };
}
var SG = /* @__PURE__ */ function(n) {
  Wd(t, n);
  var e = jd(t);
  function t() {
    return ki(this, t), e.apply(this, arguments);
  }
  return $i(t, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), t;
}(O.Component);
function _G(n, e) {
  var t = n.children, r = n.disabled, i = O.useRef(null), a = O.useRef(null), o = O.useContext(BT), s = typeof t == "function", u = s ? t(i) : t, d = O.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }), f = !s && /* @__PURE__ */ O.isValidElement(u) && pg(u), p = f ? u.ref : null, g = dE(p, i), v = function() {
    var _;
    return by(i.current) || // Support `nativeElement` format
    (i.current && bn(i.current) === "object" ? by((_ = i.current) === null || _ === void 0 ? void 0 : _.nativeElement) : null) || by(a.current);
  };
  O.useImperativeHandle(e, function() {
    return v();
  });
  var b = O.useRef(n);
  b.current = n;
  var E = O.useCallback(function(S) {
    var _ = b.current, w = _.onResize, C = _.data, R = S.getBoundingClientRect(), P = R.width, D = R.height, I = S.offsetWidth, U = S.offsetHeight, L = Math.floor(P), N = Math.floor(D);
    if (d.current.width !== L || d.current.height !== N || d.current.offsetWidth !== I || d.current.offsetHeight !== U) {
      var H = {
        width: L,
        height: N,
        offsetWidth: I,
        offsetHeight: U
      };
      d.current = H;
      var j = I === Math.round(P) ? P : I, G = U === Math.round(D) ? D : U, X = ke(ke({}, H), {}, {
        offsetWidth: j,
        offsetHeight: G
      });
      o == null || o(X, S, C), w && Promise.resolve().then(function() {
        w(X, S);
      });
    }
  }, []);
  return O.useEffect(function() {
    var S = v();
    return S && !r && vG(S, E), function() {
      return yG(S, E);
    };
  }, [i.current, r]), /* @__PURE__ */ O.createElement(SG, {
    ref: a
  }, f ? /* @__PURE__ */ O.cloneElement(u, {
    ref: g
  }) : u);
}
var az = /* @__PURE__ */ O.forwardRef(_G);
Ee.env.NODE_ENV !== "production" && (az.displayName = "SingleObserver");
var xG = "rc-observer-key";
function EG(n, e) {
  var t = n.children, r = typeof t == "function" ? [t] : dc(t);
  return Ee.env.NODE_ENV !== "production" && (r.length > 1 ? Th(!1, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.") : r.length === 0 && Th(!1, "`children` of ResizeObserver is empty. Nothing is in observe.")), r.map(function(i, a) {
    var o = (i == null ? void 0 : i.key) || "".concat(xG, "-").concat(a);
    return /* @__PURE__ */ O.createElement(az, gn({}, n, {
      key: o,
      ref: a === 0 ? e : void 0
    }), i);
  });
}
var Su = /* @__PURE__ */ O.forwardRef(EG);
Ee.env.NODE_ENV !== "production" && (Su.displayName = "ResizeObserver");
Su.Collection = Qj;
function du(n, e) {
  var t = Object.assign({}, n);
  return Array.isArray(e) && e.forEach(function(r) {
    delete t[r];
  }), t;
}
function VT(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = Array(e); t < e; t++) r[t] = n[t];
  return r;
}
function CG(n) {
  if (Array.isArray(n)) return VT(n);
}
function oz(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n);
}
function OA(n, e) {
  if (n) {
    if (typeof n == "string") return VT(n, e);
    var t = {}.toString.call(n).slice(8, -1);
    return t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set" ? Array.from(n) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? VT(n, e) : void 0;
  }
}
function wG() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jt(n) {
  return CG(n) || oz(n) || OA(n) || wG();
}
var sz = function(e) {
  return +setTimeout(e, 16);
}, lz = function(e) {
  return clearTimeout(e);
};
typeof window < "u" && "requestAnimationFrame" in window && (sz = function(e) {
  return window.requestAnimationFrame(e);
}, lz = function(e) {
  return window.cancelAnimationFrame(e);
});
var UN = 0, hE = /* @__PURE__ */ new Map();
function cz(n) {
  hE.delete(n);
}
var Wr = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  UN += 1;
  var r = UN;
  function i(a) {
    if (a === 0)
      cz(r), e();
    else {
      var o = sz(function() {
        i(a - 1);
      });
      hE.set(r, o);
    }
  }
  return i(t), r;
};
Wr.cancel = function(n) {
  var e = hE.get(n);
  return cz(n), lz(e);
};
Ee.env.NODE_ENV !== "production" && (Wr.ids = function() {
  return hE;
});
function uz(n) {
  if (Array.isArray(n)) return n;
}
function MG(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r, i, a, o, s = [], u = !0, d = !1;
    try {
      if (a = (t = t.call(n)).next, e === 0) {
        if (Object(t) !== t) return;
        u = !1;
      } else for (; !(u = (r = a.call(t)).done) && (s.push(r.value), s.length !== e); u = !0) ;
    } catch (f) {
      d = !0, i = f;
    } finally {
      try {
        if (!u && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (d) throw i;
      }
    }
    return s;
  }
}
function dz() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ot(n, e) {
  return uz(n) || MG(n, e) || OA(n, e) || dz();
}
function Vy(n) {
  for (var e = 0, t, r = 0, i = n.length; i >= 4; ++r, i -= 4)
    t = n.charCodeAt(r) & 255 | (n.charCodeAt(++r) & 255) << 8 | (n.charCodeAt(++r) & 255) << 16 | (n.charCodeAt(++r) & 255) << 24, t = /* Math.imul(k, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), t ^= /* k >>> r: */
    t >>> 24, e = /* Math.imul(k, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      e ^= (n.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (n.charCodeAt(r + 1) & 255) << 8;
    case 1:
      e ^= n.charCodeAt(r) & 255, e = /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  }
  return e ^= e >>> 13, e = /* Math.imul(h, m): */
  (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
}
function fo() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function TG(n, e) {
  if (!n)
    return !1;
  if (n.contains)
    return n.contains(e);
  for (var t = e; t; ) {
    if (t === n)
      return !0;
    t = t.parentNode;
  }
  return !1;
}
var zN = "data-rc-order", BN = "data-rc-priority", RG = "rc-util-key", kT = /* @__PURE__ */ new Map();
function fz() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = n.mark;
  return e ? e.startsWith("data-") ? e : "data-".concat(e) : RG;
}
function pE(n) {
  if (n.attachTo)
    return n.attachTo;
  var e = document.querySelector("head");
  return e || document.body;
}
function AG(n) {
  return n === "queue" ? "prependQueue" : n ? "prepend" : "append";
}
function PA(n) {
  return Array.from((kT.get(n) || n).children).filter(function(e) {
    return e.tagName === "STYLE";
  });
}
function hz(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!fo())
    return null;
  var t = e.csp, r = e.prepend, i = e.priority, a = i === void 0 ? 0 : i, o = AG(r), s = o === "prependQueue", u = document.createElement("style");
  u.setAttribute(zN, o), s && a && u.setAttribute(BN, "".concat(a)), t != null && t.nonce && (u.nonce = t == null ? void 0 : t.nonce), u.innerHTML = n;
  var d = pE(e), f = d.firstChild;
  if (r) {
    if (s) {
      var p = (e.styles || PA(d)).filter(function(g) {
        if (!["prepend", "prependQueue"].includes(g.getAttribute(zN)))
          return !1;
        var v = Number(g.getAttribute(BN) || 0);
        return a >= v;
      });
      if (p.length)
        return d.insertBefore(u, p[p.length - 1].nextSibling), u;
    }
    d.insertBefore(u, f);
  } else
    d.appendChild(u);
  return u;
}
function pz(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = pE(e);
  return (e.styles || PA(t)).find(function(r) {
    return r.getAttribute(fz(e)) === n;
  });
}
function ky(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = pz(n, e);
  if (t) {
    var r = pE(e);
    r.removeChild(t);
  }
}
function OG(n, e) {
  var t = kT.get(n);
  if (!t || !TG(document, t)) {
    var r = hz("", e), i = r.parentNode;
    kT.set(n, i), n.removeChild(r);
  }
}
function lu(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = pE(t), i = PA(r), a = ke(ke({}, t), {}, {
    styles: i
  });
  OG(r, a);
  var o = pz(e, a);
  if (o) {
    var s, u;
    if ((s = a.csp) !== null && s !== void 0 && s.nonce && o.nonce !== ((u = a.csp) === null || u === void 0 ? void 0 : u.nonce)) {
      var d;
      o.nonce = (d = a.csp) === null || d === void 0 ? void 0 : d.nonce;
    }
    return o.innerHTML !== n && (o.innerHTML = n), o;
  }
  var f = hz(n, a);
  return f.setAttribute(fz(a), e), f;
}
function PG(n, e) {
  if (n == null) return {};
  var t = {};
  for (var r in n) if ({}.hasOwnProperty.call(n, r)) {
    if (e.includes(r)) continue;
    t[r] = n[r];
  }
  return t;
}
function br(n, e) {
  if (n == null) return {};
  var t, r, i = PG(n, e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(n);
    for (r = 0; r < a.length; r++) t = a[r], e.includes(t) || {}.propertyIsEnumerable.call(n, t) && (i[t] = n[t]);
  }
  return i;
}
function $T(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = /* @__PURE__ */ new Set();
  function i(a, o) {
    var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, u = r.has(a);
    if (Yn(!u, "Warning: There may be circular references"), u)
      return !1;
    if (a === o)
      return !0;
    if (t && s > 1)
      return !1;
    r.add(a);
    var d = s + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(o) || a.length !== o.length)
        return !1;
      for (var f = 0; f < a.length; f++)
        if (!i(a[f], o[f], d))
          return !1;
      return !0;
    }
    if (a && o && bn(a) === "object" && bn(o) === "object") {
      var p = Object.keys(a);
      return p.length !== Object.keys(o).length ? !1 : p.every(function(g) {
        return i(a[g], o[g], d);
      });
    }
    return !1;
  }
  return i(n, e);
}
var DG = "%";
function WT(n) {
  return n.join(DG);
}
var IG = /* @__PURE__ */ function() {
  function n(e) {
    ki(this, n), Re(this, "instanceId", void 0), Re(this, "cache", /* @__PURE__ */ new Map()), this.instanceId = e;
  }
  return $i(n, [{
    key: "get",
    value: function(t) {
      return this.opGet(WT(t));
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opGet",
    value: function(t) {
      return this.cache.get(t) || null;
    }
  }, {
    key: "update",
    value: function(t, r) {
      return this.opUpdate(WT(t), r);
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opUpdate",
    value: function(t, r) {
      var i = this.cache.get(t), a = r(i);
      a === null ? this.cache.delete(t) : this.cache.set(t, a);
    }
  }]), n;
}(), Qm = "data-token-hash", Cl = "data-css-hash", NG = "data-cache-path", zd = "__cssinjs_instance__";
function LG() {
  var n = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var e = document.body.querySelectorAll("style[".concat(Cl, "]")) || [], t = document.head.firstChild;
    Array.from(e).forEach(function(i) {
      i[zd] = i[zd] || n, i[zd] === n && document.head.insertBefore(i, t);
    });
    var r = {};
    Array.from(document.querySelectorAll("style[".concat(Cl, "]"))).forEach(function(i) {
      var a = i.getAttribute(Cl);
      if (r[a]) {
        if (i[zd] === n) {
          var o;
          (o = i.parentNode) === null || o === void 0 || o.removeChild(i);
        }
      } else
        r[a] = !0;
    });
  }
  return new IG(n);
}
var mE = /* @__PURE__ */ O.createContext({
  hashPriority: "low",
  cache: LG(),
  defaultCache: !0
}), mz = /* @__PURE__ */ $i(function n() {
  ki(this, n);
}), gz = "CALC_UNIT", FG = new RegExp(gz, "g");
function D1(n) {
  return typeof n == "number" ? "".concat(n).concat(gz) : n;
}
var UG = /* @__PURE__ */ function(n) {
  Wd(t, n);
  var e = jd(t);
  function t(r, i) {
    var a;
    ki(this, t), a = e.call(this), Re(tr(a), "result", ""), Re(tr(a), "unitlessCssVar", void 0), Re(tr(a), "lowPriority", void 0);
    var o = bn(r);
    return a.unitlessCssVar = i, r instanceof t ? a.result = "(".concat(r.result, ")") : o === "number" ? a.result = D1(r) : o === "string" && (a.result = r), a;
  }
  return $i(t, [{
    key: "add",
    value: function(i) {
      return i instanceof t ? this.result = "".concat(this.result, " + ").concat(i.getResult()) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " + ").concat(D1(i))), this.lowPriority = !0, this;
    }
  }, {
    key: "sub",
    value: function(i) {
      return i instanceof t ? this.result = "".concat(this.result, " - ").concat(i.getResult()) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " - ").concat(D1(i))), this.lowPriority = !0, this;
    }
  }, {
    key: "mul",
    value: function(i) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), i instanceof t ? this.result = "".concat(this.result, " * ").concat(i.getResult(!0)) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " * ").concat(i)), this.lowPriority = !1, this;
    }
  }, {
    key: "div",
    value: function(i) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), i instanceof t ? this.result = "".concat(this.result, " / ").concat(i.getResult(!0)) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " / ").concat(i)), this.lowPriority = !1, this;
    }
  }, {
    key: "getResult",
    value: function(i) {
      return this.lowPriority || i ? "(".concat(this.result, ")") : this.result;
    }
  }, {
    key: "equal",
    value: function(i) {
      var a = this, o = i || {}, s = o.unit, u = !0;
      return typeof s == "boolean" ? u = s : Array.from(this.unitlessCssVar).some(function(d) {
        return a.result.includes(d);
      }) && (u = !1), this.result = this.result.replace(FG, u ? "px" : ""), typeof this.lowPriority < "u" ? "calc(".concat(this.result, ")") : this.result;
    }
  }]), t;
}(mz), zG = /* @__PURE__ */ function(n) {
  Wd(t, n);
  var e = jd(t);
  function t(r) {
    var i;
    return ki(this, t), i = e.call(this), Re(tr(i), "result", 0), r instanceof t ? i.result = r.result : typeof r == "number" && (i.result = r), i;
  }
  return $i(t, [{
    key: "add",
    value: function(i) {
      return i instanceof t ? this.result += i.result : typeof i == "number" && (this.result += i), this;
    }
  }, {
    key: "sub",
    value: function(i) {
      return i instanceof t ? this.result -= i.result : typeof i == "number" && (this.result -= i), this;
    }
  }, {
    key: "mul",
    value: function(i) {
      return i instanceof t ? this.result *= i.result : typeof i == "number" && (this.result *= i), this;
    }
  }, {
    key: "div",
    value: function(i) {
      return i instanceof t ? this.result /= i.result : typeof i == "number" && (this.result /= i), this;
    }
  }, {
    key: "equal",
    value: function() {
      return this.result;
    }
  }]), t;
}(mz), BG = function(e, t) {
  var r = e === "css" ? UG : zG;
  return function(i) {
    return new r(i, t);
  };
};
function HG(n, e) {
  if (n.length !== e.length)
    return !1;
  for (var t = 0; t < n.length; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
var DA = /* @__PURE__ */ function() {
  function n() {
    ki(this, n), Re(this, "cache", void 0), Re(this, "keys", void 0), Re(this, "cacheCallTimes", void 0), this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  return $i(n, [{
    key: "size",
    value: function() {
      return this.keys.length;
    }
  }, {
    key: "internalGet",
    value: function(t) {
      var r, i, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o = {
        map: this.cache
      };
      return t.forEach(function(s) {
        if (!o)
          o = void 0;
        else {
          var u;
          o = (u = o) === null || u === void 0 || (u = u.map) === null || u === void 0 ? void 0 : u.get(s);
        }
      }), (r = o) !== null && r !== void 0 && r.value && a && (o.value[1] = this.cacheCallTimes++), (i = o) === null || i === void 0 ? void 0 : i.value;
    }
  }, {
    key: "get",
    value: function(t) {
      var r;
      return (r = this.internalGet(t, !0)) === null || r === void 0 ? void 0 : r[0];
    }
  }, {
    key: "has",
    value: function(t) {
      return !!this.internalGet(t);
    }
  }, {
    key: "set",
    value: function(t, r) {
      var i = this;
      if (!this.has(t)) {
        if (this.size() + 1 > n.MAX_CACHE_SIZE + n.MAX_CACHE_OFFSET) {
          var a = this.keys.reduce(function(d, f) {
            var p = ot(d, 2), g = p[1];
            return i.internalGet(f)[1] < g ? [f, i.internalGet(f)[1]] : d;
          }, [this.keys[0], this.cacheCallTimes]), o = ot(a, 1), s = o[0];
          this.delete(s);
        }
        this.keys.push(t);
      }
      var u = this.cache;
      t.forEach(function(d, f) {
        if (f === t.length - 1)
          u.set(d, {
            value: [r, i.cacheCallTimes++]
          });
        else {
          var p = u.get(d);
          p ? p.map || (p.map = /* @__PURE__ */ new Map()) : u.set(d, {
            map: /* @__PURE__ */ new Map()
          }), u = u.get(d).map;
        }
      });
    }
  }, {
    key: "deleteByPath",
    value: function(t, r) {
      var i = t.get(r[0]);
      if (r.length === 1) {
        var a;
        return i.map ? t.set(r[0], {
          map: i.map
        }) : t.delete(r[0]), (a = i.value) === null || a === void 0 ? void 0 : a[0];
      }
      var o = this.deleteByPath(i.map, r.slice(1));
      return (!i.map || i.map.size === 0) && !i.value && t.delete(r[0]), o;
    }
  }, {
    key: "delete",
    value: function(t) {
      if (this.has(t))
        return this.keys = this.keys.filter(function(r) {
          return !HG(r, t);
        }), this.deleteByPath(this.cache, t);
    }
  }]), n;
}();
Re(DA, "MAX_CACHE_SIZE", 20);
Re(DA, "MAX_CACHE_OFFSET", 5);
var HN = 0, vz = /* @__PURE__ */ function() {
  function n(e) {
    ki(this, n), Re(this, "derivatives", void 0), Re(this, "id", void 0), this.derivatives = Array.isArray(e) ? e : [e], this.id = HN, e.length === 0 && Th(e.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function."), HN += 1;
  }
  return $i(n, [{
    key: "getDerivativeToken",
    value: function(t) {
      return this.derivatives.reduce(function(r, i) {
        return i(t, r);
      }, void 0);
    }
  }]), n;
}(), I1 = new DA();
function jT(n) {
  var e = Array.isArray(n) ? n : [n];
  return I1.has(e) || I1.set(e, new vz(e)), I1.get(e);
}
var VG = /* @__PURE__ */ new WeakMap(), N1 = {};
function kG(n, e) {
  for (var t = VG, r = 0; r < e.length; r += 1) {
    var i = e[r];
    t.has(i) || t.set(i, /* @__PURE__ */ new WeakMap()), t = t.get(i);
  }
  return t.has(N1) || t.set(N1, n()), t.get(N1);
}
var VN = /* @__PURE__ */ new WeakMap();
function Sy(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, t = VN.get(n) || "";
  return t || (Object.keys(n).forEach(function(r) {
    var i = n[r];
    t += r, i instanceof vz ? t += i.id : i && bn(i) === "object" ? t += Sy(i, e) : t += i;
  }), e && (t = Vy(t)), VN.set(n, t)), t;
}
function kN(n, e) {
  return Vy("".concat(e, "_").concat(Sy(n, !0)));
}
var GT = fo();
function Mt(n) {
  return typeof n == "number" ? "".concat(n, "px") : n;
}
function ux(n, e, t) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (i)
    return n;
  var a = ke(ke({}, r), {}, Re(Re({}, Qm, e), Cl, t)), o = Object.keys(a).map(function(s) {
    var u = a[s];
    return u ? "".concat(s, '="').concat(u, '"') : null;
  }).filter(function(s) {
    return s;
  }).join(" ");
  return "<style ".concat(o, ">").concat(n, "</style>");
}
var j_ = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return "--".concat(t ? "".concat(t, "-") : "").concat(e).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
}, $G = function(e, t, r) {
  return Object.keys(e).length ? ".".concat(t).concat(r != null && r.scope ? ".".concat(r.scope) : "", "{").concat(Object.entries(e).map(function(i) {
    var a = ot(i, 2), o = a[0], s = a[1];
    return "".concat(o, ":").concat(s, ";");
  }).join(""), "}") : "";
}, yz = function(e, t, r) {
  var i = {}, a = {};
  return Object.entries(e).forEach(function(o) {
    var s, u, d = ot(o, 2), f = d[0], p = d[1];
    if (r != null && (s = r.preserve) !== null && s !== void 0 && s[f])
      a[f] = p;
    else if ((typeof p == "string" || typeof p == "number") && !(r != null && (u = r.ignore) !== null && u !== void 0 && u[f])) {
      var g, v = j_(f, r == null ? void 0 : r.prefix);
      i[v] = typeof p == "number" && !(r != null && (g = r.unitless) !== null && g !== void 0 && g[f]) ? "".concat(p, "px") : String(p), a[f] = "var(".concat(v, ")");
    }
  }), [a, $G(i, t, {
    scope: r == null ? void 0 : r.scope
  })];
}, $N = Ee.env.NODE_ENV !== "test" && fo() ? O.useLayoutEffect : O.useEffect, ti = function(e, t) {
  var r = O.useRef(!0);
  $N(function() {
    return e(r.current);
  }, t), $N(function() {
    return r.current = !1, function() {
      r.current = !0;
    };
  }, []);
}, _y = function(e, t) {
  ti(function(r) {
    if (!r)
      return e();
  }, t);
}, WG = ke({}, O), WN = WG.useInsertionEffect, jG = function(e, t, r) {
  O.useMemo(e, r), ti(function() {
    return t(!0);
  }, r);
}, GG = WN ? function(n, e, t) {
  return WN(function() {
    return n(), e();
  }, t);
} : jG, XG = ke({}, O), qG = XG.useInsertionEffect, YG = function(e) {
  var t = [], r = !1;
  function i(a) {
    if (r) {
      Ee.env.NODE_ENV !== "production" && Th(!1, "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect.");
      return;
    }
    t.push(a);
  }
  return O.useEffect(function() {
    return r = !1, function() {
      r = !0, t.length && t.forEach(function(a) {
        return a();
      });
    };
  }, e), i;
}, KG = function() {
  return function(e) {
    e();
  };
}, ZG = typeof qG < "u" ? YG : KG;
function QG() {
  return !1;
}
var XT = !1;
function JG() {
  return XT;
}
const e9 = Ee.env.NODE_ENV === "production" ? QG : JG;
if (Ee.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  var L1 = window;
  if (typeof L1.webpackHotUpdate == "function") {
    var t9 = L1.webpackHotUpdate;
    L1.webpackHotUpdate = function() {
      return XT = !0, setTimeout(function() {
        XT = !1;
      }, 0), t9.apply(void 0, arguments);
    };
  }
}
function IA(n, e, t, r, i) {
  var a = O.useContext(mE), o = a.cache, s = [n].concat(jt(e)), u = WT(s), d = ZG([u]), f = e9(), p = function(E) {
    o.opUpdate(u, function(S) {
      var _ = S || [void 0, void 0], w = ot(_, 2), C = w[0], R = C === void 0 ? 0 : C, P = w[1], D = P;
      Ee.env.NODE_ENV !== "production" && P && f && (r == null || r(D, f), D = null);
      var I = D || t(), U = [R, I];
      return E ? E(U) : U;
    });
  };
  O.useMemo(
    function() {
      p();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [u]
    /* eslint-enable */
  );
  var g = o.opGet(u);
  Ee.env.NODE_ENV !== "production" && !g && (p(), g = o.opGet(u));
  var v = g[1];
  return GG(function() {
    i == null || i(v);
  }, function(b) {
    return p(function(E) {
      var S = ot(E, 2), _ = S[0], w = S[1];
      return b && _ === 0 && (i == null || i(v)), [_ + 1, w];
    }), function() {
      o.opUpdate(u, function(E) {
        var S = E || [], _ = ot(S, 2), w = _[0], C = w === void 0 ? 0 : w, R = _[1], P = C - 1;
        return P === 0 ? (d(function() {
          (b || !o.opGet(u)) && (r == null || r(R, !1));
        }), null) : [C - 1, R];
      });
    };
  }, [u]), v;
}
var n9 = {}, r9 = Ee.env.NODE_ENV !== "production" ? "css-dev-only-do-not-override" : "css", rh = /* @__PURE__ */ new Map();
function i9(n) {
  rh.set(n, (rh.get(n) || 0) + 1);
}
function a9(n, e) {
  if (typeof document < "u") {
    var t = document.querySelectorAll("style[".concat(Qm, '="').concat(n, '"]'));
    t.forEach(function(r) {
      if (r[zd] === e) {
        var i;
        (i = r.parentNode) === null || i === void 0 || i.removeChild(r);
      }
    });
  }
}
var o9 = 0;
function s9(n, e) {
  rh.set(n, (rh.get(n) || 0) - 1);
  var t = Array.from(rh.keys()), r = t.filter(function(i) {
    var a = rh.get(i) || 0;
    return a <= 0;
  });
  t.length - r.length > o9 && r.forEach(function(i) {
    a9(i, e), rh.delete(i);
  });
}
var l9 = function(e, t, r, i) {
  var a = r.getDerivativeToken(e), o = ke(ke({}, a), t);
  return i && (o = i(o)), o;
}, bz = "token";
function c9(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = ni(mE), i = r.cache.instanceId, a = r.container, o = t.salt, s = o === void 0 ? "" : o, u = t.override, d = u === void 0 ? n9 : u, f = t.formatToken, p = t.getComputedToken, g = t.cssVar, v = kG(function() {
    return Object.assign.apply(Object, [{}].concat(jt(e)));
  }, e), b = Sy(v), E = Sy(d), S = g ? Sy(g) : "", _ = IA(bz, [s, n.id, b, E, S], function() {
    var w, C = p ? p(v, d, n) : l9(v, d, n, f), R = ke({}, C), P = "";
    if (g) {
      var D = yz(C, g.key, {
        prefix: g.prefix,
        ignore: g.ignore,
        unitless: g.unitless,
        preserve: g.preserve
      }), I = ot(D, 2);
      C = I[0], P = I[1];
    }
    var U = kN(C, s);
    C._tokenKey = U, R._tokenKey = kN(R, s);
    var L = (w = g == null ? void 0 : g.key) !== null && w !== void 0 ? w : U;
    C._themeKey = L, i9(L);
    var N = "".concat(r9, "-").concat(Vy(U));
    return C._hashId = N, [C, N, R, P, (g == null ? void 0 : g.key) || ""];
  }, function(w) {
    s9(w[0]._themeKey, i);
  }, function(w) {
    var C = ot(w, 4), R = C[0], P = C[3];
    if (g && P) {
      var D = lu(P, Vy("css-variables-".concat(R._themeKey)), {
        mark: Cl,
        prepend: "queue",
        attachTo: a,
        priority: -999
      });
      D[zd] = i, D.setAttribute(Qm, R._themeKey);
    }
  });
  return _;
}
var u9 = function(e, t, r) {
  var i = ot(e, 5), a = i[2], o = i[3], s = i[4], u = r || {}, d = u.plain;
  if (!o)
    return null;
  var f = a._tokenKey, p = -999, g = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(p)
  }, v = ux(o, s, f, g, d);
  return [p, f, v];
}, d9 = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, oi = "-ms-", xy = "-moz-", Nr = "-webkit-", Sz = "comm", gE = "rule", NA = "decl", f9 = "@import", _z = "@keyframes", h9 = "@layer", xz = Math.abs, LA = String.fromCharCode, qT = Object.assign;
function p9(n, e) {
  return ya(n, 0) ^ 45 ? (((e << 2 ^ ya(n, 0)) << 2 ^ ya(n, 1)) << 2 ^ ya(n, 2)) << 2 ^ ya(n, 3) : 0;
}
function Ez(n) {
  return n.trim();
}
function nu(n, e) {
  return (n = e.exec(n)) ? n[0] : n;
}
function qn(n, e, t) {
  return n.replace(e, t);
}
function G_(n, e, t) {
  return n.indexOf(e, t);
}
function ya(n, e) {
  return n.charCodeAt(e) | 0;
}
function Jm(n, e, t) {
  return n.slice(e, t);
}
function rc(n) {
  return n.length;
}
function Cz(n) {
  return n.length;
}
function py(n, e) {
  return e.push(n), n;
}
function m9(n, e) {
  return n.map(e).join("");
}
function jN(n, e) {
  return n.filter(function(t) {
    return !nu(t, e);
  });
}
var vE = 1, eg = 1, wz = 0, qs = 0, qi = 0, mg = "";
function yE(n, e, t, r, i, a, o, s) {
  return { value: n, root: e, parent: t, type: r, props: i, children: a, line: vE, column: eg, length: o, return: "", siblings: s };
}
function Dd(n, e) {
  return qT(yE("", null, null, "", null, null, 0, n.siblings), n, { length: -n.length }, e);
}
function Qp(n) {
  for (; n.root; )
    n = Dd(n.root, { children: [n] });
  py(n, n.siblings);
}
function g9() {
  return qi;
}
function v9() {
  return qi = qs > 0 ? ya(mg, --qs) : 0, eg--, qi === 10 && (eg = 1, vE--), qi;
}
function wl() {
  return qi = qs < wz ? ya(mg, qs++) : 0, eg++, qi === 10 && (eg = 1, vE++), qi;
}
function gh() {
  return ya(mg, qs);
}
function X_() {
  return qs;
}
function bE(n, e) {
  return Jm(mg, n, e);
}
function YT(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function y9(n) {
  return vE = eg = 1, wz = rc(mg = n), qs = 0, [];
}
function b9(n) {
  return mg = "", n;
}
function F1(n) {
  return Ez(bE(qs - 1, KT(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function S9(n) {
  for (; (qi = gh()) && qi < 33; )
    wl();
  return YT(n) > 2 || YT(qi) > 3 ? "" : " ";
}
function _9(n, e) {
  for (; --e && wl() && !(qi < 48 || qi > 102 || qi > 57 && qi < 65 || qi > 70 && qi < 97); )
    ;
  return bE(n, X_() + (e < 6 && gh() == 32 && wl() == 32));
}
function KT(n) {
  for (; wl(); )
    switch (qi) {
      case n:
        return qs;
      case 34:
      case 39:
        n !== 34 && n !== 39 && KT(qi);
        break;
      case 40:
        n === 41 && KT(n);
        break;
      case 92:
        wl();
        break;
    }
  return qs;
}
function x9(n, e) {
  for (; wl() && n + qi !== 57; )
    if (n + qi === 84 && gh() === 47)
      break;
  return "/*" + bE(e, qs - 1) + "*" + LA(n === 47 ? n : wl());
}
function E9(n) {
  for (; !YT(gh()); )
    wl();
  return bE(n, qs);
}
function Mz(n) {
  return b9(q_("", null, null, null, [""], n = y9(n), 0, [0], n));
}
function q_(n, e, t, r, i, a, o, s, u) {
  for (var d = 0, f = 0, p = o, g = 0, v = 0, b = 0, E = 1, S = 1, _ = 1, w = 0, C = "", R = i, P = a, D = r, I = C; S; )
    switch (b = w, w = wl()) {
      case 40:
        if (b != 108 && ya(I, p - 1) == 58) {
          G_(I += qn(F1(w), "&", "&\f"), "&\f", xz(d ? s[d - 1] : 0)) != -1 && (_ = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        I += F1(w);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        I += S9(b);
        break;
      case 92:
        I += _9(X_() - 1, 7);
        continue;
      case 47:
        switch (gh()) {
          case 42:
          case 47:
            py(C9(x9(wl(), X_()), e, t, u), u);
            break;
          default:
            I += "/";
        }
        break;
      case 123 * E:
        s[d++] = rc(I) * _;
      case 125 * E:
      case 59:
      case 0:
        switch (w) {
          case 0:
          case 125:
            S = 0;
          case 59 + f:
            _ == -1 && (I = qn(I, /\f/g, "")), v > 0 && rc(I) - p && py(v > 32 ? XN(I + ";", r, t, p - 1, u) : XN(qn(I, " ", "") + ";", r, t, p - 2, u), u);
            break;
          case 59:
            I += ";";
          default:
            if (py(D = GN(I, e, t, d, f, i, s, C, R = [], P = [], p, a), a), w === 123)
              if (f === 0)
                q_(I, e, D, D, R, a, p, s, P);
              else
                switch (g === 99 && ya(I, 3) === 110 ? 100 : g) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    q_(n, D, D, r && py(GN(n, D, D, 0, 0, i, s, C, i, R = [], p, P), P), i, P, p, s, r ? R : P);
                    break;
                  default:
                    q_(I, D, D, D, [""], P, 0, s, P);
                }
        }
        d = f = v = 0, E = _ = 1, C = I = "", p = o;
        break;
      case 58:
        p = 1 + rc(I), v = b;
      default:
        if (E < 1) {
          if (w == 123)
            --E;
          else if (w == 125 && E++ == 0 && v9() == 125)
            continue;
        }
        switch (I += LA(w), w * E) {
          case 38:
            _ = f > 0 ? 1 : (I += "\f", -1);
            break;
          case 44:
            s[d++] = (rc(I) - 1) * _, _ = 1;
            break;
          case 64:
            gh() === 45 && (I += F1(wl())), g = gh(), f = p = rc(C = I += E9(X_())), w++;
            break;
          case 45:
            b === 45 && rc(I) == 2 && (E = 0);
        }
    }
  return a;
}
function GN(n, e, t, r, i, a, o, s, u, d, f, p) {
  for (var g = i - 1, v = i === 0 ? a : [""], b = Cz(v), E = 0, S = 0, _ = 0; E < r; ++E)
    for (var w = 0, C = Jm(n, g + 1, g = xz(S = o[E])), R = n; w < b; ++w)
      (R = Ez(S > 0 ? v[w] + " " + C : qn(C, /&\f/g, v[w]))) && (u[_++] = R);
  return yE(n, e, t, i === 0 ? gE : s, u, d, f, p);
}
function C9(n, e, t, r) {
  return yE(n, e, t, Sz, LA(g9()), Jm(n, 2, -2), 0, r);
}
function XN(n, e, t, r, i) {
  return yE(n, e, t, NA, Jm(n, 0, r), Jm(n, r + 1, -1), r, i);
}
function Tz(n, e, t) {
  switch (p9(n, e)) {
    case 5103:
      return Nr + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Nr + n + n;
    case 4789:
      return xy + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Nr + n + xy + n + oi + n + n;
    case 5936:
      switch (ya(n, e + 11)) {
        case 114:
          return Nr + n + oi + qn(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return Nr + n + oi + qn(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return Nr + n + oi + qn(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
    case 6828:
    case 4268:
    case 2903:
      return Nr + n + oi + n + n;
    case 6165:
      return Nr + n + oi + "flex-" + n + n;
    case 5187:
      return Nr + n + qn(n, /(\w+).+(:[^]+)/, Nr + "box-$1$2" + oi + "flex-$1$2") + n;
    case 5443:
      return Nr + n + oi + "flex-item-" + qn(n, /flex-|-self/g, "") + (nu(n, /flex-|baseline/) ? "" : oi + "grid-row-" + qn(n, /flex-|-self/g, "")) + n;
    case 4675:
      return Nr + n + oi + "flex-line-pack" + qn(n, /align-content|flex-|-self/g, "") + n;
    case 5548:
      return Nr + n + oi + qn(n, "shrink", "negative") + n;
    case 5292:
      return Nr + n + oi + qn(n, "basis", "preferred-size") + n;
    case 6060:
      return Nr + "box-" + qn(n, "-grow", "") + Nr + n + oi + qn(n, "grow", "positive") + n;
    case 4554:
      return Nr + qn(n, /([^-])(transform)/g, "$1" + Nr + "$2") + n;
    case 6187:
      return qn(qn(qn(n, /(zoom-|grab)/, Nr + "$1"), /(image-set)/, Nr + "$1"), n, "") + n;
    case 5495:
    case 3959:
      return qn(n, /(image-set\([^]*)/, Nr + "$1$`$1");
    case 4968:
      return qn(qn(n, /(.+:)(flex-)?(.*)/, Nr + "box-pack:$3" + oi + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Nr + n + n;
    case 4200:
      if (!nu(n, /flex-|baseline/)) return oi + "grid-column-align" + Jm(n, e) + n;
      break;
    case 2592:
    case 3360:
      return oi + qn(n, "template-", "") + n;
    case 4384:
    case 3616:
      return t && t.some(function(r, i) {
        return e = i, nu(r.props, /grid-\w+-end/);
      }) ? ~G_(n + (t = t[e].value), "span", 0) ? n : oi + qn(n, "-start", "") + n + oi + "grid-row-span:" + (~G_(t, "span", 0) ? nu(t, /\d+/) : +nu(t, /\d+/) - +nu(n, /\d+/)) + ";" : oi + qn(n, "-start", "") + n;
    case 4896:
    case 4128:
      return t && t.some(function(r) {
        return nu(r.props, /grid-\w+-start/);
      }) ? n : oi + qn(qn(n, "-end", "-span"), "span ", "") + n;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return qn(n, /(.+)-inline(.+)/, Nr + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (rc(n) - 1 - e > 6)
        switch (ya(n, e + 1)) {
          case 109:
            if (ya(n, e + 4) !== 45)
              break;
          case 102:
            return qn(n, /(.+:)(.+)-([^]+)/, "$1" + Nr + "$2-$3$1" + xy + (ya(n, e + 3) == 108 ? "$3" : "$2-$3")) + n;
          case 115:
            return ~G_(n, "stretch", 0) ? Tz(qn(n, "stretch", "fill-available"), e, t) + n : n;
        }
      break;
    case 5152:
    case 5920:
      return qn(n, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(r, i, a, o, s, u, d) {
        return oi + i + ":" + a + d + (o ? oi + i + "-span:" + (s ? u : +u - +a) + d : "") + n;
      });
    case 4949:
      if (ya(n, e + 6) === 121)
        return qn(n, ":", ":" + Nr) + n;
      break;
    case 6444:
      switch (ya(n, ya(n, 14) === 45 ? 18 : 11)) {
        case 120:
          return qn(n, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + Nr + (ya(n, 14) === 45 ? "inline-" : "") + "box$3$1" + Nr + "$2$3$1" + oi + "$2box$3") + n;
        case 100:
          return qn(n, ":", ":" + oi) + n;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return qn(n, "scroll-", "scroll-snap-") + n;
  }
  return n;
}
function $y(n, e) {
  for (var t = "", r = 0; r < n.length; r++)
    t += e(n[r], r, n, e) || "";
  return t;
}
function Rz(n, e, t, r) {
  switch (n.type) {
    case h9:
      if (n.children.length) break;
    case f9:
    case NA:
      return n.return = n.return || n.value;
    case Sz:
      return "";
    case _z:
      return n.return = n.value + "{" + $y(n.children, r) + "}";
    case gE:
      if (!rc(n.value = n.props.join(","))) return "";
  }
  return rc(t = $y(n.children, r)) ? n.return = n.value + "{" + t + "}" : "";
}
function w9(n) {
  var e = Cz(n);
  return function(t, r, i, a) {
    for (var o = "", s = 0; s < e; s++)
      o += n[s](t, r, i, a) || "";
    return o;
  };
}
function M9(n) {
  return function(e) {
    e.root || (e = e.return) && n(e);
  };
}
function T9(n, e, t, r) {
  if (n.length > -1 && !n.return)
    switch (n.type) {
      case NA:
        n.return = Tz(n.value, n.length, t);
        return;
      case _z:
        return $y([Dd(n, { value: qn(n.value, "@", "@" + Nr) })], r);
      case gE:
        if (n.length)
          return m9(t = n.props, function(i) {
            switch (nu(i, r = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                Qp(Dd(n, { props: [qn(i, /:(read-\w+)/, ":" + xy + "$1")] })), Qp(Dd(n, { props: [i] })), qT(n, { props: jN(t, r) });
                break;
              case "::placeholder":
                Qp(Dd(n, { props: [qn(i, /:(plac\w+)/, ":" + Nr + "input-$1")] })), Qp(Dd(n, { props: [qn(i, /:(plac\w+)/, ":" + xy + "$1")] })), Qp(Dd(n, { props: [qn(i, /:(plac\w+)/, oi + "input-$1")] })), Qp(Dd(n, { props: [i] })), qT(n, { props: jN(t, r) });
                break;
            }
            return "";
          });
    }
}
function Az(n, e) {
  var t = e.path, r = e.parentSelectors;
  Yn(!1, "[Ant Design CSS-in-JS] ".concat(t ? "Error in ".concat(t, ": ") : "").concat(n).concat(r.length ? " Selector: ".concat(r.join(" | ")) : ""));
}
var R9 = function(e, t, r) {
  if (e === "content") {
    var i = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, a = ["normal", "none", "initial", "inherit", "unset"];
    (typeof t != "string" || a.indexOf(t) === -1 && !i.test(t) && (t.charAt(0) !== t.charAt(t.length - 1) || t.charAt(0) !== '"' && t.charAt(0) !== "'")) && Az("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(t, "\"'`."), r);
  }
}, A9 = function(e, t, r) {
  e === "animation" && r.hashId && t !== "none" && Az("You seem to be using hashed animation '".concat(t, "', in which case 'animationName' with Keyframe as value is recommended."), r);
}, qN = "data-ant-cssinjs-cache-path", Oz = "_FILE_STYLE__", vh, Pz = !0;
function O9() {
  if (!vh && (vh = {}, fo())) {
    var n = document.createElement("div");
    n.className = qN, n.style.position = "fixed", n.style.visibility = "hidden", n.style.top = "-9999px", document.body.appendChild(n);
    var e = getComputedStyle(n).content || "";
    e = e.replace(/^"/, "").replace(/"$/, ""), e.split(";").forEach(function(i) {
      var a = i.split(":"), o = ot(a, 2), s = o[0], u = o[1];
      vh[s] = u;
    });
    var t = document.querySelector("style[".concat(qN, "]"));
    if (t) {
      var r;
      Pz = !1, (r = t.parentNode) === null || r === void 0 || r.removeChild(t);
    }
    document.body.removeChild(n);
  }
}
function P9(n) {
  return O9(), !!vh[n];
}
function D9(n) {
  var e = vh[n], t = null;
  if (e && fo())
    if (Pz)
      t = Oz;
    else {
      var r = document.querySelector("style[".concat(Cl, '="').concat(vh[n], '"]'));
      r ? t = r.innerHTML : delete vh[n];
    }
  return [t, e];
}
var Dz = "_skip_check_", Iz = "_multi_value_";
function Y_(n) {
  var e = $y(Mz(n), Rz);
  return e.replace(/\{%%%\:[^;];}/g, ";");
}
function I9(n) {
  return bn(n) === "object" && n && (Dz in n || Iz in n);
}
function N9(n, e, t) {
  if (!e)
    return n;
  var r = ".".concat(e), i = t === "low" ? ":where(".concat(r, ")") : r, a = n.split(",").map(function(o) {
    var s, u = o.trim().split(/\s+/), d = u[0] || "", f = ((s = d.match(/^\w+/)) === null || s === void 0 ? void 0 : s[0]) || "";
    return d = "".concat(f).concat(i).concat(d.slice(f.length)), [d].concat(jt(u.slice(1))).join(" ");
  });
  return a.join(",");
}
var L9 = function n(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  }, i = r.root, a = r.injectHash, o = r.parentSelectors, s = t.hashId, u = t.layer, d = t.path, f = t.hashPriority, p = t.transformers, g = p === void 0 ? [] : p, v = t.linters, b = v === void 0 ? [] : v, E = "", S = {};
  function _(R) {
    var P = R.getName(s);
    if (!S[P]) {
      var D = n(R.style, t, {
        root: !1,
        parentSelectors: o
      }), I = ot(D, 1), U = I[0];
      S[P] = "@keyframes ".concat(R.getName(s)).concat(U);
    }
  }
  function w(R) {
    var P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return R.forEach(function(D) {
      Array.isArray(D) ? w(D, P) : D && P.push(D);
    }), P;
  }
  var C = w(Array.isArray(e) ? e : [e]);
  return C.forEach(function(R) {
    var P = typeof R == "string" && !i ? {} : R;
    if (typeof P == "string")
      E += "".concat(P, `
`);
    else if (P._keyframe)
      _(P);
    else {
      var D = g.reduce(function(I, U) {
        var L;
        return (U == null || (L = U.visit) === null || L === void 0 ? void 0 : L.call(U, I)) || I;
      }, P);
      Object.keys(D).forEach(function(I) {
        var U = D[I];
        if (bn(U) === "object" && U && (I !== "animationName" || !U._keyframe) && !I9(U)) {
          var L = !1, N = I.trim(), H = !1;
          (i || a) && s ? N.startsWith("@") ? L = !0 : N = N9(I, s, f) : i && !s && (N === "&" || N === "") && (N = "", H = !0);
          var j = n(U, t, {
            root: H,
            injectHash: L,
            parentSelectors: [].concat(jt(o), [N])
          }), G = ot(j, 2), X = G[0], ae = G[1];
          S = ke(ke({}, S), ae), E += "".concat(N).concat(X);
        } else {
          let B = function(Q, V) {
            Ee.env.NODE_ENV !== "production" && (bn(U) !== "object" || !(U != null && U[Dz])) && [R9, A9].concat(jt(b)).forEach(function(ce) {
              return ce(Q, V, {
                path: d,
                hashId: s,
                parentSelectors: o
              });
            });
            var q = Q.replace(/[A-Z]/g, function(ce) {
              return "-".concat(ce.toLowerCase());
            }), ne = V;
            !d9[Q] && typeof ne == "number" && ne !== 0 && (ne = "".concat(ne, "px")), Q === "animationName" && V !== null && V !== void 0 && V._keyframe && (_(V), ne = V.getName(s)), E += "".concat(q, ":").concat(ne, ";");
          };
          var Z, K = (Z = U == null ? void 0 : U.value) !== null && Z !== void 0 ? Z : U;
          bn(U) === "object" && U !== null && U !== void 0 && U[Iz] && Array.isArray(K) ? K.forEach(function(Q) {
            B(I, Q);
          }) : B(I, K);
        }
      });
    }
  }), i ? u && (E = "@layer ".concat(u.name, " {").concat(E, "}"), u.dependencies && (S["@layer ".concat(u.name)] = u.dependencies.map(function(R) {
    return "@layer ".concat(R, ", ").concat(u.name, ";");
  }).join(`
`))) : E = "{".concat(E, "}"), [E, S];
};
function Nz(n, e) {
  return Vy("".concat(n.join("%")).concat(e));
}
function F9() {
  return null;
}
var Lz = "style";
function ZT(n, e) {
  var t = n.token, r = n.path, i = n.hashId, a = n.layer, o = n.nonce, s = n.clientOnly, u = n.order, d = u === void 0 ? 0 : u, f = O.useContext(mE), p = f.autoClear, g = f.mock, v = f.defaultCache, b = f.hashPriority, E = f.container, S = f.ssrInline, _ = f.transformers, w = f.linters, C = f.cache, R = f.layer, P = t._tokenKey, D = [P];
  R && D.push("layer"), D.push.apply(D, jt(r));
  var I = GT;
  Ee.env.NODE_ENV !== "production" && g !== void 0 && (I = g === "client");
  var U = IA(
    Lz,
    D,
    // Create cache if needed
    function() {
      var G = D.join("|");
      if (P9(G)) {
        var X = D9(G), ae = ot(X, 2), Z = ae[0], K = ae[1];
        if (Z)
          return [Z, P, K, {}, s, d];
      }
      var B = e(), Q = L9(B, {
        hashId: i,
        hashPriority: b,
        layer: R ? a : void 0,
        path: r.join("-"),
        transformers: _,
        linters: w
      }), V = ot(Q, 2), q = V[0], ne = V[1], ce = Y_(q), ie = Nz(D, ce);
      return [ce, P, ie, ne, s, d];
    },
    // Remove cache if no need
    function(G, X) {
      var ae = ot(G, 3), Z = ae[2];
      (X || p) && GT && ky(Z, {
        mark: Cl
      });
    },
    // Effect: Inject style here
    function(G) {
      var X = ot(G, 4), ae = X[0];
      X[1];
      var Z = X[2], K = X[3];
      if (I && ae !== Oz) {
        var B = {
          mark: Cl,
          prepend: R ? !1 : "queue",
          attachTo: E,
          priority: d
        }, Q = typeof o == "function" ? o() : o;
        Q && (B.csp = {
          nonce: Q
        });
        var V = [], q = [];
        Object.keys(K).forEach(function(ce) {
          ce.startsWith("@layer") ? V.push(ce) : q.push(ce);
        }), V.forEach(function(ce) {
          lu(Y_(K[ce]), "_layer-".concat(ce), ke(ke({}, B), {}, {
            prepend: !0
          }));
        });
        var ne = lu(ae, Z, B);
        ne[zd] = C.instanceId, ne.setAttribute(Qm, P), Ee.env.NODE_ENV !== "production" && ne.setAttribute(NG, D.join("|")), q.forEach(function(ce) {
          lu(Y_(K[ce]), "_effect-".concat(ce), B);
        });
      }
    }
  ), L = ot(U, 3), N = L[0], H = L[1], j = L[2];
  return function(G) {
    var X;
    return !S || I || !v ? X = /* @__PURE__ */ O.createElement(F9, null) : X = /* @__PURE__ */ O.createElement("style", gn({}, Re(Re({}, Qm, H), Cl, j), {
      dangerouslySetInnerHTML: {
        __html: N
      }
    })), /* @__PURE__ */ O.createElement(O.Fragment, null, X, G);
  };
}
var U9 = function(e, t, r) {
  var i = ot(e, 6), a = i[0], o = i[1], s = i[2], u = i[3], d = i[4], f = i[5], p = r || {}, g = p.plain;
  if (d)
    return null;
  var v = a, b = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(f)
  };
  return v = ux(a, o, s, b, g), u && Object.keys(u).forEach(function(E) {
    if (!t[E]) {
      t[E] = !0;
      var S = Y_(u[E]), _ = ux(S, o, "_effect-".concat(E), b, g);
      E.startsWith("@layer") ? v = _ + v : v += _;
    }
  }), [f, s, v];
}, Fz = "cssVar", z9 = function(e, t) {
  var r = e.key, i = e.prefix, a = e.unitless, o = e.ignore, s = e.token, u = e.scope, d = u === void 0 ? "" : u, f = ni(mE), p = f.cache.instanceId, g = f.container, v = s._tokenKey, b = [].concat(jt(e.path), [r, d, v]), E = IA(Fz, b, function() {
    var S = t(), _ = yz(S, r, {
      prefix: i,
      unitless: a,
      ignore: o,
      scope: d
    }), w = ot(_, 2), C = w[0], R = w[1], P = Nz(b, R);
    return [C, R, P, r];
  }, function(S) {
    var _ = ot(S, 3), w = _[2];
    GT && ky(w, {
      mark: Cl
    });
  }, function(S) {
    var _ = ot(S, 3), w = _[1], C = _[2];
    if (w) {
      var R = lu(w, C, {
        mark: Cl,
        prepend: "queue",
        attachTo: g,
        priority: -999
      });
      R[zd] = p, R.setAttribute(Qm, r);
    }
  });
  return E;
}, B9 = function(e, t, r) {
  var i = ot(e, 4), a = i[1], o = i[2], s = i[3], u = r || {}, d = u.plain;
  if (!a)
    return null;
  var f = -999, p = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(f)
  }, g = ux(a, s, o, p, d);
  return [f, o, g];
};
Re(Re(Re({}, Lz, U9), bz, u9), Fz, B9);
var Gr = /* @__PURE__ */ function() {
  function n(e, t) {
    ki(this, n), Re(this, "name", void 0), Re(this, "style", void 0), Re(this, "_keyframe", !0), this.name = e, this.style = t;
  }
  return $i(n, [{
    key: "getName",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return t ? "".concat(t, "-").concat(this.name) : this.name;
    }
  }]), n;
}();
function Jp(n) {
  return n.notSplit = !0, n;
}
Jp(["borderTop", "borderBottom"]), Jp(["borderTop"]), Jp(["borderBottom"]), Jp(["borderLeft", "borderRight"]), Jp(["borderLeft"]), Jp(["borderRight"]);
var FA = /* @__PURE__ */ hg({});
function Uz(n) {
  return uz(n) || oz(n) || OA(n) || dz();
}
function ac(n, e) {
  for (var t = n, r = 0; r < e.length; r += 1) {
    if (t == null)
      return;
    t = t[e[r]];
  }
  return t;
}
function zz(n, e, t, r) {
  if (!e.length)
    return t;
  var i = Uz(e), a = i[0], o = i.slice(1), s;
  return !n && typeof a == "number" ? s = [] : Array.isArray(n) ? s = jt(n) : s = ke({}, n), r && t === void 0 && o.length === 1 ? delete s[a][o[0]] : s[a] = zz(s[a], o, t, r), s;
}
function Sl(n, e, t) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return e.length && r && t === void 0 && !ac(n, e.slice(0, -1)) ? n : zz(n, e, t, r);
}
function H9(n) {
  return bn(n) === "object" && n !== null && Object.getPrototypeOf(n) === Object.prototype;
}
function YN(n) {
  return Array.isArray(n) ? [] : {};
}
var V9 = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function Bm() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  var r = YN(e[0]);
  return e.forEach(function(i) {
    function a(o, s) {
      var u = new Set(s), d = ac(i, o), f = Array.isArray(d);
      if (f || H9(d)) {
        if (!u.has(d)) {
          u.add(d);
          var p = ac(r, o);
          f ? r = Sl(r, o, []) : (!p || bn(p) !== "object") && (r = Sl(r, o, YN(d))), V9(d).forEach(function(g) {
            a([].concat(jt(o), [g]), u);
          });
        }
      } else
        r = Sl(r, o, d);
    }
    a([]);
  }), r;
}
function Bz() {
}
let eu = null;
function k9() {
  eu = null, qU();
}
let Bh = Bz;
Ee.env.NODE_ENV !== "production" && (Bh = (n, e, t) => {
  Yn(n, `[antd: ${e}] ${t}`), Ee.env.NODE_ENV === "test" && k9();
});
const Hz = /* @__PURE__ */ O.createContext({}), ci = Ee.env.NODE_ENV !== "production" ? (n) => {
  const {
    strict: e
  } = O.useContext(Hz), t = (r, i, a) => {
    if (!r)
      if (e === !1 && i === "deprecated") {
        const o = eu;
        eu || (eu = {}), eu[n] = eu[n] || [], eu[n].includes(a || "") || eu[n].push(a || ""), o || console.warn("[antd] There exists deprecated usage in your code:", eu);
      } else
        Ee.env.NODE_ENV !== "production" && Bh(r, n, a);
  };
  return t.deprecated = (r, i, a, o) => {
    t(r, "deprecated", `\`${i}\` is deprecated. Please use \`${a}\` instead.${o ? ` ${o}` : ""}`);
  }, t;
} : () => {
  const n = () => {
  };
  return n.deprecated = Bz, n;
}, Vz = /* @__PURE__ */ hg(void 0);
var $9 = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
}, W9 = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: !0
}, j9 = ke(ke({}, W9), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  dateFormat: "M/D/YYYY",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
const kz = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, KN = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, j9),
  timePickerLocale: Object.assign({}, kz)
}, as = "${label} is not a valid ${type}", Rh = {
  locale: "en",
  Pagination: $9,
  DatePicker: KN,
  TimePicker: kz,
  Calendar: KN,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: as,
        method: as,
        array: as,
        object: as,
        number: as,
        date: as,
        boolean: as,
        integer: as,
        float: as,
        regexp: as,
        email: as,
        url: as,
        hex: as
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty"
  }
};
Object.assign({}, Rh.Modal);
let K_ = [];
const ZN = () => K_.reduce((n, e) => Object.assign(Object.assign({}, n), e), Rh.Modal);
function G9(n) {
  if (n) {
    const e = Object.assign({}, n);
    return K_.push(e), ZN(), () => {
      K_ = K_.filter((t) => t !== e), ZN();
    };
  }
  Object.assign({}, Rh.Modal);
}
const UA = /* @__PURE__ */ hg(void 0), zA = (n, e) => {
  const t = O.useContext(UA), r = O.useMemo(() => {
    var a;
    const o = Rh[n], s = (a = t == null ? void 0 : t[n]) !== null && a !== void 0 ? a : {};
    return Object.assign(Object.assign({}, typeof o == "function" ? o() : o), s || {});
  }, [n, e, t]), i = O.useMemo(() => {
    const a = t == null ? void 0 : t.locale;
    return t != null && t.exist && !a ? Rh.locale : a;
  }, [t]);
  return [r, i];
}, $z = "internalMark", Wz = (n) => {
  const {
    locale: e = {},
    children: t,
    _ANT_MARK__: r
  } = n;
  if (Ee.env.NODE_ENV !== "production") {
    const a = ci("LocaleProvider");
    Ee.env.NODE_ENV !== "production" && a(r === $z, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale");
  }
  O.useEffect(() => G9(e == null ? void 0 : e.Modal), [e]);
  const i = O.useMemo(() => Object.assign(Object.assign({}, e), {
    exist: !0
  }), [e]);
  return /* @__PURE__ */ O.createElement(UA.Provider, {
    value: i
  }, t);
};
Ee.env.NODE_ENV !== "production" && (Wz.displayName = "LocaleProvider");
function Oa(n, e) {
  X9(n) && (n = "100%");
  var t = q9(n);
  return n = e === 360 ? n : Math.min(e, Math.max(0, parseFloat(n))), t && (n = parseInt(String(n * e), 10) / 100), Math.abs(n - e) < 1e-6 ? 1 : (e === 360 ? n = (n < 0 ? n % e + e : n % e) / parseFloat(String(e)) : n = n % e / parseFloat(String(e)), n);
}
function CS(n) {
  return Math.min(1, Math.max(0, n));
}
function X9(n) {
  return typeof n == "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function q9(n) {
  return typeof n == "string" && n.indexOf("%") !== -1;
}
function jz(n) {
  return n = parseFloat(n), (isNaN(n) || n < 0 || n > 1) && (n = 1), n;
}
function wS(n) {
  return n <= 1 ? "".concat(Number(n) * 100, "%") : n;
}
function sh(n) {
  return n.length === 1 ? "0" + n : String(n);
}
function Y9(n, e, t) {
  return {
    r: Oa(n, 255) * 255,
    g: Oa(e, 255) * 255,
    b: Oa(t, 255) * 255
  };
}
function QN(n, e, t) {
  n = Oa(n, 255), e = Oa(e, 255), t = Oa(t, 255);
  var r = Math.max(n, e, t), i = Math.min(n, e, t), a = 0, o = 0, s = (r + i) / 2;
  if (r === i)
    o = 0, a = 0;
  else {
    var u = r - i;
    switch (o = s > 0.5 ? u / (2 - r - i) : u / (r + i), r) {
      case n:
        a = (e - t) / u + (e < t ? 6 : 0);
        break;
      case e:
        a = (t - n) / u + 2;
        break;
      case t:
        a = (n - e) / u + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: o, l: s };
}
function U1(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * (6 * t) : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function K9(n, e, t) {
  var r, i, a;
  if (n = Oa(n, 360), e = Oa(e, 100), t = Oa(t, 100), e === 0)
    i = t, a = t, r = t;
  else {
    var o = t < 0.5 ? t * (1 + e) : t + e - t * e, s = 2 * t - o;
    r = U1(s, o, n + 1 / 3), i = U1(s, o, n), a = U1(s, o, n - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: a * 255 };
}
function QT(n, e, t) {
  n = Oa(n, 255), e = Oa(e, 255), t = Oa(t, 255);
  var r = Math.max(n, e, t), i = Math.min(n, e, t), a = 0, o = r, s = r - i, u = r === 0 ? 0 : s / r;
  if (r === i)
    a = 0;
  else {
    switch (r) {
      case n:
        a = (e - t) / s + (e < t ? 6 : 0);
        break;
      case e:
        a = (t - n) / s + 2;
        break;
      case t:
        a = (n - e) / s + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: u, v: o };
}
function Z9(n, e, t) {
  n = Oa(n, 360) * 6, e = Oa(e, 100), t = Oa(t, 100);
  var r = Math.floor(n), i = n - r, a = t * (1 - e), o = t * (1 - i * e), s = t * (1 - (1 - i) * e), u = r % 6, d = [t, o, a, a, s, t][u], f = [s, t, t, o, a, a][u], p = [a, a, s, t, t, o][u];
  return { r: d * 255, g: f * 255, b: p * 255 };
}
function JT(n, e, t, r) {
  var i = [
    sh(Math.round(n).toString(16)),
    sh(Math.round(e).toString(16)),
    sh(Math.round(t).toString(16))
  ];
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function Q9(n, e, t, r, i) {
  var a = [
    sh(Math.round(n).toString(16)),
    sh(Math.round(e).toString(16)),
    sh(Math.round(t).toString(16)),
    sh(J9(r))
  ];
  return i && a[0].startsWith(a[0].charAt(1)) && a[1].startsWith(a[1].charAt(1)) && a[2].startsWith(a[2].charAt(1)) && a[3].startsWith(a[3].charAt(1)) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function J9(n) {
  return Math.round(parseFloat(n) * 255).toString(16);
}
function JN(n) {
  return us(n) / 255;
}
function us(n) {
  return parseInt(n, 16);
}
function e7(n) {
  return {
    r: n >> 16,
    g: (n & 65280) >> 8,
    b: n & 255
  };
}
var eR = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function Lm(n) {
  var e = { r: 0, g: 0, b: 0 }, t = 1, r = null, i = null, a = null, o = !1, s = !1;
  return typeof n == "string" && (n = r7(n)), typeof n == "object" && (Gc(n.r) && Gc(n.g) && Gc(n.b) ? (e = Y9(n.r, n.g, n.b), o = !0, s = String(n.r).substr(-1) === "%" ? "prgb" : "rgb") : Gc(n.h) && Gc(n.s) && Gc(n.v) ? (r = wS(n.s), i = wS(n.v), e = Z9(n.h, r, i), o = !0, s = "hsv") : Gc(n.h) && Gc(n.s) && Gc(n.l) && (r = wS(n.s), a = wS(n.l), e = K9(n.h, r, a), o = !0, s = "hsl"), Object.prototype.hasOwnProperty.call(n, "a") && (t = n.a)), t = jz(t), {
    ok: o,
    format: n.format || s,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: t
  };
}
var t7 = "[-\\+]?\\d+%?", n7 = "[-\\+]?\\d*\\.\\d+%?", Bd = "(?:".concat(n7, ")|(?:").concat(t7, ")"), z1 = "[\\s|\\(]+(".concat(Bd, ")[,|\\s]+(").concat(Bd, ")[,|\\s]+(").concat(Bd, ")\\s*\\)?"), B1 = "[\\s|\\(]+(".concat(Bd, ")[,|\\s]+(").concat(Bd, ")[,|\\s]+(").concat(Bd, ")[,|\\s]+(").concat(Bd, ")\\s*\\)?"), gl = {
  CSS_UNIT: new RegExp(Bd),
  rgb: new RegExp("rgb" + z1),
  rgba: new RegExp("rgba" + B1),
  hsl: new RegExp("hsl" + z1),
  hsla: new RegExp("hsla" + B1),
  hsv: new RegExp("hsv" + z1),
  hsva: new RegExp("hsva" + B1),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function r7(n) {
  if (n = n.trim().toLowerCase(), n.length === 0)
    return !1;
  var e = !1;
  if (eR[n])
    n = eR[n], e = !0;
  else if (n === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var t = gl.rgb.exec(n);
  return t ? { r: t[1], g: t[2], b: t[3] } : (t = gl.rgba.exec(n), t ? { r: t[1], g: t[2], b: t[3], a: t[4] } : (t = gl.hsl.exec(n), t ? { h: t[1], s: t[2], l: t[3] } : (t = gl.hsla.exec(n), t ? { h: t[1], s: t[2], l: t[3], a: t[4] } : (t = gl.hsv.exec(n), t ? { h: t[1], s: t[2], v: t[3] } : (t = gl.hsva.exec(n), t ? { h: t[1], s: t[2], v: t[3], a: t[4] } : (t = gl.hex8.exec(n), t ? {
    r: us(t[1]),
    g: us(t[2]),
    b: us(t[3]),
    a: JN(t[4]),
    format: e ? "name" : "hex8"
  } : (t = gl.hex6.exec(n), t ? {
    r: us(t[1]),
    g: us(t[2]),
    b: us(t[3]),
    format: e ? "name" : "hex"
  } : (t = gl.hex4.exec(n), t ? {
    r: us(t[1] + t[1]),
    g: us(t[2] + t[2]),
    b: us(t[3] + t[3]),
    a: JN(t[4] + t[4]),
    format: e ? "name" : "hex8"
  } : (t = gl.hex3.exec(n), t ? {
    r: us(t[1] + t[1]),
    g: us(t[2] + t[2]),
    b: us(t[3] + t[3]),
    format: e ? "name" : "hex"
  } : !1)))))))));
}
function Gc(n) {
  return !!gl.CSS_UNIT.exec(String(n));
}
var la = (
  /** @class */
  function() {
    function n(e, t) {
      e === void 0 && (e = ""), t === void 0 && (t = {});
      var r;
      if (e instanceof n)
        return e;
      typeof e == "number" && (e = e7(e)), this.originalInput = e;
      var i = Lm(e);
      this.originalInput = e, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (r = t.format) !== null && r !== void 0 ? r : i.format, this.gradientType = t.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return n.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, n.prototype.isLight = function() {
      return !this.isDark();
    }, n.prototype.getBrightness = function() {
      var e = this.toRgb();
      return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
    }, n.prototype.getLuminance = function() {
      var e = this.toRgb(), t, r, i, a = e.r / 255, o = e.g / 255, s = e.b / 255;
      return a <= 0.03928 ? t = a / 12.92 : t = Math.pow((a + 0.055) / 1.055, 2.4), o <= 0.03928 ? r = o / 12.92 : r = Math.pow((o + 0.055) / 1.055, 2.4), s <= 0.03928 ? i = s / 12.92 : i = Math.pow((s + 0.055) / 1.055, 2.4), 0.2126 * t + 0.7152 * r + 0.0722 * i;
    }, n.prototype.getAlpha = function() {
      return this.a;
    }, n.prototype.setAlpha = function(e) {
      return this.a = jz(e), this.roundA = Math.round(100 * this.a) / 100, this;
    }, n.prototype.isMonochrome = function() {
      var e = this.toHsl().s;
      return e === 0;
    }, n.prototype.toHsv = function() {
      var e = QT(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
    }, n.prototype.toHsvString = function() {
      var e = QT(this.r, this.g, this.b), t = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.v * 100);
      return this.a === 1 ? "hsv(".concat(t, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(t, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, n.prototype.toHsl = function() {
      var e = QN(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
    }, n.prototype.toHslString = function() {
      var e = QN(this.r, this.g, this.b), t = Math.round(e.h * 360), r = Math.round(e.s * 100), i = Math.round(e.l * 100);
      return this.a === 1 ? "hsl(".concat(t, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(t, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, n.prototype.toHex = function(e) {
      return e === void 0 && (e = !1), JT(this.r, this.g, this.b, e);
    }, n.prototype.toHexString = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex(e);
    }, n.prototype.toHex8 = function(e) {
      return e === void 0 && (e = !1), Q9(this.r, this.g, this.b, this.a, e);
    }, n.prototype.toHex8String = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex8(e);
    }, n.prototype.toHexShortString = function(e) {
      return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e);
    }, n.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, n.prototype.toRgbString = function() {
      var e = Math.round(this.r), t = Math.round(this.g), r = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(e, ", ").concat(t, ", ").concat(r, ")") : "rgba(".concat(e, ", ").concat(t, ", ").concat(r, ", ").concat(this.roundA, ")");
    }, n.prototype.toPercentageRgb = function() {
      var e = function(t) {
        return "".concat(Math.round(Oa(t, 255) * 100), "%");
      };
      return {
        r: e(this.r),
        g: e(this.g),
        b: e(this.b),
        a: this.a
      };
    }, n.prototype.toPercentageRgbString = function() {
      var e = function(t) {
        return Math.round(Oa(t, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")");
    }, n.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var e = "#" + JT(this.r, this.g, this.b, !1), t = 0, r = Object.entries(eR); t < r.length; t++) {
        var i = r[t], a = i[0], o = i[1];
        if (e === o)
          return a;
      }
      return !1;
    }, n.prototype.toString = function(e) {
      var t = !!e;
      e = e ?? this.format;
      var r = !1, i = this.a < 1 && this.a >= 0, a = !t && i && (e.startsWith("hex") || e === "name");
      return a ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()), e === "prgb" && (r = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (r = this.toHexString()), e === "hex3" && (r = this.toHexString(!0)), e === "hex4" && (r = this.toHex8String(!0)), e === "hex8" && (r = this.toHex8String()), e === "name" && (r = this.toName()), e === "hsl" && (r = this.toHslString()), e === "hsv" && (r = this.toHsvString()), r || this.toHexString());
    }, n.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, n.prototype.clone = function() {
      return new n(this.toString());
    }, n.prototype.lighten = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.l += e / 100, t.l = CS(t.l), new n(t);
    }, n.prototype.brighten = function(e) {
      e === void 0 && (e = 10);
      var t = this.toRgb();
      return t.r = Math.max(0, Math.min(255, t.r - Math.round(255 * -(e / 100)))), t.g = Math.max(0, Math.min(255, t.g - Math.round(255 * -(e / 100)))), t.b = Math.max(0, Math.min(255, t.b - Math.round(255 * -(e / 100)))), new n(t);
    }, n.prototype.darken = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.l -= e / 100, t.l = CS(t.l), new n(t);
    }, n.prototype.tint = function(e) {
      return e === void 0 && (e = 10), this.mix("white", e);
    }, n.prototype.shade = function(e) {
      return e === void 0 && (e = 10), this.mix("black", e);
    }, n.prototype.desaturate = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.s -= e / 100, t.s = CS(t.s), new n(t);
    }, n.prototype.saturate = function(e) {
      e === void 0 && (e = 10);
      var t = this.toHsl();
      return t.s += e / 100, t.s = CS(t.s), new n(t);
    }, n.prototype.greyscale = function() {
      return this.desaturate(100);
    }, n.prototype.spin = function(e) {
      var t = this.toHsl(), r = (t.h + e) % 360;
      return t.h = r < 0 ? 360 + r : r, new n(t);
    }, n.prototype.mix = function(e, t) {
      t === void 0 && (t = 50);
      var r = this.toRgb(), i = new n(e).toRgb(), a = t / 100, o = {
        r: (i.r - r.r) * a + r.r,
        g: (i.g - r.g) * a + r.g,
        b: (i.b - r.b) * a + r.b,
        a: (i.a - r.a) * a + r.a
      };
      return new n(o);
    }, n.prototype.analogous = function(e, t) {
      e === void 0 && (e = 6), t === void 0 && (t = 30);
      var r = this.toHsl(), i = 360 / t, a = [this];
      for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e; )
        r.h = (r.h + i) % 360, a.push(new n(r));
      return a;
    }, n.prototype.complement = function() {
      var e = this.toHsl();
      return e.h = (e.h + 180) % 360, new n(e);
    }, n.prototype.monochromatic = function(e) {
      e === void 0 && (e = 6);
      for (var t = this.toHsv(), r = t.h, i = t.s, a = t.v, o = [], s = 1 / e; e--; )
        o.push(new n({ h: r, s: i, v: a })), a = (a + s) % 1;
      return o;
    }, n.prototype.splitcomplement = function() {
      var e = this.toHsl(), t = e.h;
      return [
        this,
        new n({ h: (t + 72) % 360, s: e.s, l: e.l }),
        new n({ h: (t + 216) % 360, s: e.s, l: e.l })
      ];
    }, n.prototype.onBackground = function(e) {
      var t = this.toRgb(), r = new n(e).toRgb(), i = t.a + r.a * (1 - t.a);
      return new n({
        r: (t.r * t.a + r.r * r.a * (1 - t.a)) / i,
        g: (t.g * t.a + r.g * r.a * (1 - t.a)) / i,
        b: (t.b * t.a + r.b * r.a * (1 - t.a)) / i,
        a: i
      });
    }, n.prototype.triad = function() {
      return this.polyad(3);
    }, n.prototype.tetrad = function() {
      return this.polyad(4);
    }, n.prototype.polyad = function(e) {
      for (var t = this.toHsl(), r = t.h, i = [this], a = 360 / e, o = 1; o < e; o++)
        i.push(new n({ h: (r + o * a) % 360, s: t.s, l: t.l }));
      return i;
    }, n.prototype.equals = function(e) {
      return this.toRgbString() === new n(e).toRgbString();
    }, n;
  }()
), MS = 2, e2 = 0.16, i7 = 0.05, a7 = 0.05, o7 = 0.15, Gz = 5, Xz = 4, s7 = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function t2(n) {
  var e = n.r, t = n.g, r = n.b, i = QT(e, t, r);
  return {
    h: i.h * 360,
    s: i.s,
    v: i.v
  };
}
function TS(n) {
  var e = n.r, t = n.g, r = n.b;
  return "#".concat(JT(e, t, r, !1));
}
function l7(n, e, t) {
  var r = t / 100, i = {
    r: (e.r - n.r) * r + n.r,
    g: (e.g - n.g) * r + n.g,
    b: (e.b - n.b) * r + n.b
  };
  return i;
}
function n2(n, e, t) {
  var r;
  return Math.round(n.h) >= 60 && Math.round(n.h) <= 240 ? r = t ? Math.round(n.h) - MS * e : Math.round(n.h) + MS * e : r = t ? Math.round(n.h) + MS * e : Math.round(n.h) - MS * e, r < 0 ? r += 360 : r >= 360 && (r -= 360), r;
}
function r2(n, e, t) {
  if (n.h === 0 && n.s === 0)
    return n.s;
  var r;
  return t ? r = n.s - e2 * e : e === Xz ? r = n.s + e2 : r = n.s + i7 * e, r > 1 && (r = 1), t && e === Gz && r > 0.1 && (r = 0.1), r < 0.06 && (r = 0.06), Number(r.toFixed(2));
}
function i2(n, e, t) {
  var r;
  return t ? r = n.v + a7 * e : r = n.v - o7 * e, r > 1 && (r = 1), Number(r.toFixed(2));
}
function Wy(n) {
  for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = [], r = Lm(n), i = Gz; i > 0; i -= 1) {
    var a = t2(r), o = TS(Lm({
      h: n2(a, i, !0),
      s: r2(a, i, !0),
      v: i2(a, i, !0)
    }));
    t.push(o);
  }
  t.push(TS(r));
  for (var s = 1; s <= Xz; s += 1) {
    var u = t2(r), d = TS(Lm({
      h: n2(u, s),
      s: r2(u, s),
      v: i2(u, s)
    }));
    t.push(d);
  }
  return e.theme === "dark" ? s7.map(function(f) {
    var p = f.index, g = f.opacity, v = TS(l7(Lm(e.backgroundColor || "#141414"), Lm(t[p]), g * 100));
    return v;
  }) : t;
}
var H1 = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1677FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, tR = ["#fff1f0", "#ffccc7", "#ffa39e", "#ff7875", "#ff4d4f", "#f5222d", "#cf1322", "#a8071a", "#820014", "#5c0011"];
tR.primary = tR[5];
var nR = ["#fff2e8", "#ffd8bf", "#ffbb96", "#ff9c6e", "#ff7a45", "#fa541c", "#d4380d", "#ad2102", "#871400", "#610b00"];
nR.primary = nR[5];
var rR = ["#fff7e6", "#ffe7ba", "#ffd591", "#ffc069", "#ffa940", "#fa8c16", "#d46b08", "#ad4e00", "#873800", "#612500"];
rR.primary = rR[5];
var iR = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
iR.primary = iR[5];
var aR = ["#feffe6", "#ffffb8", "#fffb8f", "#fff566", "#ffec3d", "#fadb14", "#d4b106", "#ad8b00", "#876800", "#614700"];
aR.primary = aR[5];
var oR = ["#fcffe6", "#f4ffb8", "#eaff8f", "#d3f261", "#bae637", "#a0d911", "#7cb305", "#5b8c00", "#3f6600", "#254000"];
oR.primary = oR[5];
var sR = ["#f6ffed", "#d9f7be", "#b7eb8f", "#95de64", "#73d13d", "#52c41a", "#389e0d", "#237804", "#135200", "#092b00"];
sR.primary = sR[5];
var lR = ["#e6fffb", "#b5f5ec", "#87e8de", "#5cdbd3", "#36cfc9", "#13c2c2", "#08979c", "#006d75", "#00474f", "#002329"];
lR.primary = lR[5];
var dx = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
dx.primary = dx[5];
var cR = ["#f0f5ff", "#d6e4ff", "#adc6ff", "#85a5ff", "#597ef7", "#2f54eb", "#1d39c4", "#10239e", "#061178", "#030852"];
cR.primary = cR[5];
var uR = ["#f9f0ff", "#efdbff", "#d3adf7", "#b37feb", "#9254de", "#722ed1", "#531dab", "#391085", "#22075e", "#120338"];
uR.primary = uR[5];
var dR = ["#fff0f6", "#ffd6e7", "#ffadd2", "#ff85c0", "#f759ab", "#eb2f96", "#c41d7f", "#9e1068", "#780650", "#520339"];
dR.primary = dR[5];
var fR = ["#a6a6a6", "#999999", "#8c8c8c", "#808080", "#737373", "#666666", "#404040", "#1a1a1a", "#000000", "#000000"];
fR.primary = fR[5];
var V1 = {
  red: tR,
  volcano: nR,
  orange: rR,
  gold: iR,
  yellow: aR,
  lime: oR,
  green: sR,
  cyan: lR,
  blue: dx,
  geekblue: cR,
  purple: uR,
  magenta: dR,
  grey: fR
};
const qz = {
  blue: "#1677FF",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  /**
   * @deprecated Use magenta instead
   */
  pink: "#EB2F96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, jy = Object.assign(Object.assign({}, qz), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1,
  // Motion
  motion: !0
});
function c7(n, e) {
  let {
    generateColorPalettes: t,
    generateNeutralColorPalettes: r
  } = e;
  const {
    colorSuccess: i,
    colorWarning: a,
    colorError: o,
    colorInfo: s,
    colorPrimary: u,
    colorBgBase: d,
    colorTextBase: f
  } = n, p = t(u), g = t(i), v = t(a), b = t(o), E = t(s), S = r(d, f), _ = n.colorLink || n.colorInfo, w = t(_);
  return Object.assign(Object.assign({}, S), {
    colorPrimaryBg: p[1],
    colorPrimaryBgHover: p[2],
    colorPrimaryBorder: p[3],
    colorPrimaryBorderHover: p[4],
    colorPrimaryHover: p[5],
    colorPrimary: p[6],
    colorPrimaryActive: p[7],
    colorPrimaryTextHover: p[8],
    colorPrimaryText: p[9],
    colorPrimaryTextActive: p[10],
    colorSuccessBg: g[1],
    colorSuccessBgHover: g[2],
    colorSuccessBorder: g[3],
    colorSuccessBorderHover: g[4],
    colorSuccessHover: g[4],
    colorSuccess: g[6],
    colorSuccessActive: g[7],
    colorSuccessTextHover: g[8],
    colorSuccessText: g[9],
    colorSuccessTextActive: g[10],
    colorErrorBg: b[1],
    colorErrorBgHover: b[2],
    colorErrorBgActive: b[3],
    colorErrorBorder: b[3],
    colorErrorBorderHover: b[4],
    colorErrorHover: b[5],
    colorError: b[6],
    colorErrorActive: b[7],
    colorErrorTextHover: b[8],
    colorErrorText: b[9],
    colorErrorTextActive: b[10],
    colorWarningBg: v[1],
    colorWarningBgHover: v[2],
    colorWarningBorder: v[3],
    colorWarningBorderHover: v[4],
    colorWarningHover: v[4],
    colorWarning: v[6],
    colorWarningActive: v[7],
    colorWarningTextHover: v[8],
    colorWarningText: v[9],
    colorWarningTextActive: v[10],
    colorInfoBg: E[1],
    colorInfoBgHover: E[2],
    colorInfoBorder: E[3],
    colorInfoBorderHover: E[4],
    colorInfoHover: E[4],
    colorInfo: E[6],
    colorInfoActive: E[7],
    colorInfoTextHover: E[8],
    colorInfoText: E[9],
    colorInfoTextActive: E[10],
    colorLinkHover: w[4],
    colorLink: w[6],
    colorLinkActive: w[7],
    colorBgMask: new la("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const u7 = (n) => {
  let e = n, t = n, r = n, i = n;
  return n < 6 && n >= 5 ? e = n + 1 : n < 16 && n >= 6 ? e = n + 2 : n >= 16 && (e = 16), n < 7 && n >= 5 ? t = 4 : n < 8 && n >= 7 ? t = 5 : n < 14 && n >= 8 ? t = 6 : n < 16 && n >= 14 ? t = 7 : n >= 16 && (t = 8), n < 6 && n >= 2 ? r = 1 : n >= 6 && (r = 2), n > 4 && n < 8 ? i = 4 : n >= 8 && (i = 6), {
    borderRadius: n,
    borderRadiusXS: r,
    borderRadiusSM: t,
    borderRadiusLG: e,
    borderRadiusOuter: i
  };
};
function d7(n) {
  const {
    motionUnit: e,
    motionBase: t,
    borderRadius: r,
    lineWidth: i
  } = n;
  return Object.assign({
    // motion
    motionDurationFast: `${(t + e).toFixed(1)}s`,
    motionDurationMid: `${(t + e * 2).toFixed(1)}s`,
    motionDurationSlow: `${(t + e * 3).toFixed(1)}s`,
    // line
    lineWidthBold: i + 1
  }, u7(r));
}
const f7 = (n) => {
  const {
    controlHeight: e
  } = n;
  return {
    controlHeightSM: e * 0.75,
    controlHeightXS: e * 0.5,
    controlHeightLG: e * 1.25
  };
};
function Z_(n) {
  return (n + 8) / n;
}
function h7(n) {
  const e = new Array(10).fill(null).map((t, r) => {
    const i = r - 1, a = n * Math.pow(Math.E, i / 5), o = r > 1 ? Math.floor(a) : Math.ceil(a);
    return Math.floor(o / 2) * 2;
  });
  return e[1] = n, e.map((t) => ({
    size: t,
    lineHeight: Z_(t)
  }));
}
const p7 = (n) => {
  const e = h7(n), t = e.map((f) => f.size), r = e.map((f) => f.lineHeight), i = t[1], a = t[0], o = t[2], s = r[1], u = r[0], d = r[2];
  return {
    fontSizeSM: a,
    fontSize: i,
    fontSizeLG: o,
    fontSizeXL: t[3],
    fontSizeHeading1: t[6],
    fontSizeHeading2: t[5],
    fontSizeHeading3: t[4],
    fontSizeHeading4: t[3],
    fontSizeHeading5: t[2],
    lineHeight: s,
    lineHeightLG: d,
    lineHeightSM: u,
    fontHeight: Math.round(s * i),
    fontHeightLG: Math.round(d * o),
    fontHeightSM: Math.round(u * a),
    lineHeightHeading1: r[6],
    lineHeightHeading2: r[5],
    lineHeightHeading3: r[4],
    lineHeightHeading4: r[3],
    lineHeightHeading5: r[2]
  };
};
function m7(n) {
  const {
    sizeUnit: e,
    sizeStep: t
  } = n;
  return {
    sizeXXL: e * (t + 8),
    // 48
    sizeXL: e * (t + 4),
    // 32
    sizeLG: e * (t + 2),
    // 24
    sizeMD: e * (t + 1),
    // 20
    sizeMS: e * t,
    // 16
    size: e * t,
    // 16
    sizeSM: e * (t - 1),
    // 12
    sizeXS: e * (t - 2),
    // 8
    sizeXXS: e * (t - 3)
    // 4
  };
}
const Xc = (n, e) => new la(n).setAlpha(e).toRgbString(), Gv = (n, e) => new la(n).darken(e).toHexString(), g7 = (n) => {
  const e = Wy(n);
  return {
    1: e[0],
    2: e[1],
    3: e[2],
    4: e[3],
    5: e[4],
    6: e[5],
    7: e[6],
    8: e[4],
    9: e[5],
    10: e[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, v7 = (n, e) => {
  const t = n || "#fff", r = e || "#000";
  return {
    colorBgBase: t,
    colorTextBase: r,
    colorText: Xc(r, 0.88),
    colorTextSecondary: Xc(r, 0.65),
    colorTextTertiary: Xc(r, 0.45),
    colorTextQuaternary: Xc(r, 0.25),
    colorFill: Xc(r, 0.15),
    colorFillSecondary: Xc(r, 0.06),
    colorFillTertiary: Xc(r, 0.04),
    colorFillQuaternary: Xc(r, 0.02),
    colorBgLayout: Gv(t, 4),
    colorBgContainer: Gv(t, 0),
    colorBgElevated: Gv(t, 0),
    colorBgSpotlight: Xc(r, 0.85),
    colorBgBlur: "transparent",
    colorBorder: Gv(t, 15),
    colorBorderSecondary: Gv(t, 6)
  };
};
function y7(n) {
  H1.pink = H1.magenta, V1.pink = V1.magenta;
  const e = Object.keys(qz).map((t) => {
    const r = n[t] === H1[t] ? V1[t] : Wy(n[t]);
    return new Array(10).fill(1).reduce((i, a, o) => (i[`${t}-${o + 1}`] = r[o], i[`${t}${o + 1}`] = r[o], i), {});
  }).reduce((t, r) => (t = Object.assign(Object.assign({}, t), r), t), {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, n), e), c7(n, {
    generateColorPalettes: g7,
    generateNeutralColorPalettes: v7
  })), p7(n.fontSize)), m7(n)), f7(n)), d7(n));
}
const Yz = jT(y7), hR = {
  token: jy,
  override: {
    override: jy
  },
  hashed: !0
}, Kz = /* @__PURE__ */ Fe.createContext(hR), fx = "ant", Zz = "anticon", b7 = ["outlined", "borderless", "filled"], S7 = (n, e) => e || (n ? `${fx}-${n}` : fx), mr = /* @__PURE__ */ O.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: S7,
  iconPrefixCls: Zz
}), _7 = `-ant-${Date.now()}-${Math.random()}`;
function x7(n, e) {
  const t = {}, r = (o, s) => {
    let u = o.clone();
    return u = (s == null ? void 0 : s(u)) || u, u.toRgbString();
  }, i = (o, s) => {
    const u = new la(o), d = Wy(u.toRgbString());
    t[`${s}-color`] = r(u), t[`${s}-color-disabled`] = d[1], t[`${s}-color-hover`] = d[4], t[`${s}-color-active`] = d[6], t[`${s}-color-outline`] = u.clone().setAlpha(0.2).toRgbString(), t[`${s}-color-deprecated-bg`] = d[0], t[`${s}-color-deprecated-border`] = d[2];
  };
  if (e.primaryColor) {
    i(e.primaryColor, "primary");
    const o = new la(e.primaryColor), s = Wy(o.toRgbString());
    s.forEach((d, f) => {
      t[`primary-${f + 1}`] = d;
    }), t["primary-color-deprecated-l-35"] = r(o, (d) => d.lighten(35)), t["primary-color-deprecated-l-20"] = r(o, (d) => d.lighten(20)), t["primary-color-deprecated-t-20"] = r(o, (d) => d.tint(20)), t["primary-color-deprecated-t-50"] = r(o, (d) => d.tint(50)), t["primary-color-deprecated-f-12"] = r(o, (d) => d.setAlpha(d.getAlpha() * 0.12));
    const u = new la(s[0]);
    t["primary-color-active-deprecated-f-30"] = r(u, (d) => d.setAlpha(d.getAlpha() * 0.3)), t["primary-color-active-deprecated-d-02"] = r(u, (d) => d.darken(2));
  }
  return e.successColor && i(e.successColor, "success"), e.warningColor && i(e.warningColor, "warning"), e.errorColor && i(e.errorColor, "error"), e.infoColor && i(e.infoColor, "info"), `
  :root {
    ${Object.keys(t).map((o) => `--${n}-${o}: ${t[o]};`).join(`
`)}
  }
  `.trim();
}
function E7(n, e) {
  const t = x7(n, e);
  fo() ? lu(t, `${_7}-dynamic-theme`) : Ee.env.NODE_ENV !== "production" && Bh(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
const fc = /* @__PURE__ */ O.createContext(!1), Qz = (n) => {
  let {
    children: e,
    disabled: t
  } = n;
  const r = O.useContext(fc);
  return /* @__PURE__ */ O.createElement(fc.Provider, {
    value: t ?? r
  }, e);
}, Ah = /* @__PURE__ */ O.createContext(void 0), C7 = (n) => {
  let {
    children: e,
    size: t
  } = n;
  const r = O.useContext(Ah);
  return /* @__PURE__ */ O.createElement(Ah.Provider, {
    value: t || r
  }, e);
};
function w7() {
  const n = ni(fc), e = ni(Ah);
  return {
    componentDisabled: n,
    componentSize: e
  };
}
const Gy = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"], M7 = "5.19.2";
function k1(n) {
  return n >= 0 && n <= 255;
}
function RS(n, e) {
  const {
    r: t,
    g: r,
    b: i,
    a
  } = new la(n).toRgb();
  if (a < 1)
    return n;
  const {
    r: o,
    g: s,
    b: u
  } = new la(e).toRgb();
  for (let d = 0.01; d <= 1; d += 0.01) {
    const f = Math.round((t - o * (1 - d)) / d), p = Math.round((r - s * (1 - d)) / d), g = Math.round((i - u * (1 - d)) / d);
    if (k1(f) && k1(p) && k1(g))
      return new la({
        r: f,
        g: p,
        b: g,
        a: Math.round(d * 100) / 100
      }).toRgbString();
  }
  return new la({
    r: t,
    g: r,
    b: i,
    a: 1
  }).toRgbString();
}
var T7 = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function Jz(n) {
  const {
    override: e
  } = n, t = T7(n, ["override"]), r = Object.assign({}, e);
  Object.keys(jy).forEach((g) => {
    delete r[g];
  });
  const i = Object.assign(Object.assign({}, t), r), a = 480, o = 576, s = 768, u = 992, d = 1200, f = 1600;
  if (i.motion === !1) {
    const g = "0s";
    i.motionDurationFast = g, i.motionDurationMid = g, i.motionDurationSlow = g;
  }
  return Object.assign(Object.assign(Object.assign({}, i), {
    // ============== Background ============== //
    colorFillContent: i.colorFillSecondary,
    colorFillContentHover: i.colorFill,
    colorFillAlter: i.colorFillQuaternary,
    colorBgContainerDisabled: i.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: i.colorBgContainer,
    colorSplit: RS(i.colorBorderSecondary, i.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: i.colorTextQuaternary,
    colorTextDisabled: i.colorTextQuaternary,
    colorTextHeading: i.colorText,
    colorTextLabel: i.colorTextSecondary,
    colorTextDescription: i.colorTextTertiary,
    colorTextLightSolid: i.colorWhite,
    colorHighlight: i.colorError,
    colorBgTextHover: i.colorFillSecondary,
    colorBgTextActive: i.colorFill,
    colorIcon: i.colorTextTertiary,
    colorIconHover: i.colorText,
    colorErrorOutline: RS(i.colorErrorBg, i.colorBgContainer),
    colorWarningOutline: RS(i.colorWarningBg, i.colorBgContainer),
    // Font
    fontSizeIcon: i.fontSizeSM,
    // Line
    lineWidthFocus: i.lineWidth * 4,
    // Control
    lineWidth: i.lineWidth,
    controlOutlineWidth: i.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: i.controlHeight / 2,
    controlItemBgHover: i.colorFillTertiary,
    controlItemBgActive: i.colorPrimaryBg,
    controlItemBgActiveHover: i.colorPrimaryBgHover,
    controlItemBgActiveDisabled: i.colorFill,
    controlTmpOutline: i.colorFillQuaternary,
    controlOutline: RS(i.colorPrimaryBg, i.colorBgContainer),
    lineType: i.lineType,
    borderRadius: i.borderRadius,
    borderRadiusXS: i.borderRadiusXS,
    borderRadiusSM: i.borderRadiusSM,
    borderRadiusLG: i.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: i.sizeXXS,
    paddingXS: i.sizeXS,
    paddingSM: i.sizeSM,
    padding: i.size,
    paddingMD: i.sizeMD,
    paddingLG: i.sizeLG,
    paddingXL: i.sizeXL,
    paddingContentHorizontalLG: i.sizeLG,
    paddingContentVerticalLG: i.sizeMS,
    paddingContentHorizontal: i.sizeMS,
    paddingContentVertical: i.sizeSM,
    paddingContentHorizontalSM: i.size,
    paddingContentVerticalSM: i.sizeXS,
    marginXXS: i.sizeXXS,
    marginXS: i.sizeXS,
    marginSM: i.sizeSM,
    margin: i.size,
    marginMD: i.sizeMD,
    marginLG: i.sizeLG,
    marginXL: i.sizeXL,
    marginXXL: i.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: a,
    screenXSMin: a,
    screenXSMax: o - 1,
    screenSM: o,
    screenSMMin: o,
    screenSMMax: s - 1,
    screenMD: s,
    screenMDMin: s,
    screenMDMax: u - 1,
    screenLG: u,
    screenLGMin: u,
    screenLGMax: d - 1,
    screenXL: d,
    screenXLMin: d,
    screenXLMax: f - 1,
    screenXXL: f,
    screenXXLMin: f,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new la("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new la("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new la("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), r);
}
var a2 = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const eB = {
  lineHeight: !0,
  lineHeightSM: !0,
  lineHeightLG: !0,
  lineHeightHeading1: !0,
  lineHeightHeading2: !0,
  lineHeightHeading3: !0,
  lineHeightHeading4: !0,
  lineHeightHeading5: !0,
  opacityLoading: !0,
  fontWeightStrong: !0,
  zIndexPopupBase: !0,
  zIndexBase: !0
}, tB = {
  size: !0,
  sizeSM: !0,
  sizeLG: !0,
  sizeMD: !0,
  sizeXS: !0,
  sizeXXS: !0,
  sizeMS: !0,
  sizeXL: !0,
  sizeXXL: !0,
  sizeUnit: !0,
  sizeStep: !0,
  motionBase: !0,
  motionUnit: !0
}, R7 = {
  screenXS: !0,
  screenXSMin: !0,
  screenXSMax: !0,
  screenSM: !0,
  screenSMMin: !0,
  screenSMMax: !0,
  screenMD: !0,
  screenMDMin: !0,
  screenMDMax: !0,
  screenLG: !0,
  screenLGMin: !0,
  screenLGMax: !0,
  screenXL: !0,
  screenXLMin: !0,
  screenXLMax: !0,
  screenXXL: !0,
  screenXXLMin: !0
}, nB = (n, e, t) => {
  const r = t.getDerivativeToken(n), {
    override: i
  } = e, a = a2(e, ["override"]);
  let o = Object.assign(Object.assign({}, r), {
    override: i
  });
  return o = Jz(o), a && Object.entries(a).forEach((s) => {
    let [u, d] = s;
    const {
      theme: f
    } = d, p = a2(d, ["theme"]);
    let g = p;
    f && (g = nB(Object.assign(Object.assign({}, o), p), {
      override: p
    }, f)), o[u] = g;
  }), o;
};
function mo() {
  const {
    token: n,
    hashed: e,
    theme: t,
    override: r,
    cssVar: i
  } = Fe.useContext(Kz), a = `${M7}-${e || ""}`, o = t || Yz, [s, u, d] = c9(o, [jy, n], {
    salt: a,
    override: r,
    getComputedToken: nB,
    // formatToken will not be consumed after 1.15.0 with getComputedToken.
    // But token will break if @ant-design/cssinjs is under 1.15.0 without it
    formatToken: Jz,
    cssVar: i && {
      prefix: i.prefix,
      key: i.key,
      unitless: eB,
      ignore: tB,
      preserve: R7
    }
  });
  return [o, d, e ? u : "", s, i];
}
function Yi(n) {
  var e = O.useRef();
  e.current = n;
  var t = O.useCallback(function() {
    for (var r, i = arguments.length, a = new Array(i), o = 0; o < i; o++)
      a[o] = arguments[o];
    return (r = e.current) === null || r === void 0 ? void 0 : r.call.apply(r, [e].concat(a));
  }, []);
  return t;
}
function tg(n) {
  var e = O.useRef(!1), t = O.useState(n), r = ot(t, 2), i = r[0], a = r[1];
  O.useEffect(function() {
    return e.current = !1, function() {
      e.current = !0;
    };
  }, []);
  function o(s, u) {
    u && e.current || a(s);
  }
  return [i, o];
}
function $1(n) {
  return n !== void 0;
}
function ko(n, e) {
  var t = e || {}, r = t.defaultValue, i = t.value, a = t.onChange, o = t.postState, s = tg(function() {
    return $1(i) ? i : $1(r) ? typeof r == "function" ? r() : r : typeof n == "function" ? n() : n;
  }), u = ot(s, 2), d = u[0], f = u[1], p = i !== void 0 ? i : d, g = o ? o(p) : p, v = Yi(a), b = tg([p]), E = ot(b, 2), S = E[0], _ = E[1];
  _y(function() {
    var C = S[0];
    d !== C && v(d, C);
  }, [S]), _y(function() {
    $1(i) || f(i);
  }, [i]);
  var w = Yi(function(C, R) {
    f(C, R), _([p], R);
  });
  return [g, w];
}
const A7 = 1e3 * 60 * 10;
let O7 = /* @__PURE__ */ function() {
  function n() {
    ki(this, n), this.map = /* @__PURE__ */ new Map(), this.objectIDMap = /* @__PURE__ */ new WeakMap(), this.nextID = 0, this.lastAccessBeat = /* @__PURE__ */ new Map(), this.accessBeat = 0;
  }
  return $i(n, [{
    key: "set",
    value: function(t, r) {
      this.clear();
      const i = this.getCompositeKey(t);
      this.map.set(i, r), this.lastAccessBeat.set(i, Date.now());
    }
  }, {
    key: "get",
    value: function(t) {
      const r = this.getCompositeKey(t), i = this.map.get(r);
      return this.lastAccessBeat.set(r, Date.now()), this.accessBeat += 1, i;
    }
  }, {
    key: "getCompositeKey",
    value: function(t) {
      return t.map((i) => i && typeof i == "object" ? `obj_${this.getObjectID(i)}` : `${typeof i}_${i}`).join("|");
    }
  }, {
    key: "getObjectID",
    value: function(t) {
      if (this.objectIDMap.has(t))
        return this.objectIDMap.get(t);
      const r = this.nextID;
      return this.objectIDMap.set(t, r), this.nextID += 1, r;
    }
  }, {
    key: "clear",
    value: function() {
      if (this.accessBeat > 1e4) {
        const t = Date.now();
        this.lastAccessBeat.forEach((r, i) => {
          t - r > A7 && (this.map.delete(i), this.lastAccessBeat.delete(i));
        }), this.accessBeat = 0;
      }
    }
  }]);
}();
const o2 = new O7();
function P7(n, e) {
  return Fe.useMemo(() => {
    const t = o2.get(e);
    if (t)
      return t;
    const r = n();
    return o2.set(e, r), r;
  }, e);
}
const pR = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, Vo = function(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return {
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: n.colorText,
    fontSize: n.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: n.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: e ? "inherit" : n.fontFamily
  };
}, b0 = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), D7 = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), I7 = (n) => ({
  a: {
    color: n.colorLink,
    textDecoration: n.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${n.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: n.colorLinkHover
    },
    "&:active": {
      color: n.colorLinkActive
    },
    "&:active, &:hover": {
      textDecoration: n.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: n.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: n.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), N7 = (n, e, t, r) => {
  const i = `[class^="${e}"], [class*=" ${e}"]`, a = t ? `.${t}` : i, o = {
    boxSizing: "border-box",
    "&::before, &::after": {
      boxSizing: "border-box"
    }
  };
  let s = {};
  return r !== !1 && (s = {
    fontFamily: n.fontFamily,
    fontSize: n.fontSize
  }), {
    [a]: Object.assign(Object.assign(Object.assign({}, s), o), {
      [i]: o
    })
  };
}, L7 = (n) => ({
  outline: `${Mt(n.lineWidthFocus)} solid ${n.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), F7 = (n) => ({
  "&:focus-visible": Object.assign({}, L7(n))
});
function U7(n) {
  return n === "js" ? {
    max: Math.max,
    min: Math.min
  } : {
    max: function() {
      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
        t[r] = arguments[r];
      return `max(${t.map((i) => Mt(i)).join(",")})`;
    },
    min: function() {
      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
        t[r] = arguments[r];
      return `min(${t.map((i) => Mt(i)).join(",")})`;
    }
  };
}
const rB = Ee.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u";
let mR = !0;
function li() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  if (!rB)
    return Object.assign.apply(Object, [{}].concat(e));
  mR = !1;
  const r = {};
  return e.forEach((i) => {
    Object.keys(i).forEach((o) => {
      Object.defineProperty(r, o, {
        configurable: !0,
        enumerable: !0,
        get: () => i[o]
      });
    });
  }), mR = !0, r;
}
const s2 = {};
function z7() {
}
const B7 = (n) => {
  let e, t = n, r = z7;
  return rB && typeof Proxy < "u" && (e = /* @__PURE__ */ new Set(), t = new Proxy(n, {
    get(i, a) {
      return mR && e.add(a), i[a];
    }
  }), r = (i, a) => {
    var o;
    s2[i] = {
      global: Array.from(e),
      component: Object.assign(Object.assign({}, (o = s2[i]) === null || o === void 0 ? void 0 : o.component), a)
    };
  }), {
    token: t,
    keys: e,
    flush: r
  };
}, iB = (n, e) => {
  const [t, r] = mo();
  return ZT({
    theme: t,
    token: r,
    hashId: "",
    path: ["ant-design-icons", n],
    nonce: () => e == null ? void 0 : e.nonce,
    layer: {
      name: "antd"
    }
  }, () => [{
    [`.${n}`]: Object.assign(Object.assign({}, b0()), {
      [`.${n} .${n}-icon`]: {
        display: "block"
      }
    })
  }]);
}, aB = (n, e, t) => {
  var r;
  return typeof t == "function" ? t(li(e, (r = e[n]) !== null && r !== void 0 ? r : {})) : t ?? {};
}, oB = (n, e, t, r) => {
  const i = Object.assign({}, e[n]);
  if (r != null && r.deprecatedTokens) {
    const {
      deprecatedTokens: o
    } = r;
    o.forEach((s) => {
      let [u, d] = s;
      var f;
      Ee.env.NODE_ENV !== "production" && Ee.env.NODE_ENV !== "production" && Yn(!(i != null && i[u]), `Component Token \`${String(u)}\` of ${n} is deprecated. Please use \`${String(d)}\` instead.`), (i != null && i[u] || i != null && i[d]) && ((f = i[d]) !== null && f !== void 0 || (i[d] = i == null ? void 0 : i[u]));
    });
  }
  const a = Object.assign(Object.assign({}, t), i);
  return Object.keys(a).forEach((o) => {
    a[o] === e[o] && delete a[o];
  }), a;
}, l2 = (n, e) => `${[e, n.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-")}`;
function BA(n, e, t) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const i = Array.isArray(n) ? n : [n, n], [a] = i, o = i.join("-");
  return function(s) {
    let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
    const [d, f, p, g, v] = mo(), {
      getPrefixCls: b,
      iconPrefixCls: E,
      csp: S
    } = ni(mr), _ = b(), w = v ? "css" : "js", C = P7(() => {
      const U = /* @__PURE__ */ new Set();
      return v && Object.keys(r.unitless || {}).forEach((L) => {
        U.add(j_(L, v.prefix)), U.add(j_(L, l2(a, v.prefix)));
      }), BG(w, U);
    }, [w, a, v == null ? void 0 : v.prefix]), {
      max: R,
      min: P
    } = U7(w), D = {
      theme: d,
      token: g,
      hashId: p,
      nonce: () => S == null ? void 0 : S.nonce,
      clientOnly: r.clientOnly,
      layer: {
        name: "antd"
      },
      // antd is always at top of styles
      order: r.order || -999
    };
    return ZT(Object.assign(Object.assign({}, D), {
      clientOnly: !1,
      path: ["Shared", _]
    }), () => [{
      // Link
      "&": I7(g)
    }]), iB(E, S), [ZT(Object.assign(Object.assign({}, D), {
      path: [o, s, E]
    }), () => {
      if (r.injectStyle === !1)
        return [];
      const {
        token: U,
        flush: L
      } = B7(g), N = aB(a, f, t), H = `.${s}`, j = oB(a, f, N, {
        deprecatedTokens: r.deprecatedTokens
      });
      v && Object.keys(N).forEach((ae) => {
        N[ae] = `var(${j_(ae, l2(a, v.prefix))})`;
      });
      const G = li(U, {
        componentCls: H,
        prefixCls: s,
        iconCls: `.${E}`,
        antCls: `.${_}`,
        calc: C,
        // @ts-ignore
        max: R,
        // @ts-ignore
        min: P
      }, v ? N : j), X = e(G, {
        hashId: p,
        prefixCls: s,
        rootPrefixCls: _,
        iconPrefixCls: E
      });
      return L(a, j), [r.resetStyle === !1 ? null : N7(G, s, u, r.resetFont), X];
    }), p];
  };
}
const sB = (n, e, t, r) => {
  const i = BA(n, e, t, Object.assign({
    resetStyle: !1,
    // Sub Style should default after root one
    order: -998
  }, r)), a = (o) => {
    let {
      prefixCls: s,
      rootCls: u = s
    } = o;
    return i(s, u), null;
  };
  return Ee.env.NODE_ENV !== "production" && (a.displayName = `SubStyle_${Array.isArray(n) ? n.join(".") : n}`), a;
}, H7 = (n, e, t) => {
  const {
    unitless: r,
    injectStyle: i = !0,
    prefixToken: a
  } = t, o = (u) => {
    let {
      rootCls: d,
      cssVar: f
    } = u;
    const [, p] = mo();
    return z9({
      path: [n],
      prefix: f.prefix,
      key: f == null ? void 0 : f.key,
      unitless: r,
      ignore: tB,
      token: p,
      scope: d
    }, () => {
      const g = aB(n, p, e), v = oB(n, p, g, {
        deprecatedTokens: t == null ? void 0 : t.deprecatedTokens
      });
      return Object.keys(g).forEach((b) => {
        v[a(b)] = v[b], delete v[b];
      }), v;
    }), null;
  };
  return (u) => {
    const [, , , , d] = mo();
    return [(f) => i && d ? /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, /* @__PURE__ */ Fe.createElement(o, {
      rootCls: u,
      cssVar: d,
      component: n
    }), f) : f, d == null ? void 0 : d.key];
  };
}, $o = (n, e, t, r) => {
  const i = Array.isArray(n) ? n[0] : n;
  function a(p) {
    return `${i}${p.slice(0, 1).toUpperCase()}${p.slice(1)}`;
  }
  const o = (r == null ? void 0 : r.unitless) || {}, s = Object.assign(Object.assign({}, eB), {
    [a("zIndexPopup")]: !0
  });
  Object.keys(o).forEach((p) => {
    s[a(p)] = o[p];
  });
  const u = Object.assign(Object.assign({}, r), {
    unitless: s,
    prefixToken: a
  }), d = BA(n, e, t, u), f = H7(i, t, u);
  return function(p) {
    let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p;
    const [, v] = d(p, g), [b, E] = f(g);
    return [b, v, E];
  };
};
function V7(n, e) {
  return Gy.reduce((t, r) => {
    const i = n[`${r}1`], a = n[`${r}3`], o = n[`${r}6`], s = n[`${r}7`];
    return Object.assign(Object.assign({}, t), e(r, {
      lightColor: i,
      lightBorderColor: a,
      darkColor: o,
      textColor: s
    }));
  }, {});
}
const k7 = Object.assign({}, O), {
  useId: c2
} = k7, $7 = () => "", W7 = typeof c2 > "u" ? $7 : c2;
function j7(n, e, t) {
  var r, i;
  const a = ci("ConfigProvider"), o = n || {}, s = o.inherit === !1 || !e ? Object.assign(Object.assign({}, hR), {
    hashed: (r = e == null ? void 0 : e.hashed) !== null && r !== void 0 ? r : hR.hashed,
    cssVar: e == null ? void 0 : e.cssVar
  }) : e, u = W7();
  if (Ee.env.NODE_ENV !== "production") {
    const d = o.cssVar || s.cssVar, f = !!(typeof o.cssVar == "object" && (!((i = o.cssVar) === null || i === void 0) && i.key) || u);
    Ee.env.NODE_ENV !== "production" && a(!d || f, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.");
  }
  return uE(() => {
    var d, f;
    if (!n)
      return e;
    const p = Object.assign({}, s.components);
    Object.keys(n.components || {}).forEach((b) => {
      p[b] = Object.assign(Object.assign({}, p[b]), n.components[b]);
    });
    const g = `css-var-${u.replace(/:/g, "")}`, v = ((d = o.cssVar) !== null && d !== void 0 ? d : s.cssVar) && Object.assign(Object.assign(Object.assign({
      prefix: t == null ? void 0 : t.prefixCls
    }, typeof s.cssVar == "object" ? s.cssVar : {}), typeof o.cssVar == "object" ? o.cssVar : {}), {
      key: typeof o.cssVar == "object" && ((f = o.cssVar) === null || f === void 0 ? void 0 : f.key) || g
    });
    return Object.assign(Object.assign(Object.assign({}, s), o), {
      token: Object.assign(Object.assign({}, s.token), o.token),
      components: p,
      cssVar: v
    });
  }, [o, s], (d, f) => d.some((p, g) => {
    const v = f[g];
    return !$T(p, v, !0);
  }));
}
var G7 = ["children"], lB = /* @__PURE__ */ O.createContext({});
function X7(n) {
  var e = n.children, t = br(n, G7);
  return /* @__PURE__ */ O.createElement(lB.Provider, {
    value: t
  }, e);
}
var q7 = /* @__PURE__ */ function(n) {
  Wd(t, n);
  var e = jd(t);
  function t() {
    return ki(this, t), e.apply(this, arguments);
  }
  return $i(t, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), t;
}(O.Component);
function Y7(n) {
  var e = O.useReducer(function(s) {
    return s + 1;
  }, 0), t = ot(e, 2), r = t[1], i = O.useRef(n), a = Yi(function() {
    return i.current;
  }), o = Yi(function(s) {
    i.current = typeof s == "function" ? s(i.current) : s, r();
  });
  return [a, o];
}
var Id = "none", AS = "appear", OS = "enter", PS = "leave", u2 = "none", _l = "prepare", Hm = "start", Vm = "active", HA = "end", cB = "prepared";
function d2(n, e) {
  var t = {};
  return t[n.toLowerCase()] = e.toLowerCase(), t["Webkit".concat(n)] = "webkit".concat(e), t["Moz".concat(n)] = "moz".concat(e), t["ms".concat(n)] = "MS".concat(e), t["O".concat(n)] = "o".concat(e.toLowerCase()), t;
}
function K7(n, e) {
  var t = {
    animationend: d2("Animation", "AnimationEnd"),
    transitionend: d2("Transition", "TransitionEnd")
  };
  return n && ("AnimationEvent" in e || delete t.animationend.animation, "TransitionEvent" in e || delete t.transitionend.transition), t;
}
var Z7 = K7(fo(), typeof window < "u" ? window : {}), uB = {};
if (fo()) {
  var Q7 = document.createElement("div");
  uB = Q7.style;
}
var DS = {};
function dB(n) {
  if (DS[n])
    return DS[n];
  var e = Z7[n];
  if (e)
    for (var t = Object.keys(e), r = t.length, i = 0; i < r; i += 1) {
      var a = t[i];
      if (Object.prototype.hasOwnProperty.call(e, a) && a in uB)
        return DS[n] = e[a], DS[n];
    }
  return "";
}
var fB = dB("animationend"), hB = dB("transitionend"), pB = !!(fB && hB), f2 = fB || "animationend", h2 = hB || "transitionend";
function p2(n, e) {
  if (!n) return null;
  if (bn(n) === "object") {
    var t = e.replace(/-\w/g, function(r) {
      return r[1].toUpperCase();
    });
    return n[t];
  }
  return "".concat(n, "-").concat(e);
}
const J7 = function(n) {
  var e = kt();
  function t(i) {
    i && (i.removeEventListener(h2, n), i.removeEventListener(f2, n));
  }
  function r(i) {
    e.current && e.current !== i && t(e.current), i && i !== e.current && (i.addEventListener(h2, n), i.addEventListener(f2, n), e.current = i);
  }
  return O.useEffect(function() {
    return function() {
      t(e.current);
    };
  }, []), [r, t];
};
var mB = fo() ? xA : In;
const eX = function() {
  var n = O.useRef(null);
  function e() {
    Wr.cancel(n.current);
  }
  function t(r) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    e();
    var a = Wr(function() {
      i <= 1 ? r({
        isCanceled: function() {
          return a !== n.current;
        }
      }) : t(r, i - 1);
    });
    n.current = a;
  }
  return O.useEffect(function() {
    return function() {
      e();
    };
  }, []), [t, e];
};
var tX = [_l, Hm, Vm, HA], nX = [_l, cB], gB = !1, rX = !0;
function vB(n) {
  return n === Vm || n === HA;
}
const iX = function(n, e, t) {
  var r = tg(u2), i = ot(r, 2), a = i[0], o = i[1], s = eX(), u = ot(s, 2), d = u[0], f = u[1];
  function p() {
    o(_l, !0);
  }
  var g = e ? nX : tX;
  return mB(function() {
    if (a !== u2 && a !== HA) {
      var v = g.indexOf(a), b = g[v + 1], E = t(a);
      E === gB ? o(b, !0) : b && d(function(S) {
        function _() {
          S.isCanceled() || o(b, !0);
        }
        E === !0 ? _() : Promise.resolve(E).then(_);
      });
    }
  }, [n, a]), O.useEffect(function() {
    return function() {
      f();
    };
  }, []), [p, a];
};
function aX(n, e, t, r) {
  var i = r.motionEnter, a = i === void 0 ? !0 : i, o = r.motionAppear, s = o === void 0 ? !0 : o, u = r.motionLeave, d = u === void 0 ? !0 : u, f = r.motionDeadline, p = r.motionLeaveImmediately, g = r.onAppearPrepare, v = r.onEnterPrepare, b = r.onLeavePrepare, E = r.onAppearStart, S = r.onEnterStart, _ = r.onLeaveStart, w = r.onAppearActive, C = r.onEnterActive, R = r.onLeaveActive, P = r.onAppearEnd, D = r.onEnterEnd, I = r.onLeaveEnd, U = r.onVisibleChanged, L = tg(), N = ot(L, 2), H = N[0], j = N[1], G = Y7(Id), X = ot(G, 2), ae = X[0], Z = X[1], K = tg(null), B = ot(K, 2), Q = B[0], V = B[1], q = ae(), ne = kt(!1), ce = kt(null);
  function ie() {
    return t();
  }
  var oe = kt(!1);
  function he() {
    Z(Id), V(null, !0);
  }
  var le = Yi(function(te) {
    var Y = ae();
    if (Y !== Id) {
      var Se = ie();
      if (!(te && !te.deadline && te.target !== Se)) {
        var Oe = oe.current, Pe;
        Y === AS && Oe ? Pe = P == null ? void 0 : P(Se, te) : Y === OS && Oe ? Pe = D == null ? void 0 : D(Se, te) : Y === PS && Oe && (Pe = I == null ? void 0 : I(Se, te)), Oe && Pe !== !1 && he();
      }
    }
  }), ve = J7(le), Ne = ot(ve, 1), xe = Ne[0], Me = function(Y) {
    switch (Y) {
      case AS:
        return Re(Re(Re({}, _l, g), Hm, E), Vm, w);
      case OS:
        return Re(Re(Re({}, _l, v), Hm, S), Vm, C);
      case PS:
        return Re(Re(Re({}, _l, b), Hm, _), Vm, R);
      default:
        return {};
    }
  }, $ = O.useMemo(function() {
    return Me(q);
  }, [q]), Te = iX(q, !n, function(te) {
    if (te === _l) {
      var Y = $[_l];
      return Y ? Y(ie()) : gB;
    }
    if (be in $) {
      var Se;
      V(((Se = $[be]) === null || Se === void 0 ? void 0 : Se.call($, ie(), null)) || null);
    }
    return be === Vm && q !== Id && (xe(ie()), f > 0 && (clearTimeout(ce.current), ce.current = setTimeout(function() {
      le({
        deadline: !0
      });
    }, f))), be === cB && he(), rX;
  }), se = ot(Te, 2), Ie = se[0], be = se[1], et = vB(be);
  oe.current = et, mB(function() {
    j(e);
    var te = ne.current;
    ne.current = !0;
    var Y;
    !te && e && s && (Y = AS), te && e && a && (Y = OS), (te && !e && d || !te && p && !e && d) && (Y = PS);
    var Se = Me(Y);
    Y && (n || Se[_l]) ? (Z(Y), Ie()) : Z(Id);
  }, [e]), In(function() {
    // Cancel appear
    (q === AS && !s || // Cancel enter
    q === OS && !a || // Cancel leave
    q === PS && !d) && Z(Id);
  }, [s, a, d]), In(function() {
    return function() {
      ne.current = !1, clearTimeout(ce.current);
    };
  }, []);
  var Xe = O.useRef(!1);
  In(function() {
    H && (Xe.current = !0), H !== void 0 && q === Id && ((Xe.current || H) && (U == null || U(H)), Xe.current = !0);
  }, [H, q]);
  var $e = Q;
  return $[_l] && be === Hm && ($e = ke({
    transition: "none"
  }, $e)), [q, be, $e, H ?? e];
}
function oX(n) {
  var e = n;
  bn(n) === "object" && (e = n.transitionSupport);
  function t(i, a) {
    return !!(i.motionName && e && a !== !1);
  }
  var r = /* @__PURE__ */ O.forwardRef(function(i, a) {
    var o = i.visible, s = o === void 0 ? !0 : o, u = i.removeOnLeave, d = u === void 0 ? !0 : u, f = i.forceRender, p = i.children, g = i.motionName, v = i.leavedClassName, b = i.eventProps, E = O.useContext(lB), S = E.motion, _ = t(i, S), w = kt(), C = kt();
    function R() {
      try {
        return w.current instanceof HTMLElement ? w.current : by(C.current);
      } catch {
        return null;
      }
    }
    var P = aX(_, s, R, i), D = ot(P, 4), I = D[0], U = D[1], L = D[2], N = D[3], H = O.useRef(N);
    N && (H.current = !0);
    var j = O.useCallback(function(Q) {
      w.current = Q, RA(a, Q);
    }, [a]), G, X = ke(ke({}, b), {}, {
      visible: s
    });
    if (!p)
      G = null;
    else if (I === Id)
      N ? G = p(ke({}, X), j) : !d && H.current && v ? G = p(ke(ke({}, X), {}, {
        className: v
      }), j) : f || !d && !v ? G = p(ke(ke({}, X), {}, {
        style: {
          display: "none"
        }
      }), j) : G = null;
    else {
      var ae;
      U === _l ? ae = "prepare" : vB(U) ? ae = "active" : U === Hm && (ae = "start");
      var Z = p2(g, "".concat(I, "-").concat(ae));
      G = p(ke(ke({}, X), {}, {
        className: Et(p2(g, I), Re(Re({}, Z, Z && ae), g, typeof g == "string")),
        style: L
      }), j);
    }
    if (/* @__PURE__ */ O.isValidElement(G) && pg(G)) {
      var K = G, B = K.ref;
      B || (G = /* @__PURE__ */ O.cloneElement(G, {
        ref: j
      }));
    }
    return /* @__PURE__ */ O.createElement(q7, {
      ref: C
    }, G);
  });
  return r.displayName = "CSSMotion", r;
}
const Hh = oX(pB);
var gR = "add", vR = "keep", yR = "remove", W1 = "removed";
function sX(n) {
  var e;
  return n && bn(n) === "object" && "key" in n ? e = n : e = {
    key: n
  }, ke(ke({}, e), {}, {
    key: String(e.key)
  });
}
function bR() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return n.map(sX);
}
function lX() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = [], r = 0, i = e.length, a = bR(n), o = bR(e);
  a.forEach(function(d) {
    for (var f = !1, p = r; p < i; p += 1) {
      var g = o[p];
      if (g.key === d.key) {
        r < p && (t = t.concat(o.slice(r, p).map(function(v) {
          return ke(ke({}, v), {}, {
            status: gR
          });
        })), r = p), t.push(ke(ke({}, g), {}, {
          status: vR
        })), r += 1, f = !0;
        break;
      }
    }
    f || t.push(ke(ke({}, d), {}, {
      status: yR
    }));
  }), r < i && (t = t.concat(o.slice(r).map(function(d) {
    return ke(ke({}, d), {}, {
      status: gR
    });
  })));
  var s = {};
  t.forEach(function(d) {
    var f = d.key;
    s[f] = (s[f] || 0) + 1;
  });
  var u = Object.keys(s).filter(function(d) {
    return s[d] > 1;
  });
  return u.forEach(function(d) {
    t = t.filter(function(f) {
      var p = f.key, g = f.status;
      return p !== d || g !== yR;
    }), t.forEach(function(f) {
      f.key === d && (f.status = vR);
    });
  }), t;
}
var cX = ["component", "children", "onVisibleChanged", "onAllRemoved"], uX = ["status"], dX = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function fX(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hh, t = /* @__PURE__ */ function(r) {
    Wd(a, r);
    var i = jd(a);
    function a() {
      var o;
      ki(this, a);
      for (var s = arguments.length, u = new Array(s), d = 0; d < s; d++)
        u[d] = arguments[d];
      return o = i.call.apply(i, [this].concat(u)), Re(tr(o), "state", {
        keyEntities: []
      }), Re(tr(o), "removeKey", function(f) {
        var p = o.state.keyEntities, g = p.map(function(v) {
          return v.key !== f ? v : ke(ke({}, v), {}, {
            status: W1
          });
        });
        return o.setState({
          keyEntities: g
        }), g.filter(function(v) {
          var b = v.status;
          return b !== W1;
        }).length;
      }), o;
    }
    return $i(a, [{
      key: "render",
      value: function() {
        var s = this, u = this.state.keyEntities, d = this.props, f = d.component, p = d.children, g = d.onVisibleChanged, v = d.onAllRemoved, b = br(d, cX), E = f || O.Fragment, S = {};
        return dX.forEach(function(_) {
          S[_] = b[_], delete b[_];
        }), delete b.keys, /* @__PURE__ */ O.createElement(E, b, u.map(function(_, w) {
          var C = _.status, R = br(_, uX), P = C === gR || C === vR;
          return /* @__PURE__ */ O.createElement(e, gn({}, S, {
            key: R.key,
            visible: P,
            eventProps: R,
            onVisibleChanged: function(I) {
              if (g == null || g(I, {
                key: R.key
              }), !I) {
                var U = s.removeKey(R.key);
                U === 0 && v && v();
              }
            }
          }), function(D, I) {
            return p(ke(ke({}, D), {}, {
              index: w
            }), I);
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(s, u) {
        var d = s.keys, f = u.keyEntities, p = bR(d), g = lX(f, p);
        return {
          keyEntities: g.filter(function(v) {
            var b = f.find(function(E) {
              var S = E.key;
              return v.key === S;
            });
            return !(b && b.status === W1 && v.status === yR);
          })
        };
      }
    }]), a;
  }(O.Component);
  return Re(t, "defaultProps", {
    component: "div"
  }), t;
}
const hX = fX(pB);
function pX(n) {
  const {
    children: e
  } = n, [, t] = mo(), {
    motion: r
  } = t, i = O.useRef(!1);
  return i.current = i.current || r === !1, i.current ? /* @__PURE__ */ O.createElement(X7, {
    motion: r
  }, e) : e;
}
const yB = /* @__PURE__ */ O.memo((n) => {
  let {
    dropdownMatchSelectWidth: e
  } = n;
  return ci("ConfigProvider").deprecated(e === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), null;
});
Ee.env.NODE_ENV !== "production" && (yB.displayName = "PropWarning");
const mX = Ee.env.NODE_ENV !== "production" ? yB : () => null;
var gX = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
let SR = !1;
Ee.env.NODE_ENV;
const vX = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"];
let bB;
function yX() {
  return bB || fx;
}
function bX(n) {
  return Object.keys(n).some((e) => e.endsWith("Color"));
}
const SX = (n) => {
  const {
    prefixCls: e,
    iconPrefixCls: t,
    theme: r,
    holderRender: i
  } = n;
  e !== void 0 && (bB = e), r && bX(r) && (Ee.env.NODE_ENV !== "production" && Bh(!1, "ConfigProvider", "`config` of css variable theme is not work in v5. Please use new `theme` config instead."), E7(yX(), r));
}, _X = (n) => {
  const {
    children: e,
    csp: t,
    autoInsertSpaceInButton: r,
    alert: i,
    anchor: a,
    form: o,
    locale: s,
    componentSize: u,
    direction: d,
    space: f,
    virtual: p,
    dropdownMatchSelectWidth: g,
    popupMatchSelectWidth: v,
    popupOverflow: b,
    legacyLocale: E,
    parentContext: S,
    iconPrefixCls: _,
    theme: w,
    componentDisabled: C,
    segmented: R,
    statistic: P,
    spin: D,
    calendar: I,
    carousel: U,
    cascader: L,
    collapse: N,
    typography: H,
    checkbox: j,
    descriptions: G,
    divider: X,
    drawer: ae,
    skeleton: Z,
    steps: K,
    image: B,
    layout: Q,
    list: V,
    mentions: q,
    modal: ne,
    progress: ce,
    result: ie,
    slider: oe,
    breadcrumb: he,
    menu: le,
    pagination: ve,
    input: Ne,
    textArea: xe,
    empty: Me,
    badge: $,
    radio: Te,
    rate: se,
    switch: Ie,
    transfer: be,
    avatar: et,
    message: Xe,
    tag: $e,
    table: te,
    card: Y,
    tabs: Se,
    timeline: Oe,
    timePicker: Pe,
    upload: Ve,
    notification: Ze,
    tree: nt,
    colorPicker: ht,
    datePicker: pt,
    rangePicker: Be,
    flex: ye,
    wave: Ue,
    dropdown: Ye,
    warning: tt,
    tour: st,
    floatButtonGroup: Tt,
    variant: Rt,
    inputNumber: ue,
    treeSelect: De
  } = n, Ge = O.useCallback((xt, Pt) => {
    const {
      prefixCls: Bt
    } = n;
    if (Pt)
      return Pt;
    const Qt = Bt || S.getPrefixCls("");
    return xt ? `${Qt}-${xt}` : Qt;
  }, [S.getPrefixCls, n.prefixCls]), We = _ || S.iconPrefixCls || Zz, He = t || S.csp;
  iB(We, He);
  const ut = j7(w, S.theme, {
    prefixCls: Ge("")
  });
  Ee.env.NODE_ENV !== "production" && (SR = SR || !!ut);
  const vt = {
    csp: He,
    autoInsertSpaceInButton: r,
    alert: i,
    anchor: a,
    locale: s || E,
    direction: d,
    space: f,
    virtual: p,
    popupMatchSelectWidth: v ?? g,
    popupOverflow: b,
    getPrefixCls: Ge,
    iconPrefixCls: We,
    theme: ut,
    segmented: R,
    statistic: P,
    spin: D,
    calendar: I,
    carousel: U,
    cascader: L,
    collapse: N,
    typography: H,
    checkbox: j,
    descriptions: G,
    divider: X,
    drawer: ae,
    skeleton: Z,
    steps: K,
    image: B,
    input: Ne,
    textArea: xe,
    layout: Q,
    list: V,
    mentions: q,
    modal: ne,
    progress: ce,
    result: ie,
    slider: oe,
    breadcrumb: he,
    menu: le,
    pagination: ve,
    empty: Me,
    badge: $,
    radio: Te,
    rate: se,
    switch: Ie,
    transfer: be,
    avatar: et,
    message: Xe,
    tag: $e,
    table: te,
    card: Y,
    tabs: Se,
    timeline: Oe,
    timePicker: Pe,
    upload: Ve,
    notification: Ze,
    tree: nt,
    colorPicker: ht,
    datePicker: pt,
    rangePicker: Be,
    flex: ye,
    wave: Ue,
    dropdown: Ye,
    warning: tt,
    tour: st,
    floatButtonGroup: Tt,
    variant: Rt,
    inputNumber: ue,
    treeSelect: De
  };
  Ee.env.NODE_ENV !== "production" && ci("ConfigProvider")(!("autoInsertSpaceInButton" in n), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
  const _t = Object.assign({}, S);
  Object.keys(vt).forEach((xt) => {
    vt[xt] !== void 0 && (_t[xt] = vt[xt]);
  }), vX.forEach((xt) => {
    const Pt = n[xt];
    Pt && (_t[xt] = Pt);
  }), typeof r < "u" && (_t.button = Object.assign({
    autoInsertSpace: r
  }, _t.button));
  const Wt = uE(() => _t, _t, (xt, Pt) => {
    const Bt = Object.keys(xt), Qt = Object.keys(Pt);
    return Bt.length !== Qt.length || Bt.some((vn) => xt[vn] !== Pt[vn]);
  }), lt = O.useMemo(() => ({
    prefixCls: We,
    csp: He
  }), [We, He]);
  let Ct = /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement(mX, {
    dropdownMatchSelectWidth: g
  }), e);
  const un = O.useMemo(() => {
    var xt, Pt, Bt, Qt;
    return Bm(((xt = Rh.Form) === null || xt === void 0 ? void 0 : xt.defaultValidateMessages) || {}, ((Bt = (Pt = Wt.locale) === null || Pt === void 0 ? void 0 : Pt.Form) === null || Bt === void 0 ? void 0 : Bt.defaultValidateMessages) || {}, ((Qt = Wt.form) === null || Qt === void 0 ? void 0 : Qt.validateMessages) || {}, (o == null ? void 0 : o.validateMessages) || {});
  }, [Wt, o == null ? void 0 : o.validateMessages]);
  Object.keys(un).length > 0 && (Ct = /* @__PURE__ */ O.createElement(Vz.Provider, {
    value: un
  }, Ct)), s && (Ct = /* @__PURE__ */ O.createElement(Wz, {
    locale: s,
    _ANT_MARK__: $z
  }, Ct)), (We || He) && (Ct = /* @__PURE__ */ O.createElement(FA.Provider, {
    value: lt
  }, Ct)), u && (Ct = /* @__PURE__ */ O.createElement(C7, {
    size: u
  }, Ct)), Ct = /* @__PURE__ */ O.createElement(pX, null, Ct);
  const Nn = O.useMemo(() => {
    const xt = ut || {}, {
      algorithm: Pt,
      token: Bt,
      components: Qt,
      cssVar: vn
    } = xt, Mn = gX(xt, ["algorithm", "token", "components", "cssVar"]), cr = Pt && (!Array.isArray(Pt) || Pt.length > 0) ? jT(Pt) : Yz, ge = {};
    Object.entries(Qt || {}).forEach((yt) => {
      let [Kt, Sn] = yt;
      const ee = Object.assign({}, Sn);
      "algorithm" in ee && (ee.algorithm === !0 ? ee.theme = cr : (Array.isArray(ee.algorithm) || typeof ee.algorithm == "function") && (ee.theme = jT(ee.algorithm)), delete ee.algorithm), ge[Kt] = ee;
    });
    const it = Object.assign(Object.assign({}, jy), Bt);
    return Object.assign(Object.assign({}, Mn), {
      theme: cr,
      token: it,
      components: ge,
      override: Object.assign({
        override: it
      }, ge),
      cssVar: vn
    });
  }, [ut]);
  return w && (Ct = /* @__PURE__ */ O.createElement(Kz.Provider, {
    value: Nn
  }, Ct)), Wt.warning && (Ct = /* @__PURE__ */ O.createElement(Hz.Provider, {
    value: Wt.warning
  }, Ct)), C !== void 0 && (Ct = /* @__PURE__ */ O.createElement(Qz, {
    disabled: C
  }, Ct)), /* @__PURE__ */ O.createElement(mr.Provider, {
    value: Wt
  }, Ct);
}, Gd = (n) => {
  const e = O.useContext(mr), t = O.useContext(UA);
  return /* @__PURE__ */ O.createElement(_X, Object.assign({
    parentContext: e,
    legacyLocale: t
  }, n));
};
Gd.ConfigContext = mr;
Gd.SizeContext = Ah;
Gd.config = SX;
Gd.useConfig = w7;
Object.defineProperty(Gd, "SizeContext", {
  get: () => (Ee.env.NODE_ENV !== "production" && Bh(!1, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead."), Ah)
});
Ee.env.NODE_ENV !== "production" && (Gd.displayName = "ConfigProvider");
var xX = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, name: "check-circle", theme: "filled" };
function SB(n) {
  var e;
  return n == null || (e = n.getRootNode) === null || e === void 0 ? void 0 : e.call(n);
}
function EX(n) {
  return SB(n) instanceof ShadowRoot;
}
function hx(n) {
  return EX(n) ? SB(n) : null;
}
function CX(n) {
  return n.replace(/-(.)/g, function(e, t) {
    return t.toUpperCase();
  });
}
function wX(n, e) {
  Yn(n, "[@ant-design/icons] ".concat(e));
}
function m2(n) {
  return bn(n) === "object" && typeof n.name == "string" && typeof n.theme == "string" && (bn(n.icon) === "object" || typeof n.icon == "function");
}
function g2() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(n).reduce(function(e, t) {
    var r = n[t];
    switch (t) {
      case "class":
        e.className = r, delete e.class;
        break;
      default:
        delete e[t], e[CX(t)] = r;
    }
    return e;
  }, {});
}
function _R(n, e, t) {
  return t ? /* @__PURE__ */ Fe.createElement(n.tag, ke(ke({
    key: e
  }, g2(n.attrs)), t), (n.children || []).map(function(r, i) {
    return _R(r, "".concat(e, "-").concat(n.tag, "-").concat(i));
  })) : /* @__PURE__ */ Fe.createElement(n.tag, ke({
    key: e
  }, g2(n.attrs)), (n.children || []).map(function(r, i) {
    return _R(r, "".concat(e, "-").concat(n.tag, "-").concat(i));
  }));
}
function _B(n) {
  return Wy(n)[0];
}
function xB(n) {
  return n ? Array.isArray(n) ? n : [n] : [];
}
var MX = `
.anticon {
  display: inline-flex;
  align-items: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`, TX = function(e) {
  var t = ni(FA), r = t.csp, i = t.prefixCls, a = MX;
  i && (a = a.replace(/anticon/g, i)), In(function() {
    var o = e.current, s = hx(o);
    lu(a, "@ant-design-icons", {
      prepend: !0,
      csp: r,
      attachTo: s
    });
  }, []);
}, RX = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"], Ey = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
};
function AX(n) {
  var e = n.primaryColor, t = n.secondaryColor;
  Ey.primaryColor = e, Ey.secondaryColor = t || _B(e), Ey.calculated = !!t;
}
function OX() {
  return ke({}, Ey);
}
var gg = function(e) {
  var t = e.icon, r = e.className, i = e.onClick, a = e.style, o = e.primaryColor, s = e.secondaryColor, u = br(e, RX), d = O.useRef(), f = Ey;
  if (o && (f = {
    primaryColor: o,
    secondaryColor: s || _B(o)
  }), TX(d), wX(m2(t), "icon should be icon definiton, but got ".concat(t)), !m2(t))
    return null;
  var p = t;
  return p && typeof p.icon == "function" && (p = ke(ke({}, p), {}, {
    icon: p.icon(f.primaryColor, f.secondaryColor)
  })), _R(p.icon, "svg-".concat(p.name), ke(ke({
    className: r,
    onClick: i,
    style: a,
    "data-icon": p.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, u), {}, {
    ref: d
  }));
};
gg.displayName = "IconReact";
gg.getTwoToneColors = OX;
gg.setTwoToneColors = AX;
function EB(n) {
  var e = xB(n), t = ot(e, 2), r = t[0], i = t[1];
  return gg.setTwoToneColors({
    primaryColor: r,
    secondaryColor: i
  });
}
function PX() {
  var n = gg.getTwoToneColors();
  return n.calculated ? [n.primaryColor, n.secondaryColor] : n.primaryColor;
}
var DX = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
EB(dx.primary);
var Ka = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.className, r = n.icon, i = n.spin, a = n.rotate, o = n.tabIndex, s = n.onClick, u = n.twoToneColor, d = br(n, DX), f = O.useContext(FA), p = f.prefixCls, g = p === void 0 ? "anticon" : p, v = f.rootClassName, b = Et(v, g, Re(Re({}, "".concat(g, "-").concat(r.name), !!r.name), "".concat(g, "-spin"), !!i || r.name === "loading"), t), E = o;
  E === void 0 && s && (E = -1);
  var S = a ? {
    msTransform: "rotate(".concat(a, "deg)"),
    transform: "rotate(".concat(a, "deg)")
  } : void 0, _ = xB(u), w = ot(_, 2), C = w[0], R = w[1];
  return /* @__PURE__ */ O.createElement("span", gn({
    role: "img",
    "aria-label": r.name
  }, d, {
    ref: e,
    tabIndex: E,
    onClick: s,
    className: b
  }), /* @__PURE__ */ O.createElement(gg, {
    icon: r,
    primaryColor: C,
    secondaryColor: R,
    style: S
  }));
});
Ka.displayName = "AntdIcon";
Ka.getTwoToneColor = PX;
Ka.setTwoToneColor = EB;
var IX = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: xX
  }));
}, CB = /* @__PURE__ */ O.forwardRef(IX);
Ee.env.NODE_ENV !== "production" && (CB.displayName = "CheckCircleFilled");
var NX = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" }, LX = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: NX
  }));
}, SE = /* @__PURE__ */ O.forwardRef(LX);
Ee.env.NODE_ENV !== "production" && (SE.displayName = "CloseCircleFilled");
var FX = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" }, UX = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: FX
  }));
}, wB = /* @__PURE__ */ O.forwardRef(UX);
Ee.env.NODE_ENV !== "production" && (wB.displayName = "CloseOutlined");
var zX = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" }, BX = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: zX
  }));
}, MB = /* @__PURE__ */ O.forwardRef(BX);
Ee.env.NODE_ENV !== "production" && (MB.displayName = "ExclamationCircleFilled");
var HX = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`, VX = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`, kX = "".concat(HX, " ").concat(VX).split(/[\s\n]+/), $X = "aria-", WX = "data-";
function v2(n, e) {
  return n.indexOf(e) === 0;
}
function ng(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, t;
  e === !1 ? t = {
    aria: !0,
    data: !0,
    attr: !0
  } : e === !0 ? t = {
    aria: !0
  } : t = ke({}, e);
  var r = {};
  return Object.keys(n).forEach(function(i) {
    // Aria
    (t.aria && (i === "role" || v2(i, $X)) || // Data
    t.data && v2(i, WX) || // Attr
    t.attr && kX.includes(i)) && (r[i] = n[i]);
  }), r;
}
function TB(n) {
  return n && /* @__PURE__ */ Fe.isValidElement(n) && n.type === Fe.Fragment;
}
const jX = (n, e, t) => /* @__PURE__ */ Fe.isValidElement(n) ? /* @__PURE__ */ Fe.cloneElement(n, typeof t == "function" ? t(n.props || {}) : t) : e;
function fu(n, e) {
  return jX(n, n, e);
}
const y2 = (n) => typeof n == "object" && n != null && n.nodeType === 1, b2 = (n, e) => (!e || n !== "hidden") && n !== "visible" && n !== "clip", j1 = (n, e) => {
  if (n.clientHeight < n.scrollHeight || n.clientWidth < n.scrollWidth) {
    const t = getComputedStyle(n, null);
    return b2(t.overflowY, e) || b2(t.overflowX, e) || ((r) => {
      const i = ((a) => {
        if (!a.ownerDocument || !a.ownerDocument.defaultView) return null;
        try {
          return a.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth);
    })(n);
  }
  return !1;
}, IS = (n, e, t, r, i, a, o, s) => a < n && o > e || a > n && o < e ? 0 : a <= n && s <= t || o >= e && s >= t ? a - n - r : o > e && s < t || a < n && s > t ? o - e + i : 0, GX = (n) => {
  const e = n.parentElement;
  return e ?? (n.getRootNode().host || null);
}, S2 = (n, e) => {
  var t, r, i, a;
  if (typeof document > "u") return [];
  const { scrollMode: o, block: s, inline: u, boundary: d, skipOverflowHiddenElements: f } = e, p = typeof d == "function" ? d : (Z) => Z !== d;
  if (!y2(n)) throw new TypeError("Invalid target");
  const g = document.scrollingElement || document.documentElement, v = [];
  let b = n;
  for (; y2(b) && p(b); ) {
    if (b = GX(b), b === g) {
      v.push(b);
      break;
    }
    b != null && b === document.body && j1(b) && !j1(document.documentElement) || b != null && j1(b, f) && v.push(b);
  }
  const E = (r = (t = window.visualViewport) == null ? void 0 : t.width) != null ? r : innerWidth, S = (a = (i = window.visualViewport) == null ? void 0 : i.height) != null ? a : innerHeight, { scrollX: _, scrollY: w } = window, { height: C, width: R, top: P, right: D, bottom: I, left: U } = n.getBoundingClientRect(), { top: L, right: N, bottom: H, left: j } = ((Z) => {
    const K = window.getComputedStyle(Z);
    return { top: parseFloat(K.scrollMarginTop) || 0, right: parseFloat(K.scrollMarginRight) || 0, bottom: parseFloat(K.scrollMarginBottom) || 0, left: parseFloat(K.scrollMarginLeft) || 0 };
  })(n);
  let G = s === "start" || s === "nearest" ? P - L : s === "end" ? I + H : P + C / 2 - L + H, X = u === "center" ? U + R / 2 - j + N : u === "end" ? D + N : U - j;
  const ae = [];
  for (let Z = 0; Z < v.length; Z++) {
    const K = v[Z], { height: B, width: Q, top: V, right: q, bottom: ne, left: ce } = K.getBoundingClientRect();
    if (o === "if-needed" && P >= 0 && U >= 0 && I <= S && D <= E && P >= V && I <= ne && U >= ce && D <= q) return ae;
    const ie = getComputedStyle(K), oe = parseInt(ie.borderLeftWidth, 10), he = parseInt(ie.borderTopWidth, 10), le = parseInt(ie.borderRightWidth, 10), ve = parseInt(ie.borderBottomWidth, 10);
    let Ne = 0, xe = 0;
    const Me = "offsetWidth" in K ? K.offsetWidth - K.clientWidth - oe - le : 0, $ = "offsetHeight" in K ? K.offsetHeight - K.clientHeight - he - ve : 0, Te = "offsetWidth" in K ? K.offsetWidth === 0 ? 0 : Q / K.offsetWidth : 0, se = "offsetHeight" in K ? K.offsetHeight === 0 ? 0 : B / K.offsetHeight : 0;
    if (g === K) Ne = s === "start" ? G : s === "end" ? G - S : s === "nearest" ? IS(w, w + S, S, he, ve, w + G, w + G + C, C) : G - S / 2, xe = u === "start" ? X : u === "center" ? X - E / 2 : u === "end" ? X - E : IS(_, _ + E, E, oe, le, _ + X, _ + X + R, R), Ne = Math.max(0, Ne + w), xe = Math.max(0, xe + _);
    else {
      Ne = s === "start" ? G - V - he : s === "end" ? G - ne + ve + $ : s === "nearest" ? IS(V, ne, B, he, ve + $, G, G + C, C) : G - (V + B / 2) + $ / 2, xe = u === "start" ? X - ce - oe : u === "center" ? X - (ce + Q / 2) + Me / 2 : u === "end" ? X - q + le + Me : IS(ce, q, Q, oe, le + Me, X, X + R, R);
      const { scrollLeft: Ie, scrollTop: be } = K;
      Ne = se === 0 ? 0 : Math.max(0, Math.min(be + Ne / se, K.scrollHeight - B / se + $)), xe = Te === 0 ? 0 : Math.max(0, Math.min(Ie + xe / Te, K.scrollWidth - Q / Te + Me)), G += be - Ne, X += Ie - xe;
    }
    ae.push({ el: K, top: Ne, left: xe });
  }
  return ae;
}, XX = (n) => n === !1 ? { block: "end", inline: "nearest" } : ((e) => e === Object(e) && Object.keys(e).length !== 0)(n) ? n : { block: "start", inline: "nearest" };
function qX(n, e) {
  if (!n.isConnected || !((i) => {
    let a = i;
    for (; a && a.parentNode; ) {
      if (a.parentNode === document) return !0;
      a = a.parentNode instanceof ShadowRoot ? a.parentNode.host : a.parentNode;
    }
    return !1;
  })(n)) return;
  const t = ((i) => {
    const a = window.getComputedStyle(i);
    return { top: parseFloat(a.scrollMarginTop) || 0, right: parseFloat(a.scrollMarginRight) || 0, bottom: parseFloat(a.scrollMarginBottom) || 0, left: parseFloat(a.scrollMarginLeft) || 0 };
  })(n);
  if (((i) => typeof i == "object" && typeof i.behavior == "function")(e)) return e.behavior(S2(n, e));
  const r = typeof e == "boolean" || e == null ? void 0 : e.behavior;
  for (const { el: i, top: a, left: o } of S2(n, XX(e))) {
    const s = a - t.top + t.bottom, u = o - t.left + t.right;
    i.scroll({ top: s, left: u, behavior: r });
  }
}
const _u = (n) => {
  const [, , , , e] = mo();
  return e ? `${n}-css-var` : "";
};
var Ft = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(e) {
    var t = e.keyCode;
    if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
    t >= Ft.F1 && t <= Ft.F12)
      return !1;
    switch (t) {
      case Ft.ALT:
      case Ft.CAPS_LOCK:
      case Ft.CONTEXT_MENU:
      case Ft.CTRL:
      case Ft.DOWN:
      case Ft.END:
      case Ft.ESC:
      case Ft.HOME:
      case Ft.INSERT:
      case Ft.LEFT:
      case Ft.MAC_FF_META:
      case Ft.META:
      case Ft.NUMLOCK:
      case Ft.NUM_CENTER:
      case Ft.PAGE_DOWN:
      case Ft.PAGE_UP:
      case Ft.PAUSE:
      case Ft.PRINT_SCREEN:
      case Ft.RIGHT:
      case Ft.SHIFT:
      case Ft.UP:
      case Ft.WIN_KEY:
      case Ft.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(e) {
    if (e >= Ft.ZERO && e <= Ft.NINE || e >= Ft.NUM_ZERO && e <= Ft.NUM_MULTIPLY || e >= Ft.A && e <= Ft.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && e === 0)
      return !0;
    switch (e) {
      case Ft.SPACE:
      case Ft.QUESTION_MARK:
      case Ft.NUM_PLUS:
      case Ft.NUM_MINUS:
      case Ft.NUM_PERIOD:
      case Ft.NUM_DIVISION:
      case Ft.SEMICOLON:
      case Ft.DASH:
      case Ft.EQUALS:
      case Ft.COMMA:
      case Ft.PERIOD:
      case Ft.SLASH:
      case Ft.APOSTROPHE:
      case Ft.SINGLE_QUOTE:
      case Ft.OPEN_SQUARE_BRACKET:
      case Ft.BACKSLASH:
      case Ft.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
}, YX = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" }, KX = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: YX
  }));
}, _E = /* @__PURE__ */ O.forwardRef(KX);
Ee.env.NODE_ENV !== "production" && (_E.displayName = "LoadingOutlined");
const VA = /* @__PURE__ */ Fe.createContext(void 0);
Ee.env.NODE_ENV !== "production" && (VA.displayName = "zIndexContext");
const eh = 100, ZX = 10, QX = eh * ZX, RB = {
  Modal: eh,
  Drawer: eh,
  Popover: eh,
  Popconfirm: eh,
  Tooltip: eh,
  Tour: eh
}, JX = {
  SelectLike: 50,
  Dropdown: 50,
  DatePicker: 50,
  Menu: 50,
  ImagePreview: 1
};
function eq(n) {
  return n in RB;
}
function AB(n, e) {
  const [, t] = mo(), r = Fe.useContext(VA), i = eq(n);
  let a;
  if (e !== void 0)
    a = [e, e];
  else {
    let o = r ?? 0;
    i ? o += // Use preset token zIndex by default but not stack when has parent container
    (r ? 0 : t.zIndexPopupBase) + // Container offset
    RB[n] : o += JX[n], a = [r === void 0 ? e : o, o];
  }
  if (Ee.env.NODE_ENV !== "production") {
    const o = ci(n), s = t.zIndexPopupBase + QX, u = a[0] || 0;
    Ee.env.NODE_ENV !== "production" && o(e !== void 0 || u <= s, "usage", "`zIndex` is over design token `zIndexPopupBase` too much. It may cause unexpected override.");
  }
  return a;
}
function go() {
  go = function() {
    return e;
  };
  var n, e = {}, t = Object.prototype, r = t.hasOwnProperty, i = Object.defineProperty || function(Z, K, B) {
    Z[K] = B.value;
  }, a = typeof Symbol == "function" ? Symbol : {}, o = a.iterator || "@@iterator", s = a.asyncIterator || "@@asyncIterator", u = a.toStringTag || "@@toStringTag";
  function d(Z, K, B) {
    return Object.defineProperty(Z, K, {
      value: B,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), Z[K];
  }
  try {
    d({}, "");
  } catch {
    d = function(B, Q, V) {
      return B[Q] = V;
    };
  }
  function f(Z, K, B, Q) {
    var V = K && K.prototype instanceof _ ? K : _, q = Object.create(V.prototype), ne = new X(Q || []);
    return i(q, "_invoke", {
      value: N(Z, B, ne)
    }), q;
  }
  function p(Z, K, B) {
    try {
      return {
        type: "normal",
        arg: Z.call(K, B)
      };
    } catch (Q) {
      return {
        type: "throw",
        arg: Q
      };
    }
  }
  e.wrap = f;
  var g = "suspendedStart", v = "suspendedYield", b = "executing", E = "completed", S = {};
  function _() {
  }
  function w() {
  }
  function C() {
  }
  var R = {};
  d(R, o, function() {
    return this;
  });
  var P = Object.getPrototypeOf, D = P && P(P(ae([])));
  D && D !== t && r.call(D, o) && (R = D);
  var I = C.prototype = _.prototype = Object.create(R);
  function U(Z) {
    ["next", "throw", "return"].forEach(function(K) {
      d(Z, K, function(B) {
        return this._invoke(K, B);
      });
    });
  }
  function L(Z, K) {
    function B(V, q, ne, ce) {
      var ie = p(Z[V], Z, q);
      if (ie.type !== "throw") {
        var oe = ie.arg, he = oe.value;
        return he && bn(he) == "object" && r.call(he, "__await") ? K.resolve(he.__await).then(function(le) {
          B("next", le, ne, ce);
        }, function(le) {
          B("throw", le, ne, ce);
        }) : K.resolve(he).then(function(le) {
          oe.value = le, ne(oe);
        }, function(le) {
          return B("throw", le, ne, ce);
        });
      }
      ce(ie.arg);
    }
    var Q;
    i(this, "_invoke", {
      value: function(q, ne) {
        function ce() {
          return new K(function(ie, oe) {
            B(q, ne, ie, oe);
          });
        }
        return Q = Q ? Q.then(ce, ce) : ce();
      }
    });
  }
  function N(Z, K, B) {
    var Q = g;
    return function(V, q) {
      if (Q === b) throw Error("Generator is already running");
      if (Q === E) {
        if (V === "throw") throw q;
        return {
          value: n,
          done: !0
        };
      }
      for (B.method = V, B.arg = q; ; ) {
        var ne = B.delegate;
        if (ne) {
          var ce = H(ne, B);
          if (ce) {
            if (ce === S) continue;
            return ce;
          }
        }
        if (B.method === "next") B.sent = B._sent = B.arg;
        else if (B.method === "throw") {
          if (Q === g) throw Q = E, B.arg;
          B.dispatchException(B.arg);
        } else B.method === "return" && B.abrupt("return", B.arg);
        Q = b;
        var ie = p(Z, K, B);
        if (ie.type === "normal") {
          if (Q = B.done ? E : v, ie.arg === S) continue;
          return {
            value: ie.arg,
            done: B.done
          };
        }
        ie.type === "throw" && (Q = E, B.method = "throw", B.arg = ie.arg);
      }
    };
  }
  function H(Z, K) {
    var B = K.method, Q = Z.iterator[B];
    if (Q === n) return K.delegate = null, B === "throw" && Z.iterator.return && (K.method = "return", K.arg = n, H(Z, K), K.method === "throw") || B !== "return" && (K.method = "throw", K.arg = new TypeError("The iterator does not provide a '" + B + "' method")), S;
    var V = p(Q, Z.iterator, K.arg);
    if (V.type === "throw") return K.method = "throw", K.arg = V.arg, K.delegate = null, S;
    var q = V.arg;
    return q ? q.done ? (K[Z.resultName] = q.value, K.next = Z.nextLoc, K.method !== "return" && (K.method = "next", K.arg = n), K.delegate = null, S) : q : (K.method = "throw", K.arg = new TypeError("iterator result is not an object"), K.delegate = null, S);
  }
  function j(Z) {
    var K = {
      tryLoc: Z[0]
    };
    1 in Z && (K.catchLoc = Z[1]), 2 in Z && (K.finallyLoc = Z[2], K.afterLoc = Z[3]), this.tryEntries.push(K);
  }
  function G(Z) {
    var K = Z.completion || {};
    K.type = "normal", delete K.arg, Z.completion = K;
  }
  function X(Z) {
    this.tryEntries = [{
      tryLoc: "root"
    }], Z.forEach(j, this), this.reset(!0);
  }
  function ae(Z) {
    if (Z || Z === "") {
      var K = Z[o];
      if (K) return K.call(Z);
      if (typeof Z.next == "function") return Z;
      if (!isNaN(Z.length)) {
        var B = -1, Q = function V() {
          for (; ++B < Z.length; ) if (r.call(Z, B)) return V.value = Z[B], V.done = !1, V;
          return V.value = n, V.done = !0, V;
        };
        return Q.next = Q;
      }
    }
    throw new TypeError(bn(Z) + " is not iterable");
  }
  return w.prototype = C, i(I, "constructor", {
    value: C,
    configurable: !0
  }), i(C, "constructor", {
    value: w,
    configurable: !0
  }), w.displayName = d(C, u, "GeneratorFunction"), e.isGeneratorFunction = function(Z) {
    var K = typeof Z == "function" && Z.constructor;
    return !!K && (K === w || (K.displayName || K.name) === "GeneratorFunction");
  }, e.mark = function(Z) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(Z, C) : (Z.__proto__ = C, d(Z, u, "GeneratorFunction")), Z.prototype = Object.create(I), Z;
  }, e.awrap = function(Z) {
    return {
      __await: Z
    };
  }, U(L.prototype), d(L.prototype, s, function() {
    return this;
  }), e.AsyncIterator = L, e.async = function(Z, K, B, Q, V) {
    V === void 0 && (V = Promise);
    var q = new L(f(Z, K, B, Q), V);
    return e.isGeneratorFunction(K) ? q : q.next().then(function(ne) {
      return ne.done ? ne.value : q.next();
    });
  }, U(I), d(I, u, "Generator"), d(I, o, function() {
    return this;
  }), d(I, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(Z) {
    var K = Object(Z), B = [];
    for (var Q in K) B.push(Q);
    return B.reverse(), function V() {
      for (; B.length; ) {
        var q = B.pop();
        if (q in K) return V.value = q, V.done = !1, V;
      }
      return V.done = !0, V;
    };
  }, e.values = ae, X.prototype = {
    constructor: X,
    reset: function(K) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = n, this.done = !1, this.delegate = null, this.method = "next", this.arg = n, this.tryEntries.forEach(G), !K) for (var B in this) B.charAt(0) === "t" && r.call(this, B) && !isNaN(+B.slice(1)) && (this[B] = n);
    },
    stop: function() {
      this.done = !0;
      var K = this.tryEntries[0].completion;
      if (K.type === "throw") throw K.arg;
      return this.rval;
    },
    dispatchException: function(K) {
      if (this.done) throw K;
      var B = this;
      function Q(oe, he) {
        return ne.type = "throw", ne.arg = K, B.next = oe, he && (B.method = "next", B.arg = n), !!he;
      }
      for (var V = this.tryEntries.length - 1; V >= 0; --V) {
        var q = this.tryEntries[V], ne = q.completion;
        if (q.tryLoc === "root") return Q("end");
        if (q.tryLoc <= this.prev) {
          var ce = r.call(q, "catchLoc"), ie = r.call(q, "finallyLoc");
          if (ce && ie) {
            if (this.prev < q.catchLoc) return Q(q.catchLoc, !0);
            if (this.prev < q.finallyLoc) return Q(q.finallyLoc);
          } else if (ce) {
            if (this.prev < q.catchLoc) return Q(q.catchLoc, !0);
          } else {
            if (!ie) throw Error("try statement without catch or finally");
            if (this.prev < q.finallyLoc) return Q(q.finallyLoc);
          }
        }
      }
    },
    abrupt: function(K, B) {
      for (var Q = this.tryEntries.length - 1; Q >= 0; --Q) {
        var V = this.tryEntries[Q];
        if (V.tryLoc <= this.prev && r.call(V, "finallyLoc") && this.prev < V.finallyLoc) {
          var q = V;
          break;
        }
      }
      q && (K === "break" || K === "continue") && q.tryLoc <= B && B <= q.finallyLoc && (q = null);
      var ne = q ? q.completion : {};
      return ne.type = K, ne.arg = B, q ? (this.method = "next", this.next = q.finallyLoc, S) : this.complete(ne);
    },
    complete: function(K, B) {
      if (K.type === "throw") throw K.arg;
      return K.type === "break" || K.type === "continue" ? this.next = K.arg : K.type === "return" ? (this.rval = this.arg = K.arg, this.method = "return", this.next = "end") : K.type === "normal" && B && (this.next = B), S;
    },
    finish: function(K) {
      for (var B = this.tryEntries.length - 1; B >= 0; --B) {
        var Q = this.tryEntries[B];
        if (Q.finallyLoc === K) return this.complete(Q.completion, Q.afterLoc), G(Q), S;
      }
    },
    catch: function(K) {
      for (var B = this.tryEntries.length - 1; B >= 0; --B) {
        var Q = this.tryEntries[B];
        if (Q.tryLoc === K) {
          var V = Q.completion;
          if (V.type === "throw") {
            var q = V.arg;
            G(Q);
          }
          return q;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(K, B, Q) {
      return this.delegate = {
        iterator: ae(K),
        resultName: B,
        nextLoc: Q
      }, this.method === "next" && (this.arg = n), S;
    }
  }, e;
}
function _2(n, e, t, r, i, a, o) {
  try {
    var s = n[a](o), u = s.value;
  } catch (d) {
    return void t(d);
  }
  s.done ? e(u) : Promise.resolve(u).then(r, i);
}
function Vh(n) {
  return function() {
    var e = this, t = arguments;
    return new Promise(function(r, i) {
      var a = n.apply(e, t);
      function o(u) {
        _2(a, r, i, o, s, "next", u);
      }
      function s(u) {
        _2(a, r, i, o, s, "throw", u);
      }
      o(void 0);
    });
  };
}
var S0 = ke({}, k8), tq = S0.version, nq = S0.render, rq = S0.unmountComponentAtNode, xE;
try {
  var iq = Number((tq || "").split(".")[0]);
  iq >= 18 && (xE = S0.createRoot);
} catch {
}
function x2(n) {
  var e = S0.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  e && bn(e) === "object" && (e.usingClientEntryPoint = n);
}
var px = "__rc_react_root__";
function aq(n, e) {
  x2(!0);
  var t = e[px] || xE(e);
  x2(!1), t.render(n), e[px] = t;
}
function oq(n, e) {
  nq(n, e);
}
function sq(n, e) {
  if (xE) {
    aq(n, e);
    return;
  }
  oq(n, e);
}
function lq(n) {
  return xR.apply(this, arguments);
}
function xR() {
  return xR = Vh(/* @__PURE__ */ go().mark(function n(e) {
    return go().wrap(function(r) {
      for (; ; ) switch (r.prev = r.next) {
        case 0:
          return r.abrupt("return", Promise.resolve().then(function() {
            var i;
            (i = e[px]) === null || i === void 0 || i.unmount(), delete e[px];
          }));
        case 1:
        case "end":
          return r.stop();
      }
    }, n);
  })), xR.apply(this, arguments);
}
function cq(n) {
  rq(n);
}
function uq(n) {
  return ER.apply(this, arguments);
}
function ER() {
  return ER = Vh(/* @__PURE__ */ go().mark(function n(e) {
    return go().wrap(function(r) {
      for (; ; ) switch (r.prev = r.next) {
        case 0:
          if (xE === void 0) {
            r.next = 2;
            break;
          }
          return r.abrupt("return", lq(e));
        case 2:
          cq(e);
        case 3:
        case "end":
          return r.stop();
      }
    }, n);
  })), ER.apply(this, arguments);
}
const G1 = () => ({
  height: 0,
  opacity: 0
}), E2 = (n) => {
  const {
    scrollHeight: e
  } = n;
  return {
    height: e,
    opacity: 1
  };
}, dq = (n) => ({
  height: n ? n.offsetHeight : 0
}), X1 = (n, e) => (e == null ? void 0 : e.deadline) === !0 || e.propertyName === "height", CR = function() {
  return {
    motionName: `${arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant"}-motion-collapse`,
    onAppearStart: G1,
    onEnterStart: G1,
    onAppearActive: E2,
    onEnterActive: E2,
    onLeaveStart: dq,
    onLeaveActive: G1,
    onAppearEnd: X1,
    onEnterEnd: X1,
    onLeaveEnd: X1,
    motionDeadline: 500
  };
}, kA = (n, e, t) => t !== void 0 ? t : `${n}-${e}`, $A = function(n) {
  if (!n)
    return !1;
  if (n instanceof Element) {
    if (n.offsetParent)
      return !0;
    if (n.getBBox) {
      var e = n.getBBox(), t = e.width, r = e.height;
      if (t || r)
        return !0;
    }
    if (n.getBoundingClientRect) {
      var i = n.getBoundingClientRect(), a = i.width, o = i.height;
      if (a || o)
        return !0;
    }
  }
  return !1;
}, fq = (n) => {
  const {
    componentCls: e,
    colorPrimary: t
  } = n;
  return {
    [e]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${t})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${n.motionEaseOutCirc}`, `opacity 2s ${n.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        },
        "&.wave-quick": {
          transition: [`box-shadow ${n.motionDurationSlow} ${n.motionEaseInOut}`, `opacity ${n.motionDurationSlow} ${n.motionEaseInOut}`].join(",")
        }
      }
    }
  };
}, hq = BA("Wave", (n) => [fq(n)]), OB = `${fx}-wave-target`;
function pq(n) {
  const e = (n || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return e && e[1] && e[2] && e[3] ? !(e[1] === e[2] && e[2] === e[3]) : !0;
}
function q1(n) {
  return n && n !== "#fff" && n !== "#ffffff" && n !== "rgb(255, 255, 255)" && n !== "rgba(255, 255, 255, 1)" && pq(n) && !/rgba\((?:\d*, ){3}0\)/.test(n) && // any transparent rgba color
  n !== "transparent";
}
function mq(n) {
  const {
    borderTopColor: e,
    borderColor: t,
    backgroundColor: r
  } = getComputedStyle(n);
  return q1(e) ? e : q1(t) ? t : q1(r) ? r : null;
}
function Y1(n) {
  return Number.isNaN(n) ? 0 : n;
}
const gq = (n) => {
  const {
    className: e,
    target: t,
    component: r
  } = n, i = O.useRef(null), [a, o] = O.useState(null), [s, u] = O.useState([]), [d, f] = O.useState(0), [p, g] = O.useState(0), [v, b] = O.useState(0), [E, S] = O.useState(0), [_, w] = O.useState(!1), C = {
    left: d,
    top: p,
    width: v,
    height: E,
    borderRadius: s.map((D) => `${D}px`).join(" ")
  };
  a && (C["--wave-color"] = a);
  function R() {
    const D = getComputedStyle(t);
    o(mq(t));
    const I = D.position === "static", {
      borderLeftWidth: U,
      borderTopWidth: L
    } = D;
    f(I ? t.offsetLeft : Y1(-parseFloat(U))), g(I ? t.offsetTop : Y1(-parseFloat(L))), b(t.offsetWidth), S(t.offsetHeight);
    const {
      borderTopLeftRadius: N,
      borderTopRightRadius: H,
      borderBottomLeftRadius: j,
      borderBottomRightRadius: G
    } = D;
    u([N, H, G, j].map((X) => Y1(parseFloat(X))));
  }
  if (O.useEffect(() => {
    if (t) {
      const D = Wr(() => {
        R(), w(!0);
      });
      let I;
      return typeof ResizeObserver < "u" && (I = new ResizeObserver(R), I.observe(t)), () => {
        Wr.cancel(D), I == null || I.disconnect();
      };
    }
  }, []), !_)
    return null;
  const P = (r === "Checkbox" || r === "Radio") && (t == null ? void 0 : t.classList.contains(OB));
  return /* @__PURE__ */ O.createElement(Hh, {
    visible: !0,
    motionAppear: !0,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (D, I) => {
      var U;
      if (I.deadline || I.propertyName === "opacity") {
        const L = (U = i.current) === null || U === void 0 ? void 0 : U.parentElement;
        uq(L).then(() => {
          L == null || L.remove();
        });
      }
      return !1;
    }
  }, (D, I) => {
    let {
      className: U
    } = D;
    return /* @__PURE__ */ O.createElement("div", {
      ref: Ol(i, I),
      className: Et(e, U, {
        "wave-quick": P
      }),
      style: C
    });
  });
}, vq = (n, e) => {
  var t;
  const {
    component: r
  } = e;
  if (r === "Checkbox" && !(!((t = n.querySelector("input")) === null || t === void 0) && t.checked))
    return;
  const i = document.createElement("div");
  i.style.position = "absolute", i.style.left = "0px", i.style.top = "0px", n == null || n.insertBefore(i, n == null ? void 0 : n.firstChild), sq(/* @__PURE__ */ O.createElement(gq, Object.assign({}, e, {
    target: n
  })), i);
}, yq = (n, e, t) => {
  const {
    wave: r
  } = O.useContext(mr), [, i, a] = mo(), o = Yi((d) => {
    const f = n.current;
    if (r != null && r.disabled || !f)
      return;
    const p = f.querySelector(`.${OB}`) || f, {
      showEffect: g
    } = r || {};
    (g || vq)(p, {
      className: e,
      token: i,
      component: t,
      event: d,
      hashId: a
    });
  }), s = O.useRef();
  return (d) => {
    Wr.cancel(s.current), s.current = Wr(() => {
      o(d);
    });
  };
}, PB = (n) => {
  const {
    children: e,
    disabled: t,
    component: r
  } = n, {
    getPrefixCls: i
  } = ni(mr), a = kt(null), o = i("wave"), [, s] = hq(o), u = yq(a, Et(o, s), r);
  if (Fe.useEffect(() => {
    const f = a.current;
    if (!f || f.nodeType !== 1 || t)
      return;
    const p = (g) => {
      !$A(g.target) || // No need wave
      !f.getAttribute || f.getAttribute("disabled") || f.disabled || f.className.includes("disabled") || f.className.includes("-leave") || u(g);
    };
    return f.addEventListener("click", p, !0), () => {
      f.removeEventListener("click", p, !0);
    };
  }, [t]), !/* @__PURE__ */ Fe.isValidElement(e))
    return e ?? null;
  const d = pg(e) ? Ol(e.ref, a) : a;
  return fu(e, {
    ref: d
  });
};
Ee.env.NODE_ENV !== "production" && (PB.displayName = "Wave");
const mc = (n) => {
  const e = Fe.useContext(Ah);
  return Fe.useMemo(() => n ? typeof n == "string" ? n ?? e : n instanceof Function ? n(e) : e : e, [n, e]);
}, DB = /* @__PURE__ */ O.createContext(null), _0 = (n, e) => {
  const t = O.useContext(DB), r = O.useMemo(() => {
    if (!t)
      return "";
    const {
      compactDirection: i,
      isFirstItem: a,
      isLastItem: o
    } = t, s = i === "vertical" ? "-vertical-" : "-";
    return Et(`${n}-compact${s}item`, {
      [`${n}-compact${s}first-item`]: a,
      [`${n}-compact${s}last-item`]: o,
      [`${n}-compact${s}item-rtl`]: e === "rtl"
    });
  }, [n, e, t]);
  return {
    compactSize: t == null ? void 0 : t.compactSize,
    compactDirection: t == null ? void 0 : t.compactDirection,
    compactItemClassnames: r
  };
}, bq = (n) => {
  let {
    children: e
  } = n;
  return /* @__PURE__ */ O.createElement(DB.Provider, {
    value: null
  }, e);
};
var Sq = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const IB = /* @__PURE__ */ O.createContext(void 0), _q = (n) => {
  const {
    getPrefixCls: e,
    direction: t
  } = O.useContext(mr), {
    prefixCls: r,
    size: i,
    className: a
  } = n, o = Sq(n, ["prefixCls", "size", "className"]), s = e("btn-group", r), [, , u] = mo();
  let d = "";
  switch (i) {
    case "large":
      d = "lg";
      break;
    case "small":
      d = "sm";
      break;
  }
  if (Ee.env.NODE_ENV !== "production") {
    const p = ci("Button.Group");
    Ee.env.NODE_ENV !== "production" && p(!i || ["large", "small", "middle"].includes(i), "usage", "Invalid prop `size`.");
  }
  const f = Et(s, {
    [`${s}-${d}`]: d,
    [`${s}-rtl`]: t === "rtl"
  }, a, u);
  return /* @__PURE__ */ O.createElement(IB.Provider, {
    value: i
  }, /* @__PURE__ */ O.createElement("div", Object.assign({}, o, {
    className: f
  })));
}, C2 = /^[\u4e00-\u9fa5]{2}$/, wR = C2.test.bind(C2);
function w2(n) {
  return typeof n == "string";
}
function NS(n) {
  return n === "text" || n === "link";
}
function xq(n, e) {
  if (n == null)
    return;
  const t = e ? " " : "";
  return typeof n != "string" && typeof n != "number" && w2(n.type) && wR(n.props.children) ? fu(n, {
    children: n.props.children.split("").join(t)
  }) : w2(n) ? wR(n) ? /* @__PURE__ */ Fe.createElement("span", null, n.split("").join(t)) : /* @__PURE__ */ Fe.createElement("span", null, n) : TB(n) ? /* @__PURE__ */ Fe.createElement("span", null, n) : n;
}
function Eq(n, e) {
  let t = !1;
  const r = [];
  return Fe.Children.forEach(n, (i) => {
    const a = typeof i, o = a === "string" || a === "number";
    if (t && o) {
      const s = r.length - 1, u = r[s];
      r[s] = `${u}${i}`;
    } else
      r.push(i);
    t = o;
  }), Fe.Children.map(r, (i) => xq(i, e));
}
const NB = /* @__PURE__ */ Al((n, e) => {
  const {
    className: t,
    style: r,
    children: i,
    prefixCls: a
  } = n, o = Et(`${a}-icon`, t);
  return /* @__PURE__ */ Fe.createElement("span", {
    ref: e,
    className: o,
    style: r
  }, i);
}), M2 = /* @__PURE__ */ Al((n, e) => {
  const {
    prefixCls: t,
    className: r,
    style: i,
    iconClassName: a
  } = n, o = Et(`${t}-loading-icon`, r);
  return /* @__PURE__ */ Fe.createElement(NB, {
    prefixCls: t,
    className: o,
    style: i,
    ref: e
  }, /* @__PURE__ */ Fe.createElement(_E, {
    className: a
  }));
}), K1 = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
}), Z1 = (n) => ({
  width: n.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
}), Cq = (n) => {
  const {
    prefixCls: e,
    loading: t,
    existIcon: r,
    className: i,
    style: a
  } = n, o = !!t;
  return r ? /* @__PURE__ */ Fe.createElement(M2, {
    prefixCls: e,
    className: i,
    style: a
  }) : /* @__PURE__ */ Fe.createElement(Hh, {
    visible: o,
    // We do not really use this motionName
    motionName: `${e}-loading-icon-motion`,
    motionLeave: o,
    removeOnLeave: !0,
    onAppearStart: K1,
    onAppearActive: Z1,
    onEnterStart: K1,
    onEnterActive: Z1,
    onLeaveStart: Z1,
    onLeaveActive: K1
  }, (s, u) => {
    let {
      className: d,
      style: f
    } = s;
    return /* @__PURE__ */ Fe.createElement(M2, {
      prefixCls: e,
      className: i,
      style: Object.assign(Object.assign({}, a), f),
      ref: u,
      iconClassName: d
    });
  });
}, T2 = (n, e) => ({
  // Border
  [`> span, > ${n}`]: {
    "&:not(:last-child)": {
      [`&, & > ${n}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: e
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${n}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: e
        }
      }
    }
  }
}), wq = (n) => {
  const {
    componentCls: e,
    fontSize: t,
    lineWidth: r,
    groupBorderColor: i,
    colorErrorHover: a
  } = n;
  return {
    [`${e}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${e}`]: {
          "&:not(:last-child)": {
            [`&, & > ${e}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: n.calc(r).mul(-1).equal(),
            [`&, & > ${e}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [e]: {
          position: "relative",
          zIndex: 1,
          "&:hover, &:focus, &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${e}-icon-only`]: {
          fontSize: t
        }
      },
      // Border Color
      T2(`${e}-primary`, i),
      T2(`${e}-danger`, a)
    ]
  };
}, LB = (n) => {
  const {
    paddingInline: e,
    onlyIconSize: t,
    paddingBlock: r
  } = n;
  return li(n, {
    buttonPaddingHorizontal: e,
    buttonPaddingVertical: r,
    buttonIconOnlyFontSize: t
  });
}, FB = (n) => {
  var e, t, r, i, a, o;
  const s = (e = n.contentFontSize) !== null && e !== void 0 ? e : n.fontSize, u = (t = n.contentFontSizeSM) !== null && t !== void 0 ? t : n.fontSize, d = (r = n.contentFontSizeLG) !== null && r !== void 0 ? r : n.fontSizeLG, f = (i = n.contentLineHeight) !== null && i !== void 0 ? i : Z_(s), p = (a = n.contentLineHeightSM) !== null && a !== void 0 ? a : Z_(u), g = (o = n.contentLineHeightLG) !== null && o !== void 0 ? o : Z_(d);
  return {
    fontWeight: 400,
    defaultShadow: `0 ${n.controlOutlineWidth}px 0 ${n.controlTmpOutline}`,
    primaryShadow: `0 ${n.controlOutlineWidth}px 0 ${n.controlOutline}`,
    dangerShadow: `0 ${n.controlOutlineWidth}px 0 ${n.colorErrorOutline}`,
    primaryColor: n.colorTextLightSolid,
    dangerColor: n.colorTextLightSolid,
    borderColorDisabled: n.colorBorder,
    defaultGhostColor: n.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: n.colorBgContainer,
    paddingInline: n.paddingContentHorizontal - n.lineWidth,
    paddingInlineLG: n.paddingContentHorizontal - n.lineWidth,
    paddingInlineSM: 8 - n.lineWidth,
    onlyIconSize: n.fontSizeLG,
    onlyIconSizeSM: n.fontSizeLG - 2,
    onlyIconSizeLG: n.fontSizeLG + 2,
    groupBorderColor: n.colorPrimaryHover,
    linkHoverBg: "transparent",
    textHoverBg: n.colorBgTextHover,
    defaultColor: n.colorText,
    defaultBg: n.colorBgContainer,
    defaultBorderColor: n.colorBorder,
    defaultBorderColorDisabled: n.colorBorder,
    defaultHoverBg: n.colorBgContainer,
    defaultHoverColor: n.colorPrimaryHover,
    defaultHoverBorderColor: n.colorPrimaryHover,
    defaultActiveBg: n.colorBgContainer,
    defaultActiveColor: n.colorPrimaryActive,
    defaultActiveBorderColor: n.colorPrimaryActive,
    contentFontSize: s,
    contentFontSizeSM: u,
    contentFontSizeLG: d,
    contentLineHeight: f,
    contentLineHeightSM: p,
    contentLineHeightLG: g,
    paddingBlock: Math.max((n.controlHeight - s * f) / 2 - n.lineWidth, 0),
    paddingBlockSM: Math.max((n.controlHeightSM - u * p) / 2 - n.lineWidth, 0),
    paddingBlockLG: Math.max((n.controlHeightLG - d * g) / 2 - n.lineWidth, 0)
  };
}, Mq = (n) => {
  const {
    componentCls: e,
    iconCls: t,
    fontWeight: r
  } = n;
  return {
    [e]: {
      outline: "none",
      position: "relative",
      display: "inline-flex",
      gap: n.marginXS,
      alignItems: "center",
      justifyContent: "center",
      fontWeight: r,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      background: "transparent",
      border: `${Mt(n.lineWidth)} ${n.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${n.motionDurationMid} ${n.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      color: n.colorText,
      "&:disabled > *": {
        pointerEvents: "none"
      },
      "> span": {
        display: "inline-block"
      },
      [`${e}-icon`]: {
        lineHeight: 1
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": Object.assign({}, F7(n)),
      [`&${e}-two-chinese-chars::first-letter`]: {
        letterSpacing: "0.34em"
      },
      [`&${e}-two-chinese-chars > *:not(${t})`]: {
        marginInlineEnd: "-0.34em",
        letterSpacing: "0.34em"
      },
      // iconPosition="end"
      "&-icon-end": {
        flexDirection: "row-reverse"
      }
    }
  };
}, hu = (n, e, t) => ({
  [`&:not(:disabled):not(${n}-disabled)`]: {
    "&:hover": e,
    "&:active": t
  }
}), Tq = (n) => ({
  minWidth: n.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), Rq = (n) => ({
  borderRadius: n.controlHeight,
  paddingInlineStart: n.calc(n.controlHeight).div(2).equal(),
  paddingInlineEnd: n.calc(n.controlHeight).div(2).equal()
}), Aq = (n) => ({
  cursor: "not-allowed",
  borderColor: n.borderColorDisabled,
  color: n.colorTextDisabled,
  background: n.colorBgContainerDisabled,
  boxShadow: "none"
}), Xy = (n, e, t, r, i, a, o, s) => ({
  [`&${n}-background-ghost`]: Object.assign(Object.assign({
    color: t || void 0,
    background: e,
    borderColor: r || void 0,
    boxShadow: "none"
  }, hu(n, Object.assign({
    background: e
  }, o), Object.assign({
    background: e
  }, s))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: i || void 0,
      borderColor: a || void 0
    }
  })
}), WA = (n) => ({
  [`&:disabled, &${n.componentCls}-disabled`]: Object.assign({}, Aq(n))
}), UB = (n) => Object.assign({}, WA(n)), mx = (n) => ({
  [`&:disabled, &${n.componentCls}-disabled`]: {
    cursor: "not-allowed",
    color: n.colorTextDisabled
  }
}), zB = (n) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UB(n)), {
  background: n.defaultBg,
  borderColor: n.defaultBorderColor,
  color: n.defaultColor,
  boxShadow: n.defaultShadow
}), hu(n.componentCls, {
  color: n.defaultHoverColor,
  borderColor: n.defaultHoverBorderColor,
  background: n.defaultHoverBg
}, {
  color: n.defaultActiveColor,
  borderColor: n.defaultActiveBorderColor,
  background: n.defaultActiveBg
})), Xy(n.componentCls, n.ghostBg, n.defaultGhostColor, n.defaultGhostBorderColor, n.colorTextDisabled, n.colorBorder)), {
  [`&${n.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    color: n.colorError,
    borderColor: n.colorError
  }, hu(n.componentCls, {
    color: n.colorErrorHover,
    borderColor: n.colorErrorBorderHover
  }, {
    color: n.colorErrorActive,
    borderColor: n.colorErrorActive
  })), Xy(n.componentCls, n.ghostBg, n.colorError, n.colorError, n.colorTextDisabled, n.colorBorder)), WA(n))
}), Oq = (n) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UB(n)), {
  color: n.primaryColor,
  background: n.colorPrimary,
  boxShadow: n.primaryShadow
}), hu(n.componentCls, {
  color: n.colorTextLightSolid,
  background: n.colorPrimaryHover
}, {
  color: n.colorTextLightSolid,
  background: n.colorPrimaryActive
})), Xy(n.componentCls, n.ghostBg, n.colorPrimary, n.colorPrimary, n.colorTextDisabled, n.colorBorder, {
  color: n.colorPrimaryHover,
  borderColor: n.colorPrimaryHover
}, {
  color: n.colorPrimaryActive,
  borderColor: n.colorPrimaryActive
})), {
  [`&${n.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    background: n.colorError,
    boxShadow: n.dangerShadow,
    color: n.dangerColor
  }, hu(n.componentCls, {
    background: n.colorErrorHover
  }, {
    background: n.colorErrorActive
  })), Xy(n.componentCls, n.ghostBg, n.colorError, n.colorError, n.colorTextDisabled, n.colorBorder, {
    color: n.colorErrorHover,
    borderColor: n.colorErrorHover
  }, {
    color: n.colorErrorActive,
    borderColor: n.colorErrorActive
  })), WA(n))
}), Pq = (n) => Object.assign(Object.assign({}, zB(n)), {
  borderStyle: "dashed"
}), Dq = (n) => Object.assign(Object.assign(Object.assign({
  color: n.colorLink
}, hu(n.componentCls, {
  color: n.colorLinkHover,
  background: n.linkHoverBg
}, {
  color: n.colorLinkActive
})), mx(n)), {
  [`&${n.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: n.colorError
  }, hu(n.componentCls, {
    color: n.colorErrorHover
  }, {
    color: n.colorErrorActive
  })), mx(n))
}), Iq = (n) => Object.assign(Object.assign(Object.assign({}, hu(n.componentCls, {
  color: n.colorText,
  background: n.textHoverBg
}, {
  color: n.colorText,
  background: n.colorBgTextActive
})), mx(n)), {
  [`&${n.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: n.colorError
  }, mx(n)), hu(n.componentCls, {
    color: n.colorErrorHover,
    background: n.colorErrorBg
  }, {
    color: n.colorErrorHover,
    background: n.colorErrorBgActive
  }))
}), Nq = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    [`${e}-default`]: zB(n),
    [`${e}-primary`]: Oq(n),
    [`${e}-dashed`]: Pq(n),
    [`${e}-link`]: Dq(n),
    [`${e}-text`]: Iq(n),
    [`${e}-ghost`]: Xy(n.componentCls, n.ghostBg, n.colorBgContainer, n.colorBgContainer, n.colorTextDisabled, n.colorBorder)
  };
}, jA = function(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls: t,
    controlHeight: r,
    fontSize: i,
    lineHeight: a,
    borderRadius: o,
    buttonPaddingHorizontal: s,
    iconCls: u,
    buttonPaddingVertical: d
  } = n, f = `${t}-icon-only`;
  return [
    {
      [`${e}`]: {
        fontSize: i,
        lineHeight: a,
        height: r,
        padding: `${Mt(d)} ${Mt(s)}`,
        borderRadius: o,
        [`&${f}`]: {
          width: r,
          paddingInline: 0,
          // make `btn-icon-only` not too narrow
          [`&${t}-compact-item`]: {
            flex: "none"
          },
          [`&${t}-round`]: {
            width: "auto"
          },
          [u]: {
            fontSize: n.buttonIconOnlyFontSize
          }
        },
        // Loading
        [`&${t}-loading`]: {
          opacity: n.opacityLoading,
          cursor: "default"
        },
        [`${t}-loading-icon`]: {
          transition: `width ${n.motionDurationSlow} ${n.motionEaseInOut}, opacity ${n.motionDurationSlow} ${n.motionEaseInOut}`
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${t}${t}-circle${e}`]: Tq(n)
    },
    {
      [`${t}${t}-round${e}`]: Rq(n)
    }
  ];
}, Lq = (n) => {
  const e = li(n, {
    fontSize: n.contentFontSize,
    lineHeight: n.contentLineHeight
  });
  return jA(e, n.componentCls);
}, Fq = (n) => {
  const e = li(n, {
    controlHeight: n.controlHeightSM,
    fontSize: n.contentFontSizeSM,
    lineHeight: n.contentLineHeightSM,
    padding: n.paddingXS,
    buttonPaddingHorizontal: n.paddingInlineSM,
    buttonPaddingVertical: n.paddingBlockSM,
    borderRadius: n.borderRadiusSM,
    buttonIconOnlyFontSize: n.onlyIconSizeSM
  });
  return jA(e, `${n.componentCls}-sm`);
}, Uq = (n) => {
  const e = li(n, {
    controlHeight: n.controlHeightLG,
    fontSize: n.contentFontSizeLG,
    lineHeight: n.contentLineHeightLG,
    buttonPaddingHorizontal: n.paddingInlineLG,
    buttonPaddingVertical: n.paddingBlockLG,
    borderRadius: n.borderRadiusLG,
    buttonIconOnlyFontSize: n.onlyIconSizeLG
  });
  return jA(e, `${n.componentCls}-lg`);
}, zq = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    [e]: {
      [`&${e}-block`]: {
        width: "100%"
      }
    }
  };
}, Bq = $o("Button", (n) => {
  const e = LB(n);
  return [
    // Shared
    Mq(e),
    // Size
    Lq(e),
    Fq(e),
    Uq(e),
    // Block
    zq(e),
    // Group (type, ghost, danger, loading)
    Nq(e),
    // Button Group
    wq(e)
  ];
}, FB, {
  unitless: {
    fontWeight: !0,
    contentLineHeight: !0,
    contentLineHeightSM: !0,
    contentLineHeightLG: !0
  }
});
function Hq(n, e, t) {
  const {
    focusElCls: r,
    focus: i,
    borderElCls: a
  } = t, o = a ? "> *" : "", s = ["hover", i ? "focus" : null, "active"].filter(Boolean).map((u) => `&:${u} ${o}`).join(",");
  return {
    [`&-item:not(${e}-last-item)`]: {
      marginInlineEnd: n.calc(n.lineWidth).mul(-1).equal()
    },
    "&-item": Object.assign(Object.assign({
      [s]: {
        zIndex: 2
      }
    }, r ? {
      [`&${r}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${o}`]: {
        zIndex: 0
      }
    })
  };
}
function Vq(n, e, t) {
  const {
    borderElCls: r
  } = t, i = r ? `> ${r}` : "";
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item) ${i}`]: {
      borderRadius: 0
    },
    [`&-item:not(${e}-last-item)${e}-first-item`]: {
      [`& ${i}, &${n}-sm ${i}, &${n}-lg ${i}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${e}-first-item)${e}-last-item`]: {
      [`& ${i}, &${n}-sm ${i}, &${n}-lg ${i}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function EE(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: t
  } = n, r = `${t}-compact`;
  return {
    [r]: Object.assign(Object.assign({}, Hq(n, r, e)), Vq(t, r, e))
  };
}
function kq(n, e) {
  return {
    // border collapse
    [`&-item:not(${e}-last-item)`]: {
      marginBottom: n.calc(n.lineWidth).mul(-1).equal()
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function $q(n, e) {
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${e}-first-item:not(${e}-last-item)`]: {
      [`&, &${n}-sm, &${n}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${e}-last-item:not(${e}-first-item)`]: {
      [`&, &${n}-sm, &${n}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function Wq(n) {
  const e = `${n.componentCls}-compact-vertical`;
  return {
    [e]: Object.assign(Object.assign({}, kq(n, e)), $q(n.componentCls, e))
  };
}
const jq = (n) => {
  const {
    componentCls: e,
    calc: t
  } = n;
  return {
    [e]: {
      // Special styles for Primary Button
      [`&-compact-item${e}-primary`]: {
        [`&:not([disabled]) + ${e}-compact-item${e}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: t(n.lineWidth).mul(-1).equal(),
            insetInlineStart: t(n.lineWidth).mul(-1).equal(),
            display: "inline-block",
            width: n.lineWidth,
            height: `calc(100% + ${Mt(n.lineWidth)} * 2)`,
            backgroundColor: n.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${e}-primary`]: {
          [`&:not([disabled]) + ${e}-compact-vertical-item${e}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: t(n.lineWidth).mul(-1).equal(),
              insetInlineStart: t(n.lineWidth).mul(-1).equal(),
              display: "inline-block",
              width: `calc(100% + ${Mt(n.lineWidth)} * 2)`,
              height: n.lineWidth,
              backgroundColor: n.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, Gq = sB(["Button", "compact"], (n) => {
  const e = LB(n);
  return [
    // Space Compact
    EE(e),
    Wq(e),
    jq(e)
  ];
}, FB);
var Xq = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function qq(n) {
  if (typeof n == "object" && n) {
    let e = n == null ? void 0 : n.delay;
    return e = !Number.isNaN(e) && typeof e == "number" ? e : 0, {
      loading: e <= 0,
      delay: e
    };
  }
  return {
    loading: !!n,
    delay: 0
  };
}
const Yq = /* @__PURE__ */ Fe.forwardRef((n, e) => {
  var t, r, i;
  const {
    loading: a = !1,
    prefixCls: o,
    type: s,
    danger: u = !1,
    shape: d = "default",
    size: f,
    styles: p,
    disabled: g,
    className: v,
    rootClassName: b,
    children: E,
    icon: S,
    iconPosition: _ = "start",
    ghost: w = !1,
    block: C = !1,
    // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
    htmlType: R = "button",
    classNames: P,
    style: D = {},
    autoInsertSpace: I
  } = n, U = Xq(n, ["loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "iconPosition", "ghost", "block", "htmlType", "classNames", "style", "autoInsertSpace"]), L = s || "default", {
    getPrefixCls: N,
    direction: H,
    button: j
  } = ni(mr), G = (t = I ?? (j == null ? void 0 : j.autoInsertSpace)) !== null && t !== void 0 ? t : !0, X = N("btn", o), [ae, Z, K] = Bq(X), B = ni(fc), Q = g ?? B, V = ni(IB), q = Mr(() => qq(a), [a]), [ne, ce] = Lr(q.loading), [ie, oe] = Lr(!1), le = Ol(e, /* @__PURE__ */ z8()), ve = U8.count(E) === 1 && !S && !NS(L);
  In(() => {
    let Pe = null;
    q.delay > 0 ? Pe = setTimeout(() => {
      Pe = null, ce(!0);
    }, q.delay) : ce(q.loading);
    function Ve() {
      Pe && (clearTimeout(Pe), Pe = null);
    }
    return Ve;
  }, [q]), In(() => {
    if (!le || !le.current || !G)
      return;
    const Pe = le.current.textContent;
    ve && wR(Pe) ? ie || oe(!0) : ie && oe(!1);
  }, [le]);
  const Ne = (Pe) => {
    const {
      onClick: Ve
    } = n;
    if (ne || Q) {
      Pe.preventDefault();
      return;
    }
    Ve == null || Ve(Pe);
  };
  if (Ee.env.NODE_ENV !== "production") {
    const Pe = ci("Button");
    Ee.env.NODE_ENV !== "production" && Pe(!(typeof S == "string" && S.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${S}\` at https://ant.design/components/icon`), Ee.env.NODE_ENV !== "production" && Pe(!(w && NS(L)), "usage", "`link` or `text` button can't be a `ghost` button.");
  }
  const {
    compactSize: xe,
    compactItemClassnames: Me
  } = _0(X, H), $ = {
    large: "lg",
    small: "sm",
    middle: void 0
  }, Te = mc((Pe) => {
    var Ve, Ze;
    return (Ze = (Ve = f ?? xe) !== null && Ve !== void 0 ? Ve : V) !== null && Ze !== void 0 ? Ze : Pe;
  }), se = Te && $[Te] || "", Ie = ne ? "loading" : S, be = du(U, ["navigate"]), et = Et(X, Z, K, {
    [`${X}-${d}`]: d !== "default" && d,
    [`${X}-${L}`]: L,
    [`${X}-${se}`]: se,
    [`${X}-icon-only`]: !E && E !== 0 && !!Ie,
    [`${X}-background-ghost`]: w && !NS(L),
    [`${X}-loading`]: ne,
    [`${X}-two-chinese-chars`]: ie && G && !ne,
    [`${X}-block`]: C,
    [`${X}-dangerous`]: u,
    [`${X}-rtl`]: H === "rtl",
    [`${X}-icon-end`]: _ === "end"
  }, Me, v, b, j == null ? void 0 : j.className), Xe = Object.assign(Object.assign({}, j == null ? void 0 : j.style), D), $e = Et(P == null ? void 0 : P.icon, (r = j == null ? void 0 : j.classNames) === null || r === void 0 ? void 0 : r.icon), te = Object.assign(Object.assign({}, (p == null ? void 0 : p.icon) || {}), ((i = j == null ? void 0 : j.styles) === null || i === void 0 ? void 0 : i.icon) || {}), Y = S && !ne ? /* @__PURE__ */ Fe.createElement(NB, {
    prefixCls: X,
    className: $e,
    style: te
  }, S) : /* @__PURE__ */ Fe.createElement(Cq, {
    existIcon: !!S,
    prefixCls: X,
    loading: ne
  }), Se = E || E === 0 ? Eq(E, ve && G) : null;
  if (be.href !== void 0)
    return ae(/* @__PURE__ */ Fe.createElement("a", Object.assign({}, be, {
      className: Et(et, {
        [`${X}-disabled`]: Q
      }),
      href: Q ? void 0 : be.href,
      style: Xe,
      onClick: Ne,
      ref: le,
      tabIndex: Q ? -1 : 0
    }), Y, Se));
  let Oe = /* @__PURE__ */ Fe.createElement("button", Object.assign({}, U, {
    type: R,
    className: et,
    style: Xe,
    onClick: Ne,
    disabled: Q,
    ref: le
  }), Y, Se, !!Me && /* @__PURE__ */ Fe.createElement(Gq, {
    key: "compact",
    prefixCls: X
  }));
  return NS(L) || (Oe = /* @__PURE__ */ Fe.createElement(PB, {
    component: "Button",
    disabled: ne
  }, Oe)), ae(Oe);
}), kh = Yq;
kh.Group = _q;
kh.__ANT_BUTTON = !0;
Ee.env.NODE_ENV !== "production" && (kh.displayName = "Button");
var BB = /* @__PURE__ */ O.createContext(null), R2 = [];
function Kq(n, e) {
  var t = O.useState(function() {
    if (!fo())
      return null;
    var b = document.createElement("div");
    return Ee.env.NODE_ENV !== "production" && e && b.setAttribute("data-debug", e), b;
  }), r = ot(t, 1), i = r[0], a = O.useRef(!1), o = O.useContext(BB), s = O.useState(R2), u = ot(s, 2), d = u[0], f = u[1], p = o || (a.current ? void 0 : function(b) {
    f(function(E) {
      var S = [b].concat(jt(E));
      return S;
    });
  });
  function g() {
    i.parentElement || document.body.appendChild(i), a.current = !0;
  }
  function v() {
    var b;
    (b = i.parentElement) === null || b === void 0 || b.removeChild(i), a.current = !1;
  }
  return ti(function() {
    return n ? o ? o(g) : g() : v(), v;
  }, [n]), ti(function() {
    d.length && (d.forEach(function(b) {
      return b();
    }), f(R2));
  }, [d]), [i, p];
}
function Zq(n) {
  var e = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7)), t = document.createElement("div");
  t.id = e;
  var r = t.style;
  r.position = "absolute", r.left = "0", r.top = "0", r.width = "100px", r.height = "100px", r.overflow = "scroll";
  var i, a;
  if (n) {
    var o = getComputedStyle(n);
    r.scrollbarColor = o.scrollbarColor, r.scrollbarWidth = o.scrollbarWidth;
    var s = getComputedStyle(n, "::-webkit-scrollbar"), u = parseInt(s.width, 10), d = parseInt(s.height, 10);
    try {
      var f = u ? "width: ".concat(s.width, ";") : "", p = d ? "height: ".concat(s.height, ";") : "";
      lu(`
#`.concat(e, `::-webkit-scrollbar {
`).concat(f, `
`).concat(p, `
}`), e);
    } catch (b) {
      console.error(b), i = u, a = d;
    }
  }
  document.body.appendChild(t);
  var g = n && i && !isNaN(i) ? i : t.offsetWidth - t.clientWidth, v = n && a && !isNaN(a) ? a : t.offsetHeight - t.clientHeight;
  return document.body.removeChild(t), ky(e), {
    width: g,
    height: v
  };
}
function Qq(n) {
  return typeof document > "u" || !n || !(n instanceof Element) ? {
    width: 0,
    height: 0
  } : Zq(n);
}
function Jq() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var eY = "rc-util-locker-".concat(Date.now()), A2 = 0;
function tY(n) {
  var e = !!n, t = O.useState(function() {
    return A2 += 1, "".concat(eY, "_").concat(A2);
  }), r = ot(t, 1), i = r[0];
  ti(function() {
    if (e) {
      var a = Qq(document.body).width, o = Jq();
      lu(`
html body {
  overflow-y: hidden;
  `.concat(o ? "width: calc(100% - ".concat(a, "px);") : "", `
}`), i);
    } else
      ky(i);
    return function() {
      ky(i);
    };
  }, [e, i]);
}
var nY = !1;
function rY(n) {
  return nY;
}
var O2 = function(e) {
  return e === !1 ? !1 : !fo() || !e ? null : typeof e == "string" ? document.querySelector(e) : typeof e == "function" ? e() : e;
}, GA = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.open, r = n.autoLock, i = n.getContainer, a = n.debug, o = n.autoDestroy, s = o === void 0 ? !0 : o, u = n.children, d = O.useState(t), f = ot(d, 2), p = f[0], g = f[1], v = p || t;
  Ee.env.NODE_ENV !== "production" && Yn(fo() || !t, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR."), O.useEffect(function() {
    (s || t) && g(t);
  }, [t, s]);
  var b = O.useState(function() {
    return O2(i);
  }), E = ot(b, 2), S = E[0], _ = E[1];
  O.useEffect(function() {
    var j = O2(i);
    _(j ?? null);
  });
  var w = Kq(v && !S, a), C = ot(w, 2), R = C[0], P = C[1], D = S ?? R;
  tY(r && t && fo() && (D === R || D === document.body));
  var I = null;
  if (u && pg(u) && e) {
    var U = u;
    I = U.ref;
  }
  var L = dE(I, e);
  if (!v || !fo() || S === void 0)
    return null;
  var N = D === !1 || rY(), H = u;
  return e && (H = /* @__PURE__ */ O.cloneElement(u, {
    ref: L
  })), /* @__PURE__ */ O.createElement(BB.Provider, {
    value: P
  }, N ? H : /* @__PURE__ */ $8(H, D));
});
Ee.env.NODE_ENV !== "production" && (GA.displayName = "Portal");
function iY() {
  var n = ke({}, O);
  return n.useId;
}
var P2 = 0, D2 = iY();
const aY = D2 ? (
  // Use React `useId`
  function(e) {
    var t = D2();
    return e || (Ee.env.NODE_ENV === "test" ? "test-id" : t);
  }
) : (
  // Use compatible of `useId`
  function(e) {
    var t = O.useState("ssr-id"), r = ot(t, 2), i = r[0], a = r[1];
    return O.useEffect(function() {
      var o = P2;
      P2 += 1, a("rc_unique_".concat(o));
    }, []), e || (Ee.env.NODE_ENV === "test" ? "test-id" : i);
  }
);
var lh = "RC_FORM_INTERNAL_HOOKS", $r = function() {
  Yn(!1, "Can not find FormContext. Please make sure you wrap Field under Form.");
}, Oh = /* @__PURE__ */ O.createContext({
  getFieldValue: $r,
  getFieldsValue: $r,
  getFieldError: $r,
  getFieldWarning: $r,
  getFieldsError: $r,
  isFieldsTouched: $r,
  isFieldTouched: $r,
  isFieldValidating: $r,
  isFieldsValidating: $r,
  resetFields: $r,
  setFields: $r,
  setFieldValue: $r,
  setFieldsValue: $r,
  validateFields: $r,
  submit: $r,
  getInternalHooks: function() {
    return $r(), {
      dispatch: $r,
      initEntityValue: $r,
      registerField: $r,
      useSubscribe: $r,
      setInitialValues: $r,
      destroyForm: $r,
      setCallbacks: $r,
      registerWatch: $r,
      getFields: $r,
      setValidateMessages: $r,
      setPreserve: $r,
      getInitialValue: $r
    };
  }
}), qy = /* @__PURE__ */ O.createContext(null);
function MR(n) {
  return n == null ? [] : Array.isArray(n) ? n : [n];
}
function oY(n) {
  return n && !!n._init;
}
function TR() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var e = JSON.parse(JSON.stringify(this));
      return e.clone = this.clone, e;
    }
  };
}
var RR = TR();
function sY(n) {
  try {
    return Function.toString.call(n).indexOf("[native code]") !== -1;
  } catch {
    return typeof n == "function";
  }
}
function lY(n, e, t) {
  if (AA()) return Reflect.construct.apply(null, arguments);
  var r = [null];
  r.push.apply(r, e);
  var i = new (n.bind.apply(n, r))();
  return t && By(i, t.prototype), i;
}
function AR(n) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return AR = function(r) {
    if (r === null || !sY(r)) return r;
    if (typeof r != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(r)) return e.get(r);
      e.set(r, i);
    }
    function i() {
      return lY(r, arguments, Hy(this).constructor);
    }
    return i.prototype = Object.create(r.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), By(i, r);
  }, AR(n);
}
var cY = /%[sdj%]/g, HB = function() {
};
typeof Ee < "u" && Ee.env && Ee.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (HB = function(e, t) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && t.every(function(r) {
    return typeof r == "string";
  }) && console.warn(e, t);
});
function OR(n) {
  if (!n || !n.length) return null;
  var e = {};
  return n.forEach(function(t) {
    var r = t.field;
    e[r] = e[r] || [], e[r].push(t);
  }), e;
}
function fs(n) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    t[r - 1] = arguments[r];
  var i = 0, a = t.length;
  if (typeof n == "function")
    return n.apply(null, t);
  if (typeof n == "string") {
    var o = n.replace(cY, function(s) {
      if (s === "%%")
        return "%";
      if (i >= a)
        return s;
      switch (s) {
        case "%s":
          return String(t[i++]);
        case "%d":
          return Number(t[i++]);
        case "%j":
          try {
            return JSON.stringify(t[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return o;
  }
  return n;
}
function uY(n) {
  return n === "string" || n === "url" || n === "hex" || n === "email" || n === "date" || n === "pattern";
}
function ca(n, e) {
  return !!(n == null || e === "array" && Array.isArray(n) && !n.length || uY(e) && typeof n == "string" && !n);
}
function dY(n, e, t) {
  var r = [], i = 0, a = n.length;
  function o(s) {
    r.push.apply(r, jt(s || [])), i++, i === a && t(r);
  }
  n.forEach(function(s) {
    e(s, o);
  });
}
function I2(n, e, t) {
  var r = 0, i = n.length;
  function a(o) {
    if (o && o.length) {
      t(o);
      return;
    }
    var s = r;
    r = r + 1, s < i ? e(n[s], a) : t([]);
  }
  a([]);
}
function fY(n) {
  var e = [];
  return Object.keys(n).forEach(function(t) {
    e.push.apply(e, jt(n[t] || []));
  }), e;
}
var N2 = /* @__PURE__ */ function(n) {
  Wd(t, n);
  var e = jd(t);
  function t(r, i) {
    var a;
    return ki(this, t), a = e.call(this, "Async Validation Error"), Re(tr(a), "errors", void 0), Re(tr(a), "fields", void 0), a.errors = r, a.fields = i, a;
  }
  return $i(t);
}(/* @__PURE__ */ AR(Error));
function hY(n, e, t, r, i) {
  if (e.first) {
    var a = new Promise(function(g, v) {
      var b = function(_) {
        return r(_), _.length ? v(new N2(_, OR(_))) : g(i);
      }, E = fY(n);
      I2(E, t, b);
    });
    return a.catch(function(g) {
      return g;
    }), a;
  }
  var o = e.firstFields === !0 ? Object.keys(n) : e.firstFields || [], s = Object.keys(n), u = s.length, d = 0, f = [], p = new Promise(function(g, v) {
    var b = function(S) {
      if (f.push.apply(f, S), d++, d === u)
        return r(f), f.length ? v(new N2(f, OR(f))) : g(i);
    };
    s.length || (r(f), g(i)), s.forEach(function(E) {
      var S = n[E];
      o.indexOf(E) !== -1 ? I2(S, t, b) : dY(S, t, b);
    });
  });
  return p.catch(function(g) {
    return g;
  }), p;
}
function pY(n) {
  return !!(n && n.message !== void 0);
}
function mY(n, e) {
  for (var t = n, r = 0; r < e.length; r++) {
    if (t == null)
      return t;
    t = t[e[r]];
  }
  return t;
}
function L2(n, e) {
  return function(t) {
    var r;
    return n.fullFields ? r = mY(e, n.fullFields) : r = e[t.field || n.fullField], pY(t) ? (t.field = t.field || n.fullField, t.fieldValue = r, t) : {
      message: typeof t == "function" ? t() : t,
      fieldValue: r,
      field: t.field || n.fullField
    };
  };
}
function F2(n, e) {
  if (e) {
    for (var t in e)
      if (e.hasOwnProperty(t)) {
        var r = e[t];
        bn(r) === "object" && bn(n[t]) === "object" ? n[t] = ke(ke({}, n[t]), r) : n[t] = r;
      }
  }
  return n;
}
var em = "enum", gY = function(e, t, r, i, a) {
  e[em] = Array.isArray(e[em]) ? e[em] : [], e[em].indexOf(t) === -1 && i.push(fs(a.messages[em], e.fullField, e[em].join(", ")));
}, vY = function(e, t, r, i, a) {
  if (e.pattern) {
    if (e.pattern instanceof RegExp)
      e.pattern.lastIndex = 0, e.pattern.test(t) || i.push(fs(a.messages.pattern.mismatch, e.fullField, t, e.pattern));
    else if (typeof e.pattern == "string") {
      var o = new RegExp(e.pattern);
      o.test(t) || i.push(fs(a.messages.pattern.mismatch, e.fullField, t, e.pattern));
    }
  }
}, yY = function(e, t, r, i, a) {
  var o = typeof e.len == "number", s = typeof e.min == "number", u = typeof e.max == "number", d = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, f = t, p = null, g = typeof t == "number", v = typeof t == "string", b = Array.isArray(t);
  if (g ? p = "number" : v ? p = "string" : b && (p = "array"), !p)
    return !1;
  b && (f = t.length), v && (f = t.replace(d, "_").length), o ? f !== e.len && i.push(fs(a.messages[p].len, e.fullField, e.len)) : s && !u && f < e.min ? i.push(fs(a.messages[p].min, e.fullField, e.min)) : u && !s && f > e.max ? i.push(fs(a.messages[p].max, e.fullField, e.max)) : s && u && (f < e.min || f > e.max) && i.push(fs(a.messages[p].range, e.fullField, e.min, e.max));
}, VB = function(e, t, r, i, a, o) {
  e.required && (!r.hasOwnProperty(e.field) || ca(t, o || e.type)) && i.push(fs(a.messages.required, e.fullField));
}, LS;
const bY = function() {
  if (LS)
    return LS;
  var n = "[a-fA-F\\d:]", e = function(D) {
    return D && D.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(n, ")|(?<=").concat(n, ")(?=\\s|$))") : "";
  }, t = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", r = "[a-fA-F\\d]{1,4}", i = [
    "(?:".concat(r, ":){7}(?:").concat(r, "|:)"),
    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
    "(?:".concat(r, ":){6}(?:").concat(t, "|:").concat(r, "|:)"),
    // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
    "(?:".concat(r, ":){5}(?::").concat(t, "|(?::").concat(r, "){1,2}|:)"),
    // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
    "(?:".concat(r, ":){4}(?:(?::").concat(r, "){0,1}:").concat(t, "|(?::").concat(r, "){1,3}|:)"),
    // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
    "(?:".concat(r, ":){3}(?:(?::").concat(r, "){0,2}:").concat(t, "|(?::").concat(r, "){1,4}|:)"),
    // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
    "(?:".concat(r, ":){2}(?:(?::").concat(r, "){0,3}:").concat(t, "|(?::").concat(r, "){1,5}|:)"),
    // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
    "(?:".concat(r, ":){1}(?:(?::").concat(r, "){0,4}:").concat(t, "|(?::").concat(r, "){1,6}|:)"),
    // 1::              1::3:4:5:6:7:8   1::8            1::
    "(?::(?:(?::".concat(r, "){0,5}:").concat(t, "|(?::").concat(r, "){1,7}|:))")
    // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
  ], a = "(?:%[0-9a-zA-Z]{1,})?", o = "(?:".concat(i.join("|"), ")").concat(a), s = new RegExp("(?:^".concat(t, "$)|(?:^").concat(o, "$)")), u = new RegExp("^".concat(t, "$")), d = new RegExp("^".concat(o, "$")), f = function(D) {
    return D && D.exact ? s : new RegExp("(?:".concat(e(D)).concat(t).concat(e(D), ")|(?:").concat(e(D)).concat(o).concat(e(D), ")"), "g");
  };
  f.v4 = function(P) {
    return P && P.exact ? u : new RegExp("".concat(e(P)).concat(t).concat(e(P)), "g");
  }, f.v6 = function(P) {
    return P && P.exact ? d : new RegExp("".concat(e(P)).concat(o).concat(e(P)), "g");
  };
  var p = "(?:(?:[a-z]+:)?//)", g = "(?:\\S+(?::\\S*)?@)?", v = f.v4().source, b = f.v6().source, E = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", S = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", _ = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", w = "(?::\\d{2,5})?", C = '(?:[/?#][^\\s"]*)?', R = "(?:".concat(p, "|www\\.)").concat(g, "(?:localhost|").concat(v, "|").concat(b, "|").concat(E).concat(S).concat(_, ")").concat(w).concat(C);
  return LS = new RegExp("(?:^".concat(R, "$)"), "i"), LS;
};
var U2 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, my = {
  integer: function(e) {
    return my.number(e) && parseInt(e, 10) === e;
  },
  float: function(e) {
    return my.number(e) && !my.integer(e);
  },
  array: function(e) {
    return Array.isArray(e);
  },
  regexp: function(e) {
    if (e instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(e);
    } catch {
      return !1;
    }
  },
  date: function(e) {
    return typeof e.getTime == "function" && typeof e.getMonth == "function" && typeof e.getYear == "function" && !isNaN(e.getTime());
  },
  number: function(e) {
    return isNaN(e) ? !1 : typeof e == "number";
  },
  object: function(e) {
    return bn(e) === "object" && !my.array(e);
  },
  method: function(e) {
    return typeof e == "function";
  },
  email: function(e) {
    return typeof e == "string" && e.length <= 320 && !!e.match(U2.email);
  },
  url: function(e) {
    return typeof e == "string" && e.length <= 2048 && !!e.match(bY());
  },
  hex: function(e) {
    return typeof e == "string" && !!e.match(U2.hex);
  }
}, SY = function(e, t, r, i, a) {
  if (e.required && t === void 0) {
    VB(e, t, r, i, a);
    return;
  }
  var o = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = e.type;
  o.indexOf(s) > -1 ? my[s](t) || i.push(fs(a.messages.types[s], e.fullField, e.type)) : s && bn(t) !== e.type && i.push(fs(a.messages.types[s], e.fullField, e.type));
}, _Y = function(e, t, r, i, a) {
  (/^\s+$/.test(t) || t === "") && i.push(fs(a.messages.whitespace, e.fullField));
};
const sr = {
  required: VB,
  whitespace: _Y,
  type: SY,
  range: yY,
  enum: gY,
  pattern: vY
};
var xY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a);
  }
  r(o);
}, EY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (t == null && !e.required)
      return r();
    sr.required(e, t, i, o, a, "array"), t != null && (sr.type(e, t, i, o, a), sr.range(e, t, i, o, a));
  }
  r(o);
}, CY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a), t !== void 0 && sr.type(e, t, i, o, a);
  }
  r(o);
}, wY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t, "date") && !e.required)
      return r();
    if (sr.required(e, t, i, o, a), !ca(t, "date")) {
      var u;
      t instanceof Date ? u = t : u = new Date(t), sr.type(e, u, i, o, a), u && sr.range(e, u.getTime(), i, o, a);
    }
  }
  r(o);
}, MY = "enum", TY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a), t !== void 0 && sr[MY](e, t, i, o, a);
  }
  r(o);
}, RY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a), t !== void 0 && (sr.type(e, t, i, o, a), sr.range(e, t, i, o, a));
  }
  r(o);
}, AY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a), t !== void 0 && (sr.type(e, t, i, o, a), sr.range(e, t, i, o, a));
  }
  r(o);
}, OY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a), t !== void 0 && sr.type(e, t, i, o, a);
  }
  r(o);
}, PY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (t === "" && (t = void 0), ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a), t !== void 0 && (sr.type(e, t, i, o, a), sr.range(e, t, i, o, a));
  }
  r(o);
}, DY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a), t !== void 0 && sr.type(e, t, i, o, a);
  }
  r(o);
}, IY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t, "string") && !e.required)
      return r();
    sr.required(e, t, i, o, a), ca(t, "string") || sr.pattern(e, t, i, o, a);
  }
  r(o);
}, NY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t) && !e.required)
      return r();
    sr.required(e, t, i, o, a), ca(t) || sr.type(e, t, i, o, a);
  }
  r(o);
}, LY = function(e, t, r, i, a) {
  var o = [], s = Array.isArray(t) ? "array" : bn(t);
  sr.required(e, t, i, o, a, s), r(o);
}, FY = function(e, t, r, i, a) {
  var o = [], s = e.required || !e.required && i.hasOwnProperty(e.field);
  if (s) {
    if (ca(t, "string") && !e.required)
      return r();
    sr.required(e, t, i, o, a, "string"), ca(t, "string") || (sr.type(e, t, i, o, a), sr.range(e, t, i, o, a), sr.pattern(e, t, i, o, a), e.whitespace === !0 && sr.whitespace(e, t, i, o, a));
  }
  r(o);
}, Q1 = function(e, t, r, i, a) {
  var o = e.type, s = [], u = e.required || !e.required && i.hasOwnProperty(e.field);
  if (u) {
    if (ca(t, o) && !e.required)
      return r();
    sr.required(e, t, i, s, a, o), ca(t, o) || sr.type(e, t, i, s, a);
  }
  r(s);
};
const Cy = {
  string: FY,
  method: OY,
  number: PY,
  boolean: CY,
  regexp: NY,
  integer: AY,
  float: RY,
  array: EY,
  object: DY,
  enum: TY,
  pattern: IY,
  date: wY,
  url: Q1,
  hex: Q1,
  email: Q1,
  required: LY,
  any: xY
};
var x0 = /* @__PURE__ */ function() {
  function n(e) {
    ki(this, n), Re(this, "rules", null), Re(this, "_messages", RR), this.define(e);
  }
  return $i(n, [{
    key: "define",
    value: function(t) {
      var r = this;
      if (!t)
        throw new Error("Cannot configure a schema with no rules");
      if (bn(t) !== "object" || Array.isArray(t))
        throw new Error("Rules must be an object");
      this.rules = {}, Object.keys(t).forEach(function(i) {
        var a = t[i];
        r.rules[i] = Array.isArray(a) ? a : [a];
      });
    }
  }, {
    key: "messages",
    value: function(t) {
      return t && (this._messages = F2(TR(), t)), this._messages;
    }
  }, {
    key: "validate",
    value: function(t) {
      var r = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      }, o = t, s = i, u = a;
      if (typeof s == "function" && (u = s, s = {}), !this.rules || Object.keys(this.rules).length === 0)
        return u && u(null, o), Promise.resolve(o);
      function d(b) {
        var E = [], S = {};
        function _(C) {
          if (Array.isArray(C)) {
            var R;
            E = (R = E).concat.apply(R, jt(C));
          } else
            E.push(C);
        }
        for (var w = 0; w < b.length; w++)
          _(b[w]);
        E.length ? (S = OR(E), u(E, S)) : u(null, o);
      }
      if (s.messages) {
        var f = this.messages();
        f === RR && (f = TR()), F2(f, s.messages), s.messages = f;
      } else
        s.messages = this.messages();
      var p = {}, g = s.keys || Object.keys(this.rules);
      g.forEach(function(b) {
        var E = r.rules[b], S = o[b];
        E.forEach(function(_) {
          var w = _;
          typeof w.transform == "function" && (o === t && (o = ke({}, o)), S = o[b] = w.transform(S), S != null && (w.type = w.type || (Array.isArray(S) ? "array" : bn(S)))), typeof w == "function" ? w = {
            validator: w
          } : w = ke({}, w), w.validator = r.getValidationMethod(w), w.validator && (w.field = b, w.fullField = w.fullField || b, w.type = r.getType(w), p[b] = p[b] || [], p[b].push({
            rule: w,
            value: S,
            source: o,
            field: b
          }));
        });
      });
      var v = {};
      return hY(p, s, function(b, E) {
        var S = b.rule, _ = (S.type === "object" || S.type === "array") && (bn(S.fields) === "object" || bn(S.defaultField) === "object");
        _ = _ && (S.required || !S.required && b.value), S.field = b.field;
        function w(I, U) {
          return ke(ke({}, U), {}, {
            fullField: "".concat(S.fullField, ".").concat(I),
            fullFields: S.fullFields ? [].concat(jt(S.fullFields), [I]) : [I]
          });
        }
        function C() {
          var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], U = Array.isArray(I) ? I : [I];
          !s.suppressWarning && U.length && n.warning("async-validator:", U), U.length && S.message !== void 0 && (U = [].concat(S.message));
          var L = U.map(L2(S, o));
          if (s.first && L.length)
            return v[S.field] = 1, E(L);
          if (!_)
            E(L);
          else {
            if (S.required && !b.value)
              return S.message !== void 0 ? L = [].concat(S.message).map(L2(S, o)) : s.error && (L = [s.error(S, fs(s.messages.required, S.field))]), E(L);
            var N = {};
            S.defaultField && Object.keys(b.value).map(function(G) {
              N[G] = S.defaultField;
            }), N = ke(ke({}, N), b.rule.fields);
            var H = {};
            Object.keys(N).forEach(function(G) {
              var X = N[G], ae = Array.isArray(X) ? X : [X];
              H[G] = ae.map(w.bind(null, G));
            });
            var j = new n(H);
            j.messages(s.messages), b.rule.options && (b.rule.options.messages = s.messages, b.rule.options.error = s.error), j.validate(b.value, b.rule.options || s, function(G) {
              var X = [];
              L && L.length && X.push.apply(X, jt(L)), G && G.length && X.push.apply(X, jt(G)), E(X.length ? X : null);
            });
          }
        }
        var R;
        if (S.asyncValidator)
          R = S.asyncValidator(S, b.value, C, b.source, s);
        else if (S.validator) {
          try {
            R = S.validator(S, b.value, C, b.source, s);
          } catch (I) {
            var P, D;
            (P = (D = console).error) === null || P === void 0 || P.call(D, I), s.suppressValidatorError || setTimeout(function() {
              throw I;
            }, 0), C(I.message);
          }
          R === !0 ? C() : R === !1 ? C(typeof S.message == "function" ? S.message(S.fullField || S.field) : S.message || "".concat(S.fullField || S.field, " fails")) : R instanceof Array ? C(R) : R instanceof Error && C(R.message);
        }
        R && R.then && R.then(function() {
          return C();
        }, function(I) {
          return C(I);
        });
      }, function(b) {
        d(b);
      }, o);
    }
  }, {
    key: "getType",
    value: function(t) {
      if (t.type === void 0 && t.pattern instanceof RegExp && (t.type = "pattern"), typeof t.validator != "function" && t.type && !Cy.hasOwnProperty(t.type))
        throw new Error(fs("Unknown rule type %s", t.type));
      return t.type || "string";
    }
  }, {
    key: "getValidationMethod",
    value: function(t) {
      if (typeof t.validator == "function")
        return t.validator;
      var r = Object.keys(t), i = r.indexOf("message");
      return i !== -1 && r.splice(i, 1), r.length === 1 && r[0] === "required" ? Cy.required : Cy[this.getType(t)] || void 0;
    }
  }]), n;
}();
Re(x0, "register", function(e, t) {
  if (typeof t != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Cy[e] = t;
});
Re(x0, "warning", HB);
Re(x0, "messages", RR);
Re(x0, "validators", Cy);
var os = "'${name}' is not a valid ${type}", kB = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: os,
    method: os,
    array: os,
    object: os,
    number: os,
    date: os,
    boolean: os,
    integer: os,
    float: os,
    regexp: os,
    email: os,
    url: os,
    hex: os
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
}, z2 = x0;
function UY(n, e) {
  return n.replace(/\$\{\w+\}/g, function(t) {
    var r = t.slice(2, -1);
    return e[r];
  });
}
var B2 = "CODE_LOGIC_ERROR";
function PR(n, e, t, r, i) {
  return DR.apply(this, arguments);
}
function DR() {
  return DR = Vh(/* @__PURE__ */ go().mark(function n(e, t, r, i, a) {
    var o, s, u, d, f, p, g, v, b;
    return go().wrap(function(S) {
      for (; ; ) switch (S.prev = S.next) {
        case 0:
          return o = ke({}, r), delete o.ruleIndex, z2.warning = function() {
          }, o.validator && (s = o.validator, o.validator = function() {
            try {
              return s.apply(void 0, arguments);
            } catch (_) {
              return console.error(_), Promise.reject(B2);
            }
          }), u = null, o && o.type === "array" && o.defaultField && (u = o.defaultField, delete o.defaultField), d = new z2(Re({}, e, [o])), f = Bm(kB, i.validateMessages), d.messages(f), p = [], S.prev = 10, S.next = 13, Promise.resolve(d.validate(Re({}, e, t), ke({}, i)));
        case 13:
          S.next = 18;
          break;
        case 15:
          S.prev = 15, S.t0 = S.catch(10), S.t0.errors && (p = S.t0.errors.map(function(_, w) {
            var C = _.message, R = C === B2 ? f.default : C;
            return /* @__PURE__ */ O.isValidElement(R) ? (
              // Wrap ReactNode with `key`
              /* @__PURE__ */ O.cloneElement(R, {
                key: "error_".concat(w)
              })
            ) : R;
          }));
        case 18:
          if (!(!p.length && u)) {
            S.next = 23;
            break;
          }
          return S.next = 21, Promise.all(t.map(function(_, w) {
            return PR("".concat(e, ".").concat(w), _, u, i, a);
          }));
        case 21:
          return g = S.sent, S.abrupt("return", g.reduce(function(_, w) {
            return [].concat(jt(_), jt(w));
          }, []));
        case 23:
          return v = ke(ke({}, r), {}, {
            name: e,
            enum: (r.enum || []).join(", ")
          }, a), b = p.map(function(_) {
            return typeof _ == "string" ? UY(_, v) : _;
          }), S.abrupt("return", b);
        case 26:
        case "end":
          return S.stop();
      }
    }, n, null, [[10, 15]]);
  })), DR.apply(this, arguments);
}
function zY(n, e, t, r, i, a) {
  var o = n.join("."), s = t.map(function(f, p) {
    var g = f.validator, v = ke(ke({}, f), {}, {
      ruleIndex: p
    });
    return g && (v.validator = function(b, E, S) {
      var _ = !1, w = function() {
        for (var P = arguments.length, D = new Array(P), I = 0; I < P; I++)
          D[I] = arguments[I];
        Promise.resolve().then(function() {
          Yn(!_, "Your validator function has already return a promise. `callback` will be ignored."), _ || S.apply(void 0, D);
        });
      }, C = g(b, E, w);
      _ = C && typeof C.then == "function" && typeof C.catch == "function", Yn(_, "`callback` is deprecated. Please return a promise instead."), _ && C.then(function() {
        S();
      }).catch(function(R) {
        S(R || " ");
      });
    }), v;
  }).sort(function(f, p) {
    var g = f.warningOnly, v = f.ruleIndex, b = p.warningOnly, E = p.ruleIndex;
    return !!g == !!b ? v - E : g ? 1 : -1;
  }), u;
  if (i === !0)
    u = new Promise(/* @__PURE__ */ function() {
      var f = Vh(/* @__PURE__ */ go().mark(function p(g, v) {
        var b, E, S;
        return go().wrap(function(w) {
          for (; ; ) switch (w.prev = w.next) {
            case 0:
              b = 0;
            case 1:
              if (!(b < s.length)) {
                w.next = 12;
                break;
              }
              return E = s[b], w.next = 5, PR(o, e, E, r, a);
            case 5:
              if (S = w.sent, !S.length) {
                w.next = 9;
                break;
              }
              return v([{
                errors: S,
                rule: E
              }]), w.abrupt("return");
            case 9:
              b += 1, w.next = 1;
              break;
            case 12:
              g([]);
            case 13:
            case "end":
              return w.stop();
          }
        }, p);
      }));
      return function(p, g) {
        return f.apply(this, arguments);
      };
    }());
  else {
    var d = s.map(function(f) {
      return PR(o, e, f, r, a).then(function(p) {
        return {
          errors: p,
          rule: f
        };
      });
    });
    u = (i ? HY(d) : BY(d)).then(function(f) {
      return Promise.reject(f);
    });
  }
  return u.catch(function(f) {
    return f;
  }), u;
}
function BY(n) {
  return IR.apply(this, arguments);
}
function IR() {
  return IR = Vh(/* @__PURE__ */ go().mark(function n(e) {
    return go().wrap(function(r) {
      for (; ; ) switch (r.prev = r.next) {
        case 0:
          return r.abrupt("return", Promise.all(e).then(function(i) {
            var a, o = (a = []).concat.apply(a, jt(i));
            return o;
          }));
        case 1:
        case "end":
          return r.stop();
      }
    }, n);
  })), IR.apply(this, arguments);
}
function HY(n) {
  return NR.apply(this, arguments);
}
function NR() {
  return NR = Vh(/* @__PURE__ */ go().mark(function n(e) {
    var t;
    return go().wrap(function(i) {
      for (; ; ) switch (i.prev = i.next) {
        case 0:
          return t = 0, i.abrupt("return", new Promise(function(a) {
            e.forEach(function(o) {
              o.then(function(s) {
                s.errors.length && a([s]), t += 1, t === e.length && a([]);
              });
            });
          }));
        case 2:
        case "end":
          return i.stop();
      }
    }, n);
  })), NR.apply(this, arguments);
}
function Hi(n) {
  return MR(n);
}
function H2(n, e) {
  var t = {};
  return e.forEach(function(r) {
    var i = ac(n, r);
    t = Sl(t, r, i);
  }), t;
}
function Ym(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return n && n.some(function(r) {
    return $B(e, r, t);
  });
}
function $B(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !n || !e || !t && n.length !== e.length ? !1 : e.every(function(r, i) {
    return n[i] === r;
  });
}
function VY(n, e) {
  if (n === e)
    return !0;
  if (!n && e || n && !e || !n || !e || bn(n) !== "object" || bn(e) !== "object")
    return !1;
  var t = Object.keys(n), r = Object.keys(e), i = new Set([].concat(t, r));
  return jt(i).every(function(a) {
    var o = n[a], s = e[a];
    return typeof o == "function" && typeof s == "function" ? !0 : o === s;
  });
}
function kY(n) {
  var e = arguments.length <= 1 ? void 0 : arguments[1];
  return e && e.target && bn(e.target) === "object" && n in e.target ? e.target[n] : e;
}
function V2(n, e, t) {
  var r = n.length;
  if (e < 0 || e >= r || t < 0 || t >= r)
    return n;
  var i = n[e], a = e - t;
  return a > 0 ? [].concat(jt(n.slice(0, t)), [i], jt(n.slice(t, e)), jt(n.slice(e + 1, r))) : a < 0 ? [].concat(jt(n.slice(0, e)), jt(n.slice(e + 1, t + 1)), [i], jt(n.slice(t + 1, r))) : n;
}
var $Y = ["name"], Bs = [];
function k2(n, e, t, r, i, a) {
  return typeof n == "function" ? n(e, t, "source" in a ? {
    source: a.source
  } : {}) : r !== i;
}
var XA = /* @__PURE__ */ function(n) {
  Wd(t, n);
  var e = jd(t);
  function t(r) {
    var i;
    if (ki(this, t), i = e.call(this, r), Re(tr(i), "state", {
      resetCount: 0
    }), Re(tr(i), "cancelRegisterFunc", null), Re(tr(i), "mounted", !1), Re(tr(i), "touched", !1), Re(tr(i), "dirty", !1), Re(tr(i), "validatePromise", void 0), Re(tr(i), "prevValidating", void 0), Re(tr(i), "errors", Bs), Re(tr(i), "warnings", Bs), Re(tr(i), "cancelRegister", function() {
      var u = i.props, d = u.preserve, f = u.isListField, p = u.name;
      i.cancelRegisterFunc && i.cancelRegisterFunc(f, d, Hi(p)), i.cancelRegisterFunc = null;
    }), Re(tr(i), "getNamePath", function() {
      var u = i.props, d = u.name, f = u.fieldContext, p = f.prefixName, g = p === void 0 ? [] : p;
      return d !== void 0 ? [].concat(jt(g), jt(d)) : [];
    }), Re(tr(i), "getRules", function() {
      var u = i.props, d = u.rules, f = d === void 0 ? [] : d, p = u.fieldContext;
      return f.map(function(g) {
        return typeof g == "function" ? g(p) : g;
      });
    }), Re(tr(i), "refresh", function() {
      i.mounted && i.setState(function(u) {
        var d = u.resetCount;
        return {
          resetCount: d + 1
        };
      });
    }), Re(tr(i), "metaCache", null), Re(tr(i), "triggerMetaEvent", function(u) {
      var d = i.props.onMetaChange;
      if (d) {
        var f = ke(ke({}, i.getMeta()), {}, {
          destroy: u
        });
        $T(i.metaCache, f) || d(f), i.metaCache = f;
      } else
        i.metaCache = null;
    }), Re(tr(i), "onStoreChange", function(u, d, f) {
      var p = i.props, g = p.shouldUpdate, v = p.dependencies, b = v === void 0 ? [] : v, E = p.onReset, S = f.store, _ = i.getNamePath(), w = i.getValue(u), C = i.getValue(S), R = d && Ym(d, _);
      switch (f.type === "valueUpdate" && f.source === "external" && !$T(w, C) && (i.touched = !0, i.dirty = !0, i.validatePromise = null, i.errors = Bs, i.warnings = Bs, i.triggerMetaEvent()), f.type) {
        case "reset":
          if (!d || R) {
            i.touched = !1, i.dirty = !1, i.validatePromise = void 0, i.errors = Bs, i.warnings = Bs, i.triggerMetaEvent(), E == null || E(), i.refresh();
            return;
          }
          break;
        case "remove": {
          if (g) {
            i.reRender();
            return;
          }
          break;
        }
        case "setField": {
          var P = f.data;
          if (R) {
            "touched" in P && (i.touched = P.touched), "validating" in P && !("originRCField" in P) && (i.validatePromise = P.validating ? Promise.resolve([]) : null), "errors" in P && (i.errors = P.errors || Bs), "warnings" in P && (i.warnings = P.warnings || Bs), i.dirty = !0, i.triggerMetaEvent(), i.reRender();
            return;
          } else if ("value" in P && Ym(d, _, !0)) {
            i.reRender();
            return;
          }
          if (g && !_.length && k2(g, u, S, w, C, f)) {
            i.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var D = b.map(Hi);
          if (D.some(function(I) {
            return Ym(f.relatedFields, I);
          })) {
            i.reRender();
            return;
          }
          break;
        }
        default:
          if (R || (!b.length || _.length || g) && k2(g, u, S, w, C, f)) {
            i.reRender();
            return;
          }
          break;
      }
      g === !0 && i.reRender();
    }), Re(tr(i), "validateRules", function(u) {
      var d = i.getNamePath(), f = i.getValue(), p = u || {}, g = p.triggerName, v = p.validateOnly, b = v === void 0 ? !1 : v, E = Promise.resolve().then(/* @__PURE__ */ Vh(/* @__PURE__ */ go().mark(function S() {
        var _, w, C, R, P, D, I;
        return go().wrap(function(L) {
          for (; ; ) switch (L.prev = L.next) {
            case 0:
              if (i.mounted) {
                L.next = 2;
                break;
              }
              return L.abrupt("return", []);
            case 2:
              if (_ = i.props, w = _.validateFirst, C = w === void 0 ? !1 : w, R = _.messageVariables, P = _.validateDebounce, D = i.getRules(), g && (D = D.filter(function(N) {
                return N;
              }).filter(function(N) {
                var H = N.validateTrigger;
                if (!H)
                  return !0;
                var j = MR(H);
                return j.includes(g);
              })), !(P && g)) {
                L.next = 10;
                break;
              }
              return L.next = 8, new Promise(function(N) {
                setTimeout(N, P);
              });
            case 8:
              if (i.validatePromise === E) {
                L.next = 10;
                break;
              }
              return L.abrupt("return", []);
            case 10:
              return I = zY(d, f, D, u, C, R), I.catch(function(N) {
                return N;
              }).then(function() {
                var N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Bs;
                if (i.validatePromise === E) {
                  var H;
                  i.validatePromise = null;
                  var j = [], G = [];
                  (H = N.forEach) === null || H === void 0 || H.call(N, function(X) {
                    var ae = X.rule.warningOnly, Z = X.errors, K = Z === void 0 ? Bs : Z;
                    ae ? G.push.apply(G, jt(K)) : j.push.apply(j, jt(K));
                  }), i.errors = j, i.warnings = G, i.triggerMetaEvent(), i.reRender();
                }
              }), L.abrupt("return", I);
            case 13:
            case "end":
              return L.stop();
          }
        }, S);
      })));
      return b || (i.validatePromise = E, i.dirty = !0, i.errors = Bs, i.warnings = Bs, i.triggerMetaEvent(), i.reRender()), E;
    }), Re(tr(i), "isFieldValidating", function() {
      return !!i.validatePromise;
    }), Re(tr(i), "isFieldTouched", function() {
      return i.touched;
    }), Re(tr(i), "isFieldDirty", function() {
      if (i.dirty || i.props.initialValue !== void 0)
        return !0;
      var u = i.props.fieldContext, d = u.getInternalHooks(lh), f = d.getInitialValue;
      return f(i.getNamePath()) !== void 0;
    }), Re(tr(i), "getErrors", function() {
      return i.errors;
    }), Re(tr(i), "getWarnings", function() {
      return i.warnings;
    }), Re(tr(i), "isListField", function() {
      return i.props.isListField;
    }), Re(tr(i), "isList", function() {
      return i.props.isList;
    }), Re(tr(i), "isPreserve", function() {
      return i.props.preserve;
    }), Re(tr(i), "getMeta", function() {
      i.prevValidating = i.isFieldValidating();
      var u = {
        touched: i.isFieldTouched(),
        validating: i.prevValidating,
        errors: i.errors,
        warnings: i.warnings,
        name: i.getNamePath(),
        validated: i.validatePromise === null
      };
      return u;
    }), Re(tr(i), "getOnlyChild", function(u) {
      if (typeof u == "function") {
        var d = i.getMeta();
        return ke(ke({}, i.getOnlyChild(u(i.getControlled(), d, i.props.fieldContext))), {}, {
          isFunction: !0
        });
      }
      var f = dc(u);
      return f.length !== 1 || !/* @__PURE__ */ O.isValidElement(f[0]) ? {
        child: f,
        isFunction: !1
      } : {
        child: f[0],
        isFunction: !1
      };
    }), Re(tr(i), "getValue", function(u) {
      var d = i.props.fieldContext.getFieldsValue, f = i.getNamePath();
      return ac(u || d(!0), f);
    }), Re(tr(i), "getControlled", function() {
      var u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, d = i.props, f = d.name, p = d.trigger, g = d.validateTrigger, v = d.getValueFromEvent, b = d.normalize, E = d.valuePropName, S = d.getValueProps, _ = d.fieldContext, w = g !== void 0 ? g : _.validateTrigger, C = i.getNamePath(), R = _.getInternalHooks, P = _.getFieldsValue, D = R(lh), I = D.dispatch, U = i.getValue(), L = S || function(X) {
        return Re({}, E, X);
      }, N = u[p], H = f !== void 0 ? L(U) : {};
      Ee.env.NODE_ENV !== "production" && H && Object.keys(H).forEach(function(X) {
        Yn(typeof H[X] != "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(X, ")"));
      });
      var j = ke(ke({}, u), H);
      j[p] = function() {
        i.touched = !0, i.dirty = !0, i.triggerMetaEvent();
        for (var X, ae = arguments.length, Z = new Array(ae), K = 0; K < ae; K++)
          Z[K] = arguments[K];
        v ? X = v.apply(void 0, Z) : X = kY.apply(void 0, [E].concat(Z)), b && (X = b(X, U, P(!0))), I({
          type: "updateValue",
          namePath: C,
          value: X
        }), N && N.apply(void 0, Z);
      };
      var G = MR(w || []);
      return G.forEach(function(X) {
        var ae = j[X];
        j[X] = function() {
          ae && ae.apply(void 0, arguments);
          var Z = i.props.rules;
          Z && Z.length && I({
            type: "validateField",
            namePath: C,
            triggerName: X
          });
        };
      }), j;
    }), r.fieldContext) {
      var a = r.fieldContext.getInternalHooks, o = a(lh), s = o.initEntityValue;
      s(tr(i));
    }
    return i;
  }
  return $i(t, [{
    key: "componentDidMount",
    value: function() {
      var i = this.props, a = i.shouldUpdate, o = i.fieldContext;
      if (this.mounted = !0, o) {
        var s = o.getInternalHooks, u = s(lh), d = u.registerField;
        this.cancelRegisterFunc = d(this);
      }
      a === !0 && this.reRender();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.cancelRegister(), this.triggerMetaEvent(!0), this.mounted = !1;
    }
  }, {
    key: "reRender",
    value: function() {
      this.mounted && this.forceUpdate();
    }
  }, {
    key: "render",
    value: function() {
      var i = this.state.resetCount, a = this.props.children, o = this.getOnlyChild(a), s = o.child, u = o.isFunction, d;
      return u ? d = s : /* @__PURE__ */ O.isValidElement(s) ? d = /* @__PURE__ */ O.cloneElement(s, this.getControlled(s.props)) : (Yn(!s, "`children` of Field is not validate ReactElement."), d = s), /* @__PURE__ */ O.createElement(O.Fragment, {
        key: i
      }, d);
    }
  }]), t;
}(O.Component);
Re(XA, "contextType", Oh);
Re(XA, "defaultProps", {
  trigger: "onChange",
  valuePropName: "value"
});
function qA(n) {
  var e = n.name, t = br(n, $Y), r = O.useContext(Oh), i = O.useContext(qy), a = e !== void 0 ? Hi(e) : void 0, o = "keep";
  return t.isListField || (o = "_".concat((a || []).join("_"))), Ee.env.NODE_ENV !== "production" && t.preserve === !1 && t.isListField && a.length <= 1 && Yn(!1, "`preserve` should not apply on Form.List fields."), /* @__PURE__ */ O.createElement(XA, gn({
    key: o,
    name: a,
    isListField: !!i
  }, t, {
    fieldContext: r
  }));
}
function WB(n) {
  var e = n.name, t = n.initialValue, r = n.children, i = n.rules, a = n.validateTrigger, o = n.isListField, s = O.useContext(Oh), u = O.useContext(qy), d = O.useRef({
    keys: [],
    id: 0
  }), f = d.current, p = O.useMemo(function() {
    var E = Hi(s.prefixName) || [];
    return [].concat(jt(E), jt(Hi(e)));
  }, [s.prefixName, e]), g = O.useMemo(function() {
    return ke(ke({}, s), {}, {
      prefixName: p
    });
  }, [s, p]), v = O.useMemo(function() {
    return {
      getKey: function(S) {
        var _ = p.length, w = S[_];
        return [f.keys[w], S.slice(_ + 1)];
      }
    };
  }, [p]);
  if (typeof r != "function")
    return Yn(!1, "Form.List only accepts function as children."), null;
  var b = function(S, _, w) {
    var C = w.source;
    return C === "internal" ? !1 : S !== _;
  };
  return /* @__PURE__ */ O.createElement(qy.Provider, {
    value: v
  }, /* @__PURE__ */ O.createElement(Oh.Provider, {
    value: g
  }, /* @__PURE__ */ O.createElement(qA, {
    name: [],
    shouldUpdate: b,
    rules: i,
    validateTrigger: a,
    initialValue: t,
    isList: !0,
    isListField: o ?? !!u
  }, function(E, S) {
    var _ = E.value, w = _ === void 0 ? [] : _, C = E.onChange, R = s.getFieldValue, P = function() {
      var L = R(p || []);
      return L || [];
    }, D = {
      add: function(L, N) {
        var H = P();
        N >= 0 && N <= H.length ? (f.keys = [].concat(jt(f.keys.slice(0, N)), [f.id], jt(f.keys.slice(N))), C([].concat(jt(H.slice(0, N)), [L], jt(H.slice(N))))) : (Ee.env.NODE_ENV !== "production" && (N < 0 || N > H.length) && Yn(!1, "The second parameter of the add function should be a valid positive number."), f.keys = [].concat(jt(f.keys), [f.id]), C([].concat(jt(H), [L]))), f.id += 1;
      },
      remove: function(L) {
        var N = P(), H = new Set(Array.isArray(L) ? L : [L]);
        H.size <= 0 || (f.keys = f.keys.filter(function(j, G) {
          return !H.has(G);
        }), C(N.filter(function(j, G) {
          return !H.has(G);
        })));
      },
      move: function(L, N) {
        if (L !== N) {
          var H = P();
          L < 0 || L >= H.length || N < 0 || N >= H.length || (f.keys = V2(f.keys, L, N), C(V2(H, L, N)));
        }
      }
    }, I = w || [];
    return Array.isArray(I) || (I = [], Ee.env.NODE_ENV !== "production" && Yn(!1, "Current value of '".concat(p.join(" > "), "' is not an array type."))), r(I.map(function(U, L) {
      var N = f.keys[L];
      return N === void 0 && (f.keys[L] = f.id, N = f.keys[L], f.id += 1), {
        name: L,
        key: N,
        isListField: !0
      };
    }), D, S);
  })));
}
function WY(n) {
  var e = !1, t = n.length, r = [];
  return n.length ? new Promise(function(i, a) {
    n.forEach(function(o, s) {
      o.catch(function(u) {
        return e = !0, u;
      }).then(function(u) {
        t -= 1, r[s] = u, !(t > 0) && (e && a(r), i(r));
      });
    });
  }) : Promise.resolve([]);
}
var jB = "__@field_split__";
function J1(n) {
  return n.map(function(e) {
    return "".concat(bn(e), ":").concat(e);
  }).join(jB);
}
var tm = /* @__PURE__ */ function() {
  function n() {
    ki(this, n), Re(this, "kvs", /* @__PURE__ */ new Map());
  }
  return $i(n, [{
    key: "set",
    value: function(t, r) {
      this.kvs.set(J1(t), r);
    }
  }, {
    key: "get",
    value: function(t) {
      return this.kvs.get(J1(t));
    }
  }, {
    key: "update",
    value: function(t, r) {
      var i = this.get(t), a = r(i);
      a ? this.set(t, a) : this.delete(t);
    }
  }, {
    key: "delete",
    value: function(t) {
      this.kvs.delete(J1(t));
    }
    // Since we only use this in test, let simply realize this
  }, {
    key: "map",
    value: function(t) {
      return jt(this.kvs.entries()).map(function(r) {
        var i = ot(r, 2), a = i[0], o = i[1], s = a.split(jB);
        return t({
          key: s.map(function(u) {
            var d = u.match(/^([^:]*):(.*)$/), f = ot(d, 3), p = f[1], g = f[2];
            return p === "number" ? Number(g) : g;
          }),
          value: o
        });
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      var t = {};
      return this.map(function(r) {
        var i = r.key, a = r.value;
        return t[i.join(".")] = a, null;
      }), t;
    }
  }]), n;
}(), jY = ["name"], GY = /* @__PURE__ */ $i(function n(e) {
  var t = this;
  ki(this, n), Re(this, "formHooked", !1), Re(this, "forceRootUpdate", void 0), Re(this, "subscribable", !0), Re(this, "store", {}), Re(this, "fieldEntities", []), Re(this, "initialValues", {}), Re(this, "callbacks", {}), Re(this, "validateMessages", null), Re(this, "preserve", null), Re(this, "lastValidatePromise", null), Re(this, "getForm", function() {
    return {
      getFieldValue: t.getFieldValue,
      getFieldsValue: t.getFieldsValue,
      getFieldError: t.getFieldError,
      getFieldWarning: t.getFieldWarning,
      getFieldsError: t.getFieldsError,
      isFieldsTouched: t.isFieldsTouched,
      isFieldTouched: t.isFieldTouched,
      isFieldValidating: t.isFieldValidating,
      isFieldsValidating: t.isFieldsValidating,
      resetFields: t.resetFields,
      setFields: t.setFields,
      setFieldValue: t.setFieldValue,
      setFieldsValue: t.setFieldsValue,
      validateFields: t.validateFields,
      submit: t.submit,
      _init: !0,
      getInternalHooks: t.getInternalHooks
    };
  }), Re(this, "getInternalHooks", function(r) {
    return r === lh ? (t.formHooked = !0, {
      dispatch: t.dispatch,
      initEntityValue: t.initEntityValue,
      registerField: t.registerField,
      useSubscribe: t.useSubscribe,
      setInitialValues: t.setInitialValues,
      destroyForm: t.destroyForm,
      setCallbacks: t.setCallbacks,
      setValidateMessages: t.setValidateMessages,
      getFields: t.getFields,
      setPreserve: t.setPreserve,
      getInitialValue: t.getInitialValue,
      registerWatch: t.registerWatch
    }) : (Yn(!1, "`getInternalHooks` is internal usage. Should not call directly."), null);
  }), Re(this, "useSubscribe", function(r) {
    t.subscribable = r;
  }), Re(this, "prevWithoutPreserves", null), Re(this, "setInitialValues", function(r, i) {
    if (t.initialValues = r || {}, i) {
      var a, o = Bm(r, t.store);
      (a = t.prevWithoutPreserves) === null || a === void 0 || a.map(function(s) {
        var u = s.key;
        o = Sl(o, u, ac(r, u));
      }), t.prevWithoutPreserves = null, t.updateStore(o);
    }
  }), Re(this, "destroyForm", function(r) {
    if (r)
      t.updateStore({});
    else {
      var i = new tm();
      t.getFieldEntities(!0).forEach(function(a) {
        t.isMergedPreserve(a.isPreserve()) || i.set(a.getNamePath(), !0);
      }), t.prevWithoutPreserves = i;
    }
  }), Re(this, "getInitialValue", function(r) {
    var i = ac(t.initialValues, r);
    return r.length ? Bm(i) : i;
  }), Re(this, "setCallbacks", function(r) {
    t.callbacks = r;
  }), Re(this, "setValidateMessages", function(r) {
    t.validateMessages = r;
  }), Re(this, "setPreserve", function(r) {
    t.preserve = r;
  }), Re(this, "watchList", []), Re(this, "registerWatch", function(r) {
    return t.watchList.push(r), function() {
      t.watchList = t.watchList.filter(function(i) {
        return i !== r;
      });
    };
  }), Re(this, "notifyWatch", function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (t.watchList.length) {
      var i = t.getFieldsValue(), a = t.getFieldsValue(!0);
      t.watchList.forEach(function(o) {
        o(i, a, r);
      });
    }
  }), Re(this, "timeoutId", null), Re(this, "warningUnhooked", function() {
    Ee.env.NODE_ENV !== "production" && !t.timeoutId && typeof window < "u" && (t.timeoutId = setTimeout(function() {
      t.timeoutId = null, t.formHooked || Yn(!1, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
    }));
  }), Re(this, "updateStore", function(r) {
    t.store = r;
  }), Re(this, "getFieldEntities", function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    return r ? t.fieldEntities.filter(function(i) {
      return i.getNamePath().length;
    }) : t.fieldEntities;
  }), Re(this, "getFieldsMap", function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, i = new tm();
    return t.getFieldEntities(r).forEach(function(a) {
      var o = a.getNamePath();
      i.set(o, a);
    }), i;
  }), Re(this, "getFieldEntitiesForNamePathList", function(r) {
    if (!r)
      return t.getFieldEntities(!0);
    var i = t.getFieldsMap(!0);
    return r.map(function(a) {
      var o = Hi(a);
      return i.get(o) || {
        INVALIDATE_NAME_PATH: Hi(a)
      };
    });
  }), Re(this, "getFieldsValue", function(r, i) {
    t.warningUnhooked();
    var a, o, s;
    if (r === !0 || Array.isArray(r) ? (a = r, o = i) : r && bn(r) === "object" && (s = r.strict, o = r.filter), a === !0 && !o)
      return t.store;
    var u = t.getFieldEntitiesForNamePathList(Array.isArray(a) ? a : null), d = [];
    return u.forEach(function(f) {
      var p, g, v = "INVALIDATE_NAME_PATH" in f ? f.INVALIDATE_NAME_PATH : f.getNamePath();
      if (s) {
        var b, E;
        if ((b = (E = f).isList) !== null && b !== void 0 && b.call(E))
          return;
      } else if (!a && (p = (g = f).isListField) !== null && p !== void 0 && p.call(g))
        return;
      if (!o)
        d.push(v);
      else {
        var S = "getMeta" in f ? f.getMeta() : null;
        o(S) && d.push(v);
      }
    }), H2(t.store, d.map(Hi));
  }), Re(this, "getFieldValue", function(r) {
    t.warningUnhooked();
    var i = Hi(r);
    return ac(t.store, i);
  }), Re(this, "getFieldsError", function(r) {
    t.warningUnhooked();
    var i = t.getFieldEntitiesForNamePathList(r);
    return i.map(function(a, o) {
      return a && !("INVALIDATE_NAME_PATH" in a) ? {
        name: a.getNamePath(),
        errors: a.getErrors(),
        warnings: a.getWarnings()
      } : {
        name: Hi(r[o]),
        errors: [],
        warnings: []
      };
    });
  }), Re(this, "getFieldError", function(r) {
    t.warningUnhooked();
    var i = Hi(r), a = t.getFieldsError([i])[0];
    return a.errors;
  }), Re(this, "getFieldWarning", function(r) {
    t.warningUnhooked();
    var i = Hi(r), a = t.getFieldsError([i])[0];
    return a.warnings;
  }), Re(this, "isFieldsTouched", function() {
    t.warningUnhooked();
    for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)
      i[a] = arguments[a];
    var o = i[0], s = i[1], u, d = !1;
    i.length === 0 ? u = null : i.length === 1 ? Array.isArray(o) ? (u = o.map(Hi), d = !1) : (u = null, d = o) : (u = o.map(Hi), d = s);
    var f = t.getFieldEntities(!0), p = function(S) {
      return S.isFieldTouched();
    };
    if (!u)
      return d ? f.every(function(E) {
        return p(E) || E.isList();
      }) : f.some(p);
    var g = new tm();
    u.forEach(function(E) {
      g.set(E, []);
    }), f.forEach(function(E) {
      var S = E.getNamePath();
      u.forEach(function(_) {
        _.every(function(w, C) {
          return S[C] === w;
        }) && g.update(_, function(w) {
          return [].concat(jt(w), [E]);
        });
      });
    });
    var v = function(S) {
      return S.some(p);
    }, b = g.map(function(E) {
      var S = E.value;
      return S;
    });
    return d ? b.every(v) : b.some(v);
  }), Re(this, "isFieldTouched", function(r) {
    return t.warningUnhooked(), t.isFieldsTouched([r]);
  }), Re(this, "isFieldsValidating", function(r) {
    t.warningUnhooked();
    var i = t.getFieldEntities();
    if (!r)
      return i.some(function(o) {
        return o.isFieldValidating();
      });
    var a = r.map(Hi);
    return i.some(function(o) {
      var s = o.getNamePath();
      return Ym(a, s) && o.isFieldValidating();
    });
  }), Re(this, "isFieldValidating", function(r) {
    return t.warningUnhooked(), t.isFieldsValidating([r]);
  }), Re(this, "resetWithFieldInitialValue", function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = new tm(), a = t.getFieldEntities(!0);
    a.forEach(function(u) {
      var d = u.props.initialValue, f = u.getNamePath();
      if (d !== void 0) {
        var p = i.get(f) || /* @__PURE__ */ new Set();
        p.add({
          entity: u,
          value: d
        }), i.set(f, p);
      }
    });
    var o = function(d) {
      d.forEach(function(f) {
        var p = f.props.initialValue;
        if (p !== void 0) {
          var g = f.getNamePath(), v = t.getInitialValue(g);
          if (v !== void 0)
            Yn(!1, "Form already set 'initialValues' with path '".concat(g.join("."), "'. Field can not overwrite it."));
          else {
            var b = i.get(g);
            if (b && b.size > 1)
              Yn(!1, "Multiple Field with path '".concat(g.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            else if (b) {
              var E = t.getFieldValue(g), S = f.isListField();
              !S && (!r.skipExist || E === void 0) && t.updateStore(Sl(t.store, g, jt(b)[0].value));
            }
          }
        }
      });
    }, s;
    r.entities ? s = r.entities : r.namePathList ? (s = [], r.namePathList.forEach(function(u) {
      var d = i.get(u);
      if (d) {
        var f;
        (f = s).push.apply(f, jt(jt(d).map(function(p) {
          return p.entity;
        })));
      }
    })) : s = a, o(s);
  }), Re(this, "resetFields", function(r) {
    t.warningUnhooked();
    var i = t.store;
    if (!r) {
      t.updateStore(Bm(t.initialValues)), t.resetWithFieldInitialValue(), t.notifyObservers(i, null, {
        type: "reset"
      }), t.notifyWatch();
      return;
    }
    var a = r.map(Hi);
    a.forEach(function(o) {
      var s = t.getInitialValue(o);
      t.updateStore(Sl(t.store, o, s));
    }), t.resetWithFieldInitialValue({
      namePathList: a
    }), t.notifyObservers(i, a, {
      type: "reset"
    }), t.notifyWatch(a);
  }), Re(this, "setFields", function(r) {
    t.warningUnhooked();
    var i = t.store, a = [];
    r.forEach(function(o) {
      var s = o.name, u = br(o, jY), d = Hi(s);
      a.push(d), "value" in u && t.updateStore(Sl(t.store, d, u.value)), t.notifyObservers(i, [d], {
        type: "setField",
        data: o
      });
    }), t.notifyWatch(a);
  }), Re(this, "getFields", function() {
    var r = t.getFieldEntities(!0), i = r.map(function(a) {
      var o = a.getNamePath(), s = a.getMeta(), u = ke(ke({}, s), {}, {
        name: o,
        value: t.getFieldValue(o)
      });
      return Object.defineProperty(u, "originRCField", {
        value: !0
      }), u;
    });
    return i;
  }), Re(this, "initEntityValue", function(r) {
    var i = r.props.initialValue;
    if (i !== void 0) {
      var a = r.getNamePath(), o = ac(t.store, a);
      o === void 0 && t.updateStore(Sl(t.store, a, i));
    }
  }), Re(this, "isMergedPreserve", function(r) {
    var i = r !== void 0 ? r : t.preserve;
    return i ?? !0;
  }), Re(this, "registerField", function(r) {
    t.fieldEntities.push(r);
    var i = r.getNamePath();
    if (t.notifyWatch([i]), r.props.initialValue !== void 0) {
      var a = t.store;
      t.resetWithFieldInitialValue({
        entities: [r],
        skipExist: !0
      }), t.notifyObservers(a, [r.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(o, s) {
      var u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (t.fieldEntities = t.fieldEntities.filter(function(p) {
        return p !== r;
      }), !t.isMergedPreserve(s) && (!o || u.length > 1)) {
        var d = o ? void 0 : t.getInitialValue(i);
        if (i.length && t.getFieldValue(i) !== d && t.fieldEntities.every(function(p) {
          return (
            // Only reset when no namePath exist
            !$B(p.getNamePath(), i)
          );
        })) {
          var f = t.store;
          t.updateStore(Sl(f, i, d, !0)), t.notifyObservers(f, [i], {
            type: "remove"
          }), t.triggerDependenciesUpdate(f, i);
        }
      }
      t.notifyWatch([i]);
    };
  }), Re(this, "dispatch", function(r) {
    switch (r.type) {
      case "updateValue": {
        var i = r.namePath, a = r.value;
        t.updateValue(i, a);
        break;
      }
      case "validateField": {
        var o = r.namePath, s = r.triggerName;
        t.validateFields([o], {
          triggerName: s
        });
        break;
      }
    }
  }), Re(this, "notifyObservers", function(r, i, a) {
    if (t.subscribable) {
      var o = ke(ke({}, a), {}, {
        store: t.getFieldsValue(!0)
      });
      t.getFieldEntities().forEach(function(s) {
        var u = s.onStoreChange;
        u(r, i, o);
      });
    } else
      t.forceRootUpdate();
  }), Re(this, "triggerDependenciesUpdate", function(r, i) {
    var a = t.getDependencyChildrenFields(i);
    return a.length && t.validateFields(a), t.notifyObservers(r, a, {
      type: "dependenciesUpdate",
      relatedFields: [i].concat(jt(a))
    }), a;
  }), Re(this, "updateValue", function(r, i) {
    var a = Hi(r), o = t.store;
    t.updateStore(Sl(t.store, a, i)), t.notifyObservers(o, [a], {
      type: "valueUpdate",
      source: "internal"
    }), t.notifyWatch([a]);
    var s = t.triggerDependenciesUpdate(o, a), u = t.callbacks.onValuesChange;
    if (u) {
      var d = H2(t.store, [a]);
      u(d, t.getFieldsValue());
    }
    t.triggerOnFieldsChange([a].concat(jt(s)));
  }), Re(this, "setFieldsValue", function(r) {
    t.warningUnhooked();
    var i = t.store;
    if (r) {
      var a = Bm(t.store, r);
      t.updateStore(a);
    }
    t.notifyObservers(i, null, {
      type: "valueUpdate",
      source: "external"
    }), t.notifyWatch();
  }), Re(this, "setFieldValue", function(r, i) {
    t.setFields([{
      name: r,
      value: i
    }]);
  }), Re(this, "getDependencyChildrenFields", function(r) {
    var i = /* @__PURE__ */ new Set(), a = [], o = new tm();
    t.getFieldEntities().forEach(function(u) {
      var d = u.props.dependencies;
      (d || []).forEach(function(f) {
        var p = Hi(f);
        o.update(p, function() {
          var g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          return g.add(u), g;
        });
      });
    });
    var s = function u(d) {
      var f = o.get(d) || /* @__PURE__ */ new Set();
      f.forEach(function(p) {
        if (!i.has(p)) {
          i.add(p);
          var g = p.getNamePath();
          p.isFieldDirty() && g.length && (a.push(g), u(g));
        }
      });
    };
    return s(r), a;
  }), Re(this, "triggerOnFieldsChange", function(r, i) {
    var a = t.callbacks.onFieldsChange;
    if (a) {
      var o = t.getFields();
      if (i) {
        var s = new tm();
        i.forEach(function(d) {
          var f = d.name, p = d.errors;
          s.set(f, p);
        }), o.forEach(function(d) {
          d.errors = s.get(d.name) || d.errors;
        });
      }
      var u = o.filter(function(d) {
        var f = d.name;
        return Ym(r, f);
      });
      u.length && a(u, o);
    }
  }), Re(this, "validateFields", function(r, i) {
    t.warningUnhooked();
    var a, o;
    Array.isArray(r) || typeof r == "string" || typeof i == "string" ? (a = r, o = i) : o = r;
    var s = !!a, u = s ? a.map(Hi) : [], d = [], f = String(Date.now()), p = /* @__PURE__ */ new Set(), g = o || {}, v = g.recursive, b = g.dirty;
    t.getFieldEntities(!0).forEach(function(w) {
      if (s || u.push(w.getNamePath()), !(!w.props.rules || !w.props.rules.length) && !(b && !w.isFieldDirty())) {
        var C = w.getNamePath();
        if (p.add(C.join(f)), !s || Ym(u, C, v)) {
          var R = w.validateRules(ke({
            validateMessages: ke(ke({}, kB), t.validateMessages)
          }, o));
          d.push(R.then(function() {
            return {
              name: C,
              errors: [],
              warnings: []
            };
          }).catch(function(P) {
            var D, I = [], U = [];
            return (D = P.forEach) === null || D === void 0 || D.call(P, function(L) {
              var N = L.rule.warningOnly, H = L.errors;
              N ? U.push.apply(U, jt(H)) : I.push.apply(I, jt(H));
            }), I.length ? Promise.reject({
              name: C,
              errors: I,
              warnings: U
            }) : {
              name: C,
              errors: I,
              warnings: U
            };
          }));
        }
      }
    });
    var E = WY(d);
    t.lastValidatePromise = E, E.catch(function(w) {
      return w;
    }).then(function(w) {
      var C = w.map(function(R) {
        var P = R.name;
        return P;
      });
      t.notifyObservers(t.store, C, {
        type: "validateFinish"
      }), t.triggerOnFieldsChange(C, w);
    });
    var S = E.then(function() {
      return t.lastValidatePromise === E ? Promise.resolve(t.getFieldsValue(u)) : Promise.reject([]);
    }).catch(function(w) {
      var C = w.filter(function(R) {
        return R && R.errors.length;
      });
      return Promise.reject({
        values: t.getFieldsValue(u),
        errorFields: C,
        outOfDate: t.lastValidatePromise !== E
      });
    });
    S.catch(function(w) {
      return w;
    });
    var _ = u.filter(function(w) {
      return p.has(w.join(f));
    });
    return t.triggerOnFieldsChange(_), S;
  }), Re(this, "submit", function() {
    t.warningUnhooked(), t.validateFields().then(function(r) {
      var i = t.callbacks.onFinish;
      if (i)
        try {
          i(r);
        } catch (a) {
          console.error(a);
        }
    }).catch(function(r) {
      var i = t.callbacks.onFinishFailed;
      i && i(r);
    });
  }), this.forceRootUpdate = e;
});
function YA(n) {
  var e = O.useRef(), t = O.useState({}), r = ot(t, 2), i = r[1];
  if (!e.current)
    if (n)
      e.current = n;
    else {
      var a = function() {
        i({});
      }, o = new GY(a);
      e.current = o.getForm();
    }
  return [e.current];
}
var LR = /* @__PURE__ */ O.createContext({
  triggerFormChange: function() {
  },
  triggerFormFinish: function() {
  },
  registerForm: function() {
  },
  unregisterForm: function() {
  }
}), GB = function(e) {
  var t = e.validateMessages, r = e.onFormChange, i = e.onFormFinish, a = e.children, o = O.useContext(LR), s = O.useRef({});
  return /* @__PURE__ */ O.createElement(LR.Provider, {
    value: ke(ke({}, o), {}, {
      validateMessages: ke(ke({}, o.validateMessages), t),
      // =========================================================
      // =                  Global Form Control                  =
      // =========================================================
      triggerFormChange: function(d, f) {
        r && r(d, {
          changedFields: f,
          forms: s.current
        }), o.triggerFormChange(d, f);
      },
      triggerFormFinish: function(d, f) {
        i && i(d, {
          values: f,
          forms: s.current
        }), o.triggerFormFinish(d, f);
      },
      registerForm: function(d, f) {
        d && (s.current = ke(ke({}, s.current), {}, Re({}, d, f))), o.registerForm(d, f);
      },
      unregisterForm: function(d) {
        var f = ke({}, s.current);
        delete f[d], s.current = f, o.unregisterForm(d);
      }
    })
  }, a);
}, XY = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed", "clearOnDestroy"], qY = function(e, t) {
  var r = e.name, i = e.initialValues, a = e.fields, o = e.form, s = e.preserve, u = e.children, d = e.component, f = d === void 0 ? "form" : d, p = e.validateMessages, g = e.validateTrigger, v = g === void 0 ? "onChange" : g, b = e.onValuesChange, E = e.onFieldsChange, S = e.onFinish, _ = e.onFinishFailed, w = e.clearOnDestroy, C = br(e, XY), R = O.useRef(null), P = O.useContext(LR), D = YA(o), I = ot(D, 1), U = I[0], L = U.getInternalHooks(lh), N = L.useSubscribe, H = L.setInitialValues, j = L.setCallbacks, G = L.setValidateMessages, X = L.setPreserve, ae = L.destroyForm;
  O.useImperativeHandle(t, function() {
    return ke(ke({}, U), {}, {
      nativeElement: R.current
    });
  }), O.useEffect(function() {
    return P.registerForm(r, U), function() {
      P.unregisterForm(r);
    };
  }, [P, U, r]), G(ke(ke({}, P.validateMessages), p)), j({
    onValuesChange: b,
    onFieldsChange: function(ie) {
      if (P.triggerFormChange(r, ie), E) {
        for (var oe = arguments.length, he = new Array(oe > 1 ? oe - 1 : 0), le = 1; le < oe; le++)
          he[le - 1] = arguments[le];
        E.apply(void 0, [ie].concat(he));
      }
    },
    onFinish: function(ie) {
      P.triggerFormFinish(r, ie), S && S(ie);
    },
    onFinishFailed: _
  }), X(s);
  var Z = O.useRef(null);
  H(i, !Z.current), Z.current || (Z.current = !0), O.useEffect(
    function() {
      return function() {
        return ae(w);
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var K, B = typeof u == "function";
  if (B) {
    var Q = U.getFieldsValue(!0);
    K = u(Q, U);
  } else
    K = u;
  N(!B);
  var V = O.useRef();
  O.useEffect(function() {
    VY(V.current || [], a || []) || U.setFields(a || []), V.current = a;
  }, [a, U]);
  var q = O.useMemo(function() {
    return ke(ke({}, U), {}, {
      validateTrigger: v
    });
  }, [U, v]), ne = /* @__PURE__ */ O.createElement(qy.Provider, {
    value: null
  }, /* @__PURE__ */ O.createElement(Oh.Provider, {
    value: q
  }, K));
  return f === !1 ? ne : /* @__PURE__ */ O.createElement(f, gn({}, C, {
    ref: R,
    onSubmit: function(ie) {
      ie.preventDefault(), ie.stopPropagation(), U.submit();
    },
    onReset: function(ie) {
      var oe;
      ie.preventDefault(), U.resetFields(), (oe = C.onReset) === null || oe === void 0 || oe.call(C, ie);
    }
  }), ne);
};
function $2(n) {
  try {
    return JSON.stringify(n);
  } catch {
    return Math.random();
  }
}
var YY = Ee.env.NODE_ENV !== "production" ? function(n) {
  var e = n.join("__RC_FIELD_FORM_SPLIT__"), t = kt(e);
  Yn(t.current === e, "`useWatch` is not support dynamic `namePath`. Please provide static instead.");
} : function() {
};
function XB() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  var r = e[0], i = e[1], a = i === void 0 ? {} : i, o = oY(a) ? {
    form: a
  } : a, s = o.form, u = Lr(), d = ot(u, 2), f = d[0], p = d[1], g = Mr(function() {
    return $2(f);
  }, [f]), v = kt(g);
  v.current = g;
  var b = ni(Oh), E = s || b, S = E && E._init;
  Ee.env.NODE_ENV !== "production" && Yn(e.length === 2 ? s ? S : !0 : S, "useWatch requires a form instance since it can not auto detect from context.");
  var _ = Hi(r), w = kt(_);
  return w.current = _, YY(_), In(
    function() {
      if (S) {
        var C = E.getFieldsValue, R = E.getInternalHooks, P = R(lh), D = P.registerWatch, I = function(H, j) {
          var G = o.preserve ? j : H;
          return typeof r == "function" ? r(G) : ac(G, w.current);
        }, U = D(function(N, H) {
          var j = I(N, H), G = $2(j);
          v.current !== G && (v.current = G, p(j));
        }), L = I(C(), C(!0));
        return f !== L && p(L), U;
      }
    },
    // We do not need re-register since namePath content is the same
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [S]
  ), f;
}
var KY = /* @__PURE__ */ O.forwardRef(qY), vg = KY;
vg.FormProvider = GB;
vg.Field = qA;
vg.List = WB;
vg.useForm = YA;
vg.useWatch = XB;
const pu = /* @__PURE__ */ O.createContext({
  labelAlign: "right",
  vertical: !1,
  itemRef: () => {
  }
}), qB = /* @__PURE__ */ O.createContext(null), YB = (n) => {
  const e = du(n, ["prefixCls"]);
  return /* @__PURE__ */ O.createElement(GB, Object.assign({}, e));
}, KA = /* @__PURE__ */ O.createContext({
  prefixCls: ""
}), Ya = /* @__PURE__ */ O.createContext({});
Ee.env.NODE_ENV !== "production" && (Ya.displayName = "FormItemInputContext");
const ZY = (n) => {
  let {
    children: e,
    status: t,
    override: r
  } = n;
  const i = ni(Ya), a = Mr(() => {
    const o = Object.assign({}, i);
    return r && delete o.isFormItemInput, t && (delete o.status, delete o.hasFeedback, delete o.feedbackIcon), o;
  }, [t, r, i]);
  return /* @__PURE__ */ O.createElement(Ya.Provider, {
    value: a
  }, e);
}, KB = /* @__PURE__ */ hg(void 0), rg = (n) => {
  const {
    space: e,
    form: t,
    children: r
  } = n;
  if (r == null)
    return null;
  let i = r;
  return t && (i = /* @__PURE__ */ Fe.createElement(ZY, {
    override: !0,
    status: !0
  }, i)), e && (i = /* @__PURE__ */ Fe.createElement(bq, null, i)), i;
}, ZB = (n) => ({
  [n.componentCls]: {
    // For common/openAnimation
    [`${n.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${n.motionDurationMid} ${n.motionEaseInOut},
        opacity ${n.motionDurationMid} ${n.motionEaseInOut} !important`
      }
    },
    [`${n.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${n.motionDurationMid} ${n.motionEaseInOut},
        opacity ${n.motionDurationMid} ${n.motionEaseInOut} !important`
    }
  }
}), QY = (n) => ({
  animationDuration: n,
  animationFillMode: "both"
}), JY = (n) => ({
  animationDuration: n,
  animationFillMode: "both"
}), ZA = function(n, e, t, r) {
  const a = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${a}${n}-enter,
      ${a}${n}-appear
    `]: Object.assign(Object.assign({}, QY(r)), {
      animationPlayState: "paused"
    }),
    [`${a}${n}-leave`]: Object.assign(Object.assign({}, JY(r)), {
      animationPlayState: "paused"
    }),
    [`
      ${a}${n}-enter${n}-enter-active,
      ${a}${n}-appear${n}-appear-active
    `]: {
      animationName: e,
      animationPlayState: "running"
    },
    [`${a}${n}-leave${n}-leave-active`]: {
      animationName: t,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, eK = new Gr("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), tK = new Gr("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), nK = new Gr("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), rK = new Gr("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), iK = new Gr("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), aK = new Gr("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), oK = new Gr("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), sK = new Gr("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), lK = {
  "move-up": {
    inKeyframes: oK,
    outKeyframes: sK
  },
  "move-down": {
    inKeyframes: eK,
    outKeyframes: tK
  },
  "move-left": {
    inKeyframes: nK,
    outKeyframes: rK
  },
  "move-right": {
    inKeyframes: iK,
    outKeyframes: aK
  }
}, W2 = (n, e) => {
  const {
    antCls: t
  } = n, r = `${t}-${e}`, {
    inKeyframes: i,
    outKeyframes: a
  } = lK[e];
  return [ZA(r, i, a, n.motionDurationMid), {
    [`
        ${r}-enter,
        ${r}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: n.motionEaseOutCirc
    },
    [`${r}-leave`]: {
      animationTimingFunction: n.motionEaseInOutCirc
    }
  }];
}, QB = new Gr("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), JB = new Gr("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), eH = new Gr("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), tH = new Gr("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), cK = new Gr("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), uK = new Gr("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), dK = new Gr("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), fK = new Gr("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), hK = {
  "slide-up": {
    inKeyframes: QB,
    outKeyframes: JB
  },
  "slide-down": {
    inKeyframes: eH,
    outKeyframes: tH
  },
  "slide-left": {
    inKeyframes: cK,
    outKeyframes: uK
  },
  "slide-right": {
    inKeyframes: dK,
    outKeyframes: fK
  }
}, j2 = (n, e) => {
  const {
    antCls: t
  } = n, r = `${t}-${e}`, {
    inKeyframes: i,
    outKeyframes: a
  } = hK[e];
  return [ZA(r, i, a, n.motionDurationMid), {
    [`
      ${r}-enter,
      ${r}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: n.motionEaseOutQuint,
      "&-prepare": {
        transform: "scale(1)"
      }
    },
    [`${r}-leave`]: {
      animationTimingFunction: n.motionEaseInQuint
    }
  }];
}, QA = new Gr("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), pK = new Gr("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), G2 = new Gr("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), X2 = new Gr("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), mK = new Gr("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), gK = new Gr("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), vK = new Gr("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), yK = new Gr("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), bK = new Gr("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), SK = new Gr("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), _K = new Gr("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), xK = new Gr("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), EK = {
  zoom: {
    inKeyframes: QA,
    outKeyframes: pK
  },
  "zoom-big": {
    inKeyframes: G2,
    outKeyframes: X2
  },
  "zoom-big-fast": {
    inKeyframes: G2,
    outKeyframes: X2
  },
  "zoom-left": {
    inKeyframes: vK,
    outKeyframes: yK
  },
  "zoom-right": {
    inKeyframes: bK,
    outKeyframes: SK
  },
  "zoom-up": {
    inKeyframes: mK,
    outKeyframes: gK
  },
  "zoom-down": {
    inKeyframes: _K,
    outKeyframes: xK
  }
}, nH = (n, e) => {
  const {
    antCls: t
  } = n, r = `${t}-${e}`, {
    inKeyframes: i,
    outKeyframes: a
  } = EK[e];
  return [ZA(r, i, a, e === "zoom-big-fast" ? n.motionDurationFast : n.motionDurationMid), {
    [`
        ${r}-enter,
        ${r}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: n.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${r}-leave`]: {
      animationTimingFunction: n.motionEaseInOutCirc
    }
  }];
};
function CK(n) {
  return (e) => /* @__PURE__ */ O.createElement(Gd, {
    theme: {
      token: {
        motion: !1,
        zIndexPopupBase: 0
      }
    }
  }, /* @__PURE__ */ O.createElement(n, Object.assign({}, e)));
}
const rH = (n, e, t, r) => CK((a) => {
  const {
    prefixCls: o,
    style: s
  } = a, u = O.useRef(null), [d, f] = O.useState(0), [p, g] = O.useState(0), [v, b] = ko(!1, {
    value: a.open
  }), {
    getPrefixCls: E
  } = O.useContext(mr), S = E(e || "select", o);
  O.useEffect(() => {
    if (b(!0), typeof ResizeObserver < "u") {
      const C = new ResizeObserver((P) => {
        const D = P[0].target;
        f(D.offsetHeight + 8), g(D.offsetWidth);
      }), R = setInterval(() => {
        var P;
        const D = t ? `.${t(S)}` : `.${S}-dropdown`, I = (P = u.current) === null || P === void 0 ? void 0 : P.querySelector(D);
        I && (clearInterval(R), C.observe(I));
      }, 10);
      return () => {
        clearInterval(R), C.disconnect();
      };
    }
  }, []);
  let _ = Object.assign(Object.assign({}, a), {
    style: Object.assign(Object.assign({}, s), {
      margin: 0
    }),
    open: v,
    visible: v,
    getPopupContainer: () => u.current
  });
  r && (_ = r(_));
  const w = {
    paddingBottom: d,
    position: "relative",
    minWidth: p
  };
  return /* @__PURE__ */ O.createElement("div", {
    ref: u,
    style: w
  }, /* @__PURE__ */ O.createElement(n, Object.assign({}, _)));
}), JA = function() {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  var n = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(n) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(n == null ? void 0 : n.substr(0, 4));
};
var CE = function(e) {
  var t = e.className, r = e.customizeIcon, i = e.customizeIconProps, a = e.children, o = e.onMouseDown, s = e.onClick, u = typeof r == "function" ? r(i) : r;
  return /* @__PURE__ */ O.createElement("span", {
    className: t,
    onMouseDown: function(f) {
      f.preventDefault(), o == null || o(f);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick: s,
    "aria-hidden": !0
  }, u !== void 0 ? u : /* @__PURE__ */ O.createElement("span", {
    className: Et(t.split(/\s+/).map(function(d) {
      return "".concat(d, "-icon");
    }))
  }, a));
}, wK = function(e, t, r, i, a) {
  var o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1, s = arguments.length > 6 ? arguments[6] : void 0, u = arguments.length > 7 ? arguments[7] : void 0, d = Fe.useMemo(function() {
    if (bn(i) === "object")
      return i.clearIcon;
    if (a)
      return a;
  }, [i, a]), f = Fe.useMemo(function() {
    return !!(!o && i && (r.length || s) && !(u === "combobox" && s === ""));
  }, [i, o, r.length, s, u]);
  return {
    allowClear: f,
    clearIcon: /* @__PURE__ */ Fe.createElement(CE, {
      className: "".concat(e, "-clear"),
      onMouseDown: t,
      customizeIcon: d
    }, "")
  };
}, iH = /* @__PURE__ */ O.createContext(null);
function MK() {
  return O.useContext(iH);
}
function TK() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, e = O.useState(!1), t = ot(e, 2), r = t[0], i = t[1], a = O.useRef(null), o = function() {
    window.clearTimeout(a.current);
  };
  O.useEffect(function() {
    return o;
  }, []);
  var s = function(d, f) {
    o(), a.current = window.setTimeout(function() {
      i(d), f && f();
    }, n);
  };
  return [r, s, o];
}
function aH() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, e = O.useRef(null), t = O.useRef(null);
  O.useEffect(function() {
    return function() {
      window.clearTimeout(t.current);
    };
  }, []);
  function r(i) {
    (i || e.current === null) && (e.current = i), window.clearTimeout(t.current), t.current = window.setTimeout(function() {
      e.current = null;
    }, n);
  }
  return [function() {
    return e.current;
  }, r];
}
function RK(n, e, t, r) {
  var i = O.useRef(null);
  i.current = {
    open: e,
    triggerOpen: t,
    customizedTrigger: r
  }, O.useEffect(function() {
    function a(o) {
      var s;
      if (!((s = i.current) !== null && s !== void 0 && s.customizedTrigger)) {
        var u = o.target;
        u.shadowRoot && o.composed && (u = o.composedPath()[0] || u), i.current.open && n().filter(function(d) {
          return d;
        }).every(function(d) {
          return !d.contains(u) && d !== u;
        }) && i.current.triggerOpen(!1);
      }
    }
    return window.addEventListener("mousedown", a), function() {
      return window.removeEventListener("mousedown", a);
    };
  }, []);
}
function AK(n) {
  return ![
    // System function button
    Ft.ESC,
    Ft.SHIFT,
    Ft.BACKSPACE,
    Ft.TAB,
    Ft.WIN_KEY,
    Ft.ALT,
    Ft.META,
    Ft.WIN_KEY_RIGHT,
    Ft.CTRL,
    Ft.SEMICOLON,
    Ft.EQUALS,
    Ft.CAPS_LOCK,
    Ft.CONTEXT_MENU,
    // F1-F12
    Ft.F1,
    Ft.F2,
    Ft.F3,
    Ft.F4,
    Ft.F5,
    Ft.F6,
    Ft.F7,
    Ft.F8,
    Ft.F9,
    Ft.F10,
    Ft.F11,
    Ft.F12
  ].includes(n);
}
var OK = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"], nm = void 0;
function PK(n, e) {
  var t = n.prefixCls, r = n.invalidate, i = n.item, a = n.renderItem, o = n.responsive, s = n.responsiveDisabled, u = n.registerSize, d = n.itemKey, f = n.className, p = n.style, g = n.children, v = n.display, b = n.order, E = n.component, S = E === void 0 ? "div" : E, _ = br(n, OK), w = o && !v;
  function C(U) {
    u(d, U);
  }
  O.useEffect(function() {
    return function() {
      C(null);
    };
  }, []);
  var R = a && i !== nm ? a(i) : g, P;
  r || (P = {
    opacity: w ? 0 : 1,
    height: w ? 0 : nm,
    overflowY: w ? "hidden" : nm,
    order: o ? b : nm,
    pointerEvents: w ? "none" : nm,
    position: w ? "absolute" : nm
  });
  var D = {};
  w && (D["aria-hidden"] = !0);
  var I = /* @__PURE__ */ O.createElement(S, gn({
    className: Et(!r && t, f),
    style: ke(ke({}, P), p)
  }, D, _, {
    ref: e
  }), R);
  return o && (I = /* @__PURE__ */ O.createElement(Su, {
    onResize: function(L) {
      var N = L.offsetWidth;
      C(N);
    },
    disabled: s
  }, I)), I;
}
var wy = /* @__PURE__ */ O.forwardRef(PK);
wy.displayName = "Item";
function DK(n) {
  if (typeof MessageChannel > "u")
    Wr(n);
  else {
    var e = new MessageChannel();
    e.port1.onmessage = function() {
      return n();
    }, e.port2.postMessage(void 0);
  }
}
function IK() {
  var n = O.useRef(null), e = function(r) {
    n.current || (n.current = [], DK(function() {
      W8(function() {
        n.current.forEach(function(i) {
          i();
        }), n.current = null;
      });
    })), n.current.push(r);
  };
  return e;
}
function Xv(n, e) {
  var t = O.useState(e), r = ot(t, 2), i = r[0], a = r[1], o = Yi(function(s) {
    n(function() {
      a(s);
    });
  });
  return [i, o];
}
var gx = /* @__PURE__ */ Fe.createContext(null), NK = ["component"], LK = ["className"], FK = ["className"], UK = function(e, t) {
  var r = O.useContext(gx);
  if (!r) {
    var i = e.component, a = i === void 0 ? "div" : i, o = br(e, NK);
    return /* @__PURE__ */ O.createElement(a, gn({}, o, {
      ref: t
    }));
  }
  var s = r.className, u = br(r, LK), d = e.className, f = br(e, FK);
  return /* @__PURE__ */ O.createElement(gx.Provider, {
    value: null
  }, /* @__PURE__ */ O.createElement(wy, gn({
    ref: t,
    className: Et(s, d)
  }, u, f)));
}, oH = /* @__PURE__ */ O.forwardRef(UK);
oH.displayName = "RawItem";
var zK = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"], sH = "responsive", lH = "invalidate";
function BK(n) {
  return "+ ".concat(n.length, " ...");
}
function HK(n, e) {
  var t = n.prefixCls, r = t === void 0 ? "rc-overflow" : t, i = n.data, a = i === void 0 ? [] : i, o = n.renderItem, s = n.renderRawItem, u = n.itemKey, d = n.itemWidth, f = d === void 0 ? 10 : d, p = n.ssr, g = n.style, v = n.className, b = n.maxCount, E = n.renderRest, S = n.renderRawRest, _ = n.suffix, w = n.component, C = w === void 0 ? "div" : w, R = n.itemComponent, P = n.onVisibleChange, D = br(n, zK), I = p === "full", U = IK(), L = Xv(U, null), N = ot(L, 2), H = N[0], j = N[1], G = H || 0, X = Xv(U, /* @__PURE__ */ new Map()), ae = ot(X, 2), Z = ae[0], K = ae[1], B = Xv(U, 0), Q = ot(B, 2), V = Q[0], q = Q[1], ne = Xv(U, 0), ce = ot(ne, 2), ie = ce[0], oe = ce[1], he = Xv(U, 0), le = ot(he, 2), ve = le[0], Ne = le[1], xe = Lr(null), Me = ot(xe, 2), $ = Me[0], Te = Me[1], se = Lr(null), Ie = ot(se, 2), be = Ie[0], et = Ie[1], Xe = O.useMemo(function() {
    return be === null && I ? Number.MAX_SAFE_INTEGER : be || 0;
  }, [be, H]), $e = Lr(!1), te = ot($e, 2), Y = te[0], Se = te[1], Oe = "".concat(r, "-item"), Pe = Math.max(V, ie), Ve = b === sH, Ze = a.length && Ve, nt = b === lH, ht = Ze || typeof b == "number" && a.length > b, pt = Mr(function() {
    var lt = a;
    return Ze ? H === null && I ? lt = a : lt = a.slice(0, Math.min(a.length, G / f)) : typeof b == "number" && (lt = a.slice(0, b)), lt;
  }, [a, f, H, b, Ze]), Be = Mr(function() {
    return Ze ? a.slice(Xe + 1) : a.slice(pt.length);
  }, [a, pt, Ze, Xe]), ye = Mh(function(lt, Ct) {
    var un;
    return typeof u == "function" ? u(lt) : (un = u && (lt == null ? void 0 : lt[u])) !== null && un !== void 0 ? un : Ct;
  }, [u]), Ue = Mh(o || function(lt) {
    return lt;
  }, [o]);
  function Ye(lt, Ct, un) {
    be === lt && (Ct === void 0 || Ct === $) || (et(lt), un || (Se(lt < a.length - 1), P == null || P(lt)), Ct !== void 0 && Te(Ct));
  }
  function tt(lt, Ct) {
    j(Ct.clientWidth);
  }
  function st(lt, Ct) {
    K(function(un) {
      var Nn = new Map(un);
      return Ct === null ? Nn.delete(lt) : Nn.set(lt, Ct), Nn;
    });
  }
  function Tt(lt, Ct) {
    oe(Ct), q(ie);
  }
  function Rt(lt, Ct) {
    Ne(Ct);
  }
  function ue(lt) {
    return Z.get(ye(pt[lt], lt));
  }
  ti(function() {
    if (G && typeof Pe == "number" && pt) {
      var lt = ve, Ct = pt.length, un = Ct - 1;
      if (!Ct) {
        Ye(0, null);
        return;
      }
      for (var Nn = 0; Nn < Ct; Nn += 1) {
        var xt = ue(Nn);
        if (I && (xt = xt || 0), xt === void 0) {
          Ye(Nn - 1, void 0, !0);
          break;
        }
        if (lt += xt, // Only one means `totalWidth` is the final width
        un === 0 && lt <= G || // Last two width will be the final width
        Nn === un - 1 && lt + ue(un) <= G) {
          Ye(un, null);
          break;
        } else if (lt + Pe > G) {
          Ye(Nn - 1, lt - xt - ve + ie);
          break;
        }
      }
      _ && ue(0) + ve > G && Te(null);
    }
  }, [G, Z, ie, ve, ye, pt]);
  var De = Y && !!Be.length, Ge = {};
  $ !== null && Ze && (Ge = {
    position: "absolute",
    left: $,
    top: 0
  });
  var We = {
    prefixCls: Oe,
    responsive: Ze,
    component: R,
    invalidate: nt
  }, He = s ? function(lt, Ct) {
    var un = ye(lt, Ct);
    return /* @__PURE__ */ O.createElement(gx.Provider, {
      key: un,
      value: ke(ke({}, We), {}, {
        order: Ct,
        item: lt,
        itemKey: un,
        registerSize: st,
        display: Ct <= Xe
      })
    }, s(lt, Ct));
  } : function(lt, Ct) {
    var un = ye(lt, Ct);
    return /* @__PURE__ */ O.createElement(wy, gn({}, We, {
      order: Ct,
      key: un,
      item: lt,
      renderItem: Ue,
      itemKey: un,
      registerSize: st,
      display: Ct <= Xe
    }));
  }, ut, vt = {
    order: De ? Xe : Number.MAX_SAFE_INTEGER,
    className: "".concat(Oe, "-rest"),
    registerSize: Tt,
    display: De
  };
  if (S)
    S && (ut = /* @__PURE__ */ O.createElement(gx.Provider, {
      value: ke(ke({}, We), vt)
    }, S(Be)));
  else {
    var _t = E || BK;
    ut = /* @__PURE__ */ O.createElement(wy, gn({}, We, vt), typeof _t == "function" ? _t(Be) : _t);
  }
  var Wt = /* @__PURE__ */ O.createElement(C, gn({
    className: Et(!nt && r, v),
    style: g,
    ref: e
  }, D), pt.map(He), ht ? ut : null, _ && /* @__PURE__ */ O.createElement(wy, gn({}, We, {
    responsive: Ve,
    responsiveDisabled: !Ze,
    order: Xe,
    className: "".concat(Oe, "-suffix"),
    registerSize: Rt,
    display: !0,
    style: Ge
  }), _));
  return Ve && (Wt = /* @__PURE__ */ O.createElement(Su, {
    onResize: tt,
    disabled: !Ze
  }, Wt)), Wt;
}
var E0 = /* @__PURE__ */ O.forwardRef(HK);
E0.displayName = "Overflow";
E0.Item = oH;
E0.RESPONSIVE = sH;
E0.INVALIDATE = lH;
var VK = function(e, t) {
  var r, i = e.prefixCls, a = e.id, o = e.inputElement, s = e.disabled, u = e.tabIndex, d = e.autoFocus, f = e.autoComplete, p = e.editable, g = e.activeDescendantId, v = e.value, b = e.maxLength, E = e.onKeyDown, S = e.onMouseDown, _ = e.onChange, w = e.onPaste, C = e.onCompositionStart, R = e.onCompositionEnd, P = e.open, D = e.attrs, I = o || /* @__PURE__ */ O.createElement("input", null), U = I, L = U.ref, N = U.props, H = N.onKeyDown, j = N.onChange, G = N.onMouseDown, X = N.onCompositionStart, ae = N.onCompositionEnd, Z = N.style;
  return Th(!("maxLength" in I.props), "Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled."), I = /* @__PURE__ */ O.cloneElement(I, ke(ke(ke({
    type: "search"
  }, N), {}, {
    // Override over origin props
    id: a,
    ref: Ol(t, L),
    disabled: s,
    tabIndex: u,
    autoComplete: f || "off",
    autoFocus: d,
    className: Et("".concat(i, "-selection-search-input"), (r = I) === null || r === void 0 || (r = r.props) === null || r === void 0 ? void 0 : r.className),
    role: "combobox",
    "aria-expanded": P || !1,
    "aria-haspopup": "listbox",
    "aria-owns": "".concat(a, "_list"),
    "aria-autocomplete": "list",
    "aria-controls": "".concat(a, "_list"),
    "aria-activedescendant": P ? g : void 0
  }, D), {}, {
    value: p ? v : "",
    maxLength: b,
    readOnly: !p,
    unselectable: p ? null : "on",
    style: ke(ke({}, Z), {}, {
      opacity: p ? null : 0
    }),
    onKeyDown: function(B) {
      E(B), H && H(B);
    },
    onMouseDown: function(B) {
      S(B), G && G(B);
    },
    onChange: function(B) {
      _(B), j && j(B);
    },
    onCompositionStart: function(B) {
      C(B), X && X(B);
    },
    onCompositionEnd: function(B) {
      R(B), ae && ae(B);
    },
    onPaste: w
  })), I;
}, eO = /* @__PURE__ */ O.forwardRef(VK);
Ee.env.NODE_ENV !== "production" && (eO.displayName = "Input");
function tO(n) {
  return Array.isArray(n) ? n : n !== void 0 ? [n] : [];
}
var kK = typeof window < "u" && window.document && window.document.documentElement, $K = Ee.env.NODE_ENV !== "test" && kK;
function WK(n) {
  return n != null;
}
function jK(n) {
  return !n && n !== 0;
}
function q2(n) {
  return ["string", "number"].includes(bn(n));
}
function cH(n) {
  var e = void 0;
  return n && (q2(n.title) ? e = n.title.toString() : q2(n.label) && (e = n.label.toString())), e;
}
function GK(n, e) {
  $K ? O.useLayoutEffect(n, e) : O.useEffect(n, e);
}
function XK(n) {
  var e;
  return (e = n.key) !== null && e !== void 0 ? e : n.value;
}
var Y2 = function(e) {
  e.preventDefault(), e.stopPropagation();
}, qK = function(e) {
  var t = e.id, r = e.prefixCls, i = e.values, a = e.open, o = e.searchValue, s = e.autoClearSearchValue, u = e.inputRef, d = e.placeholder, f = e.disabled, p = e.mode, g = e.showSearch, v = e.autoFocus, b = e.autoComplete, E = e.activeDescendantId, S = e.tabIndex, _ = e.removeIcon, w = e.maxTagCount, C = e.maxTagTextLength, R = e.maxTagPlaceholder, P = R === void 0 ? function(Te) {
    return "+ ".concat(Te.length, " ...");
  } : R, D = e.tagRender, I = e.onToggleOpen, U = e.onRemove, L = e.onInputChange, N = e.onInputPaste, H = e.onInputKeyDown, j = e.onInputMouseDown, G = e.onInputCompositionStart, X = e.onInputCompositionEnd, ae = O.useRef(null), Z = Lr(0), K = ot(Z, 2), B = K[0], Q = K[1], V = Lr(!1), q = ot(V, 2), ne = q[0], ce = q[1], ie = "".concat(r, "-selection"), oe = a || p === "multiple" && s === !1 || p === "tags" ? o : "", he = p === "tags" || p === "multiple" && s === !1 || g && (a || ne);
  GK(function() {
    Q(ae.current.scrollWidth);
  }, [oe]);
  var le = function(se, Ie, be, et, Xe) {
    return /* @__PURE__ */ O.createElement("span", {
      title: cH(se),
      className: Et("".concat(ie, "-item"), Re({}, "".concat(ie, "-item-disabled"), be))
    }, /* @__PURE__ */ O.createElement("span", {
      className: "".concat(ie, "-item-content")
    }, Ie), et && /* @__PURE__ */ O.createElement(CE, {
      className: "".concat(ie, "-item-remove"),
      onMouseDown: Y2,
      onClick: Xe,
      customizeIcon: _
    }, ""));
  }, ve = function(se, Ie, be, et, Xe, $e) {
    var te = function(Se) {
      Y2(Se), I(!a);
    };
    return /* @__PURE__ */ O.createElement("span", {
      onMouseDown: te
    }, D({
      label: Ie,
      value: se,
      disabled: be,
      closable: et,
      onClose: Xe,
      isMaxTag: !!$e
    }));
  }, Ne = function(se) {
    var Ie = se.disabled, be = se.label, et = se.value, Xe = !f && !Ie, $e = be;
    if (typeof C == "number" && (typeof be == "string" || typeof be == "number")) {
      var te = String($e);
      te.length > C && ($e = "".concat(te.slice(0, C), "..."));
    }
    var Y = function(Oe) {
      Oe && Oe.stopPropagation(), U(se);
    };
    return typeof D == "function" ? ve(et, $e, Ie, Xe, Y) : le(se, $e, Ie, Xe, Y);
  }, xe = function(se) {
    var Ie = typeof P == "function" ? P(se) : P;
    return typeof D == "function" ? ve(void 0, Ie, !1, !1, void 0, !0) : le({
      title: Ie
    }, Ie, !1);
  }, Me = /* @__PURE__ */ O.createElement("div", {
    className: "".concat(ie, "-search"),
    style: {
      width: B
    },
    onFocus: function() {
      ce(!0);
    },
    onBlur: function() {
      ce(!1);
    }
  }, /* @__PURE__ */ O.createElement(eO, {
    ref: u,
    open: a,
    prefixCls: r,
    id: t,
    inputElement: null,
    disabled: f,
    autoFocus: v,
    autoComplete: b,
    editable: he,
    activeDescendantId: E,
    value: oe,
    onKeyDown: H,
    onMouseDown: j,
    onChange: L,
    onPaste: N,
    onCompositionStart: G,
    onCompositionEnd: X,
    tabIndex: S,
    attrs: ng(e, !0)
  }), /* @__PURE__ */ O.createElement("span", {
    ref: ae,
    className: "".concat(ie, "-search-mirror"),
    "aria-hidden": !0
  }, oe, "")), $ = /* @__PURE__ */ O.createElement(E0, {
    prefixCls: "".concat(ie, "-overflow"),
    data: i,
    renderItem: Ne,
    renderRest: xe,
    suffix: Me,
    itemKey: XK,
    maxCount: w
  });
  return /* @__PURE__ */ O.createElement(O.Fragment, null, $, !i.length && !oe && /* @__PURE__ */ O.createElement("span", {
    className: "".concat(ie, "-placeholder")
  }, d));
}, YK = function(e) {
  var t = e.inputElement, r = e.prefixCls, i = e.id, a = e.inputRef, o = e.disabled, s = e.autoFocus, u = e.autoComplete, d = e.activeDescendantId, f = e.mode, p = e.open, g = e.values, v = e.placeholder, b = e.tabIndex, E = e.showSearch, S = e.searchValue, _ = e.activeValue, w = e.maxLength, C = e.onInputKeyDown, R = e.onInputMouseDown, P = e.onInputChange, D = e.onInputPaste, I = e.onInputCompositionStart, U = e.onInputCompositionEnd, L = e.title, N = O.useState(!1), H = ot(N, 2), j = H[0], G = H[1], X = f === "combobox", ae = X || E, Z = g[0], K = S || "";
  X && _ && !j && (K = _), O.useEffect(function() {
    X && G(!1);
  }, [X, _]);
  var B = f !== "combobox" && !p && !E ? !1 : !!K, Q = L === void 0 ? cH(Z) : L, V = O.useMemo(function() {
    return Z ? null : /* @__PURE__ */ O.createElement("span", {
      className: "".concat(r, "-selection-placeholder"),
      style: B ? {
        visibility: "hidden"
      } : void 0
    }, v);
  }, [Z, B, v, r]);
  return /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement("span", {
    className: "".concat(r, "-selection-search")
  }, /* @__PURE__ */ O.createElement(eO, {
    ref: a,
    prefixCls: r,
    id: i,
    open: p,
    inputElement: t,
    disabled: o,
    autoFocus: s,
    autoComplete: u,
    editable: ae,
    activeDescendantId: d,
    value: K,
    onKeyDown: C,
    onMouseDown: R,
    onChange: function(ne) {
      G(!0), P(ne);
    },
    onPaste: D,
    onCompositionStart: I,
    onCompositionEnd: U,
    tabIndex: b,
    attrs: ng(e, !0),
    maxLength: X ? w : void 0
  })), !X && Z ? /* @__PURE__ */ O.createElement("span", {
    className: "".concat(r, "-selection-item"),
    title: Q,
    style: B ? {
      visibility: "hidden"
    } : void 0
  }, Z.label) : null, V);
}, KK = function(e, t) {
  var r = kt(null), i = kt(!1), a = e.prefixCls, o = e.open, s = e.mode, u = e.showSearch, d = e.tokenWithEnter, f = e.disabled, p = e.autoClearSearchValue, g = e.onSearch, v = e.onSearchSubmit, b = e.onToggleOpen, E = e.onInputKeyDown, S = e.domRef;
  O.useImperativeHandle(t, function() {
    return {
      focus: function(B) {
        r.current.focus(B);
      },
      blur: function() {
        r.current.blur();
      }
    };
  });
  var _ = aH(0), w = ot(_, 2), C = w[0], R = w[1], P = function(B) {
    var Q = B.which;
    (Q === Ft.UP || Q === Ft.DOWN) && B.preventDefault(), E && E(B), Q === Ft.ENTER && s === "tags" && !i.current && !o && (v == null || v(B.target.value)), AK(Q) && b(!0);
  }, D = function() {
    R(!0);
  }, I = kt(null), U = function(B) {
    g(B, !0, i.current) !== !1 && b(!0);
  }, L = function() {
    i.current = !0;
  }, N = function(B) {
    i.current = !1, s !== "combobox" && U(B.target.value);
  }, H = function(B) {
    var Q = B.target.value;
    if (d && I.current && /[\r\n]/.test(I.current)) {
      var V = I.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      Q = Q.replace(V, I.current);
    }
    I.current = null, U(Q);
  }, j = function(B) {
    var Q = B.clipboardData, V = Q == null ? void 0 : Q.getData("text");
    I.current = V || "";
  }, G = function(B) {
    var Q = B.target;
    if (Q !== r.current) {
      var V = document.body.style.msTouchAction !== void 0;
      V ? setTimeout(function() {
        r.current.focus();
      }) : r.current.focus();
    }
  }, X = function(B) {
    var Q = C();
    B.target !== r.current && !Q && !(s === "combobox" && f) && B.preventDefault(), (s !== "combobox" && (!u || !Q) || !o) && (o && p !== !1 && g("", !0, !1), b());
  }, ae = {
    inputRef: r,
    onInputKeyDown: P,
    onInputMouseDown: D,
    onInputChange: H,
    onInputPaste: j,
    onInputCompositionStart: L,
    onInputCompositionEnd: N
  }, Z = s === "multiple" || s === "tags" ? /* @__PURE__ */ O.createElement(qK, gn({}, e, ae)) : /* @__PURE__ */ O.createElement(YK, gn({}, e, ae));
  return /* @__PURE__ */ O.createElement("div", {
    ref: S,
    className: "".concat(a, "-selector"),
    onClick: G,
    onMouseDown: X
  }, Z);
}, uH = /* @__PURE__ */ O.forwardRef(KK);
Ee.env.NODE_ENV !== "production" && (uH.displayName = "Selector");
function ZK(n) {
  var e = n.prefixCls, t = n.align, r = n.arrow, i = n.arrowPos, a = r || {}, o = a.className, s = a.content, u = i.x, d = u === void 0 ? 0 : u, f = i.y, p = f === void 0 ? 0 : f, g = O.useRef();
  if (!t || !t.points)
    return null;
  var v = {
    position: "absolute"
  };
  if (t.autoArrow !== !1) {
    var b = t.points[0], E = t.points[1], S = b[0], _ = b[1], w = E[0], C = E[1];
    S === w || !["t", "b"].includes(S) ? v.top = p : S === "t" ? v.top = 0 : v.bottom = 0, _ === C || !["l", "r"].includes(_) ? v.left = d : _ === "l" ? v.left = 0 : v.right = 0;
  }
  return /* @__PURE__ */ O.createElement("div", {
    ref: g,
    className: Et("".concat(e, "-arrow"), o),
    style: v
  }, s);
}
function QK(n) {
  var e = n.prefixCls, t = n.open, r = n.zIndex, i = n.mask, a = n.motion;
  return i ? /* @__PURE__ */ O.createElement(Hh, gn({}, a, {
    motionAppear: !0,
    visible: t,
    removeOnLeave: !0
  }), function(o) {
    var s = o.className;
    return /* @__PURE__ */ O.createElement("div", {
      style: {
        zIndex: r
      },
      className: Et("".concat(e, "-mask"), s)
    });
  }) : null;
}
var dH = /* @__PURE__ */ O.memo(function(n) {
  var e = n.children;
  return e;
}, function(n, e) {
  return e.cache;
});
Ee.env.NODE_ENV !== "production" && (dH.displayName = "PopupContent");
var fH = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.popup, r = n.className, i = n.prefixCls, a = n.style, o = n.target, s = n.onVisibleChanged, u = n.open, d = n.keepDom, f = n.fresh, p = n.onClick, g = n.mask, v = n.arrow, b = n.arrowPos, E = n.align, S = n.motion, _ = n.maskMotion, w = n.forceRender, C = n.getPopupContainer, R = n.autoDestroy, P = n.portal, D = n.zIndex, I = n.onMouseEnter, U = n.onMouseLeave, L = n.onPointerEnter, N = n.ready, H = n.offsetX, j = n.offsetY, G = n.offsetR, X = n.offsetB, ae = n.onAlign, Z = n.onPrepare, K = n.stretch, B = n.targetWidth, Q = n.targetHeight, V = typeof t == "function" ? t() : t, q = u || d, ne = (C == null ? void 0 : C.length) > 0, ce = O.useState(!C || !ne), ie = ot(ce, 2), oe = ie[0], he = ie[1];
  if (ti(function() {
    !oe && ne && o && he(!0);
  }, [oe, ne, o]), !oe)
    return null;
  var le = "auto", ve = {
    left: "-1000vw",
    top: "-1000vh",
    right: le,
    bottom: le
  };
  if (N || !u) {
    var Ne, xe = E.points, Me = E.dynamicInset || ((Ne = E._experimental) === null || Ne === void 0 ? void 0 : Ne.dynamicInset), $ = Me && xe[0][1] === "r", Te = Me && xe[0][0] === "b";
    $ ? (ve.right = G, ve.left = le) : (ve.left = H, ve.right = le), Te ? (ve.bottom = X, ve.top = le) : (ve.top = j, ve.bottom = le);
  }
  var se = {};
  return K && (K.includes("height") && Q ? se.height = Q : K.includes("minHeight") && Q && (se.minHeight = Q), K.includes("width") && B ? se.width = B : K.includes("minWidth") && B && (se.minWidth = B)), u || (se.pointerEvents = "none"), /* @__PURE__ */ O.createElement(P, {
    open: w || q,
    getContainer: C && function() {
      return C(o);
    },
    autoDestroy: R
  }, /* @__PURE__ */ O.createElement(QK, {
    prefixCls: i,
    open: u,
    zIndex: D,
    mask: g,
    motion: _
  }), /* @__PURE__ */ O.createElement(Su, {
    onResize: ae,
    disabled: !u
  }, function(Ie) {
    return /* @__PURE__ */ O.createElement(Hh, gn({
      motionAppear: !0,
      motionEnter: !0,
      motionLeave: !0,
      removeOnLeave: !1,
      forceRender: w,
      leavedClassName: "".concat(i, "-hidden")
    }, S, {
      onAppearPrepare: Z,
      onEnterPrepare: Z,
      visible: u,
      onVisibleChanged: function(et) {
        var Xe;
        S == null || (Xe = S.onVisibleChanged) === null || Xe === void 0 || Xe.call(S, et), s(et);
      }
    }), function(be, et) {
      var Xe = be.className, $e = be.style, te = Et(i, Xe, r);
      return /* @__PURE__ */ O.createElement("div", {
        ref: Ol(Ie, e, et),
        className: te,
        style: ke(ke(ke(ke({
          "--arrow-x": "".concat(b.x || 0, "px"),
          "--arrow-y": "".concat(b.y || 0, "px")
        }, ve), se), $e), {}, {
          boxSizing: "border-box",
          zIndex: D
        }, a),
        onMouseEnter: I,
        onMouseLeave: U,
        onPointerEnter: L,
        onClick: p
      }, v && /* @__PURE__ */ O.createElement(ZK, {
        prefixCls: i,
        arrow: v,
        arrowPos: b,
        align: E
      }), /* @__PURE__ */ O.createElement(dH, {
        cache: !u && !f
      }, V));
    });
  }));
});
Ee.env.NODE_ENV !== "production" && (fH.displayName = "Popup");
var hH = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.children, r = n.getTriggerDOMNode, i = pg(t), a = O.useCallback(function(s) {
    RA(e, r ? r(s) : s);
  }, [r]), o = dE(a, t.ref);
  return i ? /* @__PURE__ */ O.cloneElement(t, {
    ref: o
  }) : t;
});
Ee.env.NODE_ENV !== "production" && (hH.displayName = "TriggerWrapper");
var K2 = /* @__PURE__ */ O.createContext(null);
function Z2(n) {
  return n ? Array.isArray(n) ? n : [n] : [];
}
function JK(n, e, t, r) {
  return O.useMemo(function() {
    var i = Z2(t ?? e), a = Z2(r ?? e), o = new Set(i), s = new Set(a);
    return n && (o.has("hover") && (o.delete("hover"), o.add("click")), s.has("hover") && (s.delete("hover"), s.add("click"))), [o, s];
  }, [n, e, t, r]);
}
function eZ() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0;
  return t ? n[0] === e[0] : n[0] === e[0] && n[1] === e[1];
}
function tZ(n, e, t, r) {
  for (var i = t.points, a = Object.keys(n), o = 0; o < a.length; o += 1) {
    var s, u = a[o];
    if (eZ((s = n[u]) === null || s === void 0 ? void 0 : s.points, i, r))
      return "".concat(e, "-placement-").concat(u);
  }
  return "";
}
function Q2(n, e, t, r) {
  return e || (t ? {
    motionName: "".concat(n, "-").concat(t)
  } : r ? {
    motionName: r
  } : null);
}
function C0(n) {
  return n.ownerDocument.defaultView;
}
function FR(n) {
  for (var e = [], t = n == null ? void 0 : n.parentElement, r = ["hidden", "scroll", "clip", "auto"]; t; ) {
    var i = C0(t).getComputedStyle(t), a = i.overflowX, o = i.overflowY, s = i.overflow;
    [a, o, s].some(function(u) {
      return r.includes(u);
    }) && e.push(t), t = t.parentElement;
  }
  return e;
}
function Yy(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return Number.isNaN(n) ? e : n;
}
function qv(n) {
  return Yy(parseFloat(n), 0);
}
function J2(n, e) {
  var t = ke({}, n);
  return (e || []).forEach(function(r) {
    if (!(r instanceof HTMLBodyElement || r instanceof HTMLHtmlElement)) {
      var i = C0(r).getComputedStyle(r), a = i.overflow, o = i.overflowClipMargin, s = i.borderTopWidth, u = i.borderBottomWidth, d = i.borderLeftWidth, f = i.borderRightWidth, p = r.getBoundingClientRect(), g = r.offsetHeight, v = r.clientHeight, b = r.offsetWidth, E = r.clientWidth, S = qv(s), _ = qv(u), w = qv(d), C = qv(f), R = Yy(Math.round(p.width / b * 1e3) / 1e3), P = Yy(Math.round(p.height / g * 1e3) / 1e3), D = (b - E - w - C) * R, I = (g - v - S - _) * P, U = S * P, L = _ * P, N = w * R, H = C * R, j = 0, G = 0;
      if (a === "clip") {
        var X = qv(o);
        j = X * R, G = X * P;
      }
      var ae = p.x + N - j, Z = p.y + U - G, K = ae + p.width + 2 * j - N - H - D, B = Z + p.height + 2 * G - U - L - I;
      t.left = Math.max(t.left, ae), t.top = Math.max(t.top, Z), t.right = Math.min(t.right, K), t.bottom = Math.min(t.bottom, B);
    }
  }), t;
}
function eL(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = "".concat(e), r = t.match(/^(.*)\%$/);
  return r ? n * (parseFloat(r[1]) / 100) : parseFloat(t);
}
function tL(n, e) {
  var t = e || [], r = ot(t, 2), i = r[0], a = r[1];
  return [eL(n.width, i), eL(n.height, a)];
}
function nL() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return [n[0], n[1]];
}
function rm(n, e) {
  var t = e[0], r = e[1], i, a;
  return t === "t" ? a = n.y : t === "b" ? a = n.y + n.height : a = n.y + n.height / 2, r === "l" ? i = n.x : r === "r" ? i = n.x + n.width : i = n.x + n.width / 2, {
    x: i,
    y: a
  };
}
function _d(n, e) {
  var t = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return n.map(function(r, i) {
    return i === e ? t[r] || "c" : r;
  }).join("");
}
function nZ(n, e, t, r, i, a, o) {
  var s = O.useState({
    ready: !1,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: i[r] || {}
  }), u = ot(s, 2), d = u[0], f = u[1], p = O.useRef(0), g = O.useMemo(function() {
    return e ? FR(e) : [];
  }, [e]), v = O.useRef({}), b = function() {
    v.current = {};
  };
  n || b();
  var E = Yi(function() {
    if (e && t && n) {
      let Qi = function(_a, ri) {
        var vs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : te, bo = V.x + _a, vc = V.y + ri, Ys = bo + Ne, Qn = vc + ve, wu = Math.max(bo, vs.left), So = Math.max(vc, vs.top), Mu = Math.min(Ys, vs.right), Zd = Math.min(Qn, vs.bottom);
        return Math.max(0, (Mu - wu) * (Zd - So));
      }, ha = function() {
        ge = V.y + _t, it = ge + ve, yt = V.x + vt, Kt = yt + Ne;
      };
      var w, C, R = e, P = R.ownerDocument, D = C0(R), I = D.getComputedStyle(R), U = I.width, L = I.height, N = I.position, H = R.style.left, j = R.style.top, G = R.style.right, X = R.style.bottom, ae = R.style.overflow, Z = ke(ke({}, i[r]), a), K = P.createElement("div");
      (w = R.parentElement) === null || w === void 0 || w.appendChild(K), K.style.left = "".concat(R.offsetLeft, "px"), K.style.top = "".concat(R.offsetTop, "px"), K.style.position = N, K.style.height = "".concat(R.offsetHeight, "px"), K.style.width = "".concat(R.offsetWidth, "px"), R.style.left = "0", R.style.top = "0", R.style.right = "auto", R.style.bottom = "auto", R.style.overflow = "hidden";
      var B;
      if (Array.isArray(t))
        B = {
          x: t[0],
          y: t[1],
          width: 0,
          height: 0
        };
      else {
        var Q = t.getBoundingClientRect();
        B = {
          x: Q.x,
          y: Q.y,
          width: Q.width,
          height: Q.height
        };
      }
      var V = R.getBoundingClientRect(), q = P.documentElement, ne = q.clientWidth, ce = q.clientHeight, ie = q.scrollWidth, oe = q.scrollHeight, he = q.scrollTop, le = q.scrollLeft, ve = V.height, Ne = V.width, xe = B.height, Me = B.width, $ = {
        left: 0,
        top: 0,
        right: ne,
        bottom: ce
      }, Te = {
        left: -le,
        top: -he,
        right: ie - le,
        bottom: oe - he
      }, se = Z.htmlRegion, Ie = "visible", be = "visibleFirst";
      se !== "scroll" && se !== be && (se = Ie);
      var et = se === be, Xe = J2(Te, g), $e = J2($, g), te = se === Ie ? $e : Xe, Y = et ? $e : te;
      R.style.left = "auto", R.style.top = "auto", R.style.right = "0", R.style.bottom = "0";
      var Se = R.getBoundingClientRect();
      R.style.left = H, R.style.top = j, R.style.right = G, R.style.bottom = X, R.style.overflow = ae, (C = R.parentElement) === null || C === void 0 || C.removeChild(K);
      var Oe = Yy(Math.round(Ne / parseFloat(U) * 1e3) / 1e3), Pe = Yy(Math.round(ve / parseFloat(L) * 1e3) / 1e3);
      if (Oe === 0 || Pe === 0 || zy(t) && !$A(t))
        return;
      var Ve = Z.offset, Ze = Z.targetOffset, nt = tL(V, Ve), ht = ot(nt, 2), pt = ht[0], Be = ht[1], ye = tL(B, Ze), Ue = ot(ye, 2), Ye = Ue[0], tt = Ue[1];
      B.x -= Ye, B.y -= tt;
      var st = Z.points || [], Tt = ot(st, 2), Rt = Tt[0], ue = Tt[1], De = nL(ue), Ge = nL(Rt), We = rm(B, De), He = rm(V, Ge), ut = ke({}, Z), vt = We.x - He.x + pt, _t = We.y - He.y + Be, Wt = Qi(vt, _t), lt = Qi(vt, _t, $e), Ct = rm(B, ["t", "l"]), un = rm(V, ["t", "l"]), Nn = rm(B, ["b", "r"]), xt = rm(V, ["b", "r"]), Pt = Z.overflow || {}, Bt = Pt.adjustX, Qt = Pt.adjustY, vn = Pt.shiftX, Mn = Pt.shiftY, cr = function(ri) {
        return typeof ri == "boolean" ? ri : ri >= 0;
      }, ge, it, yt, Kt;
      ha();
      var Sn = cr(Qt), ee = Ge[0] === De[0];
      if (Sn && Ge[0] === "t" && (it > Y.bottom || v.current.bt)) {
        var _e = _t;
        ee ? _e -= ve - xe : _e = Ct.y - xt.y - Be;
        var Ae = Qi(vt, _e), Ce = Qi(vt, _e, $e);
        // Of course use larger one
        Ae > Wt || Ae === Wt && (!et || // Choose recommend one
        Ce >= lt) ? (v.current.bt = !0, _t = _e, Be = -Be, ut.points = [_d(Ge, 0), _d(De, 0)]) : v.current.bt = !1;
      }
      if (Sn && Ge[0] === "b" && (ge < Y.top || v.current.tb)) {
        var pe = _t;
        ee ? pe += ve - xe : pe = Nn.y - un.y - Be;
        var je = Qi(vt, pe), bt = Qi(vt, pe, $e);
        // Of course use larger one
        je > Wt || je === Wt && (!et || // Choose recommend one
        bt >= lt) ? (v.current.tb = !0, _t = pe, Be = -Be, ut.points = [_d(Ge, 0), _d(De, 0)]) : v.current.tb = !1;
      }
      var It = cr(Bt), Lt = Ge[1] === De[1];
      if (It && Ge[1] === "l" && (Kt > Y.right || v.current.rl)) {
        var Ht = vt;
        Lt ? Ht -= Ne - Me : Ht = Ct.x - xt.x - pt;
        var on = Qi(Ht, _t), sn = Qi(Ht, _t, $e);
        // Of course use larger one
        on > Wt || on === Wt && (!et || // Choose recommend one
        sn >= lt) ? (v.current.rl = !0, vt = Ht, pt = -pt, ut.points = [_d(Ge, 1), _d(De, 1)]) : v.current.rl = !1;
      }
      if (It && Ge[1] === "r" && (yt < Y.left || v.current.lr)) {
        var Rn = vt;
        Lt ? Rn += Ne - Me : Rn = Nn.x - un.x - pt;
        var Vn = Qi(Rn, _t), Kn = Qi(Rn, _t, $e);
        // Of course use larger one
        Vn > Wt || Vn === Wt && (!et || // Choose recommend one
        Kn >= lt) ? (v.current.lr = !0, vt = Rn, pt = -pt, ut.points = [_d(Ge, 1), _d(De, 1)]) : v.current.lr = !1;
      }
      ha();
      var Zn = vn === !0 ? 0 : vn;
      typeof Zn == "number" && (yt < $e.left && (vt -= yt - $e.left - pt, B.x + Me < $e.left + Zn && (vt += B.x - $e.left + Me - Zn)), Kt > $e.right && (vt -= Kt - $e.right - pt, B.x > $e.right - Zn && (vt += B.x - $e.right + Zn)));
      var Jt = Mn === !0 ? 0 : Mn;
      typeof Jt == "number" && (ge < $e.top && (_t -= ge - $e.top - Be, B.y + xe < $e.top + Jt && (_t += B.y - $e.top + xe - Jt)), it > $e.bottom && (_t -= it - $e.bottom - Be, B.y > $e.bottom - Jt && (_t += B.y - $e.bottom + Jt)));
      var Nt = V.x + vt, rr = Nt + Ne, hn = V.y + _t, Tn = hn + ve, Xr = B.x, ur = Xr + Me, cn = B.y, en = cn + xe, gr = Math.max(Nt, Xr), qr = Math.min(rr, ur), Pn = (gr + qr) / 2, Fr = Pn - Nt, Sr = Math.max(hn, cn), Oi = Math.min(Tn, en), fa = (Sr + Oi) / 2, Za = fa - hn;
      o == null || o(e, ut);
      var Pi = Se.right - V.x - (vt + V.width), Wi = Se.bottom - V.y - (_t + V.height);
      Oe === 1 && (vt = Math.round(vt), Pi = Math.round(Pi)), Pe === 1 && (_t = Math.round(_t), Wi = Math.round(Wi));
      var yo = {
        ready: !0,
        offsetX: vt / Oe,
        offsetY: _t / Pe,
        offsetR: Pi / Oe,
        offsetB: Wi / Pe,
        arrowX: Fr / Oe,
        arrowY: Za / Pe,
        scaleX: Oe,
        scaleY: Pe,
        align: ut
      };
      f(yo);
    }
  }), S = function() {
    p.current += 1;
    var C = p.current;
    Promise.resolve().then(function() {
      p.current === C && E();
    });
  }, _ = function() {
    f(function(C) {
      return ke(ke({}, C), {}, {
        ready: !1
      });
    });
  };
  return ti(_, [r]), ti(function() {
    n || _();
  }, [n]), [d.ready, d.offsetX, d.offsetY, d.offsetR, d.offsetB, d.arrowX, d.arrowY, d.scaleX, d.scaleY, d.align, S];
}
function rZ(n, e, t, r, i) {
  ti(function() {
    if (n && e && t) {
      let p = function() {
        r(), i();
      };
      var a = e, o = t, s = FR(a), u = FR(o), d = C0(o), f = new Set([d].concat(jt(s), jt(u)));
      return f.forEach(function(g) {
        g.addEventListener("scroll", p, {
          passive: !0
        });
      }), d.addEventListener("resize", p, {
        passive: !0
      }), r(), function() {
        f.forEach(function(g) {
          g.removeEventListener("scroll", p), d.removeEventListener("resize", p);
        });
      };
    }
  }, [n, e, t]);
}
function iZ(n, e, t, r, i, a, o, s) {
  var u = O.useRef(n);
  u.current = n, O.useEffect(function() {
    if (e && r && (!i || a)) {
      var d = function(_) {
        var w = _.target;
        u.current && !o(w) && s(!1);
      }, f = C0(r);
      f.addEventListener("mousedown", d, !0), f.addEventListener("contextmenu", d, !0);
      var p = hx(t);
      if (p && (p.addEventListener("mousedown", d, !0), p.addEventListener("contextmenu", d, !0)), Ee.env.NODE_ENV !== "production") {
        var g, v, b = t == null || (g = t.getRootNode) === null || g === void 0 ? void 0 : g.call(t), E = (v = r.getRootNode) === null || v === void 0 ? void 0 : v.call(r);
        Th(b === E, "trigger element and popup element should in same shadow root.");
      }
      return function() {
        f.removeEventListener("mousedown", d, !0), f.removeEventListener("contextmenu", d, !0), p && (p.removeEventListener("mousedown", d, !0), p.removeEventListener("contextmenu", d, !0));
      };
    }
  }, [e, t, r, i, a]);
}
var aZ = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
function oZ() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : GA, e = /* @__PURE__ */ O.forwardRef(function(t, r) {
    var i = t.prefixCls, a = i === void 0 ? "rc-trigger-popup" : i, o = t.children, s = t.action, u = s === void 0 ? "hover" : s, d = t.showAction, f = t.hideAction, p = t.popupVisible, g = t.defaultPopupVisible, v = t.onPopupVisibleChange, b = t.afterPopupVisibleChange, E = t.mouseEnterDelay, S = t.mouseLeaveDelay, _ = S === void 0 ? 0.1 : S, w = t.focusDelay, C = t.blurDelay, R = t.mask, P = t.maskClosable, D = P === void 0 ? !0 : P, I = t.getPopupContainer, U = t.forceRender, L = t.autoDestroy, N = t.destroyPopupOnHide, H = t.popup, j = t.popupClassName, G = t.popupStyle, X = t.popupPlacement, ae = t.builtinPlacements, Z = ae === void 0 ? {} : ae, K = t.popupAlign, B = t.zIndex, Q = t.stretch, V = t.getPopupClassNameFromAlign, q = t.fresh, ne = t.alignPoint, ce = t.onPopupClick, ie = t.onPopupAlign, oe = t.arrow, he = t.popupMotion, le = t.maskMotion, ve = t.popupTransitionName, Ne = t.popupAnimation, xe = t.maskTransitionName, Me = t.maskAnimation, $ = t.className, Te = t.getTriggerDOMNode, se = br(t, aZ), Ie = L || N || !1, be = O.useState(!1), et = ot(be, 2), Xe = et[0], $e = et[1];
    ti(function() {
      $e(JA());
    }, []);
    var te = O.useRef({}), Y = O.useContext(K2), Se = O.useMemo(function() {
      return {
        registerSubPopup: function(nn, Br) {
          te.current[nn] = Br, Y == null || Y.registerSubPopup(nn, Br);
        }
      };
    }, [Y]), Oe = aY(), Pe = O.useState(null), Ve = ot(Pe, 2), Ze = Ve[0], nt = Ve[1], ht = O.useRef(null), pt = Yi(function(ln) {
      ht.current = ln, zy(ln) && Ze !== ln && nt(ln), Y == null || Y.registerSubPopup(Oe, ln);
    }), Be = O.useState(null), ye = ot(Be, 2), Ue = ye[0], Ye = ye[1], tt = O.useRef(null), st = Yi(function(ln) {
      zy(ln) && Ue !== ln && (Ye(ln), tt.current = ln);
    }), Tt = O.Children.only(o), Rt = (Tt == null ? void 0 : Tt.props) || {}, ue = {}, De = Yi(function(ln) {
      var nn, Br, ui = Ue;
      return (ui == null ? void 0 : ui.contains(ln)) || ((nn = hx(ui)) === null || nn === void 0 ? void 0 : nn.host) === ln || ln === ui || (Ze == null ? void 0 : Ze.contains(ln)) || ((Br = hx(Ze)) === null || Br === void 0 ? void 0 : Br.host) === ln || ln === Ze || Object.values(te.current).some(function(Hr) {
        return (Hr == null ? void 0 : Hr.contains(ln)) || ln === Hr;
      });
    }), Ge = Q2(a, he, Ne, ve), We = Q2(a, le, Me, xe), He = O.useState(g || !1), ut = ot(He, 2), vt = ut[0], _t = ut[1], Wt = p ?? vt, lt = Yi(function(ln) {
      p === void 0 && _t(ln);
    });
    ti(function() {
      _t(p || !1);
    }, [p]);
    var Ct = O.useRef(Wt);
    Ct.current = Wt;
    var un = O.useRef([]);
    un.current = [];
    var Nn = Yi(function(ln) {
      var nn;
      lt(ln), ((nn = un.current[un.current.length - 1]) !== null && nn !== void 0 ? nn : Wt) !== ln && (un.current.push(ln), v == null || v(ln));
    }), xt = O.useRef(), Pt = function() {
      clearTimeout(xt.current);
    }, Bt = function(nn) {
      var Br = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      Pt(), Br === 0 ? Nn(nn) : xt.current = setTimeout(function() {
        Nn(nn);
      }, Br * 1e3);
    };
    O.useEffect(function() {
      return Pt;
    }, []);
    var Qt = O.useState(!1), vn = ot(Qt, 2), Mn = vn[0], cr = vn[1];
    ti(function(ln) {
      (!ln || Wt) && cr(!0);
    }, [Wt]);
    var ge = O.useState(null), it = ot(ge, 2), yt = it[0], Kt = it[1], Sn = O.useState([0, 0]), ee = ot(Sn, 2), _e = ee[0], Ae = ee[1], Ce = function(nn) {
      Ae([nn.clientX, nn.clientY]);
    }, pe = nZ(Wt, Ze, ne ? _e : Ue, X, Z, K, ie), je = ot(pe, 11), bt = je[0], It = je[1], Lt = je[2], Ht = je[3], on = je[4], sn = je[5], Rn = je[6], Vn = je[7], Kn = je[8], Zn = je[9], Jt = je[10], Nt = JK(Xe, u, d, f), rr = ot(Nt, 2), hn = rr[0], Tn = rr[1], Xr = hn.has("click"), ur = Tn.has("click") || Tn.has("contextMenu"), cn = Yi(function() {
      Mn || Jt();
    }), en = function() {
      Ct.current && ne && ur && Bt(!1);
    };
    rZ(Wt, Ue, Ze, cn, en), ti(function() {
      cn();
    }, [_e, X]), ti(function() {
      Wt && !(Z != null && Z[X]) && cn();
    }, [JSON.stringify(K)]);
    var gr = O.useMemo(function() {
      var ln = tZ(Z, a, Zn, ne);
      return Et(ln, V == null ? void 0 : V(Zn));
    }, [Zn, V, Z, a, ne]);
    O.useImperativeHandle(r, function() {
      return {
        nativeElement: tt.current,
        popupElement: ht.current,
        forceAlign: cn
      };
    });
    var qr = O.useState(0), Pn = ot(qr, 2), Fr = Pn[0], Sr = Pn[1], Oi = O.useState(0), fa = ot(Oi, 2), Za = fa[0], Pi = fa[1], Wi = function() {
      if (Q && Ue) {
        var nn = Ue.getBoundingClientRect();
        Sr(nn.width), Pi(nn.height);
      }
    }, yo = function() {
      Wi(), cn();
    }, Qi = function(nn) {
      cr(!1), Jt(), b == null || b(nn);
    }, ha = function() {
      return new Promise(function(nn) {
        Wi(), Kt(function() {
          return nn;
        });
      });
    };
    ti(function() {
      yt && (Jt(), yt(), Kt(null));
    }, [yt]);
    function _a(ln, nn, Br, ui) {
      ue[ln] = function(Hr) {
        var Tu;
        ui == null || ui(Hr), Bt(nn, Br);
        for (var Il = arguments.length, Qa = new Array(Il > 1 ? Il - 1 : 0), Ru = 1; Ru < Il; Ru++)
          Qa[Ru - 1] = arguments[Ru];
        (Tu = Rt[ln]) === null || Tu === void 0 || Tu.call.apply(Tu, [Rt, Hr].concat(Qa));
      };
    }
    (Xr || ur) && (ue.onClick = function(ln) {
      var nn;
      Ct.current && ur ? Bt(!1) : !Ct.current && Xr && (Ce(ln), Bt(!0));
      for (var Br = arguments.length, ui = new Array(Br > 1 ? Br - 1 : 0), Hr = 1; Hr < Br; Hr++)
        ui[Hr - 1] = arguments[Hr];
      (nn = Rt.onClick) === null || nn === void 0 || nn.call.apply(nn, [Rt, ln].concat(ui));
    }), iZ(Wt, ur, Ue, Ze, R, D, De, Bt);
    var ri = hn.has("hover"), vs = Tn.has("hover"), bo, vc;
    ri && (_a("onMouseEnter", !0, E, function(ln) {
      Ce(ln);
    }), _a("onPointerEnter", !0, E, function(ln) {
      Ce(ln);
    }), bo = function(nn) {
      (Wt || Mn) && Ze !== null && Ze !== void 0 && Ze.contains(nn.target) && Bt(!0, E);
    }, ne && (ue.onMouseMove = function(ln) {
      var nn;
      (nn = Rt.onMouseMove) === null || nn === void 0 || nn.call(Rt, ln);
    })), vs && (_a("onMouseLeave", !1, _), _a("onPointerLeave", !1, _), vc = function() {
      Bt(!1, _);
    }), hn.has("focus") && _a("onFocus", !0, w), Tn.has("focus") && _a("onBlur", !1, C), hn.has("contextMenu") && (ue.onContextMenu = function(ln) {
      var nn;
      Ct.current && Tn.has("contextMenu") ? Bt(!1) : (Ce(ln), Bt(!0)), ln.preventDefault();
      for (var Br = arguments.length, ui = new Array(Br > 1 ? Br - 1 : 0), Hr = 1; Hr < Br; Hr++)
        ui[Hr - 1] = arguments[Hr];
      (nn = Rt.onContextMenu) === null || nn === void 0 || nn.call.apply(nn, [Rt, ln].concat(ui));
    }), $ && (ue.className = Et(Rt.className, $));
    var Ys = ke(ke({}, Rt), ue), Qn = {}, wu = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    wu.forEach(function(ln) {
      se[ln] && (Qn[ln] = function() {
        for (var nn, Br = arguments.length, ui = new Array(Br), Hr = 0; Hr < Br; Hr++)
          ui[Hr] = arguments[Hr];
        (nn = Ys[ln]) === null || nn === void 0 || nn.call.apply(nn, [Ys].concat(ui)), se[ln].apply(se, ui);
      });
    });
    var So = /* @__PURE__ */ O.cloneElement(Tt, ke(ke({}, Ys), Qn)), Mu = {
      x: sn,
      y: Rn
    }, Zd = oe ? ke({}, oe !== !0 ? oe : {}) : null;
    return /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement(Su, {
      disabled: !Wt,
      ref: st,
      onResize: yo
    }, /* @__PURE__ */ O.createElement(hH, {
      getTriggerDOMNode: Te
    }, So)), /* @__PURE__ */ O.createElement(K2.Provider, {
      value: Se
    }, /* @__PURE__ */ O.createElement(fH, {
      portal: n,
      ref: pt,
      prefixCls: a,
      popup: H,
      className: Et(j, gr),
      style: G,
      target: Ue,
      onMouseEnter: bo,
      onMouseLeave: vc,
      onPointerEnter: bo,
      zIndex: B,
      open: Wt,
      keepDom: Mn,
      fresh: q,
      onClick: ce,
      mask: R,
      motion: Ge,
      maskMotion: We,
      onVisibleChanged: Qi,
      onPrepare: ha,
      forceRender: U,
      autoDestroy: Ie,
      getPopupContainer: I,
      align: Zn,
      arrow: Zd,
      arrowPos: Mu,
      ready: bt,
      offsetX: It,
      offsetY: Lt,
      offsetR: Ht,
      offsetB: on,
      onAlign: cn,
      stretch: Q,
      targetWidth: Fr / Vn,
      targetHeight: Za / Kn
    })));
  });
  return Ee.env.NODE_ENV !== "production" && (e.displayName = "Trigger"), e;
}
const pH = oZ(GA);
var sZ = ["prefixCls", "disabled", "visible", "children", "popupElement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"], lZ = function(e) {
  var t = e === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      },
      htmlRegion: "scroll"
    }
  };
}, cZ = function(e, t) {
  var r = e.prefixCls;
  e.disabled;
  var i = e.visible, a = e.children, o = e.popupElement, s = e.animation, u = e.transitionName, d = e.dropdownStyle, f = e.dropdownClassName, p = e.direction, g = p === void 0 ? "ltr" : p, v = e.placement, b = e.builtinPlacements, E = e.dropdownMatchSelectWidth, S = e.dropdownRender, _ = e.dropdownAlign, w = e.getPopupContainer, C = e.empty, R = e.getTriggerDOMNode, P = e.onPopupVisibleChange, D = e.onPopupMouseEnter, I = br(e, sZ), U = "".concat(r, "-dropdown"), L = o;
  S && (L = S(o));
  var N = O.useMemo(function() {
    return b || lZ(E);
  }, [b, E]), H = s ? "".concat(U, "-").concat(s) : u, j = typeof E == "number", G = O.useMemo(function() {
    return j ? null : E === !1 ? "minWidth" : "width";
  }, [E, j]), X = d;
  j && (X = ke(ke({}, X), {}, {
    width: E
  }));
  var ae = O.useRef(null);
  return O.useImperativeHandle(t, function() {
    return {
      getPopupElement: function() {
        var K;
        return (K = ae.current) === null || K === void 0 ? void 0 : K.popupElement;
      }
    };
  }), /* @__PURE__ */ O.createElement(pH, gn({}, I, {
    showAction: P ? ["click"] : [],
    hideAction: P ? ["click"] : [],
    popupPlacement: v || (g === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: N,
    prefixCls: U,
    popupTransitionName: H,
    popup: /* @__PURE__ */ O.createElement("div", {
      onMouseEnter: D
    }, L),
    ref: ae,
    stretch: G,
    popupAlign: _,
    popupVisible: i,
    getPopupContainer: w,
    popupClassName: Et(f, Re({}, "".concat(U, "-empty"), C)),
    popupStyle: X,
    getTriggerDOMNode: R,
    onPopupVisibleChange: P
  }), a);
}, mH = /* @__PURE__ */ O.forwardRef(cZ);
Ee.env.NODE_ENV !== "production" && (mH.displayName = "SelectTrigger");
function rL(n, e) {
  var t = n.key, r;
  return "value" in n && (r = n.value), t ?? (r !== void 0 ? r : "rc-index-key-".concat(e));
}
function UR(n) {
  return typeof n < "u" && !Number.isNaN(n);
}
function gH(n, e) {
  var t = n || {}, r = t.label, i = t.value, a = t.options, o = t.groupLabel, s = r || (e ? "children" : "label");
  return {
    label: s,
    value: i || "value",
    options: a || "options",
    groupLabel: o || s
  };
}
function uZ(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = e.fieldNames, r = e.childrenAsData, i = [], a = gH(t, !1), o = a.label, s = a.value, u = a.options, d = a.groupLabel;
  function f(p, g) {
    Array.isArray(p) && p.forEach(function(v) {
      if (g || !(u in v)) {
        var b = v[s];
        i.push({
          key: rL(v, i.length),
          groupOption: g,
          data: v,
          label: v[o],
          value: b
        });
      } else {
        var E = v[d];
        E === void 0 && r && (E = v.label), i.push({
          key: rL(v, i.length),
          group: !0,
          data: v,
          label: E
        }), f(v[u], !0);
      }
    });
  }
  return f(n, !1), i;
}
function zR(n) {
  var e = ke({}, n);
  return "props" in e || Object.defineProperty(e, "props", {
    get: function() {
      return Yn(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), e;
    }
  }), e;
}
var dZ = function(e, t, r) {
  if (!t || !t.length)
    return null;
  var i = !1, a = function s(u, d) {
    var f = Uz(d), p = f[0], g = f.slice(1);
    if (!p)
      return [u];
    var v = u.split(p);
    return i = i || v.length > 1, v.reduce(function(b, E) {
      return [].concat(jt(b), jt(s(E, g)));
    }, []).filter(Boolean);
  }, o = a(e, t);
  return i ? typeof r < "u" ? o.slice(0, r) : o : null;
}, nO = /* @__PURE__ */ O.createContext(null);
function fZ(n) {
  var e = n.visible, t = n.values;
  if (!e)
    return null;
  var r = 50;
  return /* @__PURE__ */ O.createElement("span", {
    "aria-live": "polite",
    style: {
      width: 0,
      height: 0,
      position: "absolute",
      overflow: "hidden",
      opacity: 0
    }
  }, "".concat(t.slice(0, r).map(function(i) {
    var a = i.label, o = i.value;
    return ["number", "string"].includes(bn(a)) ? a : o;
  }).join(", ")), t.length > r ? ", ..." : null);
}
var hZ = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "suffixIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"], pZ = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"], vx = function(e) {
  return e === "tags" || e === "multiple";
}, vH = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t, r = n.id, i = n.prefixCls, a = n.className, o = n.showSearch, s = n.tagRender, u = n.direction, d = n.omitDomProps, f = n.displayValues, p = n.onDisplayValuesChange, g = n.emptyOptions, v = n.notFoundContent, b = v === void 0 ? "Not Found" : v, E = n.onClear, S = n.mode, _ = n.disabled, w = n.loading, C = n.getInputElement, R = n.getRawInputElement, P = n.open, D = n.defaultOpen, I = n.onDropdownVisibleChange, U = n.activeValue, L = n.onActiveValueChange, N = n.activeDescendantId, H = n.searchValue, j = n.autoClearSearchValue, G = n.onSearch, X = n.onSearchSplit, ae = n.tokenSeparators, Z = n.allowClear, K = n.suffixIcon, B = n.clearIcon, Q = n.OptionList, V = n.animation, q = n.transitionName, ne = n.dropdownStyle, ce = n.dropdownClassName, ie = n.dropdownMatchSelectWidth, oe = n.dropdownRender, he = n.dropdownAlign, le = n.placement, ve = n.builtinPlacements, Ne = n.getPopupContainer, xe = n.showAction, Me = xe === void 0 ? [] : xe, $ = n.onFocus, Te = n.onBlur, se = n.onKeyUp, Ie = n.onKeyDown, be = n.onMouseDown, et = br(n, hZ), Xe = vx(S), $e = (o !== void 0 ? o : Xe) || S === "combobox", te = ke({}, et);
  pZ.forEach(function(cn) {
    delete te[cn];
  }), d == null || d.forEach(function(cn) {
    delete te[cn];
  });
  var Y = O.useState(!1), Se = ot(Y, 2), Oe = Se[0], Pe = Se[1];
  O.useEffect(function() {
    Pe(JA());
  }, []);
  var Ve = O.useRef(null), Ze = O.useRef(null), nt = O.useRef(null), ht = O.useRef(null), pt = O.useRef(null), Be = O.useRef(!1), ye = TK(), Ue = ot(ye, 3), Ye = Ue[0], tt = Ue[1], st = Ue[2];
  O.useImperativeHandle(e, function() {
    var cn, en;
    return {
      focus: (cn = ht.current) === null || cn === void 0 ? void 0 : cn.focus,
      blur: (en = ht.current) === null || en === void 0 ? void 0 : en.blur,
      scrollTo: function(qr) {
        var Pn;
        return (Pn = pt.current) === null || Pn === void 0 ? void 0 : Pn.scrollTo(qr);
      },
      nativeElement: Ve.current || Ze.current
    };
  });
  var Tt = O.useMemo(function() {
    var cn;
    if (S !== "combobox")
      return H;
    var en = (cn = f[0]) === null || cn === void 0 ? void 0 : cn.value;
    return typeof en == "string" || typeof en == "number" ? String(en) : "";
  }, [H, S, f]), Rt = S === "combobox" && typeof C == "function" && C() || null, ue = typeof R == "function" && R(), De = dE(Ze, ue == null || (t = ue.props) === null || t === void 0 ? void 0 : t.ref), Ge = O.useState(!1), We = ot(Ge, 2), He = We[0], ut = We[1];
  ti(function() {
    ut(!0);
  }, []);
  var vt = ko(!1, {
    defaultValue: D,
    value: P
  }), _t = ot(vt, 2), Wt = _t[0], lt = _t[1], Ct = He ? Wt : !1, un = !b && g;
  (_ || un && Ct && S === "combobox") && (Ct = !1);
  var Nn = un ? !1 : Ct, xt = O.useCallback(function(cn) {
    var en = cn !== void 0 ? cn : !Ct;
    _ || (lt(en), Ct !== en && (I == null || I(en)));
  }, [_, Ct, lt, I]), Pt = O.useMemo(function() {
    return (ae || []).some(function(cn) {
      return [`
`, `\r
`].includes(cn);
    });
  }, [ae]), Bt = O.useContext(nO) || {}, Qt = Bt.maxCount, vn = Bt.rawValues, Mn = function(en, gr, qr) {
    if (!(Xe && UR(Qt) && (vn == null ? void 0 : vn.size) >= Qt)) {
      var Pn = !0, Fr = en;
      L == null || L(null);
      var Sr = dZ(en, ae, UR(Qt) ? Qt - vn.size : void 0), Oi = qr ? null : Sr;
      return S !== "combobox" && Oi && (Fr = "", X == null || X(Oi), xt(!1), Pn = !1), G && Tt !== Fr && G(Fr, {
        source: gr ? "typing" : "effect"
      }), Pn;
    }
  }, cr = function(en) {
    !en || !en.trim() || G(en, {
      source: "submit"
    });
  };
  O.useEffect(function() {
    !Ct && !Xe && S !== "combobox" && Mn("", !1, !1);
  }, [Ct]), O.useEffect(function() {
    Wt && _ && lt(!1), _ && !Be.current && tt(!1);
  }, [_]);
  var ge = aH(), it = ot(ge, 2), yt = it[0], Kt = it[1], Sn = function(en) {
    var gr = yt(), qr = en.which;
    if (qr === Ft.ENTER && (S !== "combobox" && en.preventDefault(), Ct || xt(!0)), Kt(!!Tt), qr === Ft.BACKSPACE && !gr && Xe && !Tt && f.length) {
      for (var Pn = jt(f), Fr = null, Sr = Pn.length - 1; Sr >= 0; Sr -= 1) {
        var Oi = Pn[Sr];
        if (!Oi.disabled) {
          Pn.splice(Sr, 1), Fr = Oi;
          break;
        }
      }
      Fr && p(Pn, {
        type: "remove",
        values: [Fr]
      });
    }
    for (var fa = arguments.length, Za = new Array(fa > 1 ? fa - 1 : 0), Pi = 1; Pi < fa; Pi++)
      Za[Pi - 1] = arguments[Pi];
    if (Ct) {
      var Wi;
      (Wi = pt.current) === null || Wi === void 0 || Wi.onKeyDown.apply(Wi, [en].concat(Za));
    }
    Ie == null || Ie.apply(void 0, [en].concat(Za));
  }, ee = function(en) {
    for (var gr = arguments.length, qr = new Array(gr > 1 ? gr - 1 : 0), Pn = 1; Pn < gr; Pn++)
      qr[Pn - 1] = arguments[Pn];
    if (Ct) {
      var Fr;
      (Fr = pt.current) === null || Fr === void 0 || Fr.onKeyUp.apply(Fr, [en].concat(qr));
    }
    se == null || se.apply(void 0, [en].concat(qr));
  }, _e = function(en) {
    var gr = f.filter(function(qr) {
      return qr !== en;
    });
    p(gr, {
      type: "remove",
      values: [en]
    });
  }, Ae = O.useRef(!1), Ce = function() {
    tt(!0), _ || ($ && !Ae.current && $.apply(void 0, arguments), Me.includes("focus") && xt(!0)), Ae.current = !0;
  }, pe = function() {
    Be.current = !0, tt(!1, function() {
      Ae.current = !1, Be.current = !1, xt(!1);
    }), !_ && (Tt && (S === "tags" ? G(Tt, {
      source: "submit"
    }) : S === "multiple" && G("", {
      source: "blur"
    })), Te && Te.apply(void 0, arguments));
  }, je = [];
  O.useEffect(function() {
    return function() {
      je.forEach(function(cn) {
        return clearTimeout(cn);
      }), je.splice(0, je.length);
    };
  }, []);
  var bt = function(en) {
    var gr, qr = en.target, Pn = (gr = nt.current) === null || gr === void 0 ? void 0 : gr.getPopupElement();
    if (Pn && Pn.contains(qr)) {
      var Fr = setTimeout(function() {
        var Za = je.indexOf(Fr);
        if (Za !== -1 && je.splice(Za, 1), st(), !Oe && !Pn.contains(document.activeElement)) {
          var Pi;
          (Pi = ht.current) === null || Pi === void 0 || Pi.focus();
        }
      });
      je.push(Fr);
    }
    for (var Sr = arguments.length, Oi = new Array(Sr > 1 ? Sr - 1 : 0), fa = 1; fa < Sr; fa++)
      Oi[fa - 1] = arguments[fa];
    be == null || be.apply(void 0, [en].concat(Oi));
  }, It = O.useState({}), Lt = ot(It, 2), Ht = Lt[1];
  function on() {
    Ht({});
  }
  var sn;
  ue && (sn = function(en) {
    xt(en);
  }), RK(function() {
    var cn;
    return [Ve.current, (cn = nt.current) === null || cn === void 0 ? void 0 : cn.getPopupElement()];
  }, Nn, xt, !!ue);
  var Rn = O.useMemo(function() {
    return ke(ke({}, n), {}, {
      notFoundContent: b,
      open: Ct,
      triggerOpen: Nn,
      id: r,
      showSearch: $e,
      multiple: Xe,
      toggleOpen: xt
    });
  }, [n, b, Nn, Ct, r, $e, Xe, xt]), Vn = !!K || w, Kn;
  Vn && (Kn = /* @__PURE__ */ O.createElement(CE, {
    className: Et("".concat(i, "-arrow"), Re({}, "".concat(i, "-arrow-loading"), w)),
    customizeIcon: K,
    customizeIconProps: {
      loading: w,
      searchValue: Tt,
      open: Ct,
      focused: Ye,
      showSearch: $e
    }
  }));
  var Zn = function() {
    var en;
    E == null || E(), (en = ht.current) === null || en === void 0 || en.focus(), p([], {
      type: "clear",
      values: f
    }), Mn("", !1, !1);
  }, Jt = wK(i, Zn, f, Z, B, _, Tt, S), Nt = Jt.allowClear, rr = Jt.clearIcon, hn = /* @__PURE__ */ O.createElement(Q, {
    ref: pt
  }), Tn = Et(i, a, Re(Re(Re(Re(Re(Re(Re(Re(Re(Re({}, "".concat(i, "-focused"), Ye), "".concat(i, "-multiple"), Xe), "".concat(i, "-single"), !Xe), "".concat(i, "-allow-clear"), Z), "".concat(i, "-show-arrow"), Vn), "".concat(i, "-disabled"), _), "".concat(i, "-loading"), w), "".concat(i, "-open"), Ct), "".concat(i, "-customize-input"), Rt), "".concat(i, "-show-search"), $e)), Xr = /* @__PURE__ */ O.createElement(mH, {
    ref: nt,
    disabled: _,
    prefixCls: i,
    visible: Nn,
    popupElement: hn,
    animation: V,
    transitionName: q,
    dropdownStyle: ne,
    dropdownClassName: ce,
    direction: u,
    dropdownMatchSelectWidth: ie,
    dropdownRender: oe,
    dropdownAlign: he,
    placement: le,
    builtinPlacements: ve,
    getPopupContainer: Ne,
    empty: g,
    getTriggerDOMNode: function(en) {
      return (
        // TODO: This is workaround and should be removed in `rc-select`
        // And use new standard `nativeElement` for ref.
        // But we should update `rc-resize-observer` first.
        Ze.current || en
      );
    },
    onPopupVisibleChange: sn,
    onPopupMouseEnter: on
  }, ue ? /* @__PURE__ */ O.cloneElement(ue, {
    ref: De
  }) : /* @__PURE__ */ O.createElement(uH, gn({}, n, {
    domRef: Ze,
    prefixCls: i,
    inputElement: Rt,
    ref: ht,
    id: r,
    showSearch: $e,
    autoClearSearchValue: j,
    mode: S,
    activeDescendantId: N,
    tagRender: s,
    values: f,
    open: Ct,
    onToggleOpen: xt,
    activeValue: U,
    searchValue: Tt,
    onSearch: Mn,
    onSearchSubmit: cr,
    onRemove: _e,
    tokenWithEnter: Pt
  }))), ur;
  return ue ? ur = Xr : ur = /* @__PURE__ */ O.createElement("div", gn({
    className: Tn
  }, te, {
    ref: Ve,
    onMouseDown: bt,
    onKeyDown: Sn,
    onKeyUp: ee,
    onFocus: Ce,
    onBlur: pe
  }), /* @__PURE__ */ O.createElement(fZ, {
    visible: Ye && !Ct,
    values: f
  }), Xr, Kn, Nt && rr), /* @__PURE__ */ O.createElement(iH.Provider, {
    value: Rn
  }, ur);
});
Ee.env.NODE_ENV !== "production" && (vH.displayName = "BaseSelect");
var rO = function() {
  return null;
};
rO.isSelectOptGroup = !0;
var iO = function() {
  return null;
};
iO.isSelectOption = !0;
var yH = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.height, r = n.offsetY, i = n.offsetX, a = n.children, o = n.prefixCls, s = n.onInnerResize, u = n.innerProps, d = n.rtl, f = n.extra, p = {}, g = {
    display: "flex",
    flexDirection: "column"
  };
  return r !== void 0 && (p = {
    height: t,
    position: "relative",
    overflow: "hidden"
  }, g = ke(ke({}, g), {}, Re(Re(Re(Re(Re({
    transform: "translateY(".concat(r, "px)")
  }, d ? "marginRight" : "marginLeft", -i), "position", "absolute"), "left", 0), "right", 0), "top", 0))), /* @__PURE__ */ O.createElement("div", {
    style: p
  }, /* @__PURE__ */ O.createElement(Su, {
    onResize: function(b) {
      var E = b.offsetHeight;
      E && s && s();
    }
  }, /* @__PURE__ */ O.createElement("div", gn({
    style: g,
    className: Et(Re({}, "".concat(o, "-holder-inner"), o)),
    ref: e
  }, u), a, f)));
});
yH.displayName = "Filler";
function mZ(n) {
  var e = n.children, t = n.setRef, r = O.useCallback(function(i) {
    t(i);
  }, []);
  return /* @__PURE__ */ O.cloneElement(e, {
    ref: r
  });
}
function gZ(n, e, t, r, i, a, o, s) {
  var u = s.getKey;
  return n.slice(e, t + 1).map(function(d, f) {
    var p = e + f, g = o(d, p, {
      style: {
        width: r
      },
      offsetX: i
    }), v = u(d);
    return /* @__PURE__ */ O.createElement(mZ, {
      key: v,
      setRef: function(E) {
        return a(d, E);
      }
    }, g);
  });
}
function vZ(n, e, t) {
  var r = n.length, i = e.length, a, o;
  if (r === 0 && i === 0)
    return null;
  r < i ? (a = n, o = e) : (a = e, o = n);
  var s = {
    __EMPTY_ITEM__: !0
  };
  function u(b) {
    return b !== void 0 ? t(b) : s;
  }
  for (var d = null, f = Math.abs(r - i) !== 1, p = 0; p < o.length; p += 1) {
    var g = u(a[p]), v = u(o[p]);
    if (g !== v) {
      d = p, f = f || g !== u(o[p + 1]);
      break;
    }
  }
  return d === null ? null : {
    index: d,
    multiple: f
  };
}
function yZ(n, e, t) {
  var r = O.useState(n), i = ot(r, 2), a = i[0], o = i[1], s = O.useState(null), u = ot(s, 2), d = u[0], f = u[1];
  return O.useEffect(function() {
    var p = vZ(a || [], n || [], e);
    (p == null ? void 0 : p.index) !== void 0 && f(n[p.index]), o(n);
  }, [n]), [d];
}
var iL = (typeof navigator > "u" ? "undefined" : bn(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const bH = function(n, e, t, r) {
  var i = kt(!1), a = kt(null);
  function o() {
    clearTimeout(a.current), i.current = !0, a.current = setTimeout(function() {
      i.current = !1;
    }, 50);
  }
  var s = kt({
    top: n,
    bottom: e,
    left: t,
    right: r
  });
  return s.current.top = n, s.current.bottom = e, s.current.left = t, s.current.right = r, function(u, d) {
    var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, p = u ? (
      // Pass origin wheel when on the left
      d < 0 && s.current.left || // Pass origin wheel when on the right
      d > 0 && s.current.right
    ) : d < 0 && s.current.top || // Pass origin wheel when on the bottom
    d > 0 && s.current.bottom;
    return f && p ? (clearTimeout(a.current), i.current = !1) : (!p || i.current) && o(), !i.current && p;
  };
};
function bZ(n, e, t, r, i, a, o) {
  var s = kt(0), u = kt(null), d = kt(null), f = kt(!1), p = bH(e, t, r, i);
  function g(w, C) {
    Wr.cancel(u.current), s.current += C, d.current = C, !p(!1, C) && (iL || w.preventDefault(), u.current = Wr(function() {
      var R = f.current ? 10 : 1;
      o(s.current * R), s.current = 0;
    }));
  }
  function v(w, C) {
    o(C, !0), iL || w.preventDefault();
  }
  var b = kt(null), E = kt(null);
  function S(w) {
    if (n) {
      Wr.cancel(E.current), E.current = Wr(function() {
        b.current = null;
      }, 2);
      var C = w.deltaX, R = w.deltaY, P = w.shiftKey, D = C, I = R;
      (b.current === "sx" || !b.current && P && R && !C) && (D = R, I = 0, b.current = "sx");
      var U = Math.abs(D), L = Math.abs(I);
      b.current === null && (b.current = a && U > L ? "x" : "y"), b.current === "y" ? g(w, I) : v(w, D);
    }
  }
  function _(w) {
    n && (f.current = w.detail === d.current);
  }
  return [S, _];
}
function SZ(n, e, t, r) {
  var i = O.useMemo(function() {
    return [/* @__PURE__ */ new Map(), []];
  }, [n, t.id, r]), a = ot(i, 2), o = a[0], s = a[1], u = function(f) {
    var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : f, g = o.get(f), v = o.get(p);
    if (g === void 0 || v === void 0)
      for (var b = n.length, E = s.length; E < b; E += 1) {
        var S, _ = n[E], w = e(_);
        o.set(w, E);
        var C = (S = t.get(w)) !== null && S !== void 0 ? S : r;
        if (s[E] = (s[E - 1] || 0) + C, w === f && (g = E), w === p && (v = E), g !== void 0 && v !== void 0)
          break;
      }
    return {
      top: s[g - 1] || 0,
      bottom: s[v]
    };
  };
  return u;
}
var _Z = /* @__PURE__ */ function() {
  function n() {
    ki(this, n), Re(this, "maps", void 0), Re(this, "id", 0), this.maps = /* @__PURE__ */ Object.create(null);
  }
  return $i(n, [{
    key: "set",
    value: function(t, r) {
      this.maps[t] = r, this.id += 1;
    }
  }, {
    key: "get",
    value: function(t) {
      return this.maps[t];
    }
  }]), n;
}();
function xZ(n, e, t) {
  var r = O.useState(0), i = ot(r, 2), a = i[0], o = i[1], s = kt(/* @__PURE__ */ new Map()), u = kt(new _Z()), d = kt();
  function f() {
    Wr.cancel(d.current);
  }
  function p() {
    var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    f();
    var b = function() {
      s.current.forEach(function(S, _) {
        if (S && S.offsetParent) {
          var w = by(S), C = w.offsetHeight;
          u.current.get(_) !== C && u.current.set(_, w.offsetHeight);
        }
      }), o(function(S) {
        return S + 1;
      });
    };
    v ? b() : d.current = Wr(b);
  }
  function g(v, b) {
    var E = n(v);
    s.current.get(E), b ? (s.current.set(E, b), p()) : s.current.delete(E);
  }
  return In(function() {
    return f;
  }, []), [g, p, u.current, a];
}
var aL = 14 / 15;
function EZ(n, e, t) {
  var r = kt(!1), i = kt(0), a = kt(0), o = kt(null), s = kt(null), u, d = function(v) {
    if (r.current) {
      var b = Math.ceil(v.touches[0].pageX), E = Math.ceil(v.touches[0].pageY), S = i.current - b, _ = a.current - E, w = Math.abs(S) > Math.abs(_);
      w ? i.current = b : a.current = E, t(w, w ? S : _) && v.preventDefault(), clearInterval(s.current), s.current = setInterval(function() {
        w ? S *= aL : _ *= aL;
        var C = Math.floor(w ? S : _);
        (!t(w, C, !0) || Math.abs(C) <= 0.1) && clearInterval(s.current);
      }, 16);
    }
  }, f = function() {
    r.current = !1, u();
  }, p = function(v) {
    u(), v.touches.length === 1 && !r.current && (r.current = !0, i.current = Math.ceil(v.touches[0].pageX), a.current = Math.ceil(v.touches[0].pageY), o.current = v.target, o.current.addEventListener("touchmove", d, {
      passive: !1
    }), o.current.addEventListener("touchend", f, {
      passive: !0
    }));
  };
  u = function() {
    o.current && (o.current.removeEventListener("touchmove", d), o.current.removeEventListener("touchend", f));
  }, ti(function() {
    return n && e.current.addEventListener("touchstart", p, {
      passive: !0
    }), function() {
      var g;
      (g = e.current) === null || g === void 0 || g.removeEventListener("touchstart", p), u(), clearInterval(s.current);
    };
  }, [n]);
}
var oL = 10;
function CZ(n, e, t, r, i, a, o, s) {
  var u = O.useRef(), d = O.useState(null), f = ot(d, 2), p = f[0], g = f[1];
  return ti(function() {
    if (p && p.times < oL) {
      if (!n.current) {
        g(function(Q) {
          return ke({}, Q);
        });
        return;
      }
      a();
      var v = p.targetAlign, b = p.originAlign, E = p.index, S = p.offset, _ = n.current.clientHeight, w = !1, C = v, R = null;
      if (_) {
        for (var P = v || b, D = 0, I = 0, U = 0, L = Math.min(e.length - 1, E), N = 0; N <= L; N += 1) {
          var H = i(e[N]);
          I = D;
          var j = t.get(H);
          U = I + (j === void 0 ? r : j), D = U;
        }
        for (var G = P === "top" ? S : _ - S, X = L; X >= 0; X -= 1) {
          var ae = i(e[X]), Z = t.get(ae);
          if (Z === void 0) {
            w = !0;
            break;
          }
          if (G -= Z, G <= 0)
            break;
        }
        switch (P) {
          case "top":
            R = I - S;
            break;
          case "bottom":
            R = U - _ + S;
            break;
          default: {
            var K = n.current.scrollTop, B = K + _;
            I < K ? C = "top" : U > B && (C = "bottom");
          }
        }
        R !== null && o(R), R !== p.lastTop && (w = !0);
      }
      w && g(ke(ke({}, p), {}, {
        times: p.times + 1,
        targetAlign: C,
        lastTop: R
      }));
    } else Ee.env.NODE_ENV !== "production" && (p == null ? void 0 : p.times) === oL && Yn(!1, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
  }, [p, n.current]), function(v) {
    if (v == null) {
      s();
      return;
    }
    if (Wr.cancel(u.current), typeof v == "number")
      o(v);
    else if (v && bn(v) === "object") {
      var b, E = v.align;
      "index" in v ? b = v.index : b = e.findIndex(function(w) {
        return i(w) === v.key;
      });
      var S = v.offset, _ = S === void 0 ? 0 : S;
      g({
        times: 0,
        index: b,
        offset: _,
        originAlign: E
      });
    }
  };
}
function sL(n, e) {
  var t = "touches" in n ? n.touches[0] : n;
  return t[e ? "pageX" : "pageY"];
}
var BR = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.prefixCls, r = n.rtl, i = n.scrollOffset, a = n.scrollRange, o = n.onStartMove, s = n.onStopMove, u = n.onScroll, d = n.horizontal, f = n.spinSize, p = n.containerSize, g = n.style, v = n.thumbStyle, b = O.useState(!1), E = ot(b, 2), S = E[0], _ = E[1], w = O.useState(null), C = ot(w, 2), R = C[0], P = C[1], D = O.useState(null), I = ot(D, 2), U = I[0], L = I[1], N = !r, H = O.useRef(), j = O.useRef(), G = O.useState(!1), X = ot(G, 2), ae = X[0], Z = X[1], K = O.useRef(), B = function() {
    clearTimeout(K.current), Z(!0), K.current = setTimeout(function() {
      Z(!1);
    }, 3e3);
  }, Q = a - p || 0, V = p - f || 0, q = O.useMemo(function() {
    if (i === 0 || Q === 0)
      return 0;
    var xe = i / Q;
    return xe * V;
  }, [i, Q, V]), ne = function(Me) {
    Me.stopPropagation(), Me.preventDefault();
  }, ce = O.useRef({
    top: q,
    dragging: S,
    pageY: R,
    startTop: U
  });
  ce.current = {
    top: q,
    dragging: S,
    pageY: R,
    startTop: U
  };
  var ie = function(Me) {
    _(!0), P(sL(Me, d)), L(ce.current.top), o(), Me.stopPropagation(), Me.preventDefault();
  };
  O.useEffect(function() {
    var xe = function(se) {
      se.preventDefault();
    }, Me = H.current, $ = j.current;
    return Me.addEventListener("touchstart", xe, {
      passive: !1
    }), $.addEventListener("touchstart", ie, {
      passive: !1
    }), function() {
      Me.removeEventListener("touchstart", xe), $.removeEventListener("touchstart", ie);
    };
  }, []);
  var oe = O.useRef();
  oe.current = Q;
  var he = O.useRef();
  he.current = V, O.useEffect(function() {
    if (S) {
      var xe, Me = function(se) {
        var Ie = ce.current, be = Ie.dragging, et = Ie.pageY, Xe = Ie.startTop;
        Wr.cancel(xe);
        var $e = H.current.getBoundingClientRect(), te = p / (d ? $e.width : $e.height);
        if (be) {
          var Y = (sL(se, d) - et) * te, Se = Xe;
          !N && d ? Se -= Y : Se += Y;
          var Oe = oe.current, Pe = he.current, Ve = Pe ? Se / Pe : 0, Ze = Math.ceil(Ve * Oe);
          Ze = Math.max(Ze, 0), Ze = Math.min(Ze, Oe), xe = Wr(function() {
            u(Ze, d);
          });
        }
      }, $ = function() {
        _(!1), s();
      };
      return window.addEventListener("mousemove", Me, {
        passive: !0
      }), window.addEventListener("touchmove", Me, {
        passive: !0
      }), window.addEventListener("mouseup", $, {
        passive: !0
      }), window.addEventListener("touchend", $, {
        passive: !0
      }), function() {
        window.removeEventListener("mousemove", Me), window.removeEventListener("touchmove", Me), window.removeEventListener("mouseup", $), window.removeEventListener("touchend", $), Wr.cancel(xe);
      };
    }
  }, [S]), O.useEffect(function() {
    return B(), function() {
      clearTimeout(K.current);
    };
  }, [i]), O.useImperativeHandle(e, function() {
    return {
      delayHidden: B
    };
  });
  var le = "".concat(t, "-scrollbar"), ve = {
    position: "absolute",
    visibility: ae ? null : "hidden"
  }, Ne = {
    position: "absolute",
    background: "rgba(0, 0, 0, 0.5)",
    borderRadius: 99,
    cursor: "pointer",
    userSelect: "none"
  };
  return d ? (ve.height = 8, ve.left = 0, ve.right = 0, ve.bottom = 0, Ne.height = "100%", Ne.width = f, N ? Ne.left = q : Ne.right = q) : (ve.width = 8, ve.top = 0, ve.bottom = 0, N ? ve.right = 0 : ve.left = 0, Ne.width = "100%", Ne.height = f, Ne.top = q), /* @__PURE__ */ O.createElement("div", {
    ref: H,
    className: Et(le, Re(Re(Re({}, "".concat(le, "-horizontal"), d), "".concat(le, "-vertical"), !d), "".concat(le, "-visible"), ae)),
    style: ke(ke({}, ve), g),
    onMouseDown: ne,
    onMouseMove: B
  }, /* @__PURE__ */ O.createElement("div", {
    ref: j,
    className: Et("".concat(le, "-thumb"), Re({}, "".concat(le, "-thumb-moving"), S)),
    style: ke(ke({}, Ne), v),
    onMouseDown: ie
  }));
});
Ee.env.NODE_ENV !== "production" && (BR.displayName = "ScrollBar");
var wZ = 20;
function lL() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = n / e * n;
  return isNaN(t) && (t = 0), t = Math.max(t, wZ), Math.floor(t);
}
var MZ = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles"], TZ = [], RZ = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function AZ(n, e) {
  var t = n.prefixCls, r = t === void 0 ? "rc-virtual-list" : t, i = n.className, a = n.height, o = n.itemHeight, s = n.fullHeight, u = s === void 0 ? !0 : s, d = n.style, f = n.data, p = n.children, g = n.itemKey, v = n.virtual, b = n.direction, E = n.scrollWidth, S = n.component, _ = S === void 0 ? "div" : S, w = n.onScroll, C = n.onVirtualScroll, R = n.onVisibleChange, P = n.innerProps, D = n.extraRender, I = n.styles, U = br(n, MZ), L = O.useCallback(function(Ce) {
    return typeof g == "function" ? g(Ce) : Ce == null ? void 0 : Ce[g];
  }, [g]), N = xZ(L), H = ot(N, 4), j = H[0], G = H[1], X = H[2], ae = H[3], Z = !!(v !== !1 && a && o), K = O.useMemo(function() {
    return Object.values(X.maps).reduce(function(Ce, pe) {
      return Ce + pe;
    }, 0);
  }, [X.id, X.maps]), B = Z && f && (Math.max(o * f.length, K) > a || !!E), Q = b === "rtl", V = Et(r, Re({}, "".concat(r, "-rtl"), Q), i), q = f || TZ, ne = kt(), ce = kt(), ie = kt(), oe = Lr(0), he = ot(oe, 2), le = he[0], ve = he[1], Ne = Lr(0), xe = ot(Ne, 2), Me = xe[0], $ = xe[1], Te = Lr(!1), se = ot(Te, 2), Ie = se[0], be = se[1], et = function() {
    be(!0);
  }, Xe = function() {
    be(!1);
  }, $e = {
    getKey: L
  };
  function te(Ce) {
    ve(function(pe) {
      var je;
      typeof Ce == "function" ? je = Ce(pe) : je = Ce;
      var bt = He(je);
      return ne.current.scrollTop = bt, bt;
    });
  }
  var Y = kt({
    start: 0,
    end: q.length
  }), Se = kt(), Oe = yZ(q, L), Pe = ot(Oe, 1), Ve = Pe[0];
  Se.current = Ve;
  var Ze = O.useMemo(function() {
    if (!Z)
      return {
        scrollHeight: void 0,
        start: 0,
        end: q.length - 1,
        offset: void 0
      };
    if (!B) {
      var Ce;
      return {
        scrollHeight: ((Ce = ce.current) === null || Ce === void 0 ? void 0 : Ce.offsetHeight) || 0,
        start: 0,
        end: q.length - 1,
        offset: void 0
      };
    }
    for (var pe = 0, je, bt, It, Lt = q.length, Ht = 0; Ht < Lt; Ht += 1) {
      var on = q[Ht], sn = L(on), Rn = X.get(sn), Vn = pe + (Rn === void 0 ? o : Rn);
      Vn >= le && je === void 0 && (je = Ht, bt = pe), Vn > le + a && It === void 0 && (It = Ht), pe = Vn;
    }
    return je === void 0 && (je = 0, bt = 0, It = Math.ceil(a / o)), It === void 0 && (It = q.length - 1), It = Math.min(It + 1, q.length - 1), {
      scrollHeight: pe,
      start: je,
      end: It,
      offset: bt
    };
  }, [B, Z, le, q, ae, a]), nt = Ze.scrollHeight, ht = Ze.start, pt = Ze.end, Be = Ze.offset;
  Y.current.start = ht, Y.current.end = pt;
  var ye = O.useState({
    width: 0,
    height: a
  }), Ue = ot(ye, 2), Ye = Ue[0], tt = Ue[1], st = function(pe) {
    tt({
      width: pe.offsetWidth,
      height: pe.offsetHeight
    });
  }, Tt = kt(), Rt = kt(), ue = O.useMemo(function() {
    return lL(Ye.width, E);
  }, [Ye.width, E]), De = O.useMemo(function() {
    return lL(Ye.height, nt);
  }, [Ye.height, nt]), Ge = nt - a, We = kt(Ge);
  We.current = Ge;
  function He(Ce) {
    var pe = Ce;
    return Number.isNaN(We.current) || (pe = Math.min(pe, We.current)), pe = Math.max(pe, 0), pe;
  }
  var ut = le <= 0, vt = le >= Ge, _t = Me <= 0, Wt = Me >= E, lt = bH(ut, vt, _t, Wt), Ct = function() {
    return {
      x: Q ? -Me : Me,
      y: le
    };
  }, un = kt(Ct()), Nn = Yi(function(Ce) {
    if (C) {
      var pe = ke(ke({}, Ct()), Ce);
      (un.current.x !== pe.x || un.current.y !== pe.y) && (C(pe), un.current = pe);
    }
  });
  function xt(Ce, pe) {
    var je = Ce;
    pe ? (vN(function() {
      $(je);
    }), Nn()) : te(je);
  }
  function Pt(Ce) {
    var pe = Ce.currentTarget.scrollTop;
    pe !== le && te(pe), w == null || w(Ce), Nn();
  }
  var Bt = function(pe) {
    var je = pe, bt = E ? E - Ye.width : 0;
    return je = Math.max(je, 0), je = Math.min(je, bt), je;
  }, Qt = Yi(function(Ce, pe) {
    pe ? (vN(function() {
      $(function(je) {
        var bt = je + (Q ? -Ce : Ce);
        return Bt(bt);
      });
    }), Nn()) : te(function(je) {
      var bt = je + Ce;
      return bt;
    });
  }), vn = bZ(Z, ut, vt, _t, Wt, !!E, Qt), Mn = ot(vn, 2), cr = Mn[0], ge = Mn[1];
  EZ(Z, ne, function(Ce, pe, je) {
    return lt(Ce, pe, je) ? !1 : (cr({
      preventDefault: function() {
      },
      deltaX: Ce ? pe : 0,
      deltaY: Ce ? 0 : pe
    }), !0);
  }), ti(function() {
    function Ce(je) {
      Z && je.preventDefault();
    }
    var pe = ne.current;
    return pe.addEventListener("wheel", cr, {
      passive: !1
    }), pe.addEventListener("DOMMouseScroll", ge, {
      passive: !0
    }), pe.addEventListener("MozMousePixelScroll", Ce, {
      passive: !1
    }), function() {
      pe.removeEventListener("wheel", cr), pe.removeEventListener("DOMMouseScroll", ge), pe.removeEventListener("MozMousePixelScroll", Ce);
    };
  }, [Z]), ti(function() {
    if (E) {
      var Ce = Bt(Me);
      $(Ce), Nn({
        x: Ce
      });
    }
  }, [Ye.width, E]);
  var it = function() {
    var pe, je;
    (pe = Tt.current) === null || pe === void 0 || pe.delayHidden(), (je = Rt.current) === null || je === void 0 || je.delayHidden();
  }, yt = CZ(ne, q, X, o, L, function() {
    return G(!0);
  }, te, it);
  O.useImperativeHandle(e, function() {
    return {
      nativeElement: ie.current,
      getScrollInfo: Ct,
      scrollTo: function(pe) {
        function je(bt) {
          return bt && bn(bt) === "object" && ("left" in bt || "top" in bt);
        }
        je(pe) ? (pe.left !== void 0 && $(Bt(pe.left)), yt(pe.top)) : yt(pe);
      }
    };
  }), ti(function() {
    if (R) {
      var Ce = q.slice(ht, pt + 1);
      R(Ce, q);
    }
  }, [ht, pt, q]);
  var Kt = SZ(q, L, X, o), Sn = D == null ? void 0 : D({
    start: ht,
    end: pt,
    virtual: B,
    offsetX: Me,
    offsetY: Be,
    rtl: Q,
    getSize: Kt
  }), ee = gZ(q, ht, pt, E, Me, j, p, $e), _e = null;
  a && (_e = ke(Re({}, u ? "height" : "maxHeight", a), RZ), Z && (_e.overflowY = "hidden", E && (_e.overflowX = "hidden"), Ie && (_e.pointerEvents = "none")));
  var Ae = {};
  return Q && (Ae.dir = "rtl"), /* @__PURE__ */ O.createElement("div", gn({
    ref: ie,
    style: ke(ke({}, d), {}, {
      position: "relative"
    }),
    className: V
  }, Ae, U), /* @__PURE__ */ O.createElement(Su, {
    onResize: st
  }, /* @__PURE__ */ O.createElement(_, {
    className: "".concat(r, "-holder"),
    style: _e,
    ref: ne,
    onScroll: Pt,
    onMouseEnter: it
  }, /* @__PURE__ */ O.createElement(yH, {
    prefixCls: r,
    height: nt,
    offsetX: Me,
    offsetY: Be,
    scrollWidth: E,
    onInnerResize: G,
    ref: ce,
    innerProps: P,
    rtl: Q,
    extra: Sn
  }, ee))), B && nt > a && /* @__PURE__ */ O.createElement(BR, {
    ref: Tt,
    prefixCls: r,
    scrollOffset: le,
    scrollRange: nt,
    rtl: Q,
    onScroll: xt,
    onStartMove: et,
    onStopMove: Xe,
    spinSize: De,
    containerSize: Ye.height,
    style: I == null ? void 0 : I.verticalScrollBar,
    thumbStyle: I == null ? void 0 : I.verticalScrollBarThumb
  }), B && E > Ye.width && /* @__PURE__ */ O.createElement(BR, {
    ref: Rt,
    prefixCls: r,
    scrollOffset: Me,
    scrollRange: E,
    rtl: Q,
    onScroll: xt,
    onStartMove: et,
    onStopMove: Xe,
    spinSize: ue,
    containerSize: Ye.width,
    horizontal: !0,
    style: I == null ? void 0 : I.horizontalScrollBar,
    thumbStyle: I == null ? void 0 : I.horizontalScrollBarThumb
  }));
}
var SH = /* @__PURE__ */ O.forwardRef(AZ);
SH.displayName = "List";
function OZ() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var PZ = ["disabled", "title", "children", "style", "className"];
function cL(n) {
  return typeof n == "string" || typeof n == "number";
}
var DZ = function(e, t) {
  var r = MK(), i = r.prefixCls, a = r.id, o = r.open, s = r.multiple, u = r.mode, d = r.searchValue, f = r.toggleOpen, p = r.notFoundContent, g = r.onPopupScroll, v = O.useContext(nO), b = v.maxCount, E = v.flattenOptions, S = v.onActiveValue, _ = v.defaultActiveFirstOption, w = v.onSelect, C = v.menuItemSelectedIcon, R = v.rawValues, P = v.fieldNames, D = v.virtual, I = v.direction, U = v.listHeight, L = v.listItemHeight, N = v.optionRender, H = "".concat(i, "-item"), j = uE(function() {
    return E;
  }, [o, E], function(xe, Me) {
    return Me[0] && xe[1] !== Me[1];
  }), G = O.useRef(null), X = O.useMemo(function() {
    return s && UR(b) && (R == null ? void 0 : R.size) >= b;
  }, [s, b, R == null ? void 0 : R.size]), ae = function(Me) {
    Me.preventDefault();
  }, Z = function(Me) {
    var $;
    ($ = G.current) === null || $ === void 0 || $.scrollTo(typeof Me == "number" ? {
      index: Me
    } : Me);
  }, K = function(Me) {
    for (var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, Te = j.length, se = 0; se < Te; se += 1) {
      var Ie = (Me + se * $ + Te) % Te, be = j[Ie] || {}, et = be.group, Xe = be.data;
      if (!et && !(Xe != null && Xe.disabled) && !X)
        return Ie;
    }
    return -1;
  }, B = O.useState(function() {
    return K(0);
  }), Q = ot(B, 2), V = Q[0], q = Q[1], ne = function(Me) {
    var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    q(Me);
    var Te = {
      source: $ ? "keyboard" : "mouse"
    }, se = j[Me];
    if (!se) {
      S(null, -1, Te);
      return;
    }
    S(se.value, Me, Te);
  };
  In(function() {
    ne(_ !== !1 ? K(0) : -1);
  }, [j.length, d]);
  var ce = O.useCallback(function(xe) {
    return R.has(xe) && u !== "combobox";
  }, [u, jt(R).toString(), R.size]);
  In(function() {
    var xe = setTimeout(function() {
      if (!s && o && R.size === 1) {
        var $ = Array.from(R)[0], Te = j.findIndex(function(se) {
          var Ie = se.data;
          return Ie.value === $;
        });
        Te !== -1 && (ne(Te), Z(Te));
      }
    });
    if (o) {
      var Me;
      (Me = G.current) === null || Me === void 0 || Me.scrollTo(void 0);
    }
    return function() {
      return clearTimeout(xe);
    };
  }, [o, d]);
  var ie = function(Me) {
    Me !== void 0 && w(Me, {
      selected: !R.has(Me)
    }), s || f(!1);
  };
  if (O.useImperativeHandle(t, function() {
    return {
      onKeyDown: function(Me) {
        var $ = Me.which, Te = Me.ctrlKey;
        switch ($) {
          case Ft.N:
          case Ft.P:
          case Ft.UP:
          case Ft.DOWN: {
            var se = 0;
            if ($ === Ft.UP ? se = -1 : $ === Ft.DOWN ? se = 1 : OZ() && Te && ($ === Ft.N ? se = 1 : $ === Ft.P && (se = -1)), se !== 0) {
              var Ie = K(V + se, se);
              Z(Ie), ne(Ie, !0);
            }
            break;
          }
          case Ft.ENTER: {
            var be, et = j[V];
            et && !(et != null && (be = et.data) !== null && be !== void 0 && be.disabled) && !X ? ie(et.value) : ie(void 0), o && Me.preventDefault();
            break;
          }
          case Ft.ESC:
            f(!1), o && Me.stopPropagation();
        }
      },
      onKeyUp: function() {
      },
      scrollTo: function(Me) {
        Z(Me);
      }
    };
  }), j.length === 0)
    return /* @__PURE__ */ O.createElement("div", {
      role: "listbox",
      id: "".concat(a, "_list"),
      className: "".concat(H, "-empty"),
      onMouseDown: ae
    }, p);
  var oe = Object.keys(P).map(function(xe) {
    return P[xe];
  }), he = function(Me) {
    return Me.label;
  };
  function le(xe, Me) {
    var $ = xe.group;
    return {
      role: $ ? "presentation" : "option",
      id: "".concat(a, "_list_").concat(Me)
    };
  }
  var ve = function(Me) {
    var $ = j[Me];
    if (!$)
      return null;
    var Te = $.data || {}, se = Te.value, Ie = $.group, be = ng(Te, !0), et = he($);
    return $ ? /* @__PURE__ */ O.createElement("div", gn({
      "aria-label": typeof et == "string" && !Ie ? et : null
    }, be, {
      key: Me
    }, le($, Me), {
      "aria-selected": ce(se)
    }), se) : null;
  }, Ne = {
    role: "listbox",
    id: "".concat(a, "_list")
  };
  return /* @__PURE__ */ O.createElement(O.Fragment, null, D && /* @__PURE__ */ O.createElement("div", gn({}, Ne, {
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }), ve(V - 1), ve(V), ve(V + 1)), /* @__PURE__ */ O.createElement(SH, {
    itemKey: "key",
    ref: G,
    data: j,
    height: U,
    itemHeight: L,
    fullHeight: !1,
    onMouseDown: ae,
    onScroll: g,
    virtual: D,
    direction: I,
    innerProps: D ? null : Ne
  }, function(xe, Me) {
    var $ = xe.group, Te = xe.groupOption, se = xe.data, Ie = xe.label, be = xe.value, et = se.key;
    if ($) {
      var Xe, $e = (Xe = se.title) !== null && Xe !== void 0 ? Xe : cL(Ie) ? Ie.toString() : void 0;
      return /* @__PURE__ */ O.createElement("div", {
        className: Et(H, "".concat(H, "-group"), se.className),
        title: $e
      }, Ie !== void 0 ? Ie : et);
    }
    var te = se.disabled, Y = se.title;
    se.children;
    var Se = se.style, Oe = se.className, Pe = br(se, PZ), Ve = du(Pe, oe), Ze = ce(be), nt = te || !Ze && X, ht = "".concat(H, "-option"), pt = Et(H, ht, Oe, Re(Re(Re(Re({}, "".concat(ht, "-grouped"), Te), "".concat(ht, "-active"), V === Me && !nt), "".concat(ht, "-disabled"), nt), "".concat(ht, "-selected"), Ze)), Be = he(xe), ye = !C || typeof C == "function" || Ze, Ue = typeof Be == "number" ? Be : Be || be, Ye = cL(Ue) ? Ue.toString() : void 0;
    return Y !== void 0 && (Ye = Y), /* @__PURE__ */ O.createElement("div", gn({}, ng(Ve), D ? {} : le(xe, Me), {
      "aria-selected": Ze,
      className: pt,
      title: Ye,
      onMouseMove: function() {
        V === Me || nt || ne(Me);
      },
      onClick: function() {
        nt || ie(be);
      },
      style: Se
    }), /* @__PURE__ */ O.createElement("div", {
      className: "".concat(ht, "-content")
    }, typeof N == "function" ? N(xe, {
      index: Me
    }) : Ue), /* @__PURE__ */ O.isValidElement(C) || Ze, ye && /* @__PURE__ */ O.createElement(CE, {
      className: "".concat(H, "-option-state"),
      customizeIcon: C,
      customizeIconProps: {
        value: be,
        disabled: nt,
        isSelected: Ze
      }
    }, Ze ? "" : null));
  }));
}, _H = /* @__PURE__ */ O.forwardRef(DZ);
Ee.env.NODE_ENV !== "production" && (_H.displayName = "OptionList");
const IZ = function(n, e) {
  var t = O.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  }), r = O.useMemo(function() {
    var a = t.current, o = a.values, s = a.options, u = n.map(function(p) {
      if (p.label === void 0) {
        var g;
        return ke(ke({}, p), {}, {
          label: (g = o.get(p.value)) === null || g === void 0 ? void 0 : g.label
        });
      }
      return p;
    }), d = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map();
    return u.forEach(function(p) {
      d.set(p.value, p), f.set(p.value, e.get(p.value) || s.get(p.value));
    }), t.current.values = d, t.current.options = f, u;
  }, [n, e]), i = O.useCallback(function(a) {
    return e.get(a) || t.current.options.get(a);
  }, [e]);
  return [r, i];
};
function eM(n, e) {
  return tO(n).join("").toUpperCase().includes(e);
}
const NZ = function(n, e, t, r, i) {
  return O.useMemo(function() {
    if (!t || r === !1)
      return n;
    var a = e.options, o = e.label, s = e.value, u = [], d = typeof r == "function", f = t.toUpperCase(), p = d ? r : function(v, b) {
      return i ? eM(b[i], f) : b[a] ? eM(b[o !== "children" ? o : "label"], f) : eM(b[s], f);
    }, g = d ? function(v) {
      return zR(v);
    } : function(v) {
      return v;
    };
    return n.forEach(function(v) {
      if (v[a]) {
        var b = p(t, g(v));
        if (b)
          u.push(v);
        else {
          var E = v[a].filter(function(S) {
            return p(t, g(S));
          });
          E.length && u.push(ke(ke({}, v), {}, Re({}, a, E)));
        }
        return;
      }
      p(t, g(v)) && u.push(v);
    }), u;
  }, [n, r, i, t, e]);
};
var uL = 0, LZ = Ee.env.NODE_ENV !== "test" && fo();
function FZ() {
  var n;
  return LZ ? (n = uL, uL += 1) : n = "TEST_OR_SSR", n;
}
function UZ(n) {
  var e = O.useState(), t = ot(e, 2), r = t[0], i = t[1];
  return O.useEffect(function() {
    i("rc_select_".concat(FZ()));
  }, []), n || r;
}
var zZ = ["children", "value"], BZ = ["children"];
function HZ(n) {
  var e = n, t = e.key, r = e.props, i = r.children, a = r.value, o = br(r, zZ);
  return ke({
    key: t,
    value: a !== void 0 ? a : t,
    children: i
  }, o);
}
function aO(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return dc(n).map(function(t, r) {
    if (!/* @__PURE__ */ O.isValidElement(t) || !t.type)
      return null;
    var i = t, a = i.type.isSelectOptGroup, o = i.key, s = i.props, u = s.children, d = br(s, BZ);
    return e || !a ? HZ(t) : ke(ke({
      key: "__RC_SELECT_GRP__".concat(o === null ? r : o, "__"),
      label: o
    }, d), {}, {
      options: aO(u)
    });
  }).filter(function(t) {
    return t;
  });
}
var VZ = function(e, t, r, i, a) {
  return O.useMemo(function() {
    var o = e, s = !e;
    s && (o = aO(t));
    var u = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), f = function(v, b, E) {
      E && typeof E == "string" && v.set(b[E], b);
    }, p = function g(v) {
      for (var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, E = 0; E < v.length; E += 1) {
        var S = v[E];
        !S[r.options] || b ? (u.set(S[r.value], S), f(d, S, r.label), f(d, S, i), f(d, S, a)) : g(S[r.options], !0);
      }
    };
    return p(o), {
      options: o,
      valueOptions: u,
      labelOptions: d
    };
  }, [e, t, r, i, a]);
};
function dL(n) {
  var e = O.useRef();
  e.current = n;
  var t = O.useCallback(function() {
    return e.current.apply(e, arguments);
  }, []);
  return t;
}
function kZ(n) {
  var e = n.mode, t = n.options, r = n.children, i = n.backfill, a = n.allowClear, o = n.placeholder, s = n.getInputElement, u = n.showSearch, d = n.onSearch, f = n.defaultOpen, p = n.autoFocus, g = n.labelInValue, v = n.value, b = n.inputValue, E = n.optionLabelProp, S = vx(e), _ = u !== void 0 ? u : S || e === "combobox", w = t || aO(r);
  if (Yn(e !== "tags" || w.every(function(D) {
    return !D.disabled;
  }), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), e === "tags" || e === "combobox") {
    var C = w.some(function(D) {
      return D.options ? D.options.some(function(I) {
        return typeof ("value" in I ? I.value : I.key) == "number";
      }) : typeof ("value" in D ? D.value : D.key) == "number";
    });
    Yn(!C, "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
  }
  if (Yn(e !== "combobox" || !E, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), Yn(e === "combobox" || !i, "`backfill` only works with `combobox` mode."), Yn(e === "combobox" || !s, "`getInputElement` only work with `combobox` mode."), zT(e !== "combobox" || !s || !a || !o, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), d && !_ && e !== "combobox" && e !== "tags" && Yn(!1, "`onSearch` should work with `showSearch` instead of use alone."), zT(!f || p, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed."), v != null) {
    var R = tO(v);
    Yn(!g || R.every(function(D) {
      return bn(D) === "object" && ("key" in D || "value" in D);
    }), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`"), Yn(!S || Array.isArray(v), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (r) {
    var P = null;
    dc(r).some(function(D) {
      if (!/* @__PURE__ */ O.isValidElement(D) || !D.type)
        return !1;
      var I = D, U = I.type;
      if (U.isSelectOption)
        return !1;
      if (U.isSelectOptGroup) {
        var L = dc(D.props.children).every(function(N) {
          return !/* @__PURE__ */ O.isValidElement(N) || !D.type || N.type.isSelectOption ? !0 : (P = N.type, !1);
        });
        return !L;
      }
      return P = U, !0;
    }), P && Yn(!1, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(P.displayName || P.name || P, "`.")), Yn(b === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
function $Z(n, e) {
  if (n) {
    var t = function r(i) {
      for (var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o = 0; o < i.length; o++) {
        var s = i[o];
        if (s[e == null ? void 0 : e.value] === null)
          return Yn(!1, "`value` in Select options should not be `null`."), !0;
        if (!a && Array.isArray(s[e == null ? void 0 : e.options]) && r(s[e == null ? void 0 : e.options], !0))
          break;
      }
    };
    t(n);
  }
}
var WZ = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "optionRender", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "direction", "listHeight", "listItemHeight", "labelRender", "value", "defaultValue", "labelInValue", "onChange", "maxCount"], jZ = ["inputValue"];
function GZ(n) {
  return !n || bn(n) !== "object";
}
var xH = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.id, r = n.mode, i = n.prefixCls, a = i === void 0 ? "rc-select" : i, o = n.backfill, s = n.fieldNames, u = n.inputValue, d = n.searchValue, f = n.onSearch, p = n.autoClearSearchValue, g = p === void 0 ? !0 : p, v = n.onSelect, b = n.onDeselect, E = n.dropdownMatchSelectWidth, S = E === void 0 ? !0 : E, _ = n.filterOption, w = n.filterSort, C = n.optionFilterProp, R = n.optionLabelProp, P = n.options, D = n.optionRender, I = n.children, U = n.defaultActiveFirstOption, L = n.menuItemSelectedIcon, N = n.virtual, H = n.direction, j = n.listHeight, G = j === void 0 ? 200 : j, X = n.listItemHeight, ae = X === void 0 ? 20 : X, Z = n.labelRender, K = n.value, B = n.defaultValue, Q = n.labelInValue, V = n.onChange, q = n.maxCount, ne = br(n, WZ), ce = UZ(t), ie = vx(r), oe = !!(!P && I), he = O.useMemo(function() {
    return _ === void 0 && r === "combobox" ? !1 : _;
  }, [_, r]), le = O.useMemo(
    function() {
      return gH(s, oe);
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [
      // We stringify fieldNames to avoid unnecessary re-renders.
      JSON.stringify(s),
      oe
    ]
    /* eslint-enable react-hooks/exhaustive-deps */
  ), ve = ko("", {
    value: d !== void 0 ? d : u,
    postState: function(Pt) {
      return Pt || "";
    }
  }), Ne = ot(ve, 2), xe = Ne[0], Me = Ne[1], $ = VZ(P, I, le, C, R), Te = $.valueOptions, se = $.labelOptions, Ie = $.options, be = O.useCallback(function(xt) {
    var Pt = tO(xt);
    return Pt.map(function(Bt) {
      var Qt, vn, Mn, cr, ge;
      if (GZ(Bt))
        Qt = Bt;
      else {
        var it;
        Mn = Bt.key, vn = Bt.label, Qt = (it = Bt.value) !== null && it !== void 0 ? it : Mn;
      }
      var yt = Te.get(Qt);
      if (yt) {
        var Kt;
        if (vn === void 0 && (vn = yt == null ? void 0 : yt[R || le.label]), Mn === void 0 && (Mn = (Kt = yt == null ? void 0 : yt.key) !== null && Kt !== void 0 ? Kt : Qt), cr = yt == null ? void 0 : yt.disabled, ge = yt == null ? void 0 : yt.title, Ee.env.NODE_ENV !== "production" && !R) {
          var Sn = yt == null ? void 0 : yt[le.label];
          Sn !== void 0 && !/* @__PURE__ */ O.isValidElement(Sn) && !/* @__PURE__ */ O.isValidElement(vn) && Sn !== vn && Yn(!1, "`label` of `value` is not same as `label` in Select options.");
        }
      }
      return {
        label: vn,
        value: Qt,
        key: Mn,
        disabled: cr,
        title: ge
      };
    });
  }, [le, R, Te]), et = ko(B, {
    value: K
  }), Xe = ot(et, 2), $e = Xe[0], te = Xe[1], Y = O.useMemo(function() {
    var xt, Pt = ie && $e === null ? [] : $e, Bt = be(Pt);
    return r === "combobox" && jK((xt = Bt[0]) === null || xt === void 0 ? void 0 : xt.value) ? [] : Bt;
  }, [$e, be, r, ie]), Se = IZ(Y, Te), Oe = ot(Se, 2), Pe = Oe[0], Ve = Oe[1], Ze = O.useMemo(function() {
    if (!r && Pe.length === 1) {
      var xt = Pe[0];
      if (xt.value === null && (xt.label === null || xt.label === void 0))
        return [];
    }
    return Pe.map(function(Pt) {
      var Bt;
      return ke(ke({}, Pt), {}, {
        label: (Bt = typeof Z == "function" ? Z(Pt) : Pt.label) !== null && Bt !== void 0 ? Bt : Pt.value
      });
    });
  }, [r, Pe, Z]), nt = O.useMemo(function() {
    return new Set(Pe.map(function(xt) {
      return xt.value;
    }));
  }, [Pe]);
  O.useEffect(function() {
    if (r === "combobox") {
      var xt, Pt = (xt = Pe[0]) === null || xt === void 0 ? void 0 : xt.value;
      Me(WK(Pt) ? String(Pt) : "");
    }
  }, [Pe]);
  var ht = dL(function(xt, Pt) {
    var Bt = Pt ?? xt;
    return Re(Re({}, le.value, xt), le.label, Bt);
  }), pt = O.useMemo(function() {
    if (r !== "tags")
      return Ie;
    var xt = jt(Ie), Pt = function(Qt) {
      return Te.has(Qt);
    };
    return jt(Pe).sort(function(Bt, Qt) {
      return Bt.value < Qt.value ? -1 : 1;
    }).forEach(function(Bt) {
      var Qt = Bt.value;
      Pt(Qt) || xt.push(ht(Qt, Bt.label));
    }), xt;
  }, [ht, Ie, Te, Pe, r]), Be = NZ(pt, le, xe, he, C), ye = O.useMemo(function() {
    return r !== "tags" || !xe || Be.some(function(xt) {
      return xt[C || "value"] === xe;
    }) || Be.some(function(xt) {
      return xt[le.value] === xe;
    }) ? Be : [ht(xe)].concat(jt(Be));
  }, [ht, C, r, Be, xe, le]), Ue = O.useMemo(function() {
    return w ? jt(ye).sort(function(xt, Pt) {
      return w(xt, Pt, {
        searchValue: xe
      });
    }) : ye;
  }, [ye, w, xe]), Ye = O.useMemo(function() {
    return uZ(Ue, {
      fieldNames: le,
      childrenAsData: oe
    });
  }, [Ue, le, oe]), tt = function(Pt) {
    var Bt = be(Pt);
    if (te(Bt), V && // Trigger event only when value changed
    (Bt.length !== Pe.length || Bt.some(function(Mn, cr) {
      var ge;
      return ((ge = Pe[cr]) === null || ge === void 0 ? void 0 : ge.value) !== (Mn == null ? void 0 : Mn.value);
    }))) {
      var Qt = Q ? Bt : Bt.map(function(Mn) {
        return Mn.value;
      }), vn = Bt.map(function(Mn) {
        return zR(Ve(Mn.value));
      });
      V(
        // Value
        ie ? Qt : Qt[0],
        // Option
        ie ? vn : vn[0]
      );
    }
  }, st = O.useState(null), Tt = ot(st, 2), Rt = Tt[0], ue = Tt[1], De = O.useState(0), Ge = ot(De, 2), We = Ge[0], He = Ge[1], ut = U !== void 0 ? U : r !== "combobox", vt = O.useCallback(function(xt, Pt) {
    var Bt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, Qt = Bt.source, vn = Qt === void 0 ? "keyboard" : Qt;
    He(Pt), o && r === "combobox" && xt !== null && vn === "keyboard" && ue(String(xt));
  }, [o, r]), _t = function(Pt, Bt, Qt) {
    var vn = function() {
      var Ae, Ce = Ve(Pt);
      return [Q ? {
        label: Ce == null ? void 0 : Ce[le.label],
        value: Pt,
        key: (Ae = Ce == null ? void 0 : Ce.key) !== null && Ae !== void 0 ? Ae : Pt
      } : Pt, zR(Ce)];
    };
    if (Bt && v) {
      var Mn = vn(), cr = ot(Mn, 2), ge = cr[0], it = cr[1];
      v(ge, it);
    } else if (!Bt && b && Qt !== "clear") {
      var yt = vn(), Kt = ot(yt, 2), Sn = Kt[0], ee = Kt[1];
      b(Sn, ee);
    }
  }, Wt = dL(function(xt, Pt) {
    var Bt, Qt = ie ? Pt.selected : !0;
    Qt ? Bt = ie ? [].concat(jt(Pe), [xt]) : [xt] : Bt = Pe.filter(function(vn) {
      return vn.value !== xt;
    }), tt(Bt), _t(xt, Qt), r === "combobox" ? ue("") : (!vx || g) && (Me(""), ue(""));
  }), lt = function(Pt, Bt) {
    tt(Pt);
    var Qt = Bt.type, vn = Bt.values;
    (Qt === "remove" || Qt === "clear") && vn.forEach(function(Mn) {
      _t(Mn.value, !1, Qt);
    });
  }, Ct = function(Pt, Bt) {
    if (Me(Pt), ue(null), Bt.source === "submit") {
      var Qt = (Pt || "").trim();
      if (Qt) {
        var vn = Array.from(new Set([].concat(jt(nt), [Qt])));
        tt(vn), _t(Qt, !0), Me("");
      }
      return;
    }
    Bt.source !== "blur" && (r === "combobox" && tt(Pt), f == null || f(Pt));
  }, un = function(Pt) {
    var Bt = Pt;
    r !== "tags" && (Bt = Pt.map(function(vn) {
      var Mn = se.get(vn);
      return Mn == null ? void 0 : Mn.value;
    }).filter(function(vn) {
      return vn !== void 0;
    }));
    var Qt = Array.from(new Set([].concat(jt(nt), jt(Bt))));
    tt(Qt), Qt.forEach(function(vn) {
      _t(vn, !0);
    });
  }, Nn = O.useMemo(function() {
    var xt = N !== !1 && S !== !1;
    return ke(ke({}, $), {}, {
      flattenOptions: Ye,
      onActiveValue: vt,
      defaultActiveFirstOption: ut,
      onSelect: Wt,
      menuItemSelectedIcon: L,
      rawValues: nt,
      fieldNames: le,
      virtual: xt,
      direction: H,
      listHeight: G,
      listItemHeight: ae,
      childrenAsData: oe,
      maxCount: q,
      optionRender: D
    });
  }, [q, $, Ye, vt, ut, Wt, L, nt, le, N, S, H, G, ae, oe, D]);
  return Ee.env.NODE_ENV !== "production" && (kZ(n), $Z(Ie, le)), /* @__PURE__ */ O.createElement(nO.Provider, {
    value: Nn
  }, /* @__PURE__ */ O.createElement(vH, gn({}, ne, {
    // >>> MISC
    id: ce,
    prefixCls: a,
    ref: e,
    omitDomProps: jZ,
    mode: r,
    displayValues: Ze,
    onDisplayValuesChange: lt,
    direction: H,
    searchValue: xe,
    onSearch: Ct,
    autoClearSearchValue: g,
    onSearchSplit: un,
    dropdownMatchSelectWidth: S,
    OptionList: _H,
    emptyOptions: !Ye.length,
    activeValue: Rt,
    activeDescendantId: "".concat(ce, "_list_").concat(We)
  })));
});
Ee.env.NODE_ENV !== "production" && (xH.displayName = "Select");
var oO = xH;
oO.Option = iO;
oO.OptGroup = rO;
function Ph(n, e, t) {
  return Et({
    [`${n}-status-success`]: e === "success",
    [`${n}-status-warning`]: e === "warning",
    [`${n}-status-error`]: e === "error",
    [`${n}-status-validating`]: e === "validating",
    [`${n}-has-feedback`]: t
  });
}
const w0 = (n, e) => e || n, EH = () => {
  const [, n] = mo(), t = new la(n.colorBgBase).toHsl().l < 0.5 ? {
    opacity: 0.65
  } : {};
  return /* @__PURE__ */ O.createElement("svg", {
    style: t,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ O.createElement("title", null, "empty image"), /* @__PURE__ */ O.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ O.createElement("g", {
    transform: "translate(24 31.67)"
  }, /* @__PURE__ */ O.createElement("ellipse", {
    fillOpacity: ".8",
    fill: "#F5F5F7",
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
    fill: "#AEB8C2"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    fill: "url(#linearGradient-1)",
    transform: "translate(13.56)"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
    fill: "#F5F5F7"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
    fill: "#DCE0E6"
  })), /* @__PURE__ */ O.createElement("path", {
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
    fill: "#DCE0E6"
  }), /* @__PURE__ */ O.createElement("g", {
    transform: "translate(149.65 15.383)",
    fill: "#FFF"
  }, /* @__PURE__ */ O.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
Ee.env.NODE_ENV !== "production" && (EH.displayName = "EmptyImage");
const CH = () => {
  const [, n] = mo(), {
    colorFill: e,
    colorFillTertiary: t,
    colorFillQuaternary: r,
    colorBgContainer: i
  } = n, {
    borderColor: a,
    shadowColor: o,
    contentColor: s
  } = Mr(() => ({
    borderColor: new la(e).onBackground(i).toHexShortString(),
    shadowColor: new la(t).onBackground(i).toHexShortString(),
    contentColor: new la(r).onBackground(i).toHexShortString()
  }), [e, t, r, i]);
  return /* @__PURE__ */ O.createElement("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ O.createElement("title", null, "Simple Empty"), /* @__PURE__ */ O.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ O.createElement("ellipse", {
    fill: o,
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), /* @__PURE__ */ O.createElement("g", {
    fillRule: "nonzero",
    stroke: a
  }, /* @__PURE__ */ O.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: s
  }))));
};
Ee.env.NODE_ENV !== "production" && (CH.displayName = "SimpleImage");
const XZ = (n) => {
  const {
    componentCls: e,
    margin: t,
    marginXS: r,
    marginXL: i,
    fontSize: a,
    lineHeight: o
  } = n;
  return {
    [e]: {
      marginInline: r,
      fontSize: a,
      lineHeight: o,
      textAlign: "center",
      //  &-image hashId
      [`${e}-image`]: {
        height: n.emptyImgHeight,
        marginBottom: r,
        opacity: n.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          maxWidth: "100%",
          height: "100%",
          margin: "auto"
        }
      },
      [`${e}-description`]: {
        color: n.colorTextDescription
      },
      //  &-footer hashId
      [`${e}-footer`]: {
        marginTop: t
      },
      "&-normal": {
        marginBlock: i,
        color: n.colorTextDescription,
        [`${e}-description`]: {
          color: n.colorTextDescription
        },
        [`${e}-image`]: {
          height: n.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: r,
        color: n.colorTextDescription,
        [`${e}-image`]: {
          height: n.emptyImgHeightSM
        }
      }
    }
  };
}, qZ = $o("Empty", (n) => {
  const {
    componentCls: e,
    controlHeightLG: t,
    calc: r
  } = n, i = li(n, {
    emptyImgCls: `${e}-img`,
    emptyImgHeight: r(t).mul(2.5).equal(),
    emptyImgHeightMD: t,
    emptyImgHeightSM: r(t).mul(0.875).equal()
  });
  return [XZ(i)];
});
var YZ = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const wH = /* @__PURE__ */ O.createElement(EH, null), MH = /* @__PURE__ */ O.createElement(CH, null), Fd = (n) => {
  var {
    className: e,
    rootClassName: t,
    prefixCls: r,
    image: i = wH,
    description: a,
    children: o,
    imageStyle: s,
    style: u
  } = n, d = YZ(n, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style"]);
  const {
    getPrefixCls: f,
    direction: p,
    empty: g
  } = O.useContext(mr), v = f("empty", r), [b, E, S] = qZ(v), [_] = zA("Empty"), w = typeof a < "u" ? a : _ == null ? void 0 : _.description, C = typeof w == "string" ? w : "empty";
  let R = null;
  return typeof i == "string" ? R = /* @__PURE__ */ O.createElement("img", {
    alt: C,
    src: i
  }) : R = i, b(/* @__PURE__ */ O.createElement("div", Object.assign({
    className: Et(E, S, v, g == null ? void 0 : g.className, {
      [`${v}-normal`]: i === MH,
      [`${v}-rtl`]: p === "rtl"
    }, e, t),
    style: Object.assign(Object.assign({}, g == null ? void 0 : g.style), u)
  }, d), /* @__PURE__ */ O.createElement("div", {
    className: `${v}-image`,
    style: s
  }, R), w && /* @__PURE__ */ O.createElement("div", {
    className: `${v}-description`
  }, w), o && /* @__PURE__ */ O.createElement("div", {
    className: `${v}-footer`
  }, o)));
};
Fd.PRESENTED_IMAGE_DEFAULT = wH;
Fd.PRESENTED_IMAGE_SIMPLE = MH;
Ee.env.NODE_ENV !== "production" && (Fd.displayName = "Empty");
const KZ = (n) => {
  const {
    componentName: e
  } = n, {
    getPrefixCls: t
  } = ni(mr), r = t("empty");
  switch (e) {
    case "Table":
    case "List":
      return /* @__PURE__ */ Fe.createElement(Fd, {
        image: Fd.PRESENTED_IMAGE_SIMPLE
      });
    case "Select":
    case "TreeSelect":
    case "Cascader":
    case "Transfer":
    case "Mentions":
      return /* @__PURE__ */ Fe.createElement(Fd, {
        image: Fd.PRESENTED_IMAGE_SIMPLE,
        className: `${r}-small`
      });
    default:
      return /* @__PURE__ */ Fe.createElement(Fd, null);
  }
}, wE = function(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
  var r, i;
  const {
    variant: a,
    [n]: o
  } = ni(mr), s = ni(KB), u = o == null ? void 0 : o.variant;
  let d;
  typeof e < "u" ? d = e : t === !1 ? d = "borderless" : d = (i = (r = s ?? u) !== null && r !== void 0 ? r : a) !== null && i !== void 0 ? i : "outlined";
  const f = b7.includes(d);
  return [d, f];
}, ZZ = (n) => {
  const t = {
    overflow: {
      adjustX: !0,
      adjustY: !0,
      shiftY: !0
    },
    htmlRegion: n === "scroll" ? "scroll" : "visible",
    dynamicInset: !0
  };
  return {
    bottomLeft: Object.assign(Object.assign({}, t), {
      points: ["tl", "bl"],
      offset: [0, 4]
    }),
    bottomRight: Object.assign(Object.assign({}, t), {
      points: ["tr", "br"],
      offset: [0, 4]
    }),
    topLeft: Object.assign(Object.assign({}, t), {
      points: ["bl", "tl"],
      offset: [0, -4]
    }),
    topRight: Object.assign(Object.assign({}, t), {
      points: ["br", "tr"],
      offset: [0, -4]
    })
  };
};
function QZ(n, e) {
  return n || ZZ(e);
}
const fL = (n) => {
  const {
    optionHeight: e,
    optionFontSize: t,
    optionLineHeight: r,
    optionPadding: i
  } = n;
  return {
    position: "relative",
    display: "block",
    minHeight: e,
    padding: i,
    color: n.colorText,
    fontWeight: "normal",
    fontSize: t,
    lineHeight: r,
    boxSizing: "border-box"
  };
}, JZ = (n) => {
  const {
    antCls: e,
    componentCls: t
  } = n, r = `${t}-item`, i = `&${e}-slide-up-enter${e}-slide-up-enter-active`, a = `&${e}-slide-up-appear${e}-slide-up-appear-active`, o = `&${e}-slide-up-leave${e}-slide-up-leave-active`, s = `${t}-dropdown-placement-`;
  return [
    {
      [`${t}-dropdown`]: Object.assign(Object.assign({}, Vo(n)), {
        position: "absolute",
        top: -9999,
        zIndex: n.zIndexPopup,
        boxSizing: "border-box",
        padding: n.paddingXXS,
        overflow: "hidden",
        fontSize: n.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: n.colorBgElevated,
        borderRadius: n.borderRadiusLG,
        outline: "none",
        boxShadow: n.boxShadowSecondary,
        [`
          ${i}${s}bottomLeft,
          ${a}${s}bottomLeft
        `]: {
          animationName: QB
        },
        [`
          ${i}${s}topLeft,
          ${a}${s}topLeft,
          ${i}${s}topRight,
          ${a}${s}topRight
        `]: {
          animationName: eH
        },
        [`${o}${s}bottomLeft`]: {
          animationName: JB
        },
        [`
          ${o}${s}topLeft,
          ${o}${s}topRight
        `]: {
          animationName: tH
        },
        "&-hidden": {
          display: "none"
        },
        [`${r}`]: Object.assign(Object.assign({}, fL(n)), {
          cursor: "pointer",
          transition: `background ${n.motionDurationSlow} ease`,
          borderRadius: n.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: n.colorTextDescription,
            fontSize: n.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": Object.assign({
              flex: "auto"
            }, pR),
            "&-state": {
              flex: "none",
              display: "flex",
              alignItems: "center"
            },
            [`&-active:not(${r}-option-disabled)`]: {
              backgroundColor: n.optionActiveBg
            },
            [`&-selected:not(${r}-option-disabled)`]: {
              color: n.optionSelectedColor,
              fontWeight: n.optionSelectedFontWeight,
              backgroundColor: n.optionSelectedBg,
              [`${r}-option-state`]: {
                color: n.colorPrimary
              },
              [`&:has(+ ${r}-option-selected:not(${r}-option-disabled))`]: {
                borderEndStartRadius: 0,
                borderEndEndRadius: 0,
                [`& + ${r}-option-selected:not(${r}-option-disabled)`]: {
                  borderStartStartRadius: 0,
                  borderStartEndRadius: 0
                }
              }
            },
            "&-disabled": {
              [`&${r}-option-selected`]: {
                backgroundColor: n.colorBgContainerDisabled
              },
              color: n.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: n.calc(n.controlPaddingHorizontal).mul(2).equal()
            }
          },
          "&-empty": Object.assign(Object.assign({}, fL(n)), {
            color: n.colorTextDisabled
          })
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    j2(n, "slide-up"),
    j2(n, "slide-down"),
    W2(n, "move-up"),
    W2(n, "move-down")
  ];
}, eQ = (n) => {
  const {
    multipleSelectItemHeight: e,
    paddingXXS: t,
    lineWidth: r,
    INTERNAL_FIXED_ITEM_MARGIN: i
  } = n, a = n.max(n.calc(t).sub(r).equal(), 0), o = n.max(n.calc(a).sub(i).equal(), 0);
  return {
    basePadding: a,
    containerPadding: o,
    itemHeight: Mt(e),
    itemLineHeight: Mt(n.calc(e).sub(n.calc(n.lineWidth).mul(2)).equal())
  };
}, tQ = (n) => {
  const {
    multipleSelectItemHeight: e,
    selectHeight: t,
    lineWidth: r
  } = n;
  return n.calc(t).sub(e).div(2).sub(r).equal();
}, nQ = (n) => {
  const {
    componentCls: e,
    iconCls: t,
    borderRadiusSM: r,
    motionDurationSlow: i,
    paddingXS: a,
    multipleItemColorDisabled: o,
    multipleItemBorderColorDisabled: s,
    colorIcon: u,
    colorIconHover: d,
    INTERNAL_FIXED_ITEM_MARGIN: f
  } = n;
  return {
    /**
     * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
     * may update to redesign with its align logic.
     */
    // =========================== Overflow ===========================
    [`${e}-selection-overflow`]: {
      position: "relative",
      display: "flex",
      flex: "auto",
      flexWrap: "wrap",
      maxWidth: "100%",
      "&-item": {
        flex: "none",
        alignSelf: "center",
        maxWidth: "100%",
        display: "inline-flex"
      },
      // ======================== Selections ==========================
      [`${e}-selection-item`]: {
        display: "flex",
        alignSelf: "center",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        marginBlock: f,
        borderRadius: r,
        cursor: "default",
        transition: `font-size ${i}, line-height ${i}, height ${i}`,
        marginInlineEnd: n.calc(f).mul(2).equal(),
        paddingInlineStart: a,
        paddingInlineEnd: n.calc(a).div(2).equal(),
        [`${e}-disabled&`]: {
          color: o,
          borderColor: s,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: n.calc(a).div(2).equal(),
          overflow: "hidden",
          whiteSpace: "pre",
          // fix whitespace wrapping. custom tags display all whitespace within.
          textOverflow: "ellipsis"
        },
        "&-remove": Object.assign(Object.assign({}, b0()), {
          display: "inline-flex",
          alignItems: "center",
          color: u,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${t}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: d
          }
        })
      }
    }
  };
}, rQ = (n, e) => {
  const {
    componentCls: t,
    INTERNAL_FIXED_ITEM_MARGIN: r
  } = n, i = `${t}-selection-overflow`, a = n.multipleSelectItemHeight, o = tQ(n), s = e ? `${t}-${e}` : "", u = eQ(n);
  return {
    [`${t}-multiple${s}`]: Object.assign(Object.assign({}, nQ(n)), {
      // ========================= Selector =========================
      [`${t}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        height: "100%",
        // Multiple is little different that horizontal is follow the vertical
        paddingInline: u.basePadding,
        paddingBlock: u.containerPadding,
        borderRadius: n.borderRadius,
        [`${t}-disabled&`]: {
          background: n.multipleSelectorBgDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${Mt(r)} 0`,
          lineHeight: Mt(a),
          visibility: "hidden",
          content: '"\\a0"'
        }
      },
      // ======================== Selections ========================
      [`${t}-selection-item`]: {
        height: u.itemHeight,
        lineHeight: Mt(u.itemLineHeight)
      },
      // ========================== Input ==========================
      [`${i}-item + ${i}-item`]: {
        [`${t}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      // https://github.com/ant-design/ant-design/issues/44754
      [`${i}-item-suffix`]: {
        height: "100%"
      },
      [`${t}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: n.calc(n.inputPaddingHorizontalBase).sub(o).equal(),
        "\n          &-input,\n          &-mirror\n        ": {
          height: a,
          fontFamily: n.fontFamily,
          lineHeight: Mt(a),
          transition: `all ${n.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          // fix whitespace wrapping caused width calculation bug
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${t}-selection-placeholder`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: n.inputPaddingHorizontalBase,
        insetInlineEnd: n.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${n.motionDurationSlow}`
      }
    })
  };
};
function tM(n, e) {
  const {
    componentCls: t
  } = n, r = e ? `${t}-${e}` : "", i = {
    [`${t}-multiple${r}`]: {
      fontSize: n.fontSize,
      // ========================= Selector =========================
      [`${t}-selector`]: {
        [`${t}-show-search&`]: {
          cursor: "text"
        }
      },
      [`
        &${t}-show-arrow ${t}-selector,
        &${t}-allow-clear ${t}-selector
      `]: {
        paddingInlineEnd: n.calc(n.fontSizeIcon).add(n.controlPaddingHorizontal).equal()
      }
    }
  };
  return [rQ(n, e), i];
}
const iQ = (n) => {
  const {
    componentCls: e
  } = n, t = li(n, {
    selectHeight: n.controlHeightSM,
    multipleSelectItemHeight: n.multipleItemHeightSM,
    borderRadius: n.borderRadiusSM,
    borderRadiusSM: n.borderRadiusXS
  }), r = li(n, {
    fontSize: n.fontSizeLG,
    selectHeight: n.controlHeightLG,
    multipleSelectItemHeight: n.multipleItemHeightLG,
    borderRadius: n.borderRadiusLG,
    borderRadiusSM: n.borderRadius
  });
  return [
    tM(n),
    // ======================== Small ========================
    tM(t, "sm"),
    // Padding
    {
      [`${e}-multiple${e}-sm`]: {
        [`${e}-selection-placeholder`]: {
          insetInline: n.calc(n.controlPaddingHorizontalSM).sub(n.lineWidth).equal()
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${e}-selection-search`]: {
          marginInlineStart: 2
          // Magic Number
        }
      }
    },
    // ======================== Large ========================
    tM(r, "lg")
  ];
};
function nM(n, e) {
  const {
    componentCls: t,
    inputPaddingHorizontalBase: r,
    borderRadius: i
  } = n, a = n.calc(n.controlHeight).sub(n.calc(n.lineWidth).mul(2)).equal(), o = e ? `${t}-${e}` : "";
  return {
    [`${t}-single${o}`]: {
      fontSize: n.fontSize,
      height: n.controlHeight,
      // ========================= Selector =========================
      [`${t}-selector`]: Object.assign(Object.assign({}, Vo(n, !0)), {
        display: "flex",
        borderRadius: i,
        [`${t}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: r,
          insetInlineEnd: r,
          bottom: 0,
          "&-input": {
            width: "100%",
            WebkitAppearance: "textfield"
          }
        },
        [`
          ${t}-selection-item,
          ${t}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: Mt(a),
          transition: `all ${n.motionDurationSlow}, visibility 0s`,
          alignSelf: "center"
        },
        [`${t}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${t}-selection-item:empty:after`,
          /* For undefined value baseline align */
          `${t}-selection-placeholder:empty:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${t}-show-arrow ${t}-selection-item,
        &${t}-show-arrow ${t}-selection-placeholder
      `]: {
        paddingInlineEnd: n.showArrowPaddingInlineEnd
      },
      // Opacity selection if open
      [`&${t}-open ${t}-selection-item`]: {
        color: n.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${t}-customize-input)`]: {
        [`${t}-selector`]: {
          width: "100%",
          height: "100%",
          padding: `0 ${Mt(r)}`,
          [`${t}-selection-search-input`]: {
            height: a
          },
          "&:after": {
            lineHeight: Mt(a)
          }
        }
      },
      [`&${t}-customize-input`]: {
        [`${t}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${t}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${t}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${Mt(r)}`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function aQ(n) {
  const {
    componentCls: e
  } = n, t = n.calc(n.controlPaddingHorizontalSM).sub(n.lineWidth).equal();
  return [
    nM(n),
    // ======================== Small ========================
    // Shared
    nM(li(n, {
      controlHeight: n.controlHeightSM,
      borderRadius: n.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${e}-single${e}-sm`]: {
        [`&:not(${e}-customize-input)`]: {
          [`${e}-selection-search`]: {
            insetInlineStart: t,
            insetInlineEnd: t
          },
          [`${e}-selector`]: {
            padding: `0 ${Mt(t)}`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${e}-show-arrow ${e}-selection-search`]: {
            insetInlineEnd: n.calc(t).add(n.calc(n.fontSize).mul(1.5)).equal()
          },
          [`
            &${e}-show-arrow ${e}-selection-item,
            &${e}-show-arrow ${e}-selection-placeholder
          `]: {
            paddingInlineEnd: n.calc(n.fontSize).mul(1.5).equal()
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    nM(li(n, {
      controlHeight: n.singleItemHeightLG,
      fontSize: n.fontSizeLG,
      borderRadius: n.borderRadiusLG
    }), "lg")
  ];
}
const oQ = (n) => {
  const {
    fontSize: e,
    lineHeight: t,
    lineWidth: r,
    controlHeight: i,
    controlHeightSM: a,
    controlHeightLG: o,
    paddingXXS: s,
    controlPaddingHorizontal: u,
    zIndexPopupBase: d,
    colorText: f,
    fontWeightStrong: p,
    controlItemBgActive: g,
    controlItemBgHover: v,
    colorBgContainer: b,
    colorFillSecondary: E,
    colorBgContainerDisabled: S,
    colorTextDisabled: _
  } = n, w = s * 2, C = r * 2, R = Math.min(i - w, i - C), P = Math.min(a - w, a - C), D = Math.min(o - w, o - C);
  return {
    INTERNAL_FIXED_ITEM_MARGIN: Math.floor(s / 2),
    zIndexPopup: d + 50,
    optionSelectedColor: f,
    optionSelectedFontWeight: p,
    optionSelectedBg: g,
    optionActiveBg: v,
    optionPadding: `${(i - e * t) / 2}px ${u}px`,
    optionFontSize: e,
    optionLineHeight: t,
    optionHeight: i,
    selectorBg: b,
    clearBg: b,
    singleItemHeightLG: o,
    multipleItemBg: E,
    multipleItemBorderColor: "transparent",
    multipleItemHeight: R,
    multipleItemHeightSM: P,
    multipleItemHeightLG: D,
    multipleSelectorBgDisabled: S,
    multipleItemColorDisabled: _,
    multipleItemBorderColorDisabled: "transparent",
    showArrowPaddingInlineEnd: Math.ceil(n.fontSize * 1.25)
  };
}, TH = (n, e) => {
  const {
    componentCls: t,
    antCls: r,
    controlOutlineWidth: i
  } = n;
  return {
    [`&:not(${t}-customize-input) ${t}-selector`]: {
      border: `${Mt(n.lineWidth)} ${n.lineType} ${e.borderColor}`,
      background: n.selectorBg
    },
    [`&:not(${t}-disabled):not(${t}-customize-input):not(${r}-pagination-size-changer)`]: {
      [`&:hover ${t}-selector`]: {
        borderColor: e.hoverBorderHover
      },
      [`${t}-focused& ${t}-selector`]: {
        borderColor: e.activeBorderColor,
        boxShadow: `0 0 0 ${Mt(i)} ${e.activeShadowColor}`,
        outline: 0
      }
    }
  };
}, hL = (n, e) => ({
  [`&${n.componentCls}-status-${e.status}`]: Object.assign({}, TH(n, e))
}), sQ = (n) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign({}, TH(n, {
    borderColor: n.colorBorder,
    hoverBorderHover: n.colorPrimaryHover,
    activeBorderColor: n.colorPrimary,
    activeShadowColor: n.controlOutline
  })), hL(n, {
    status: "error",
    borderColor: n.colorError,
    hoverBorderHover: n.colorErrorHover,
    activeBorderColor: n.colorError,
    activeShadowColor: n.colorErrorOutline
  })), hL(n, {
    status: "warning",
    borderColor: n.colorWarning,
    hoverBorderHover: n.colorWarningHover,
    activeBorderColor: n.colorWarning,
    activeShadowColor: n.colorWarningOutline
  })), {
    [`&${n.componentCls}-disabled`]: {
      [`&:not(${n.componentCls}-customize-input) ${n.componentCls}-selector`]: {
        background: n.colorBgContainerDisabled,
        color: n.colorTextDisabled
      }
    },
    [`&${n.componentCls}-multiple ${n.componentCls}-selection-item`]: {
      background: n.multipleItemBg,
      border: `${Mt(n.lineWidth)} ${n.lineType} ${n.multipleItemBorderColor}`
    }
  })
}), RH = (n, e) => {
  const {
    componentCls: t,
    antCls: r
  } = n;
  return {
    [`&:not(${t}-customize-input) ${t}-selector`]: {
      background: e.bg,
      border: `${Mt(n.lineWidth)} ${n.lineType} transparent`,
      color: e.color
    },
    [`&:not(${t}-disabled):not(${t}-customize-input):not(${r}-pagination-size-changer)`]: {
      [`&:hover ${t}-selector`]: {
        background: e.hoverBg
      },
      [`${t}-focused& ${t}-selector`]: {
        background: n.selectorBg,
        borderColor: e.activeBorderColor,
        outline: 0
      }
    }
  };
}, pL = (n, e) => ({
  [`&${n.componentCls}-status-${e.status}`]: Object.assign({}, RH(n, e))
}), lQ = (n) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign({}, RH(n, {
    bg: n.colorFillTertiary,
    hoverBg: n.colorFillSecondary,
    activeBorderColor: n.colorPrimary,
    color: n.colorText
  })), pL(n, {
    status: "error",
    bg: n.colorErrorBg,
    hoverBg: n.colorErrorBgHover,
    activeBorderColor: n.colorError,
    color: n.colorError
  })), pL(n, {
    status: "warning",
    bg: n.colorWarningBg,
    hoverBg: n.colorWarningBgHover,
    activeBorderColor: n.colorWarning,
    color: n.colorWarning
  })), {
    [`&${n.componentCls}-disabled`]: {
      [`&:not(${n.componentCls}-customize-input) ${n.componentCls}-selector`]: {
        borderColor: n.colorBorder,
        background: n.colorBgContainerDisabled,
        color: n.colorTextDisabled
      }
    },
    [`&${n.componentCls}-multiple ${n.componentCls}-selection-item`]: {
      background: n.colorBgContainer,
      border: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorSplit}`
    }
  })
}), cQ = (n) => ({
  "&-borderless": {
    [`${n.componentCls}-selector`]: {
      background: "transparent",
      borderColor: "transparent"
    },
    [`&${n.componentCls}-disabled`]: {
      [`&:not(${n.componentCls}-customize-input) ${n.componentCls}-selector`]: {
        color: n.colorTextDisabled
      }
    },
    [`&${n.componentCls}-multiple ${n.componentCls}-selection-item`]: {
      background: n.multipleItemBg,
      border: `${Mt(n.lineWidth)} ${n.lineType} ${n.multipleItemBorderColor}`
    },
    // Status
    [`&${n.componentCls}-status-error`]: {
      [`${n.componentCls}-selection-item`]: {
        color: n.colorError
      }
    },
    [`&${n.componentCls}-status-warning`]: {
      [`${n.componentCls}-selection-item`]: {
        color: n.colorWarning
      }
    }
  }
}), uQ = (n) => ({
  [n.componentCls]: Object.assign(Object.assign(Object.assign({}, sQ(n)), lQ(n)), cQ(n))
}), dQ = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    position: "relative",
    transition: `all ${n.motionDurationMid} ${n.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${e}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit",
        height: "100%"
      }
    },
    [`${e}-disabled&`]: {
      cursor: "not-allowed",
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, fQ = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    [`${e}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      fontFamily: "inherit",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, hQ = (n) => {
  const {
    antCls: e,
    componentCls: t,
    inputPaddingHorizontalBase: r,
    iconCls: i
  } = n;
  return {
    [t]: Object.assign(Object.assign({}, Vo(n)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${t}-customize-input) ${t}-selector`]: Object.assign(Object.assign({}, dQ(n)), fQ(n)),
      // ======================== Selection ========================
      [`${t}-selection-item`]: Object.assign(Object.assign({
        flex: 1,
        fontWeight: "normal",
        position: "relative",
        userSelect: "none"
      }, pR), {
        // https://github.com/ant-design/ant-design/issues/40421
        [`> ${e}-typography`]: {
          display: "inline"
        }
      }),
      // ======================= Placeholder =======================
      [`${t}-selection-placeholder`]: Object.assign(Object.assign({}, pR), {
        flex: 1,
        color: n.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${t}-arrow`]: Object.assign(Object.assign({}, b0()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: r,
        height: n.fontSizeIcon,
        marginTop: n.calc(n.fontSizeIcon).mul(-1).div(2).equal(),
        color: n.colorTextQuaternary,
        fontSize: n.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        transition: `opacity ${n.motionDurationSlow} ease`,
        [i]: {
          verticalAlign: "top",
          transition: `transform ${n.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${t}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${t}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Clear ==========================
      [`${t}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: r,
        zIndex: 1,
        display: "inline-block",
        width: n.fontSizeIcon,
        height: n.fontSizeIcon,
        marginTop: n.calc(n.fontSizeIcon).mul(-1).div(2).equal(),
        color: n.colorTextQuaternary,
        fontSize: n.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        cursor: "pointer",
        opacity: 0,
        transition: `color ${n.motionDurationMid} ease, opacity ${n.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: n.colorTextTertiary
        }
      },
      "&:hover": {
        [`${t}-clear`]: {
          opacity: 1
        },
        // Should use the following selector, but since `:has` has poor compatibility,
        // we use `:not(:last-child)` instead, which may cause some problems in some cases.
        // [`${componentCls}-arrow:has(+ ${componentCls}-clear)`]: {
        [`${t}-arrow:not(:last-child)`]: {
          opacity: 0
        }
      }
    }),
    // ========================= Feedback ==========================
    [`${t}-has-feedback`]: {
      [`${t}-clear`]: {
        insetInlineEnd: n.calc(r).add(n.fontSize).add(n.paddingXS).equal()
      }
    }
  };
}, pQ = (n) => {
  const {
    componentCls: e
  } = n;
  return [
    {
      [e]: {
        // ==================== In Form ====================
        [`&${e}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    hQ(n),
    // Single
    aQ(n),
    // Multiple
    iQ(n),
    // Dropdown
    JZ(n),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${e}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    EE(n, {
      borderElCls: `${e}-selector`,
      focusElCls: `${e}-focused`
    })
  ];
}, mQ = $o("Select", (n, e) => {
  let {
    rootPrefixCls: t
  } = e;
  const r = li(n, {
    rootPrefixCls: t,
    inputPaddingHorizontalBase: n.calc(n.paddingSM).sub(1).equal(),
    multipleSelectItemHeight: n.multipleItemHeight,
    selectHeight: n.controlHeight
  });
  return [pQ(r), uQ(r)];
}, oQ, {
  unitless: {
    optionLineHeight: !0,
    optionSelectedFontWeight: !0
  }
});
var gQ = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" }, vQ = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: gQ
  }));
}, AH = /* @__PURE__ */ O.forwardRef(vQ);
Ee.env.NODE_ENV !== "production" && (AH.displayName = "CheckOutlined");
var yQ = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" }, bQ = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: yQ
  }));
}, sO = /* @__PURE__ */ O.forwardRef(bQ);
Ee.env.NODE_ENV !== "production" && (sO.displayName = "DownOutlined");
var SQ = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" }, _Q = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: SQ
  }));
}, lO = /* @__PURE__ */ O.forwardRef(_Q);
Ee.env.NODE_ENV !== "production" && (lO.displayName = "SearchOutlined");
function xQ(n) {
  let {
    suffixIcon: e,
    clearIcon: t,
    menuItemSelectedIcon: r,
    removeIcon: i,
    loading: a,
    multiple: o,
    hasFeedback: s,
    prefixCls: u,
    showSuffixIcon: d,
    feedbackIcon: f,
    showArrow: p,
    componentName: g
  } = n;
  Ee.env.NODE_ENV !== "production" && ci(g).deprecated(!t, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
  const v = t ?? /* @__PURE__ */ O.createElement(SE, null), b = (w) => e === null && !s && !p ? null : /* @__PURE__ */ O.createElement(O.Fragment, null, d !== !1 && w, s && f);
  let E = null;
  if (e !== void 0)
    E = b(e);
  else if (a)
    E = b(/* @__PURE__ */ O.createElement(_E, {
      spin: !0
    }));
  else {
    const w = `${u}-suffix`;
    E = (C) => {
      let {
        open: R,
        showSearch: P
      } = C;
      return b(R && P ? /* @__PURE__ */ O.createElement(lO, {
        className: w
      }) : /* @__PURE__ */ O.createElement(sO, {
        className: w
      }));
    };
  }
  let S = null;
  r !== void 0 ? S = r : o ? S = /* @__PURE__ */ O.createElement(AH, null) : S = null;
  let _ = null;
  return i !== void 0 ? _ = i : _ = /* @__PURE__ */ O.createElement(wB, null), {
    clearIcon: v,
    suffixIcon: E,
    itemIcon: S,
    removeIcon: _
  };
}
function EQ(n, e) {
  return e !== void 0 ? e : n !== null;
}
var CQ = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const OH = "SECRET_COMBOBOX_MODE_DO_NOT_USE", PH = (n, e) => {
  var t;
  const {
    prefixCls: r,
    bordered: i,
    className: a,
    rootClassName: o,
    getPopupContainer: s,
    popupClassName: u,
    dropdownClassName: d,
    listHeight: f = 256,
    placement: p,
    listItemHeight: g,
    size: v,
    disabled: b,
    notFoundContent: E,
    status: S,
    builtinPlacements: _,
    dropdownMatchSelectWidth: w,
    popupMatchSelectWidth: C,
    direction: R,
    style: P,
    allowClear: D,
    variant: I,
    dropdownStyle: U,
    transitionName: L,
    tagRender: N,
    maxCount: H
  } = n, j = CQ(n, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "builtinPlacements", "dropdownMatchSelectWidth", "popupMatchSelectWidth", "direction", "style", "allowClear", "variant", "dropdownStyle", "transitionName", "tagRender", "maxCount"]), {
    getPopupContainer: G,
    getPrefixCls: X,
    renderEmpty: ae,
    direction: Z,
    virtual: K,
    popupMatchSelectWidth: B,
    popupOverflow: Q,
    select: V
  } = O.useContext(mr), [, q] = mo(), ne = g ?? (q == null ? void 0 : q.controlHeight), ce = X("select", r), ie = X(), oe = R ?? Z, {
    compactSize: he,
    compactItemClassnames: le
  } = _0(ce, oe), [ve, Ne] = wE("select", I, i), xe = _u(ce), [Me, $, Te] = mQ(ce, xe), se = O.useMemo(() => {
    const {
      mode: Rt
    } = n;
    if (Rt !== "combobox")
      return Rt === OH ? "combobox" : Rt;
  }, [n.mode]), Ie = se === "multiple" || se === "tags", be = EQ(n.suffixIcon, n.showArrow), et = (t = C ?? w) !== null && t !== void 0 ? t : B, {
    status: Xe,
    hasFeedback: $e,
    isFormItemInput: te,
    feedbackIcon: Y
  } = O.useContext(Ya), Se = w0(Xe, S);
  let Oe;
  E !== void 0 ? Oe = E : se === "combobox" ? Oe = null : Oe = (ae == null ? void 0 : ae("Select")) || /* @__PURE__ */ O.createElement(KZ, {
    componentName: "Select"
  });
  const {
    suffixIcon: Pe,
    itemIcon: Ve,
    removeIcon: Ze,
    clearIcon: nt
  } = xQ(Object.assign(Object.assign({}, j), {
    multiple: Ie,
    hasFeedback: $e,
    feedbackIcon: Y,
    showSuffixIcon: be,
    prefixCls: ce,
    componentName: "Select"
  })), ht = D === !0 ? {
    clearIcon: nt
  } : D, pt = du(j, ["suffixIcon", "itemIcon"]), Be = Et(u || d, {
    [`${ce}-dropdown-${oe}`]: oe === "rtl"
  }, o, Te, xe, $), ye = mc((Rt) => {
    var ue;
    return (ue = v ?? he) !== null && ue !== void 0 ? ue : Rt;
  }), Ue = O.useContext(fc), Ye = b ?? Ue, tt = Et({
    [`${ce}-lg`]: ye === "large",
    [`${ce}-sm`]: ye === "small",
    [`${ce}-rtl`]: oe === "rtl",
    [`${ce}-${ve}`]: Ne,
    [`${ce}-in-form-item`]: te
  }, Ph(ce, Se, $e), le, V == null ? void 0 : V.className, a, o, Te, xe, $), st = O.useMemo(() => p !== void 0 ? p : oe === "rtl" ? "bottomRight" : "bottomLeft", [p, oe]);
  if (Ee.env.NODE_ENV !== "production") {
    const Rt = ci("Select");
    Rt.deprecated(!d, "dropdownClassName", "popupClassName"), Rt.deprecated(w === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), Ee.env.NODE_ENV !== "production" && Rt(!("showArrow" in n), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null."), Rt.deprecated(!("bordered" in n), "bordered", "variant"), Ee.env.NODE_ENV !== "production" && Rt(!(typeof H < "u" && !Ie), "usage", "`maxCount` only works with mode `multiple` or `tags`");
  }
  const [Tt] = AB("SelectLike", U == null ? void 0 : U.zIndex);
  return Me(/* @__PURE__ */ O.createElement(oO, Object.assign({
    ref: e,
    virtual: K,
    showSearch: V == null ? void 0 : V.showSearch
  }, pt, {
    style: Object.assign(Object.assign({}, V == null ? void 0 : V.style), P),
    dropdownMatchSelectWidth: et,
    transitionName: kA(ie, "slide-up", L),
    builtinPlacements: QZ(_, Q),
    listHeight: f,
    listItemHeight: ne,
    mode: se,
    prefixCls: ce,
    placement: st,
    direction: oe,
    suffixIcon: Pe,
    menuItemSelectedIcon: Ve,
    removeIcon: Ze,
    allowClear: ht,
    notFoundContent: Oe,
    className: tt,
    getPopupContainer: s || G,
    dropdownClassName: Be,
    disabled: Ye,
    dropdownStyle: Object.assign(Object.assign({}, U), {
      zIndex: Tt
    }),
    maxCount: Ie ? H : void 0,
    tagRender: Ie ? N : void 0
  })));
};
Ee.env.NODE_ENV !== "production" && (PH.displayName = "Select");
const $h = /* @__PURE__ */ O.forwardRef(PH), wQ = rH($h);
$h.SECRET_COMBOBOX_MODE_DO_NOT_USE = OH;
$h.Option = iO;
$h.OptGroup = rO;
$h._InternalPanelDoNotUseOrYouWillBeFired = wQ;
Ee.env.NODE_ENV !== "production" && ($h.displayName = "Select");
const Ky = ["xxl", "xl", "lg", "md", "sm", "xs"], MQ = (n) => ({
  xs: `(max-width: ${n.screenXSMax}px)`,
  sm: `(min-width: ${n.screenSM}px)`,
  md: `(min-width: ${n.screenMD}px)`,
  lg: `(min-width: ${n.screenLG}px)`,
  xl: `(min-width: ${n.screenXL}px)`,
  xxl: `(min-width: ${n.screenXXL}px)`
}), TQ = (n) => {
  const e = n, t = [].concat(Ky).reverse();
  return t.forEach((r, i) => {
    const a = r.toUpperCase(), o = `screen${a}Min`, s = `screen${a}`;
    if (!(e[o] <= e[s]))
      throw new Error(`${o}<=${s} fails : !(${e[o]}<=${e[s]})`);
    if (i < t.length - 1) {
      const u = `screen${a}Max`;
      if (!(e[s] <= e[u]))
        throw new Error(`${s}<=${u} fails : !(${e[s]}<=${e[u]})`);
      const f = `screen${t[i + 1].toUpperCase()}Min`;
      if (!(e[u] <= e[f]))
        throw new Error(`${u}<=${f} fails : !(${e[u]}<=${e[f]})`);
    }
  }), n;
};
function RQ() {
  const [, n] = mo(), e = MQ(TQ(n));
  return Fe.useMemo(() => {
    const t = /* @__PURE__ */ new Map();
    let r = -1, i = {};
    return {
      matchHandlers: {},
      dispatch(a) {
        return i = a, t.forEach((o) => o(i)), t.size >= 1;
      },
      subscribe(a) {
        return t.size || this.register(), r += 1, t.set(r, a), a(i), r;
      },
      unsubscribe(a) {
        t.delete(a), t.size || this.unregister();
      },
      unregister() {
        Object.keys(e).forEach((a) => {
          const o = e[a], s = this.matchHandlers[o];
          s == null || s.mql.removeListener(s == null ? void 0 : s.listener);
        }), t.clear();
      },
      register() {
        Object.keys(e).forEach((a) => {
          const o = e[a], s = (d) => {
            let {
              matches: f
            } = d;
            this.dispatch(Object.assign(Object.assign({}, i), {
              [a]: f
            }));
          }, u = window.matchMedia(o);
          u.addListener(s), this.matchHandlers[o] = {
            mql: u,
            listener: s
          }, s(u);
        });
      },
      responsiveMap: e
    };
  }, [n]);
}
const yx = (n) => n ? typeof n == "function" ? n() : n : null;
function cO(n) {
  var e = n.children, t = n.prefixCls, r = n.id, i = n.overlayInnerStyle, a = n.className, o = n.style;
  return /* @__PURE__ */ O.createElement("div", {
    className: Et("".concat(t, "-content"), a),
    style: o
  }, /* @__PURE__ */ O.createElement("div", {
    className: "".concat(t, "-inner"),
    id: r,
    role: "tooltip",
    style: i
  }, typeof e == "function" ? e() : e));
}
var im = {
  shiftX: 64,
  adjustY: 1
}, am = {
  adjustX: 1,
  shiftY: !0
}, Hs = [0, 0], AQ = {
  left: {
    points: ["cr", "cl"],
    overflow: am,
    offset: [-4, 0],
    targetOffset: Hs
  },
  right: {
    points: ["cl", "cr"],
    overflow: am,
    offset: [4, 0],
    targetOffset: Hs
  },
  top: {
    points: ["bc", "tc"],
    overflow: im,
    offset: [0, -4],
    targetOffset: Hs
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: im,
    offset: [0, 4],
    targetOffset: Hs
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: im,
    offset: [0, -4],
    targetOffset: Hs
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: am,
    offset: [-4, 0],
    targetOffset: Hs
  },
  topRight: {
    points: ["br", "tr"],
    overflow: im,
    offset: [0, -4],
    targetOffset: Hs
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: am,
    offset: [4, 0],
    targetOffset: Hs
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: im,
    offset: [0, 4],
    targetOffset: Hs
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: am,
    offset: [4, 0],
    targetOffset: Hs
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: im,
    offset: [0, 4],
    targetOffset: Hs
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: am,
    offset: [-4, 0],
    targetOffset: Hs
  }
}, OQ = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"], PQ = function(e, t) {
  var r = e.overlayClassName, i = e.trigger, a = i === void 0 ? ["hover"] : i, o = e.mouseEnterDelay, s = o === void 0 ? 0 : o, u = e.mouseLeaveDelay, d = u === void 0 ? 0.1 : u, f = e.overlayStyle, p = e.prefixCls, g = p === void 0 ? "rc-tooltip" : p, v = e.children, b = e.onVisibleChange, E = e.afterVisibleChange, S = e.transitionName, _ = e.animation, w = e.motion, C = e.placement, R = C === void 0 ? "right" : C, P = e.align, D = P === void 0 ? {} : P, I = e.destroyTooltipOnHide, U = I === void 0 ? !1 : I, L = e.defaultVisible, N = e.getTooltipContainer, H = e.overlayInnerStyle;
  e.arrowContent;
  var j = e.overlay, G = e.id, X = e.showArrow, ae = X === void 0 ? !0 : X, Z = br(e, OQ), K = kt(null);
  aE(t, function() {
    return K.current;
  });
  var B = ke({}, Z);
  "visible" in e && (B.popupVisible = e.visible);
  var Q = function() {
    return /* @__PURE__ */ O.createElement(cO, {
      key: "content",
      prefixCls: g,
      id: G,
      overlayInnerStyle: H
    }, j);
  };
  return /* @__PURE__ */ O.createElement(pH, gn({
    popupClassName: r,
    prefixCls: g,
    popup: Q,
    action: a,
    builtinPlacements: AQ,
    popupPlacement: R,
    ref: K,
    popupAlign: D,
    getPopupContainer: N,
    onPopupVisibleChange: b,
    afterPopupVisibleChange: E,
    popupTransitionName: S,
    popupAnimation: _,
    popupMotion: w,
    defaultPopupVisible: L,
    autoDestroy: U,
    mouseLeaveDelay: d,
    popupStyle: f,
    mouseEnterDelay: s,
    arrow: ae
  }, B), v);
};
const DQ = /* @__PURE__ */ Al(PQ);
function DH(n) {
  const {
    sizePopupArrow: e,
    borderRadiusXS: t,
    borderRadiusOuter: r
  } = n, i = e / 2, a = 0, o = i, s = r * 1 / Math.sqrt(2), u = i - r * (1 - 1 / Math.sqrt(2)), d = i - t * (1 / Math.sqrt(2)), f = r * (Math.sqrt(2) - 1) + t * (1 / Math.sqrt(2)), p = 2 * i - d, g = f, v = 2 * i - s, b = u, E = 2 * i - a, S = o, _ = i * Math.sqrt(2) + r * (Math.sqrt(2) - 2), w = r * (Math.sqrt(2) - 1), C = `polygon(${w}px 100%, 50% ${w}px, ${2 * i - w}px 100%, ${w}px 100%)`, R = `path('M ${a} ${o} A ${r} ${r} 0 0 0 ${s} ${u} L ${d} ${f} A ${t} ${t} 0 0 1 ${p} ${g} L ${v} ${b} A ${r} ${r} 0 0 0 ${E} ${S} Z')`;
  return {
    arrowShadowWidth: _,
    arrowPath: R,
    arrowPolygon: C
  };
}
const IQ = (n, e, t) => {
  const {
    sizePopupArrow: r,
    arrowPolygon: i,
    arrowPath: a,
    arrowShadowWidth: o,
    borderRadiusXS: s,
    calc: u
  } = n;
  return {
    pointerEvents: "none",
    width: r,
    height: r,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: r,
      height: u(r).div(2).equal(),
      background: e,
      clipPath: {
        _multi_value_: !0,
        value: [i, a]
      },
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: o,
      height: o,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${Mt(s)} 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow: t,
      zIndex: 0,
      background: "transparent"
    }
  };
}, IH = 8;
function uO(n) {
  const {
    contentRadius: e,
    limitVerticalRadius: t
  } = n, r = e > 12 ? e + 2 : 12;
  return {
    arrowOffsetHorizontal: r,
    arrowOffsetVertical: t ? IH : r
  };
}
function FS(n, e) {
  return n ? e : {};
}
function NH(n, e, t) {
  const {
    componentCls: r,
    boxShadowPopoverArrow: i,
    arrowOffsetVertical: a,
    arrowOffsetHorizontal: o
  } = n, {
    arrowDistance: s = 0,
    arrowPlacement: u = {
      left: !0,
      right: !0,
      top: !0,
      bottom: !0
    }
  } = {};
  return {
    [r]: Object.assign(Object.assign(Object.assign(Object.assign({
      // ============================ Basic ============================
      [`${r}-arrow`]: [Object.assign(Object.assign({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, IQ(n, e, i)), {
        "&:before": {
          background: e
        }
      })]
    }, FS(!!u.top, {
      [[`&-placement-top > ${r}-arrow`, `&-placement-topLeft > ${r}-arrow`, `&-placement-topRight > ${r}-arrow`].join(",")]: {
        bottom: s,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top > ${r}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft > ${r}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: o
        }
      },
      [`&-placement-topRight > ${r}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: o
        }
      }
    })), FS(!!u.bottom, {
      [[`&-placement-bottom > ${r}-arrow`, `&-placement-bottomLeft > ${r}-arrow`, `&-placement-bottomRight > ${r}-arrow`].join(",")]: {
        top: s,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom > ${r}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      [`&-placement-bottomLeft > ${r}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: o
        }
      },
      [`&-placement-bottomRight > ${r}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: o
        }
      }
    })), FS(!!u.left, {
      [[`&-placement-left > ${r}-arrow`, `&-placement-leftTop > ${r}-arrow`, `&-placement-leftBottom > ${r}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: s
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left > ${r}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop > ${r}-arrow`]: {
        top: a
      },
      [`&-placement-leftBottom > ${r}-arrow`]: {
        bottom: a
      }
    })), FS(!!u.right, {
      [[`&-placement-right > ${r}-arrow`, `&-placement-rightTop > ${r}-arrow`, `&-placement-rightBottom > ${r}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: s
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right > ${r}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop > ${r}-arrow`]: {
        top: a
      },
      [`&-placement-rightBottom > ${r}-arrow`]: {
        bottom: a
      }
    }))
  };
}
function NQ(n, e, t, r) {
  if (r === !1)
    return {
      adjustX: !1,
      adjustY: !1
    };
  const i = r && typeof r == "object" ? r : {}, a = {};
  switch (n) {
    case "top":
    case "bottom":
      a.shiftX = e.arrowOffsetHorizontal * 2 + t, a.shiftY = !0, a.adjustY = !0;
      break;
    case "left":
    case "right":
      a.shiftY = e.arrowOffsetVertical * 2 + t, a.shiftX = !0, a.adjustX = !0;
      break;
  }
  const o = Object.assign(Object.assign({}, a), i);
  return o.shiftX || (o.adjustX = !0), o.shiftY || (o.adjustY = !0), o;
}
const mL = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
}, LQ = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
}, FQ = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function UQ(n) {
  const {
    arrowWidth: e,
    autoAdjustOverflow: t,
    arrowPointAtCenter: r,
    offset: i,
    borderRadius: a,
    visibleFirst: o
  } = n, s = e / 2, u = {};
  return Object.keys(mL).forEach((d) => {
    const f = r && LQ[d] || mL[d], p = Object.assign(Object.assign({}, f), {
      offset: [0, 0],
      dynamicInset: !0
    });
    switch (u[d] = p, FQ.has(d) && (p.autoArrow = !1), d) {
      case "top":
      case "topLeft":
      case "topRight":
        p.offset[1] = -s - i;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        p.offset[1] = s + i;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        p.offset[0] = -s - i;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        p.offset[0] = s + i;
        break;
    }
    const g = uO({
      contentRadius: a,
      limitVerticalRadius: !0
    });
    if (r)
      switch (d) {
        case "topLeft":
        case "bottomLeft":
          p.offset[0] = -g.arrowOffsetHorizontal - s;
          break;
        case "topRight":
        case "bottomRight":
          p.offset[0] = g.arrowOffsetHorizontal + s;
          break;
        case "leftTop":
        case "rightTop":
          p.offset[1] = -g.arrowOffsetHorizontal - s;
          break;
        case "leftBottom":
        case "rightBottom":
          p.offset[1] = g.arrowOffsetHorizontal + s;
          break;
      }
    p.overflow = NQ(d, g, e, t), o && (p.htmlRegion = "visibleFirst");
  }), u;
}
const zQ = (n) => {
  const {
    componentCls: e,
    // ant-tooltip
    tooltipMaxWidth: t,
    tooltipColor: r,
    tooltipBg: i,
    tooltipBorderRadius: a,
    zIndexPopup: o,
    controlHeight: s,
    boxShadowSecondary: u,
    paddingSM: d,
    paddingXS: f
  } = n;
  return [
    {
      [e]: Object.assign(Object.assign(Object.assign(Object.assign({}, Vo(n)), {
        position: "absolute",
        zIndex: o,
        display: "block",
        width: "max-content",
        maxWidth: t,
        visibility: "visible",
        transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": i,
        // Wrapper for the tooltip content
        [`${e}-inner`]: {
          minWidth: "1em",
          minHeight: s,
          padding: `${Mt(n.calc(d).div(2).equal())} ${Mt(f)}`,
          color: r,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: i,
          borderRadius: a,
          boxShadow: u,
          boxSizing: "border-box"
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${e}-inner`]: {
            borderRadius: n.min(a, IH)
          }
        },
        [`${e}-content`]: {
          position: "relative"
        }
      }), V7(n, (p, g) => {
        let {
          darkColor: v
        } = g;
        return {
          [`&${e}-${p}`]: {
            [`${e}-inner`]: {
              backgroundColor: v
            },
            [`${e}-arrow`]: {
              "--antd-arrow-background-color": v
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    NH(n, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${e}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: n.sizePopupArrow
      }
    }
  ];
}, BQ = (n) => Object.assign(Object.assign({
  zIndexPopup: n.zIndexPopupBase + 70
}, uO({
  contentRadius: n.borderRadius,
  limitVerticalRadius: !0
})), DH(li(n, {
  borderRadiusOuter: Math.min(n.borderRadiusOuter, 4)
}))), LH = function(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return $o("Tooltip", (r) => {
    const {
      borderRadius: i,
      colorTextLightSolid: a,
      colorBgSpotlight: o
    } = r, s = li(r, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: a,
      tooltipBorderRadius: i,
      tooltipBg: o
    });
    return [zQ(s), nH(r, "zoom-big-fast")];
  }, BQ, {
    resetStyle: !1,
    // Popover use Tooltip as internal component. We do not need to handle this.
    injectStyle: e
  })(n);
}, HQ = Gy.map((n) => `${n}-inverse`);
function VQ(n) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [].concat(jt(HQ), jt(Gy)).includes(n) : Gy.includes(n);
}
function FH(n, e) {
  const t = VQ(e), r = Et({
    [`${n}-${e}`]: e && t
  }), i = {}, a = {};
  return e && !t && (i.background = e, a["--antd-arrow-background-color"] = e), {
    className: r,
    overlayStyle: i,
    arrowStyle: a
  };
}
const kQ = (n) => {
  const {
    prefixCls: e,
    className: t,
    placement: r = "top",
    title: i,
    color: a,
    overlayInnerStyle: o
  } = n, {
    getPrefixCls: s
  } = O.useContext(mr), u = s("tooltip", e), [d, f, p] = LH(u), g = FH(u, a), v = g.arrowStyle, b = Object.assign(Object.assign({}, o), g.overlayStyle), E = Et(f, p, u, `${u}-pure`, `${u}-placement-${r}`, t, g.className);
  return d(/* @__PURE__ */ O.createElement("div", {
    className: E,
    style: v
  }, /* @__PURE__ */ O.createElement("div", {
    className: `${u}-arrow`
  }), /* @__PURE__ */ O.createElement(cO, Object.assign({}, n, {
    className: f,
    prefixCls: u,
    overlayInnerStyle: b
  }), i)));
};
var $Q = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const WQ = /* @__PURE__ */ O.forwardRef((n, e) => {
  var t, r;
  const {
    prefixCls: i,
    openClassName: a,
    getTooltipContainer: o,
    overlayClassName: s,
    color: u,
    overlayInnerStyle: d,
    children: f,
    afterOpenChange: p,
    afterVisibleChange: g,
    destroyTooltipOnHide: v,
    arrow: b = !0,
    title: E,
    overlay: S,
    builtinPlacements: _,
    arrowPointAtCenter: w = !1,
    autoAdjustOverflow: C = !0
  } = n, R = !!b, [, P] = mo(), {
    getPopupContainer: D,
    getPrefixCls: I,
    direction: U
  } = O.useContext(mr), L = ci("Tooltip"), N = O.useRef(null), H = () => {
    var Oe;
    (Oe = N.current) === null || Oe === void 0 || Oe.forceAlign();
  };
  O.useImperativeHandle(e, () => {
    var Oe;
    return {
      forceAlign: H,
      forcePopupAlign: () => {
        L.deprecated(!1, "forcePopupAlign", "forceAlign"), H();
      },
      nativeElement: (Oe = N.current) === null || Oe === void 0 ? void 0 : Oe.nativeElement
    };
  }), Ee.env.NODE_ENV !== "production" && ([["visible", "open"], ["defaultVisible", "defaultOpen"], ["onVisibleChange", "onOpenChange"], ["afterVisibleChange", "afterOpenChange"], ["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"]].forEach((Oe) => {
    let [Pe, Ve] = Oe;
    L.deprecated(!(Pe in n), Pe, Ve);
  }), Ee.env.NODE_ENV !== "production" && L(!v || typeof v == "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly."), Ee.env.NODE_ENV !== "production" && L(!b || typeof b == "boolean" || !("arrowPointAtCenter" in b), "deprecated", "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead."));
  const [j, G] = ko(!1, {
    value: (t = n.open) !== null && t !== void 0 ? t : n.visible,
    defaultValue: (r = n.defaultOpen) !== null && r !== void 0 ? r : n.defaultVisible
  }), X = !E && !S && E !== 0, ae = (Oe) => {
    var Pe, Ve;
    G(X ? !1 : Oe), X || ((Pe = n.onOpenChange) === null || Pe === void 0 || Pe.call(n, Oe), (Ve = n.onVisibleChange) === null || Ve === void 0 || Ve.call(n, Oe));
  }, Z = O.useMemo(() => {
    var Oe, Pe;
    let Ve = w;
    return typeof b == "object" && (Ve = (Pe = (Oe = b.pointAtCenter) !== null && Oe !== void 0 ? Oe : b.arrowPointAtCenter) !== null && Pe !== void 0 ? Pe : w), _ || UQ({
      arrowPointAtCenter: Ve,
      autoAdjustOverflow: C,
      arrowWidth: R ? P.sizePopupArrow : 0,
      borderRadius: P.borderRadius,
      offset: P.marginXXS,
      visibleFirst: !0
    });
  }, [w, b, _, P]), K = O.useMemo(() => E === 0 ? E : S || E || "", [S, E]), B = /* @__PURE__ */ O.createElement(rg, {
    space: !0
  }, typeof K == "function" ? K() : K), {
    getPopupContainer: Q,
    placement: V = "top",
    mouseEnterDelay: q = 0.1,
    mouseLeaveDelay: ne = 0.1,
    overlayStyle: ce,
    rootClassName: ie
  } = n, oe = $Q(n, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]), he = I("tooltip", i), le = I(), ve = n["data-popover-inject"];
  let Ne = j;
  !("open" in n) && !("visible" in n) && X && (Ne = !1);
  const xe = /* @__PURE__ */ O.isValidElement(f) && !TB(f) ? f : /* @__PURE__ */ O.createElement("span", null, f), Me = xe.props, $ = !Me.className || typeof Me.className == "string" ? Et(Me.className, a || `${he}-open`) : Me.className, [Te, se, Ie] = LH(he, !ve), be = FH(he, u), et = be.arrowStyle, Xe = Object.assign(Object.assign({}, d), be.overlayStyle), $e = Et(s, {
    [`${he}-rtl`]: U === "rtl"
  }, be.className, ie, se, Ie), [te, Y] = AB("Tooltip", oe.zIndex), Se = /* @__PURE__ */ O.createElement(DQ, Object.assign({}, oe, {
    zIndex: te,
    showArrow: R,
    placement: V,
    mouseEnterDelay: q,
    mouseLeaveDelay: ne,
    prefixCls: he,
    overlayClassName: $e,
    overlayStyle: Object.assign(Object.assign({}, et), ce),
    getTooltipContainer: Q || o || D,
    ref: N,
    builtinPlacements: Z,
    overlay: B,
    visible: Ne,
    onVisibleChange: ae,
    afterVisibleChange: p ?? g,
    overlayInnerStyle: Xe,
    arrowContent: /* @__PURE__ */ O.createElement("span", {
      className: `${he}-arrow-content`
    }),
    motion: {
      motionName: kA(le, "zoom-big-fast", n.transitionName),
      motionDeadline: 1e3
    },
    destroyTooltipOnHide: !!v
  }), Ne ? fu(xe, {
    className: $
  }) : xe);
  return Te(/* @__PURE__ */ O.createElement(VA.Provider, {
    value: Y
  }, Se));
}), M0 = WQ;
Ee.env.NODE_ENV !== "production" && (M0.displayName = "Tooltip");
M0._InternalPanelDoNotUseOrYouWillBeFired = kQ;
const jQ = (n) => {
  const {
    componentCls: e,
    popoverColor: t,
    titleMinWidth: r,
    fontWeightStrong: i,
    innerPadding: a,
    boxShadowSecondary: o,
    colorTextHeading: s,
    borderRadiusLG: u,
    zIndexPopup: d,
    titleMarginBottom: f,
    colorBgElevated: p,
    popoverBg: g,
    titleBorderBottom: v,
    innerContentPadding: b,
    titlePadding: E
  } = n;
  return [
    {
      [e]: Object.assign(Object.assign({}, Vo(n)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: !0,
          value: 0
        },
        zIndex: d,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
        "--antd-arrow-background-color": p,
        width: "max-content",
        maxWidth: "100vw",
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${e}-content`]: {
          position: "relative"
        },
        [`${e}-inner`]: {
          backgroundColor: g,
          backgroundClip: "padding-box",
          borderRadius: u,
          boxShadow: o,
          padding: a
        },
        [`${e}-title`]: {
          minWidth: r,
          marginBottom: f,
          color: s,
          fontWeight: i,
          borderBottom: v,
          padding: E
        },
        [`${e}-inner-content`]: {
          color: t,
          padding: b
        }
      })
    },
    // Arrow Style
    NH(n, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${e}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: n.sizePopupArrow,
        display: "inline-block",
        [`${e}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, GQ = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    [e]: Gy.map((t) => {
      const r = n[`${t}6`];
      return {
        [`&${e}-${t}`]: {
          "--antd-arrow-background-color": r,
          [`${e}-inner`]: {
            backgroundColor: r
          },
          [`${e}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, XQ = (n) => {
  const {
    lineWidth: e,
    controlHeight: t,
    fontHeight: r,
    padding: i,
    wireframe: a,
    zIndexPopupBase: o,
    borderRadiusLG: s,
    marginXS: u,
    lineType: d,
    colorSplit: f,
    paddingSM: p
  } = n, g = t - r, v = g / 2, b = g / 2 - e, E = i;
  return Object.assign(Object.assign(Object.assign({
    titleMinWidth: 177,
    zIndexPopup: o + 30
  }, DH(n)), uO({
    contentRadius: s,
    limitVerticalRadius: !0
  })), {
    // internal
    innerPadding: a ? 0 : 12,
    titleMarginBottom: a ? 0 : u,
    titlePadding: a ? `${v}px ${E}px ${b}px` : 0,
    titleBorderBottom: a ? `${e}px ${d} ${f}` : "none",
    innerContentPadding: a ? `${p}px ${E}px` : 0
  });
}, UH = $o("Popover", (n) => {
  const {
    colorBgElevated: e,
    colorText: t
  } = n, r = li(n, {
    popoverBg: e,
    popoverColor: t
  });
  return [jQ(r), GQ(r), nH(r, "zoom-big")];
}, XQ, {
  resetStyle: !1,
  deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});
var qQ = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const YQ = (n, e, t) => !e && !t ? null : /* @__PURE__ */ O.createElement(O.Fragment, null, e && /* @__PURE__ */ O.createElement("div", {
  className: `${n}-title`
}, yx(e)), /* @__PURE__ */ O.createElement("div", {
  className: `${n}-inner-content`
}, yx(t))), KQ = (n) => {
  const {
    hashId: e,
    prefixCls: t,
    className: r,
    style: i,
    placement: a = "top",
    title: o,
    content: s,
    children: u
  } = n;
  return /* @__PURE__ */ O.createElement("div", {
    className: Et(e, t, `${t}-pure`, `${t}-placement-${a}`, r),
    style: i
  }, /* @__PURE__ */ O.createElement("div", {
    className: `${t}-arrow`
  }), /* @__PURE__ */ O.createElement(cO, Object.assign({}, n, {
    className: e,
    prefixCls: t
  }), u || YQ(t, o, s)));
}, ZQ = (n) => {
  const {
    prefixCls: e,
    className: t
  } = n, r = qQ(n, ["prefixCls", "className"]), {
    getPrefixCls: i
  } = O.useContext(mr), a = i("popover", e), [o, s, u] = UH(a);
  return o(/* @__PURE__ */ O.createElement(KQ, Object.assign({}, r, {
    prefixCls: a,
    hashId: s,
    className: Et(t, u)
  })));
};
var QQ = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const JQ = (n) => {
  let {
    title: e,
    content: t,
    prefixCls: r
  } = n;
  return /* @__PURE__ */ O.createElement(O.Fragment, null, e && /* @__PURE__ */ O.createElement("div", {
    className: `${r}-title`
  }, yx(e)), /* @__PURE__ */ O.createElement("div", {
    className: `${r}-inner-content`
  }, yx(t)));
}, eJ = /* @__PURE__ */ O.forwardRef((n, e) => {
  var t, r;
  const {
    prefixCls: i,
    title: a,
    content: o,
    overlayClassName: s,
    placement: u = "top",
    trigger: d = "hover",
    children: f,
    mouseEnterDelay: p = 0.1,
    mouseLeaveDelay: g = 0.1,
    onOpenChange: v,
    overlayStyle: b = {}
  } = n, E = QQ(n, ["prefixCls", "title", "content", "overlayClassName", "placement", "trigger", "children", "mouseEnterDelay", "mouseLeaveDelay", "onOpenChange", "overlayStyle"]), {
    getPrefixCls: S
  } = O.useContext(mr), _ = S("popover", i), [w, C, R] = UH(_), P = S(), D = Et(s, C, R), [I, U] = ko(!1, {
    value: (t = n.open) !== null && t !== void 0 ? t : n.visible,
    defaultValue: (r = n.defaultOpen) !== null && r !== void 0 ? r : n.defaultVisible
  }), L = (j, G) => {
    U(j, !0), v == null || v(j, G);
  }, N = (j) => {
    j.keyCode === Ft.ESC && L(!1, j);
  }, H = (j) => {
    L(j);
  };
  return w(/* @__PURE__ */ O.createElement(M0, Object.assign({
    placement: u,
    trigger: d,
    mouseEnterDelay: p,
    mouseLeaveDelay: g,
    overlayStyle: b
  }, E, {
    prefixCls: _,
    overlayClassName: D,
    ref: e,
    open: I,
    onOpenChange: H,
    overlay: a || o ? /* @__PURE__ */ O.createElement(JQ, {
      prefixCls: _,
      title: a,
      content: o
    }) : null,
    transitionName: kA(P, "zoom-big", E.transitionName),
    "data-popover-inject": !0
  }), fu(f, {
    onKeyDown: (j) => {
      var G, X;
      /* @__PURE__ */ O.isValidElement(f) && ((X = f == null ? void 0 : (G = f.props).onKeyDown) === null || X === void 0 || X.call(G, j)), N(j);
    }
  })));
}), dO = eJ;
dO._InternalPanelDoNotUseOrYouWillBeFired = ZQ;
Ee.env.NODE_ENV !== "production" && (dO.displayName = "Popover");
var tJ = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" }, nJ = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: tJ
  }));
}, zH = /* @__PURE__ */ O.forwardRef(nJ);
Ee.env.NODE_ENV !== "production" && (zH.displayName = "RightOutlined");
function fO(n) {
  return li(n, {
    inputAffixPadding: n.paddingXXS
  });
}
const hO = (n) => {
  const {
    controlHeight: e,
    fontSize: t,
    lineHeight: r,
    lineWidth: i,
    controlHeightSM: a,
    controlHeightLG: o,
    fontSizeLG: s,
    lineHeightLG: u,
    paddingSM: d,
    controlPaddingHorizontalSM: f,
    controlPaddingHorizontal: p,
    colorFillAlter: g,
    colorPrimaryHover: v,
    colorPrimary: b,
    controlOutlineWidth: E,
    controlOutline: S,
    colorErrorOutline: _,
    colorWarningOutline: w,
    colorBgContainer: C
  } = n;
  return {
    paddingBlock: Math.max(Math.round((e - t * r) / 2 * 10) / 10 - i, 0),
    paddingBlockSM: Math.max(Math.round((a - t * r) / 2 * 10) / 10 - i, 0),
    paddingBlockLG: Math.ceil((o - s * u) / 2 * 10) / 10 - i,
    paddingInline: d - i,
    paddingInlineSM: f - i,
    paddingInlineLG: p - i,
    addonBg: g,
    activeBorderColor: b,
    hoverBorderColor: v,
    activeShadow: `0 0 0 ${E}px ${S}`,
    errorActiveShadow: `0 0 0 ${E}px ${_}`,
    warningActiveShadow: `0 0 0 ${E}px ${w}`,
    hoverBg: C,
    activeBg: C,
    inputFontSize: t,
    inputFontSizeLG: s,
    inputFontSizeSM: t
  };
}, rJ = (n) => ({
  borderColor: n.hoverBorderColor,
  backgroundColor: n.hoverBg
}), pO = (n) => ({
  color: n.colorTextDisabled,
  backgroundColor: n.colorBgContainerDisabled,
  borderColor: n.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "input[disabled], textarea[disabled]": {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": Object.assign({}, rJ(li(n, {
    hoverBorderColor: n.colorBorder,
    hoverBg: n.colorBgContainerDisabled
  })))
}), BH = (n, e) => ({
  background: n.colorBgContainer,
  borderWidth: n.lineWidth,
  borderStyle: n.lineType,
  borderColor: e.borderColor,
  "&:hover": {
    borderColor: e.hoverBorderColor,
    backgroundColor: n.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: e.activeBorderColor,
    boxShadow: e.activeShadow,
    outline: 0,
    backgroundColor: n.activeBg
  }
}), gL = (n, e) => ({
  [`&${n.componentCls}-status-${e.status}:not(${n.componentCls}-disabled)`]: Object.assign(Object.assign({}, BH(n, e)), {
    [`${n.componentCls}-prefix, ${n.componentCls}-suffix`]: {
      color: e.affixColor
    }
  }),
  [`&${n.componentCls}-status-${e.status}${n.componentCls}-disabled`]: {
    borderColor: e.borderColor
  }
}), HH = (n, e) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BH(n, {
    borderColor: n.colorBorder,
    hoverBorderColor: n.hoverBorderColor,
    activeBorderColor: n.activeBorderColor,
    activeShadow: n.activeShadow
  })), {
    [`&${n.componentCls}-disabled, &[disabled]`]: Object.assign({}, pO(n))
  }), gL(n, {
    status: "error",
    borderColor: n.colorError,
    hoverBorderColor: n.colorErrorBorderHover,
    activeBorderColor: n.colorError,
    activeShadow: n.errorActiveShadow,
    affixColor: n.colorError
  })), gL(n, {
    status: "warning",
    borderColor: n.colorWarning,
    hoverBorderColor: n.colorWarningBorderHover,
    activeBorderColor: n.colorWarning,
    activeShadow: n.warningActiveShadow,
    affixColor: n.colorWarning
  })), e)
}), vL = (n, e) => ({
  [`&${n.componentCls}-group-wrapper-status-${e.status}`]: {
    [`${n.componentCls}-group-addon`]: {
      borderColor: e.addonBorderColor,
      color: e.addonColor
    }
  }
}), VH = (n) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign({
    [`${n.componentCls}-group`]: {
      "&-addon": {
        background: n.addonBg,
        border: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    }
  }, vL(n, {
    status: "error",
    addonBorderColor: n.colorError,
    addonColor: n.colorErrorText
  })), vL(n, {
    status: "warning",
    addonBorderColor: n.colorWarning,
    addonColor: n.colorWarningText
  })), {
    [`&${n.componentCls}-group-wrapper-disabled`]: {
      [`${n.componentCls}-group-addon`]: Object.assign({}, pO(n))
    }
  })
}), kH = (n, e) => {
  const {
    componentCls: t
  } = n;
  return {
    "&-borderless": Object.assign({
      background: "transparent",
      border: "none",
      "&:focus, &:focus-within": {
        outline: "none"
      },
      // >>>>> Disabled
      [`&${t}-disabled, &[disabled]`]: {
        color: n.colorTextDisabled
      },
      // >>>>> Status
      [`&${t}-status-error`]: {
        "&, & input, & textarea": {
          color: n.colorError
        }
      },
      [`&${t}-status-warning`]: {
        "&, & input, & textarea": {
          color: n.colorWarning
        }
      }
    }, e)
  };
}, $H = (n, e) => ({
  background: e.bg,
  borderWidth: n.lineWidth,
  borderStyle: n.lineType,
  borderColor: "transparent",
  "input&, & input, textarea&, & textarea": {
    color: e == null ? void 0 : e.inputColor
  },
  "&:hover": {
    background: e.hoverBg
  },
  "&:focus, &:focus-within": {
    outline: 0,
    borderColor: e.activeBorderColor,
    backgroundColor: n.activeBg
  }
}), yL = (n, e) => ({
  [`&${n.componentCls}-status-${e.status}:not(${n.componentCls}-disabled)`]: Object.assign(Object.assign({}, $H(n, e)), {
    [`${n.componentCls}-prefix, ${n.componentCls}-suffix`]: {
      color: e.affixColor
    }
  })
}), WH = (n, e) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, $H(n, {
    bg: n.colorFillTertiary,
    hoverBg: n.colorFillSecondary,
    activeBorderColor: n.activeBorderColor
  })), {
    [`&${n.componentCls}-disabled, &[disabled]`]: Object.assign({}, pO(n))
  }), yL(n, {
    status: "error",
    bg: n.colorErrorBg,
    hoverBg: n.colorErrorBgHover,
    activeBorderColor: n.colorError,
    inputColor: n.colorErrorText,
    affixColor: n.colorError
  })), yL(n, {
    status: "warning",
    bg: n.colorWarningBg,
    hoverBg: n.colorWarningBgHover,
    activeBorderColor: n.colorWarning,
    inputColor: n.colorWarningText,
    affixColor: n.colorWarning
  })), e)
}), bL = (n, e) => ({
  [`&${n.componentCls}-group-wrapper-status-${e.status}`]: {
    [`${n.componentCls}-group-addon`]: {
      background: e.addonBg,
      color: e.addonColor
    }
  }
}), jH = (n) => ({
  "&-filled": Object.assign(Object.assign(Object.assign({
    [`${n.componentCls}-group`]: {
      "&-addon": {
        background: n.colorFillTertiary
      },
      [`${n.componentCls}-filled:not(:focus):not(:focus-within)`]: {
        "&:not(:first-child)": {
          borderInlineStart: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorSplit}`
        },
        "&:not(:last-child)": {
          borderInlineEnd: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorSplit}`
        }
      }
    }
  }, bL(n, {
    status: "error",
    addonBg: n.colorErrorBg,
    addonColor: n.colorErrorText
  })), bL(n, {
    status: "warning",
    addonBg: n.colorWarningBg,
    addonColor: n.colorWarningText
  })), {
    [`&${n.componentCls}-group-wrapper-disabled`]: {
      [`${n.componentCls}-group`]: {
        "&-addon": {
          background: n.colorFillTertiary,
          color: n.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
          borderTop: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
          borderBottom: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
          borderTop: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
          borderBottom: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`
        }
      }
    }
  })
}), GH = (n) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: n,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), XH = (n) => {
  const {
    paddingBlockLG: e,
    lineHeightLG: t,
    borderRadiusLG: r,
    paddingInlineLG: i
  } = n;
  return {
    padding: `${Mt(e)} ${Mt(i)}`,
    fontSize: n.inputFontSizeLG,
    lineHeight: t,
    borderRadius: r
  };
}, qH = (n) => ({
  padding: `${Mt(n.paddingBlockSM)} ${Mt(n.paddingInlineSM)}`,
  fontSize: n.inputFontSizeSM,
  borderRadius: n.borderRadiusSM
}), ME = (n) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${Mt(n.paddingBlock)} ${Mt(n.paddingInline)}`,
  color: n.colorText,
  fontSize: n.inputFontSize,
  lineHeight: n.lineHeight,
  borderRadius: n.borderRadius,
  transition: `all ${n.motionDurationMid}`
}, GH(n.colorTextPlaceholder)), {
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    // prevent textarea resize from coming out of its container
    height: "auto",
    minHeight: n.controlHeight,
    lineHeight: n.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${n.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": Object.assign({}, XH(n)),
  "&-sm": Object.assign({}, qH(n)),
  // RTL
  "&-rtl, &-textarea-rtl": {
    direction: "rtl"
  }
}), YH = (n) => {
  const {
    componentCls: e,
    antCls: t
  } = n;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: n.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${e}, &-lg > ${e}-group-addon`]: Object.assign({}, XH(n)),
    [`&-sm ${e}, &-sm > ${e}-group-addon`]: Object.assign({}, qH(n)),
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${t}-select-single ${t}-select-selector`]: {
      height: n.controlHeightLG
    },
    [`&-sm ${t}-select-single ${t}-select-selector`]: {
      height: n.controlHeightSM
    },
    [`> ${e}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${e}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${Mt(n.paddingInline)}`,
        color: n.colorText,
        fontWeight: "normal",
        fontSize: n.inputFontSize,
        textAlign: "center",
        borderRadius: n.borderRadius,
        transition: `all ${n.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${t}-select`]: {
          margin: `${Mt(n.calc(n.paddingBlock).add(1).mul(-1).equal())} ${Mt(n.calc(n.paddingInline).mul(-1).equal())}`,
          [`&${t}-select-single:not(${t}-select-customize-input):not(${t}-pagination-size-changer)`]: {
            [`${t}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${Mt(n.lineWidth)} ${n.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${t}-select-selector`]: {
              color: n.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${t}-cascader-picker`]: {
          margin: `-9px ${Mt(n.calc(n.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${t}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [`${e}`]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${e}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${e}:first-child, ${e}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${t}-select ${t}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${e}-affix-wrapper`]: {
      [`&:not(:first-child) ${e}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${e}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${e}:last-child, ${e}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${t}-select ${t}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${e}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${e}-search &`]: {
          borderStartStartRadius: n.borderRadius,
          borderEndStartRadius: n.borderRadius
        }
      },
      [`&:not(:first-child), ${e}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${e}-group-compact`]: Object.assign(Object.assign({
      display: "block"
    }, D7()), {
      [`${e}-group-addon, ${e}-group-wrap, > ${e}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: n.lineWidth,
          "&:hover, &:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-flex",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${e}-affix-wrapper,
        & > ${e}-number-affix-wrapper,
        & > ${t}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: n.calc(n.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: n.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${e}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${t}-select > ${t}-select-selector,
      & > ${t}-select-auto-complete ${e},
      & > ${t}-cascader-picker ${e},
      & > ${e}-group-wrapper ${e}`]: {
        borderInlineEndWidth: n.lineWidth,
        borderRadius: 0,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`& > ${t}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${t}-select > ${t}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${t}-select:first-child > ${t}-select-selector,
      & > ${t}-select-auto-complete:first-child ${e},
      & > ${t}-cascader-picker:first-child ${e}`]: {
        borderStartStartRadius: n.borderRadius,
        borderEndStartRadius: n.borderRadius
      },
      [`& > *:last-child,
      & > ${t}-select:last-child > ${t}-select-selector,
      & > ${t}-cascader-picker:last-child ${e},
      & > ${t}-cascader-picker-focused:last-child ${e}`]: {
        borderInlineEndWidth: n.lineWidth,
        borderStartEndRadius: n.borderRadius,
        borderEndEndRadius: n.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${t}-select-auto-complete ${e}`]: {
        verticalAlign: "top"
      },
      [`${e}-group-wrapper + ${e}-group-wrapper`]: {
        marginInlineStart: n.calc(n.lineWidth).mul(-1).equal(),
        [`${e}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${e}-group-wrapper:not(:last-child)`]: {
        [`&${e}-search > ${e}-group`]: {
          [`& > ${e}-group-addon > ${e}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${e}`]: {
            borderStartStartRadius: n.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: n.borderRadius
          }
        }
      }
    })
  };
}, iJ = (n) => {
  const {
    componentCls: e,
    controlHeightSM: t,
    lineWidth: r,
    calc: i
  } = n, o = i(t).sub(i(r).mul(2)).sub(16).div(2).equal();
  return {
    [e]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Vo(n)), ME(n)), HH(n)), WH(n)), kH(n)), {
      '&[type="color"]': {
        height: n.controlHeight,
        [`&${e}-lg`]: {
          height: n.controlHeightLG
        },
        [`&${e}-sm`]: {
          height: t,
          paddingTop: o,
          paddingBottom: o
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        "-webkit-appearance": "none"
      }
    })
  };
}, aJ = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    // ========================= Input =========================
    [`${e}-clear-icon`]: {
      margin: 0,
      color: n.colorTextQuaternary,
      fontSize: n.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${n.motionDurationSlow}`,
      "&:hover": {
        color: n.colorTextTertiary
      },
      "&:active": {
        color: n.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${Mt(n.inputAffixPadding)}`
      }
    }
  };
}, oJ = (n) => {
  const {
    componentCls: e,
    inputAffixPadding: t,
    colorTextDescription: r,
    motionDurationSlow: i,
    colorIcon: a,
    colorIconHover: o,
    iconCls: s
  } = n;
  return {
    [`${e}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign({}, ME(n)), {
      display: "inline-flex",
      [`&:not(${e}-disabled):hover`]: {
        zIndex: 1,
        [`${e}-search-with-button &`]: {
          zIndex: 0
        }
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${e}`]: {
        padding: 0
      },
      [`> input${e}, > textarea${e}`]: {
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${e}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: n.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: r
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: n.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: t
        },
        "&-suffix": {
          marginInlineStart: t
        }
      }
    }), aJ(n)), {
      // password
      [`${s}${e}-password-icon`]: {
        color: a,
        cursor: "pointer",
        transition: `all ${i}`,
        "&:hover": {
          color: o
        }
      }
    })
  };
}, sJ = (n) => {
  const {
    componentCls: e,
    borderRadiusLG: t,
    borderRadiusSM: r
  } = n;
  return {
    [`${e}-group`]: Object.assign(Object.assign(Object.assign({}, Vo(n)), YH(n)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": Object.assign(Object.assign(Object.assign({
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${e}-group-addon`]: {
            borderRadius: t,
            fontSize: n.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${e}-group-addon`]: {
            borderRadius: r
          }
        }
      }, VH(n)), jH(n)), {
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${e}-compact-first-item):not(${e}-compact-last-item)${e}-compact-item`]: {
          [`${e}, ${e}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${e}-compact-last-item)${e}-compact-first-item`]: {
          [`${e}, ${e}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${e}-compact-first-item)${e}-compact-last-item`]: {
          [`${e}, ${e}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${e}-compact-last-item)${e}-compact-item`]: {
          [`${e}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      })
    })
  };
}, lJ = (n) => {
  const {
    componentCls: e,
    antCls: t
  } = n, r = `${e}-search`;
  return {
    [r]: {
      [`${e}`]: {
        "&:hover, &:focus": {
          borderColor: n.colorPrimaryHover,
          [`+ ${e}-group-addon ${r}-button:not(${t}-btn-primary)`]: {
            borderInlineStartColor: n.colorPrimaryHover
          }
        }
      },
      [`${e}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${e}-lg`]: {
        lineHeight: n.calc(n.lineHeightLG).sub(2e-4).equal()
      },
      [`> ${e}-group`]: {
        [`> ${e}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${r}-button`]: {
            // Fix https://github.com/ant-design/ant-design/issues/47150
            marginInlineEnd: -1,
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: n.borderRadius,
            borderEndEndRadius: n.borderRadius,
            borderEndStartRadius: 0,
            boxShadow: "none"
          },
          [`${r}-button:not(${t}-btn-primary)`]: {
            color: n.colorTextDescription,
            "&:hover": {
              color: n.colorPrimaryHover
            },
            "&:active": {
              color: n.colorPrimaryActive
            },
            [`&${t}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${r}-button`]: {
        height: n.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${r}-button`]: {
        height: n.controlHeightLG
      },
      [`&-small ${r}-button`]: {
        height: n.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${e}-compact-item`]: {
        [`&:not(${e}-compact-last-item)`]: {
          [`${e}-group-addon`]: {
            [`${e}-search-button`]: {
              marginInlineEnd: n.calc(n.lineWidth).mul(-1).equal(),
              borderRadius: 0
            }
          }
        },
        [`&:not(${e}-compact-first-item)`]: {
          [`${e},${e}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${e}-group-addon ${e}-search-button,
        > ${e},
        ${e}-affix-wrapper`]: {
          "&:hover, &:focus, &:active": {
            zIndex: 2
          }
        },
        [`> ${e}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
}, cJ = (n) => {
  const {
    componentCls: e,
    paddingLG: t
  } = n, r = `${e}-textarea`;
  return {
    [r]: {
      position: "relative",
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${e}`]: {
          height: "100%"
        },
        [`${e}-data-count`]: {
          position: "absolute",
          bottom: n.calc(n.fontSize).mul(n.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: n.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      [`
        &-allow-clear > ${e},
        &-affix-wrapper${r}-has-feedback ${e}
      `]: {
        paddingInlineEnd: t
      },
      [`&-affix-wrapper${e}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${e}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${e}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${e}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: n.paddingInline,
            insetBlockStart: n.paddingXS
          },
          // Feedback Icon
          [`${r}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: n.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      },
      [`&-affix-wrapper${e}-affix-wrapper-sm`]: {
        [`${e}-suffix`]: {
          [`${e}-clear-icon`]: {
            insetInlineEnd: n.paddingInlineSM
          }
        }
      }
    }
  };
}, uJ = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    [`${e}-out-of-range`]: {
      [`&, & input, & textarea, ${e}-show-count-suffix, ${e}-data-count`]: {
        color: n.colorError
      }
    }
  };
}, mO = $o("Input", (n) => {
  const e = li(n, fO(n));
  return [
    iJ(e),
    cJ(e),
    oJ(e),
    sJ(e),
    lJ(e),
    uJ(e),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    EE(e)
  ];
}, hO, {
  resetFont: !1
}), KH = /* @__PURE__ */ hg({}), dJ = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    // Grid system
    [e]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around": {
        justifyContent: "space-around"
      },
      "&-space-evenly": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
}, fJ = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    // Grid system
    [e]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
}, hJ = (n, e) => {
  const {
    prefixCls: t,
    componentCls: r,
    gridColumns: i
  } = n, a = {};
  for (let o = i; o >= 0; o--)
    o === 0 ? (a[`${r}${e}-${o}`] = {
      display: "none"
    }, a[`${r}-push-${o}`] = {
      insetInlineStart: "auto"
    }, a[`${r}-pull-${o}`] = {
      insetInlineEnd: "auto"
    }, a[`${r}${e}-push-${o}`] = {
      insetInlineStart: "auto"
    }, a[`${r}${e}-pull-${o}`] = {
      insetInlineEnd: "auto"
    }, a[`${r}${e}-offset-${o}`] = {
      marginInlineStart: 0
    }, a[`${r}${e}-order-${o}`] = {
      order: 0
    }) : (a[`${r}${e}-${o}`] = [
      // https://github.com/ant-design/ant-design/issues/44456
      // Form set `display: flex` on Col which will override `display: block`.
      // Let's get it from css variable to support override.
      {
        "--ant-display": "block",
        // Fallback to display if variable not support
        display: "block"
      },
      {
        display: "var(--ant-display)",
        flex: `0 0 ${o / i * 100}%`,
        maxWidth: `${o / i * 100}%`
      }
    ], a[`${r}${e}-push-${o}`] = {
      insetInlineStart: `${o / i * 100}%`
    }, a[`${r}${e}-pull-${o}`] = {
      insetInlineEnd: `${o / i * 100}%`
    }, a[`${r}${e}-offset-${o}`] = {
      marginInlineStart: `${o / i * 100}%`
    }, a[`${r}${e}-order-${o}`] = {
      order: o
    });
  return a[`${r}${e}-flex`] = {
    flex: `var(--${t}${e}-flex)`
  }, a;
}, HR = (n, e) => hJ(n, e), pJ = (n, e, t) => ({
  [`@media (min-width: ${Mt(e)})`]: Object.assign({}, HR(n, t))
}), mJ = () => ({}), gJ = () => ({}), vJ = $o("Grid", dJ, mJ), yJ = $o("Grid", (n) => {
  const e = li(n, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  }), t = {
    "-sm": e.screenSMMin,
    "-md": e.screenMDMin,
    "-lg": e.screenLGMin,
    "-xl": e.screenXLMin,
    "-xxl": e.screenXXLMin
  };
  return [fJ(e), HR(e, ""), HR(e, "-xs"), Object.keys(t).map((r) => pJ(e, t[r], r)).reduce((r, i) => Object.assign(Object.assign({}, r), i), {})];
}, gJ);
var bJ = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function SL(n) {
  return typeof n == "number" ? `${n} ${n} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(n) ? `0 0 ${n}` : n;
}
const SJ = ["xs", "sm", "md", "lg", "xl", "xxl"], gO = /* @__PURE__ */ O.forwardRef((n, e) => {
  const {
    getPrefixCls: t,
    direction: r
  } = O.useContext(mr), {
    gutter: i,
    wrap: a
  } = O.useContext(KH), {
    prefixCls: o,
    span: s,
    order: u,
    offset: d,
    push: f,
    pull: p,
    className: g,
    children: v,
    flex: b,
    style: E
  } = n, S = bJ(n, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]), _ = t("col", o), [w, C, R] = yJ(_), P = {};
  let D = {};
  SJ.forEach((L) => {
    let N = {};
    const H = n[L];
    typeof H == "number" ? N.span = H : typeof H == "object" && (N = H || {}), delete S[L], D = Object.assign(Object.assign({}, D), {
      [`${_}-${L}-${N.span}`]: N.span !== void 0,
      [`${_}-${L}-order-${N.order}`]: N.order || N.order === 0,
      [`${_}-${L}-offset-${N.offset}`]: N.offset || N.offset === 0,
      [`${_}-${L}-push-${N.push}`]: N.push || N.push === 0,
      [`${_}-${L}-pull-${N.pull}`]: N.pull || N.pull === 0,
      [`${_}-rtl`]: r === "rtl"
    }), N.flex && (D[`${_}-${L}-flex`] = !0, P[`--${_}-${L}-flex`] = SL(N.flex));
  });
  const I = Et(_, {
    [`${_}-${s}`]: s !== void 0,
    [`${_}-order-${u}`]: u,
    [`${_}-offset-${d}`]: d,
    [`${_}-push-${f}`]: f,
    [`${_}-pull-${p}`]: p
  }, g, D, C, R), U = {};
  if (i && i[0] > 0) {
    const L = i[0] / 2;
    U.paddingLeft = L, U.paddingRight = L;
  }
  return b && (U.flex = SL(b), a === !1 && !U.minWidth && (U.minWidth = 0)), w(/* @__PURE__ */ O.createElement("div", Object.assign({}, S, {
    style: Object.assign(Object.assign(Object.assign({}, U), E), P),
    className: I,
    ref: e
  }), v));
});
Ee.env.NODE_ENV !== "production" && (gO.displayName = "Col");
var _J = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function _L(n, e) {
  const [t, r] = O.useState(typeof n == "string" ? n : ""), i = () => {
    if (typeof n == "string" && r(n), typeof n == "object")
      for (let a = 0; a < Ky.length; a++) {
        const o = Ky[a];
        if (!e[o])
          continue;
        const s = n[o];
        if (s !== void 0) {
          r(s);
          return;
        }
      }
  };
  return O.useEffect(() => {
    i();
  }, [JSON.stringify(n), e]), t;
}
const ZH = /* @__PURE__ */ O.forwardRef((n, e) => {
  const {
    prefixCls: t,
    justify: r,
    align: i,
    className: a,
    style: o,
    children: s,
    gutter: u = 0,
    wrap: d
  } = n, f = _J(n, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]), {
    getPrefixCls: p,
    direction: g
  } = O.useContext(mr), [v, b] = O.useState({
    xs: !0,
    sm: !0,
    md: !0,
    lg: !0,
    xl: !0,
    xxl: !0
  }), [E, S] = O.useState({
    xs: !1,
    sm: !1,
    md: !1,
    lg: !1,
    xl: !1,
    xxl: !1
  }), _ = _L(i, E), w = _L(r, E), C = O.useRef(u), R = RQ();
  O.useEffect(() => {
    const K = R.subscribe((B) => {
      S(B);
      const Q = C.current || 0;
      (!Array.isArray(Q) && typeof Q == "object" || Array.isArray(Q) && (typeof Q[0] == "object" || typeof Q[1] == "object")) && b(B);
    });
    return () => R.unsubscribe(K);
  }, []);
  const P = () => {
    const K = [void 0, void 0];
    return (Array.isArray(u) ? u : [u, void 0]).forEach((Q, V) => {
      if (typeof Q == "object")
        for (let q = 0; q < Ky.length; q++) {
          const ne = Ky[q];
          if (v[ne] && Q[ne] !== void 0) {
            K[V] = Q[ne];
            break;
          }
        }
      else
        K[V] = Q;
    }), K;
  }, D = p("row", t), [I, U, L] = vJ(D), N = P(), H = Et(D, {
    [`${D}-no-wrap`]: d === !1,
    [`${D}-${w}`]: w,
    [`${D}-${_}`]: _,
    [`${D}-rtl`]: g === "rtl"
  }, a, U, L), j = {}, G = N[0] != null && N[0] > 0 ? N[0] / -2 : void 0;
  G && (j.marginLeft = G, j.marginRight = G);
  const [X, ae] = N;
  j.rowGap = ae;
  const Z = O.useMemo(() => ({
    gutter: [X, ae],
    wrap: d
  }), [X, ae, d]);
  return I(/* @__PURE__ */ O.createElement(KH.Provider, {
    value: Z
  }, /* @__PURE__ */ O.createElement("div", Object.assign({}, f, {
    className: H,
    style: Object.assign(Object.assign({}, j), o),
    ref: e
  }), s)));
});
Ee.env.NODE_ENV !== "production" && (ZH.displayName = "Row");
var QH = /* @__PURE__ */ Fe.forwardRef(function(n, e) {
  var t = n.prefixCls, r = n.forceRender, i = n.className, a = n.style, o = n.children, s = n.isActive, u = n.role, d = Fe.useState(s || r), f = ot(d, 2), p = f[0], g = f[1];
  return Fe.useEffect(function() {
    (r || s) && g(!0);
  }, [r, s]), p ? /* @__PURE__ */ Fe.createElement("div", {
    ref: e,
    className: Et("".concat(t, "-content"), Re(Re({}, "".concat(t, "-content-active"), s), "".concat(t, "-content-inactive"), !s), i),
    style: a,
    role: u
  }, /* @__PURE__ */ Fe.createElement("div", {
    className: "".concat(t, "-content-box")
  }, o)) : null;
});
QH.displayName = "PanelContent";
var xJ = ["showArrow", "headerClass", "isActive", "onItemClick", "forceRender", "className", "prefixCls", "collapsible", "accordion", "panelKey", "extra", "header", "expandIcon", "openMotion", "destroyInactivePanel", "children"], JH = /* @__PURE__ */ Fe.forwardRef(function(n, e) {
  var t = n.showArrow, r = t === void 0 ? !0 : t, i = n.headerClass, a = n.isActive, o = n.onItemClick, s = n.forceRender, u = n.className, d = n.prefixCls, f = n.collapsible, p = n.accordion, g = n.panelKey, v = n.extra, b = n.header, E = n.expandIcon, S = n.openMotion, _ = n.destroyInactivePanel, w = n.children, C = br(n, xJ), R = f === "disabled", P = f === "header", D = f === "icon", I = v != null && typeof v != "boolean", U = function() {
    o == null || o(g);
  }, L = function(ae) {
    (ae.key === "Enter" || ae.keyCode === Ft.ENTER || ae.which === Ft.ENTER) && U();
  }, N = typeof E == "function" ? E(n) : /* @__PURE__ */ Fe.createElement("i", {
    className: "arrow"
  });
  N && (N = /* @__PURE__ */ Fe.createElement("div", {
    className: "".concat(d, "-expand-icon"),
    onClick: ["header", "icon"].includes(f) ? U : void 0
  }, N));
  var H = Et(Re(Re(Re({}, "".concat(d, "-item"), !0), "".concat(d, "-item-active"), a), "".concat(d, "-item-disabled"), R), u), j = Et(i, Re(Re(Re({}, "".concat(d, "-header"), !0), "".concat(d, "-header-collapsible-only"), P), "".concat(d, "-icon-collapsible-only"), D)), G = {
    className: j,
    "aria-expanded": a,
    "aria-disabled": R,
    onKeyDown: L
  };
  return !P && !D && (G.onClick = U, G.role = p ? "tab" : "button", G.tabIndex = R ? -1 : 0), /* @__PURE__ */ Fe.createElement("div", gn({}, C, {
    ref: e,
    className: H
  }), /* @__PURE__ */ Fe.createElement("div", G, r && N, /* @__PURE__ */ Fe.createElement("span", {
    className: "".concat(d, "-header-text"),
    onClick: f === "header" ? U : void 0
  }, b), I && /* @__PURE__ */ Fe.createElement("div", {
    className: "".concat(d, "-extra")
  }, v)), /* @__PURE__ */ Fe.createElement(Hh, gn({
    visible: a,
    leavedClassName: "".concat(d, "-content-hidden")
  }, S, {
    forceRender: s,
    removeOnLeave: _
  }), function(X, ae) {
    var Z = X.className, K = X.style;
    return /* @__PURE__ */ Fe.createElement(QH, {
      ref: ae,
      prefixCls: d,
      className: Z,
      style: K,
      isActive: a,
      forceRender: s,
      role: p ? "tabpanel" : void 0
    }, w);
  }));
}), EJ = ["children", "label", "key", "collapsible", "onItemClick", "destroyInactivePanel"], CJ = function(e, t) {
  var r = t.prefixCls, i = t.accordion, a = t.collapsible, o = t.destroyInactivePanel, s = t.onItemClick, u = t.activeKey, d = t.openMotion, f = t.expandIcon;
  return e.map(function(p, g) {
    var v = p.children, b = p.label, E = p.key, S = p.collapsible, _ = p.onItemClick, w = p.destroyInactivePanel, C = br(p, EJ), R = String(E ?? g), P = S ?? a, D = w ?? o, I = function(N) {
      P !== "disabled" && (s(N), _ == null || _(N));
    }, U = !1;
    return i ? U = u[0] === R : U = u.indexOf(R) > -1, /* @__PURE__ */ Fe.createElement(JH, gn({}, C, {
      prefixCls: r,
      key: R,
      panelKey: R,
      isActive: U,
      accordion: i,
      openMotion: d,
      expandIcon: f,
      header: b,
      collapsible: P,
      onItemClick: I,
      destroyInactivePanel: D
    }), v);
  });
}, wJ = function(e, t, r) {
  if (!e) return null;
  var i = r.prefixCls, a = r.accordion, o = r.collapsible, s = r.destroyInactivePanel, u = r.onItemClick, d = r.activeKey, f = r.openMotion, p = r.expandIcon, g = e.key || String(t), v = e.props, b = v.header, E = v.headerClass, S = v.destroyInactivePanel, _ = v.collapsible, w = v.onItemClick, C = !1;
  a ? C = d[0] === g : C = d.indexOf(g) > -1;
  var R = _ ?? o, P = function(U) {
    R !== "disabled" && (u(U), w == null || w(U));
  }, D = {
    key: g,
    panelKey: g,
    header: b,
    headerClass: E,
    isActive: C,
    prefixCls: i,
    destroyInactivePanel: S ?? s,
    openMotion: f,
    accordion: a,
    children: e.props.children,
    onItemClick: P,
    expandIcon: p,
    collapsible: R
  };
  return typeof e.type == "string" ? e : (Object.keys(D).forEach(function(I) {
    typeof D[I] > "u" && delete D[I];
  }), /* @__PURE__ */ Fe.cloneElement(e, D));
};
function MJ(n, e, t) {
  return Array.isArray(n) ? CJ(n, t) : dc(e).map(function(r, i) {
    return wJ(r, i, t);
  });
}
function TJ(n) {
  var e = n;
  if (!Array.isArray(e)) {
    var t = bn(e);
    e = t === "number" || t === "string" ? [e] : [];
  }
  return e.map(function(r) {
    return String(r);
  });
}
var RJ = /* @__PURE__ */ Fe.forwardRef(function(n, e) {
  var t = n.prefixCls, r = t === void 0 ? "rc-collapse" : t, i = n.destroyInactivePanel, a = i === void 0 ? !1 : i, o = n.style, s = n.accordion, u = n.className, d = n.children, f = n.collapsible, p = n.openMotion, g = n.expandIcon, v = n.activeKey, b = n.defaultActiveKey, E = n.onChange, S = n.items, _ = Et(r, u), w = ko([], {
    value: v,
    onChange: function(L) {
      return E == null ? void 0 : E(L);
    },
    defaultValue: b,
    postState: TJ
  }), C = ot(w, 2), R = C[0], P = C[1], D = function(L) {
    return P(function() {
      if (s)
        return R[0] === L ? [] : [L];
      var N = R.indexOf(L), H = N > -1;
      return H ? R.filter(function(j) {
        return j !== L;
      }) : [].concat(jt(R), [L]);
    });
  };
  Yn(!d, "[rc-collapse] `children` will be removed in next major version. Please use `items` instead.");
  var I = MJ(S, d, {
    prefixCls: r,
    accordion: s,
    openMotion: p,
    expandIcon: g,
    collapsible: f,
    destroyInactivePanel: a,
    onItemClick: D,
    activeKey: R
  });
  return /* @__PURE__ */ Fe.createElement("div", gn({
    ref: e,
    className: _,
    style: o,
    role: s ? "tablist" : void 0
  }, ng(n, {
    aria: !0,
    data: !0
  })), I);
});
const vO = Object.assign(RJ, {
  /**
   * @deprecated use `items` instead, will be removed in `v4.0.0`
   */
  Panel: JH
});
vO.Panel;
const AJ = /* @__PURE__ */ O.forwardRef((n, e) => {
  Ee.env.NODE_ENV !== "production" && ci("Collapse.Panel").deprecated(!("disabled" in n), "disabled", 'collapsible="disabled"');
  const {
    getPrefixCls: t
  } = O.useContext(mr), {
    prefixCls: r,
    className: i,
    showArrow: a = !0
  } = n, o = t("collapse", r), s = Et({
    [`${o}-no-arrow`]: !a
  }, i);
  return /* @__PURE__ */ O.createElement(vO.Panel, Object.assign({
    ref: e
  }, n, {
    prefixCls: o,
    className: s
  }));
}), OJ = (n) => {
  const {
    componentCls: e,
    contentBg: t,
    padding: r,
    headerBg: i,
    headerPadding: a,
    collapseHeaderPaddingSM: o,
    collapseHeaderPaddingLG: s,
    collapsePanelBorderRadius: u,
    lineWidth: d,
    lineType: f,
    colorBorder: p,
    colorText: g,
    colorTextHeading: v,
    colorTextDisabled: b,
    fontSizeLG: E,
    lineHeight: S,
    lineHeightLG: _,
    marginSM: w,
    paddingSM: C,
    paddingLG: R,
    paddingXS: P,
    motionDurationSlow: D,
    fontSizeIcon: I,
    contentPadding: U,
    fontHeight: L,
    fontHeightLG: N
  } = n, H = `${Mt(d)} ${f} ${p}`;
  return {
    [e]: Object.assign(Object.assign({}, Vo(n)), {
      backgroundColor: i,
      border: H,
      borderRadius: u,
      "&-rtl": {
        direction: "rtl"
      },
      [`& > ${e}-item`]: {
        borderBottom: H,
        "&:last-child": {
          [`
            &,
            & > ${e}-header`]: {
            borderRadius: `0 0 ${Mt(u)} ${Mt(u)}`
          }
        },
        [`> ${e}-header`]: {
          position: "relative",
          // Compatible with old version of antd, should remove in next version
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          padding: a,
          color: v,
          lineHeight: S,
          cursor: "pointer",
          transition: `all ${D}, visibility 0s`,
          [`> ${e}-header-text`]: {
            flex: "auto"
          },
          "&:focus": {
            outline: "none"
          },
          // >>>>> Arrow
          [`${e}-expand-icon`]: {
            height: L,
            display: "flex",
            alignItems: "center",
            paddingInlineEnd: w
          },
          [`${e}-arrow`]: Object.assign(Object.assign({}, b0()), {
            fontSize: I,
            // when `transform: rotate()` is applied to icon's root element
            transition: `transform ${D}`,
            // when `transform: rotate()` is applied to icon's child element
            svg: {
              transition: `transform ${D}`
            }
          }),
          // >>>>> Text
          [`${e}-header-text`]: {
            marginInlineEnd: "auto"
          }
        },
        [`${e}-icon-collapsible-only`]: {
          cursor: "unset",
          [`${e}-expand-icon`]: {
            cursor: "pointer"
          }
        }
      },
      [`${e}-content`]: {
        color: g,
        backgroundColor: t,
        borderTop: H,
        [`& > ${e}-content-box`]: {
          padding: U
        },
        "&-hidden": {
          display: "none"
        }
      },
      "&-small": {
        [`> ${e}-item`]: {
          [`> ${e}-header`]: {
            padding: o,
            paddingInlineStart: P,
            [`> ${e}-expand-icon`]: {
              // Arrow offset
              marginInlineStart: n.calc(C).sub(P).equal()
            }
          },
          [`> ${e}-content > ${e}-content-box`]: {
            padding: C
          }
        }
      },
      "&-large": {
        [`> ${e}-item`]: {
          fontSize: E,
          lineHeight: _,
          [`> ${e}-header`]: {
            padding: s,
            paddingInlineStart: r,
            [`> ${e}-expand-icon`]: {
              height: N,
              // Arrow offset
              marginInlineStart: n.calc(R).sub(r).equal()
            }
          },
          [`> ${e}-content > ${e}-content-box`]: {
            padding: R
          }
        }
      },
      [`${e}-item:last-child`]: {
        borderBottom: 0,
        [`> ${e}-content`]: {
          borderRadius: `0 0 ${Mt(u)} ${Mt(u)}`
        }
      },
      [`& ${e}-item-disabled > ${e}-header`]: {
        "\n          &,\n          & > .arrow\n        ": {
          color: b,
          cursor: "not-allowed"
        }
      },
      // ========================== Icon Position ==========================
      [`&${e}-icon-position-end`]: {
        [`& > ${e}-item`]: {
          [`> ${e}-header`]: {
            [`${e}-expand-icon`]: {
              order: 1,
              paddingInlineEnd: 0,
              paddingInlineStart: w
            }
          }
        }
      }
    })
  };
}, PJ = (n) => {
  const {
    componentCls: e
  } = n, t = `> ${e}-item > ${e}-header ${e}-arrow`;
  return {
    [`${e}-rtl`]: {
      [t]: {
        transform: "rotate(180deg)"
      }
    }
  };
}, DJ = (n) => {
  const {
    componentCls: e,
    headerBg: t,
    paddingXXS: r,
    colorBorder: i
  } = n;
  return {
    [`${e}-borderless`]: {
      backgroundColor: t,
      border: 0,
      [`> ${e}-item`]: {
        borderBottom: `1px solid ${i}`
      },
      [`
        > ${e}-item:last-child,
        > ${e}-item:last-child ${e}-header
      `]: {
        borderRadius: 0
      },
      [`> ${e}-item:last-child`]: {
        borderBottom: 0
      },
      [`> ${e}-item > ${e}-content`]: {
        backgroundColor: "transparent",
        borderTop: 0
      },
      [`> ${e}-item > ${e}-content > ${e}-content-box`]: {
        paddingTop: r
      }
    }
  };
}, IJ = (n) => {
  const {
    componentCls: e,
    paddingSM: t
  } = n;
  return {
    [`${e}-ghost`]: {
      backgroundColor: "transparent",
      border: 0,
      [`> ${e}-item`]: {
        borderBottom: 0,
        [`> ${e}-content`]: {
          backgroundColor: "transparent",
          border: 0,
          [`> ${e}-content-box`]: {
            paddingBlock: t
          }
        }
      }
    }
  };
}, NJ = (n) => ({
  headerPadding: `${n.paddingSM}px ${n.padding}px`,
  headerBg: n.colorFillAlter,
  contentPadding: `${n.padding}px 16px`,
  // Fixed Value
  contentBg: n.colorBgContainer
}), LJ = $o("Collapse", (n) => {
  const e = li(n, {
    collapseHeaderPaddingSM: `${Mt(n.paddingXS)} ${Mt(n.paddingSM)}`,
    collapseHeaderPaddingLG: `${Mt(n.padding)} ${Mt(n.paddingLG)}`,
    collapsePanelBorderRadius: n.borderRadiusLG
  });
  return [OJ(e), DJ(e), IJ(e), PJ(e), ZB(e)];
}, NJ), eV = /* @__PURE__ */ O.forwardRef((n, e) => {
  const {
    getPrefixCls: t,
    direction: r,
    collapse: i
  } = O.useContext(mr), {
    prefixCls: a,
    className: o,
    rootClassName: s,
    style: u,
    bordered: d = !0,
    ghost: f,
    size: p,
    expandIconPosition: g = "start",
    children: v,
    expandIcon: b
  } = n, E = mc((H) => {
    var j;
    return (j = p ?? H) !== null && j !== void 0 ? j : "middle";
  }), S = t("collapse", a), _ = t(), [w, C, R] = LJ(S);
  if (Ee.env.NODE_ENV !== "production") {
    const H = ci("Collapse");
    Ee.env.NODE_ENV !== "production" && H(g !== "left" && g !== "right", "deprecated", "`expandIconPosition` with `left` or `right` is deprecated. Please use `start` or `end` instead.");
  }
  const P = O.useMemo(() => g === "left" ? "start" : g === "right" ? "end" : g, [g]), D = b ?? (i == null ? void 0 : i.expandIcon), I = O.useCallback(function() {
    let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const j = typeof D == "function" ? D(H) : /* @__PURE__ */ O.createElement(zH, {
      rotate: H.isActive ? 90 : void 0,
      "aria-label": H.isActive ? "expanded" : "collapsed"
    });
    return fu(j, () => {
      var G;
      return {
        className: Et((G = j == null ? void 0 : j.props) === null || G === void 0 ? void 0 : G.className, `${S}-arrow`)
      };
    });
  }, [D, S]), U = Et(`${S}-icon-position-${P}`, {
    [`${S}-borderless`]: !d,
    [`${S}-rtl`]: r === "rtl",
    [`${S}-ghost`]: !!f,
    [`${S}-${E}`]: E !== "middle"
  }, i == null ? void 0 : i.className, o, s, C, R), L = Object.assign(Object.assign({}, CR(_)), {
    motionAppear: !1,
    leavedClassName: `${S}-content-hidden`
  }), N = O.useMemo(() => v ? dc(v).map((H, j) => {
    var G, X;
    if (!((G = H.props) === null || G === void 0) && G.disabled) {
      const ae = (X = H.key) !== null && X !== void 0 ? X : String(j), {
        disabled: Z,
        collapsible: K
      } = H.props, B = Object.assign(Object.assign({}, du(H.props, ["disabled"])), {
        key: ae,
        collapsible: K ?? (Z ? "disabled" : void 0)
      });
      return fu(H, B);
    }
    return H;
  }) : null, [v]);
  return w(
    // @ts-ignore
    /* @__PURE__ */ O.createElement(vO, Object.assign({
      ref: e,
      openMotion: L
    }, du(n, ["rootClassName"]), {
      expandIcon: I,
      prefixCls: S,
      className: U,
      style: Object.assign(Object.assign({}, i == null ? void 0 : i.style), u)
    }), N)
  );
});
Ee.env.NODE_ENV !== "production" && (eV.displayName = "Collapse");
const FJ = Object.assign(eV, {
  Panel: AJ
}), UJ = (n) => {
  const {
    componentCls: e,
    sizePaddingEdgeHorizontal: t,
    colorSplit: r,
    lineWidth: i,
    textPaddingInline: a,
    orientationMargin: o,
    verticalMarginInline: s
  } = n;
  return {
    [e]: Object.assign(Object.assign({}, Vo(n)), {
      borderBlockStart: `${Mt(i)} solid ${r}`,
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        marginInline: s,
        marginBlock: 0,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${Mt(i)} solid ${r}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        // Fix https://github.com/ant-design/ant-design/issues/10914
        margin: `${Mt(n.dividerHorizontalGutterMargin)} 0`
      },
      [`&-horizontal${e}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${Mt(n.dividerHorizontalWithTextGutterMargin)} 0`,
        color: n.colorTextHeading,
        fontWeight: 500,
        fontSize: n.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${r}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${Mt(i)} solid transparent`,
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${e}-with-text-left`]: {
        "&::before": {
          width: `calc(${o} * 100%)`
        },
        "&::after": {
          width: `calc(100% - ${o} * 100%)`
        }
      },
      [`&-horizontal${e}-with-text-right`]: {
        "&::before": {
          width: `calc(100% - ${o} * 100%)`
        },
        "&::after": {
          width: `calc(${o} * 100%)`
        }
      },
      [`${e}-inner-text`]: {
        display: "inline-block",
        paddingBlock: 0,
        paddingInline: a
      },
      "&-dashed": {
        background: "none",
        borderColor: r,
        borderStyle: "dashed",
        borderWidth: `${Mt(i)} 0 0`
      },
      [`&-horizontal${e}-with-text${e}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${e}-dashed`]: {
        borderInlineStartWidth: i,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${e}-with-text`]: {
        color: n.colorText,
        fontWeight: "normal",
        fontSize: n.fontSize
      },
      [`&-horizontal${e}-with-text-left${e}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${e}-inner-text`]: {
          paddingInlineStart: t
        }
      },
      [`&-horizontal${e}-with-text-right${e}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${e}-inner-text`]: {
          paddingInlineEnd: t
        }
      }
    })
  };
}, zJ = (n) => ({
  textPaddingInline: "1em",
  orientationMargin: 0.05,
  verticalMarginInline: n.marginXS
}), BJ = $o("Divider", (n) => {
  const e = li(n, {
    dividerHorizontalWithTextGutterMargin: n.margin,
    dividerHorizontalGutterMargin: n.marginLG,
    sizePaddingEdgeHorizontal: 0
  });
  return [UJ(e)];
}, zJ, {
  unitless: {
    orientationMargin: !0
  }
});
var HJ = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const tV = (n) => {
  const {
    getPrefixCls: e,
    direction: t,
    divider: r
  } = O.useContext(mr), {
    prefixCls: i,
    type: a = "horizontal",
    orientation: o = "center",
    orientationMargin: s,
    className: u,
    rootClassName: d,
    children: f,
    dashed: p,
    plain: g,
    style: v
  } = n, b = HJ(n, ["prefixCls", "type", "orientation", "orientationMargin", "className", "rootClassName", "children", "dashed", "plain", "style"]), E = e("divider", i), [S, _, w] = BJ(E), C = !!f, R = o === "left" && s != null, P = o === "right" && s != null, D = Et(E, r == null ? void 0 : r.className, _, w, `${E}-${a}`, {
    [`${E}-with-text`]: C,
    [`${E}-with-text-${o}`]: C,
    [`${E}-dashed`]: !!p,
    [`${E}-plain`]: !!g,
    [`${E}-rtl`]: t === "rtl",
    [`${E}-no-default-orientation-margin-left`]: R,
    [`${E}-no-default-orientation-margin-right`]: P
  }, u, d), I = O.useMemo(() => typeof s == "number" ? s : /^\d+$/.test(s) ? Number(s) : s, [s]), U = Object.assign(Object.assign({}, R && {
    marginLeft: I
  }), P && {
    marginRight: I
  });
  if (Ee.env.NODE_ENV !== "production") {
    const L = ci("Divider");
    Ee.env.NODE_ENV !== "production" && L(!f || a !== "vertical", "usage", "`children` not working in `vertical` mode.");
  }
  return S(/* @__PURE__ */ O.createElement("div", Object.assign({
    className: D,
    style: Object.assign(Object.assign({}, r == null ? void 0 : r.style), v)
  }, b, {
    // biome-ignore lint/a11y/useAriaPropsForRole: divider do not need aria-value
    role: "separator"
  }), f && a !== "vertical" && /* @__PURE__ */ O.createElement("span", {
    className: `${E}-inner-text`,
    style: U
  }, f)));
};
Ee.env.NODE_ENV !== "production" && (tV.displayName = "Divider");
var VJ = ["b"], kJ = ["v"], rM = function(e) {
  return Math.round(Number(e || 0));
}, $J = function(e) {
  if (e && bn(e) === "object" && "h" in e && "b" in e) {
    var t = e, r = t.b, i = br(t, VJ);
    return ke(ke({}, i), {}, {
      v: r
    });
  }
  return typeof e == "string" && /hsb/.test(e) ? e.replace(/hsb/, "hsv") : e;
}, bx = /* @__PURE__ */ function(n) {
  Wd(t, n);
  var e = jd(t);
  function t(r) {
    return ki(this, t), e.call(this, $J(r));
  }
  return $i(t, [{
    key: "toHsbString",
    value: function() {
      var i = this.toHsb(), a = rM(i.s * 100), o = rM(i.b * 100), s = rM(i.h), u = i.a, d = "hsb(".concat(s, ", ").concat(a, "%, ").concat(o, "%)"), f = "hsba(".concat(s, ", ").concat(a, "%, ").concat(o, "%, ").concat(u.toFixed(u === 0 ? 0 : 2), ")");
      return u === 1 ? d : f;
    }
  }, {
    key: "toHsb",
    value: function() {
      var i = this.toHsv();
      bn(this.originalInput) === "object" && this.originalInput && "h" in this.originalInput && (i = this.originalInput);
      var a = i;
      a.v;
      var o = br(a, kJ);
      return ke(ke({}, o), {}, {
        b: i.v,
        a: this.a
      });
    }
  }]), t;
}(la), WJ = "rc-color-picker", Hd = function(e) {
  return e instanceof bx ? e : new bx(e);
}, jJ = Hd("#1677ff"), nV = function(e) {
  var t = e.offset, r = e.targetRef, i = e.containerRef, a = e.color, o = e.type, s = i.current.getBoundingClientRect(), u = s.width, d = s.height, f = r.current.getBoundingClientRect(), p = f.width, g = f.height, v = p / 2, b = g / 2, E = (t.x + v) / u, S = 1 - (t.y + b) / d, _ = a.toHsb(), w = E, C = (t.x + v) / u * 360;
  if (o)
    switch (o) {
      case "hue":
        return Hd(ke(ke({}, _), {}, {
          h: C <= 0 ? 0 : C
        }));
      case "alpha":
        return Hd(ke(ke({}, _), {}, {
          a: w <= 0 ? 0 : w
        }));
    }
  return Hd({
    h: _.h,
    s: E <= 0 ? 0 : E,
    b: S >= 1 ? 1 : S,
    a: _.a
  });
}, rV = function(e, t, r, i) {
  var a = e.current.getBoundingClientRect(), o = a.width, s = a.height, u = t.current.getBoundingClientRect(), d = u.width, f = u.height, p = d / 2, g = f / 2, v = r.toHsb();
  if (!(d === 0 && f === 0 || d !== f)) {
    if (i)
      switch (i) {
        case "hue":
          return {
            x: v.h / 360 * o - p,
            y: -g / 3
          };
        case "alpha":
          return {
            x: v.a / 1 * o - p,
            y: -g / 3
          };
      }
    return {
      x: v.s * o - p,
      y: (1 - v.b) * s - g
    };
  }
}, yO = function(e) {
  var t = e.color, r = e.prefixCls, i = e.className, a = e.style, o = e.onClick, s = "".concat(r, "-color-block");
  return /* @__PURE__ */ Fe.createElement("div", {
    className: Et(s, i),
    style: a,
    onClick: o
  }, /* @__PURE__ */ Fe.createElement("div", {
    className: "".concat(s, "-inner"),
    style: {
      background: t
    }
  }));
};
function GJ(n) {
  var e = "touches" in n ? n.touches[0] : n, t = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset, r = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
  return {
    pageX: e.pageX - t,
    pageY: e.pageY - r
  };
}
function iV(n) {
  var e = n.offset, t = n.targetRef, r = n.containerRef, i = n.direction, a = n.onDragChange, o = n.onDragChangeComplete, s = n.calculate, u = n.color, d = n.disabledDrag, f = Lr(e || {
    x: 0,
    y: 0
  }), p = ot(f, 2), g = p[0], v = p[1], b = kt(null), E = kt(null), S = kt({
    flag: !1
  });
  In(function() {
    if (S.current.flag === !1) {
      var P = s == null ? void 0 : s(r);
      P && v(P);
    }
  }, [u, r]), In(function() {
    return function() {
      document.removeEventListener("mousemove", b.current), document.removeEventListener("mouseup", E.current), document.removeEventListener("touchmove", b.current), document.removeEventListener("touchend", E.current), b.current = null, E.current = null;
    };
  }, []);
  var _ = function(D) {
    var I = GJ(D), U = I.pageX, L = I.pageY, N = r.current.getBoundingClientRect(), H = N.x, j = N.y, G = N.width, X = N.height, ae = t.current.getBoundingClientRect(), Z = ae.width, K = ae.height, B = Z / 2, Q = K / 2, V = Math.max(0, Math.min(U - H, G)) - B, q = Math.max(0, Math.min(L - j, X)) - Q, ne = {
      x: V,
      y: i === "x" ? g.y : q
    };
    if (Z === 0 && K === 0 || Z !== K)
      return !1;
    v(ne), a == null || a(ne);
  }, w = function(D) {
    D.preventDefault(), _(D);
  }, C = function(D) {
    D.preventDefault(), S.current.flag = !1, document.removeEventListener("mousemove", b.current), document.removeEventListener("mouseup", E.current), document.removeEventListener("touchmove", b.current), document.removeEventListener("touchend", E.current), b.current = null, E.current = null, o == null || o();
  }, R = function(D) {
    document.removeEventListener("mousemove", b.current), document.removeEventListener("mouseup", E.current), !d && (_(D), S.current.flag = !0, document.addEventListener("mousemove", w), document.addEventListener("mouseup", C), document.addEventListener("touchmove", w), document.addEventListener("touchend", C), b.current = w, E.current = C);
  };
  return [g, R];
}
var aV = function(e) {
  var t = e.size, r = t === void 0 ? "default" : t, i = e.color, a = e.prefixCls;
  return /* @__PURE__ */ Fe.createElement("div", {
    className: Et("".concat(a, "-handler"), Re({}, "".concat(a, "-handler-sm"), r === "small")),
    style: {
      backgroundColor: i
    }
  });
}, oV = function(e) {
  var t = e.children, r = e.style, i = e.prefixCls;
  return /* @__PURE__ */ Fe.createElement("div", {
    className: "".concat(i, "-palette"),
    style: ke({
      position: "relative"
    }, r)
  }, t);
}, sV = /* @__PURE__ */ Al(function(n, e) {
  var t = n.children, r = n.offset;
  return /* @__PURE__ */ Fe.createElement("div", {
    ref: e,
    style: {
      position: "absolute",
      left: r.x,
      top: r.y,
      zIndex: 1
    }
  }, t);
}), XJ = function(e) {
  var t = e.color, r = e.onChange, i = e.prefixCls, a = e.onChangeComplete, o = e.disabled, s = kt(), u = kt(), d = kt(t), f = Yi(function(E) {
    var S = nV({
      offset: E,
      targetRef: u,
      containerRef: s,
      color: t
    });
    d.current = S, r(S);
  }), p = iV({
    color: t,
    containerRef: s,
    targetRef: u,
    calculate: function(S) {
      return rV(S, u, t);
    },
    onDragChange: f,
    onDragChangeComplete: function() {
      return a == null ? void 0 : a(d.current);
    },
    disabledDrag: o
  }), g = ot(p, 2), v = g[0], b = g[1];
  return /* @__PURE__ */ Fe.createElement("div", {
    ref: s,
    className: "".concat(i, "-select"),
    onMouseDown: b,
    onTouchStart: b
  }, /* @__PURE__ */ Fe.createElement(oV, {
    prefixCls: i
  }, /* @__PURE__ */ Fe.createElement(sV, {
    offset: v,
    ref: u
  }, /* @__PURE__ */ Fe.createElement(aV, {
    color: t.toRgbString(),
    prefixCls: i
  })), /* @__PURE__ */ Fe.createElement("div", {
    className: "".concat(i, "-saturation"),
    style: {
      backgroundColor: "hsl(".concat(t.toHsb().h, ",100%, 50%)"),
      backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
    }
  })));
}, qJ = function(e) {
  var t = e.colors, r = e.children, i = e.direction, a = i === void 0 ? "to right" : i, o = e.type, s = e.prefixCls, u = Mr(function() {
    return t.map(function(d, f) {
      var p = Hd(d);
      return o === "alpha" && f === t.length - 1 && p.setAlpha(1), p.toRgbString();
    }).join(",");
  }, [t, o]);
  return /* @__PURE__ */ Fe.createElement("div", {
    className: "".concat(s, "-gradient"),
    style: {
      position: "absolute",
      inset: 0,
      background: "linear-gradient(".concat(a, ", ").concat(u, ")")
    }
  }, r);
}, xL = function(e) {
  var t = e.gradientColors, r = e.direction, i = e.type, a = i === void 0 ? "hue" : i, o = e.color, s = e.value, u = e.onChange, d = e.onChangeComplete, f = e.disabled, p = e.prefixCls, g = kt(), v = kt(), b = kt(o), E = Yi(function(R) {
    var P = nV({
      offset: R,
      targetRef: v,
      containerRef: g,
      color: o,
      type: a
    });
    b.current = P, u(P);
  }), S = iV({
    color: o,
    targetRef: v,
    containerRef: g,
    calculate: function(P) {
      return rV(P, v, o, a);
    },
    onDragChange: E,
    onDragChangeComplete: function() {
      d == null || d(b.current, a);
    },
    direction: "x",
    disabledDrag: f
  }), _ = ot(S, 2), w = _[0], C = _[1];
  return /* @__PURE__ */ Fe.createElement("div", {
    ref: g,
    className: Et("".concat(p, "-slider"), "".concat(p, "-slider-").concat(a)),
    onMouseDown: C,
    onTouchStart: C
  }, /* @__PURE__ */ Fe.createElement(oV, {
    prefixCls: p
  }, /* @__PURE__ */ Fe.createElement(sV, {
    offset: w,
    ref: v
  }, /* @__PURE__ */ Fe.createElement(aV, {
    size: "small",
    color: s,
    prefixCls: p
  })), /* @__PURE__ */ Fe.createElement(qJ, {
    colors: t,
    direction: r,
    type: a,
    prefixCls: p
  })));
};
function EL(n) {
  return n !== void 0;
}
var YJ = function(e, t) {
  var r = t.defaultValue, i = t.value, a = Lr(function() {
    var d;
    return EL(i) ? d = i : EL(r) ? d = r : d = e, Hd(d);
  }), o = ot(a, 2), s = o[0], u = o[1];
  return In(function() {
    i && u(Hd(i));
  }, [i]), [s, u];
}, KJ = ["rgb(255, 0, 0) 0%", "rgb(255, 255, 0) 17%", "rgb(0, 255, 0) 33%", "rgb(0, 255, 255) 50%", "rgb(0, 0, 255) 67%", "rgb(255, 0, 255) 83%", "rgb(255, 0, 0) 100%"];
const ZJ = /* @__PURE__ */ Al(function(n, e) {
  var t = n.value, r = n.defaultValue, i = n.prefixCls, a = i === void 0 ? WJ : i, o = n.onChange, s = n.onChangeComplete, u = n.className, d = n.style, f = n.panelRender, p = n.disabledAlpha, g = p === void 0 ? !1 : p, v = n.disabled, b = v === void 0 ? !1 : v, E = YJ(jJ, {
    value: t,
    defaultValue: r
  }), S = ot(E, 2), _ = S[0], w = S[1], C = Mr(function() {
    var U = Hd(_.toRgbString());
    return U.setAlpha(1), U.toRgbString();
  }, [_]), R = Et("".concat(a, "-panel"), u, Re({}, "".concat(a, "-panel-disabled"), b)), P = {
    prefixCls: a,
    onChangeComplete: s,
    disabled: b
  }, D = function(L, N) {
    t || w(L), o == null || o(L, N);
  }, I = /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, /* @__PURE__ */ Fe.createElement(XJ, gn({
    color: _,
    onChange: D
  }, P)), /* @__PURE__ */ Fe.createElement("div", {
    className: "".concat(a, "-slider-container")
  }, /* @__PURE__ */ Fe.createElement("div", {
    className: Et("".concat(a, "-slider-group"), Re({}, "".concat(a, "-slider-group-disabled-alpha"), g))
  }, /* @__PURE__ */ Fe.createElement(xL, gn({
    gradientColors: KJ,
    color: _,
    value: "hsl(".concat(_.toHsb().h, ",100%, 50%)"),
    onChange: function(L) {
      return D(L, "hue");
    }
  }, P)), !g && /* @__PURE__ */ Fe.createElement(xL, gn({
    type: "alpha",
    gradientColors: ["rgba(255, 0, 4, 0) 0%", C],
    color: _,
    value: _.toRgbString(),
    onChange: function(L) {
      return D(L, "alpha");
    }
  }, P))), /* @__PURE__ */ Fe.createElement(yO, {
    color: _.toRgbString(),
    prefixCls: a
  })));
  return /* @__PURE__ */ Fe.createElement("div", {
    className: R,
    style: d,
    ref: e
  }, typeof f == "function" ? f(I) : I);
}), lV = /* @__PURE__ */ Fe.createContext({}), cV = /* @__PURE__ */ Fe.createContext({}), {
  Provider: QJ
} = lV, {
  Provider: JJ
} = cV, Q_ = (n, e) => (n == null ? void 0 : n.replace(/[^\w/]/gi, "").slice(0, e ? 8 : 6)) || "", eee = (n, e) => n ? Q_(n, e) : "";
let CL = /* @__PURE__ */ function() {
  function n(e) {
    ki(this, n), this.cleared = !1, this.metaColor = new bx(e), e || (this.metaColor.setAlpha(0), this.cleared = !0);
  }
  return $i(n, [{
    key: "toHsb",
    value: function() {
      return this.metaColor.toHsb();
    }
  }, {
    key: "toHsbString",
    value: function() {
      return this.metaColor.toHsbString();
    }
  }, {
    key: "toHex",
    value: function() {
      return eee(this.toHexString(), this.metaColor.getAlpha() < 1);
    }
  }, {
    key: "toHexString",
    value: function() {
      return this.metaColor.getAlpha() === 1 ? this.metaColor.toHexString() : this.metaColor.toHex8String();
    }
  }, {
    key: "toRgb",
    value: function() {
      return this.metaColor.toRgb();
    }
  }, {
    key: "toRgbString",
    value: function() {
      return this.metaColor.toRgbString();
    }
  }]);
}();
const Sa = (n) => n instanceof CL ? n : new CL(n), J_ = (n) => Math.round(Number(n || 0)), Sx = (n) => J_(n.toHsb().a * 100), iM = (n, e) => {
  const t = n.toHsb();
  return t.a = 1, Sa(t);
}, uV = (n) => {
  let {
    prefixCls: e,
    value: t,
    onChange: r
  } = n;
  const i = () => {
    if (t && !t.cleared) {
      const a = t.toHsb();
      a.a = 0;
      const o = Sa(a);
      o.cleared = !0, r == null || r(o);
    }
  };
  return /* @__PURE__ */ Fe.createElement("div", {
    className: `${e}-clear`,
    onClick: i
  });
};
var Vd;
(function(n) {
  n.hex = "hex", n.rgb = "rgb", n.hsb = "hsb";
})(Vd || (Vd = {}));
var tee = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, name: "up", theme: "outlined" }, nee = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: tee
  }));
}, dV = /* @__PURE__ */ O.forwardRef(nee);
Ee.env.NODE_ENV !== "production" && (dV.displayName = "UpOutlined");
function VR() {
  return typeof BigInt == "function";
}
function fV(n) {
  return !n && n !== 0 && !Number.isNaN(n) || !String(n).trim();
}
function yh(n) {
  var e = n.trim(), t = e.startsWith("-");
  t && (e = e.slice(1)), e = e.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, ""), e.startsWith(".") && (e = "0".concat(e));
  var r = e || "0", i = r.split("."), a = i[0] || "0", o = i[1] || "0";
  a === "0" && o === "0" && (t = !1);
  var s = t ? "-" : "";
  return {
    negative: t,
    negativeStr: s,
    trimStr: r,
    integerStr: a,
    decimalStr: o,
    fullStr: "".concat(s).concat(r)
  };
}
function bO(n) {
  var e = String(n);
  return !Number.isNaN(Number(e)) && e.includes("e");
}
function ch(n) {
  var e = String(n);
  if (bO(n)) {
    var t = Number(e.slice(e.indexOf("e-") + 2)), r = e.match(/\.(\d+)/);
    return r != null && r[1] && (t += r[1].length), t;
  }
  return e.includes(".") && SO(e) ? e.length - e.indexOf(".") - 1 : 0;
}
function TE(n) {
  var e = String(n);
  if (bO(n)) {
    if (n > Number.MAX_SAFE_INTEGER)
      return String(VR() ? BigInt(n).toString() : Number.MAX_SAFE_INTEGER);
    if (n < Number.MIN_SAFE_INTEGER)
      return String(VR() ? BigInt(n).toString() : Number.MIN_SAFE_INTEGER);
    e = n.toFixed(ch(e));
  }
  return yh(e).fullStr;
}
function SO(n) {
  return typeof n == "number" ? !Number.isNaN(n) : n ? (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(n) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(n) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(n)
  ) : !1;
}
var ree = /* @__PURE__ */ function() {
  function n(e) {
    if (ki(this, n), Re(this, "origin", ""), Re(this, "negative", void 0), Re(this, "integer", void 0), Re(this, "decimal", void 0), Re(this, "decimalLen", void 0), Re(this, "empty", void 0), Re(this, "nan", void 0), fV(e)) {
      this.empty = !0;
      return;
    }
    if (this.origin = String(e), e === "-" || Number.isNaN(e)) {
      this.nan = !0;
      return;
    }
    var t = e;
    if (bO(t) && (t = Number(t)), t = typeof t == "string" ? t : TE(t), SO(t)) {
      var r = yh(t);
      this.negative = r.negative;
      var i = r.trimStr.split(".");
      this.integer = BigInt(i[0]);
      var a = i[1] || "0";
      this.decimal = BigInt(a), this.decimalLen = a.length;
    } else
      this.nan = !0;
  }
  return $i(n, [{
    key: "getMark",
    value: function() {
      return this.negative ? "-" : "";
    }
  }, {
    key: "getIntegerStr",
    value: function() {
      return this.integer.toString();
    }
    /**
     * @private get decimal string
     */
  }, {
    key: "getDecimalStr",
    value: function() {
      return this.decimal.toString().padStart(this.decimalLen, "0");
    }
    /**
     * @private Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
     * This is used for add function only.
     */
  }, {
    key: "alignDecimal",
    value: function(t) {
      var r = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(t, "0"));
      return BigInt(r);
    }
  }, {
    key: "negate",
    value: function() {
      var t = new n(this.toString());
      return t.negative = !t.negative, t;
    }
  }, {
    key: "cal",
    value: function(t, r, i) {
      var a = Math.max(this.getDecimalStr().length, t.getDecimalStr().length), o = this.alignDecimal(a), s = t.alignDecimal(a), u = r(o, s).toString(), d = i(a), f = yh(u), p = f.negativeStr, g = f.trimStr, v = "".concat(p).concat(g.padStart(d + 1, "0"));
      return new n("".concat(v.slice(0, -d), ".").concat(v.slice(-d)));
    }
  }, {
    key: "add",
    value: function(t) {
      if (this.isInvalidate())
        return new n(t);
      var r = new n(t);
      return r.isInvalidate() ? this : this.cal(r, function(i, a) {
        return i + a;
      }, function(i) {
        return i;
      });
    }
  }, {
    key: "multi",
    value: function(t) {
      var r = new n(t);
      return this.isInvalidate() || r.isInvalidate() ? new n(NaN) : this.cal(r, function(i, a) {
        return i * a;
      }, function(i) {
        return i * 2;
      });
    }
  }, {
    key: "isEmpty",
    value: function() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function() {
      return this.nan;
    }
  }, {
    key: "isInvalidate",
    value: function() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function(t) {
      return this.toString() === (t == null ? void 0 : t.toString());
    }
  }, {
    key: "lessEquals",
    value: function(t) {
      return this.add(t.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function() {
      return this.isNaN() ? NaN : Number(this.toString());
    }
  }, {
    key: "toString",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return t ? this.isInvalidate() ? "" : yh("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr : this.origin;
    }
  }]), n;
}(), iee = /* @__PURE__ */ function() {
  function n(e) {
    if (ki(this, n), Re(this, "origin", ""), Re(this, "number", void 0), Re(this, "empty", void 0), fV(e)) {
      this.empty = !0;
      return;
    }
    this.origin = String(e), this.number = Number(e);
  }
  return $i(n, [{
    key: "negate",
    value: function() {
      return new n(-this.toNumber());
    }
  }, {
    key: "add",
    value: function(t) {
      if (this.isInvalidate())
        return new n(t);
      var r = Number(t);
      if (Number.isNaN(r))
        return this;
      var i = this.number + r;
      if (i > Number.MAX_SAFE_INTEGER)
        return new n(Number.MAX_SAFE_INTEGER);
      if (i < Number.MIN_SAFE_INTEGER)
        return new n(Number.MIN_SAFE_INTEGER);
      var a = Math.max(ch(this.number), ch(r));
      return new n(i.toFixed(a));
    }
  }, {
    key: "multi",
    value: function(t) {
      var r = Number(t);
      if (this.isInvalidate() || Number.isNaN(r))
        return new n(NaN);
      var i = this.number * r;
      if (i > Number.MAX_SAFE_INTEGER)
        return new n(Number.MAX_SAFE_INTEGER);
      if (i < Number.MIN_SAFE_INTEGER)
        return new n(Number.MIN_SAFE_INTEGER);
      var a = Math.max(ch(this.number), ch(r));
      return new n(i.toFixed(a));
    }
  }, {
    key: "isEmpty",
    value: function() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function() {
      return Number.isNaN(this.number);
    }
  }, {
    key: "isInvalidate",
    value: function() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function(t) {
      return this.toNumber() === (t == null ? void 0 : t.toNumber());
    }
  }, {
    key: "lessEquals",
    value: function(t) {
      return this.add(t.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function() {
      return this.number;
    }
  }, {
    key: "toString",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return t ? this.isInvalidate() ? "" : TE(this.number) : this.origin;
    }
  }]), n;
}();
function yl(n) {
  return VR() ? new ree(n) : new iee(n);
}
function ex(n, e, t) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (n === "")
    return "";
  var i = yh(n), a = i.negativeStr, o = i.integerStr, s = i.decimalStr, u = "".concat(e).concat(s), d = "".concat(a).concat(o);
  if (t >= 0) {
    var f = Number(s[t]);
    if (f >= 5 && !r) {
      var p = yl(n).add("".concat(a, "0.").concat("0".repeat(t)).concat(10 - f));
      return ex(p.toString(), e, t, r);
    }
    return t === 0 ? d : "".concat(d).concat(e).concat(s.padEnd(t, "0").slice(0, t));
  }
  return u === ".0" ? d : "".concat(d).concat(u);
}
function aee(n) {
  return !!(n.addonBefore || n.addonAfter);
}
function oee(n) {
  return !!(n.prefix || n.suffix || n.allowClear);
}
function wL(n, e, t) {
  var r = e.cloneNode(!0), i = Object.create(n, {
    target: {
      value: r
    },
    currentTarget: {
      value: r
    }
  });
  return r.value = t, typeof e.selectionStart == "number" && typeof e.selectionEnd == "number" && (r.selectionStart = e.selectionStart, r.selectionEnd = e.selectionEnd), r.setSelectionRange = function() {
    e.setSelectionRange.apply(e, arguments);
  }, i;
}
function _x(n, e, t, r) {
  if (t) {
    var i = e;
    if (e.type === "click") {
      i = wL(e, n, ""), t(i);
      return;
    }
    if (n.type !== "file" && r !== void 0) {
      i = wL(e, n, r), t(i);
      return;
    }
    t(i);
  }
}
function hV(n, e) {
  if (n) {
    n.focus(e);
    var t = e || {}, r = t.cursor;
    if (r) {
      var i = n.value.length;
      switch (r) {
        case "start":
          n.setSelectionRange(0, 0);
          break;
        case "end":
          n.setSelectionRange(i, i);
          break;
        default:
          n.setSelectionRange(0, i);
      }
    }
  }
}
var _O = /* @__PURE__ */ Fe.forwardRef(function(n, e) {
  var t, r, i = n.inputElement, a = n.children, o = n.prefixCls, s = n.prefix, u = n.suffix, d = n.addonBefore, f = n.addonAfter, p = n.className, g = n.style, v = n.disabled, b = n.readOnly, E = n.focused, S = n.triggerFocus, _ = n.allowClear, w = n.value, C = n.handleReset, R = n.hidden, P = n.classes, D = n.classNames, I = n.dataAttrs, U = n.styles, L = n.components, N = a ?? i, H = (L == null ? void 0 : L.affixWrapper) || "span", j = (L == null ? void 0 : L.groupWrapper) || "span", G = (L == null ? void 0 : L.wrapper) || "span", X = (L == null ? void 0 : L.groupAddon) || "span", ae = kt(null), Z = function(Ie) {
    var be;
    (be = ae.current) !== null && be !== void 0 && be.contains(Ie.target) && (S == null || S());
  }, K = oee(n), B = /* @__PURE__ */ OT(N, {
    value: w,
    className: Et(N.props.className, !K && (D == null ? void 0 : D.variant)) || null
  }), Q = kt(null);
  if (Fe.useImperativeHandle(e, function() {
    return {
      nativeElement: Q.current || ae.current
    };
  }), K) {
    var V, q = null;
    if (_) {
      var ne, ce = !v && !b && w, ie = "".concat(o, "-clear-icon"), oe = bn(_) === "object" && _ !== null && _ !== void 0 && _.clearIcon ? _.clearIcon : "";
      q = /* @__PURE__ */ Fe.createElement("span", {
        onClick: C,
        onMouseDown: function(Ie) {
          return Ie.preventDefault();
        },
        className: Et(ie, (ne = {}, Re(ne, "".concat(ie, "-hidden"), !ce), Re(ne, "".concat(ie, "-has-suffix"), !!u), ne)),
        role: "button",
        tabIndex: -1
      }, oe);
    }
    var he = "".concat(o, "-affix-wrapper"), le = Et(he, (V = {}, Re(V, "".concat(o, "-disabled"), v), Re(V, "".concat(he, "-disabled"), v), Re(V, "".concat(he, "-focused"), E), Re(V, "".concat(he, "-readonly"), b), Re(V, "".concat(he, "-input-with-clear-btn"), u && _ && w), V), P == null ? void 0 : P.affixWrapper, D == null ? void 0 : D.affixWrapper, D == null ? void 0 : D.variant), ve = (u || _) && /* @__PURE__ */ Fe.createElement("span", {
      className: Et("".concat(o, "-suffix"), D == null ? void 0 : D.suffix),
      style: U == null ? void 0 : U.suffix
    }, q, u);
    B = /* @__PURE__ */ Fe.createElement(H, gn({
      className: le,
      style: U == null ? void 0 : U.affixWrapper,
      onClick: Z
    }, I == null ? void 0 : I.affixWrapper, {
      ref: ae
    }), s && /* @__PURE__ */ Fe.createElement("span", {
      className: Et("".concat(o, "-prefix"), D == null ? void 0 : D.prefix),
      style: U == null ? void 0 : U.prefix
    }, s), B, ve);
  }
  if (aee(n)) {
    var Ne = "".concat(o, "-group"), xe = "".concat(Ne, "-addon"), Me = "".concat(Ne, "-wrapper"), $ = Et("".concat(o, "-wrapper"), Ne, P == null ? void 0 : P.wrapper, D == null ? void 0 : D.wrapper), Te = Et(Me, Re({}, "".concat(Me, "-disabled"), v), P == null ? void 0 : P.group, D == null ? void 0 : D.groupWrapper);
    B = /* @__PURE__ */ Fe.createElement(j, {
      className: Te,
      ref: Q
    }, /* @__PURE__ */ Fe.createElement(G, {
      className: $
    }, d && /* @__PURE__ */ Fe.createElement(X, {
      className: xe
    }, d), B, f && /* @__PURE__ */ Fe.createElement(X, {
      className: xe
    }, f)));
  }
  return /* @__PURE__ */ Fe.cloneElement(B, {
    className: Et((t = B.props) === null || t === void 0 ? void 0 : t.className, p) || null,
    style: ke(ke({}, (r = B.props) === null || r === void 0 ? void 0 : r.style), g),
    hidden: R
  });
}), see = ["show"];
function pV(n, e) {
  return O.useMemo(function() {
    var t = {};
    e && (t.show = bn(e) === "object" && e.formatter ? e.formatter : !!e), t = ke(ke({}, t), n);
    var r = t, i = r.show, a = br(r, see);
    return ke(ke({}, a), {}, {
      show: !!i,
      showFormatter: typeof i == "function" ? i : void 0,
      strategy: a.strategy || function(o) {
        return o.length;
      }
    });
  }, [n, e]);
}
var lee = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"], cee = /* @__PURE__ */ Al(function(n, e) {
  var t = n.autoComplete, r = n.onChange, i = n.onFocus, a = n.onBlur, o = n.onPressEnter, s = n.onKeyDown, u = n.prefixCls, d = u === void 0 ? "rc-input" : u, f = n.disabled, p = n.htmlSize, g = n.className, v = n.maxLength, b = n.suffix, E = n.showCount, S = n.count, _ = n.type, w = _ === void 0 ? "text" : _, C = n.classes, R = n.classNames, P = n.styles, D = n.onCompositionStart, I = n.onCompositionEnd, U = br(n, lee), L = Lr(!1), N = ot(L, 2), H = N[0], j = N[1], G = kt(!1), X = kt(null), ae = kt(null), Z = function(Y) {
    X.current && hV(X.current, Y);
  }, K = ko(n.defaultValue, {
    value: n.value
  }), B = ot(K, 2), Q = B[0], V = B[1], q = Q == null ? "" : String(Q), ne = Lr(null), ce = ot(ne, 2), ie = ce[0], oe = ce[1], he = pV(S, E), le = he.max || v, ve = he.strategy(q), Ne = !!le && ve > le;
  aE(e, function() {
    var te;
    return {
      focus: Z,
      blur: function() {
        var Se;
        (Se = X.current) === null || Se === void 0 || Se.blur();
      },
      setSelectionRange: function(Se, Oe, Pe) {
        var Ve;
        (Ve = X.current) === null || Ve === void 0 || Ve.setSelectionRange(Se, Oe, Pe);
      },
      select: function() {
        var Se;
        (Se = X.current) === null || Se === void 0 || Se.select();
      },
      input: X.current,
      nativeElement: ((te = ae.current) === null || te === void 0 ? void 0 : te.nativeElement) || X.current
    };
  }), In(function() {
    j(function(te) {
      return te && f ? !1 : te;
    });
  }, [f]);
  var xe = function(Y, Se, Oe) {
    var Pe = Se;
    if (!G.current && he.exceedFormatter && he.max && he.strategy(Se) > he.max) {
      if (Pe = he.exceedFormatter(Se, {
        max: he.max
      }), Se !== Pe) {
        var Ve, Ze;
        oe([((Ve = X.current) === null || Ve === void 0 ? void 0 : Ve.selectionStart) || 0, ((Ze = X.current) === null || Ze === void 0 ? void 0 : Ze.selectionEnd) || 0]);
      }
    } else if (Oe.source === "compositionEnd")
      return;
    V(Pe), X.current && _x(X.current, Y, r, Pe);
  };
  In(function() {
    if (ie) {
      var te;
      (te = X.current) === null || te === void 0 || te.setSelectionRange.apply(te, jt(ie));
    }
  }, [ie]);
  var Me = function(Y) {
    xe(Y, Y.target.value, {
      source: "change"
    });
  }, $ = function(Y) {
    G.current = !1, xe(Y, Y.currentTarget.value, {
      source: "compositionEnd"
    }), I == null || I(Y);
  }, Te = function(Y) {
    o && Y.key === "Enter" && o(Y), s == null || s(Y);
  }, se = function(Y) {
    j(!0), i == null || i(Y);
  }, Ie = function(Y) {
    j(!1), a == null || a(Y);
  }, be = function(Y) {
    V(""), Z(), X.current && _x(X.current, Y, r);
  }, et = Ne && "".concat(d, "-out-of-range"), Xe = function() {
    var Y = du(n, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "showCount",
      "count",
      "classes",
      "htmlSize",
      "styles",
      "classNames"
    ]);
    return /* @__PURE__ */ Fe.createElement("input", gn({
      autoComplete: t
    }, Y, {
      onChange: Me,
      onFocus: se,
      onBlur: Ie,
      onKeyDown: Te,
      className: Et(d, Re({}, "".concat(d, "-disabled"), f), R == null ? void 0 : R.input),
      style: P == null ? void 0 : P.input,
      ref: X,
      size: p,
      type: w,
      onCompositionStart: function(Oe) {
        G.current = !0, D == null || D(Oe);
      },
      onCompositionEnd: $
    }));
  }, $e = function() {
    var Y = Number(le) > 0;
    if (b || he.show) {
      var Se = he.showFormatter ? he.showFormatter({
        value: q,
        count: ve,
        maxLength: le
      }) : "".concat(ve).concat(Y ? " / ".concat(le) : "");
      return /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, he.show && /* @__PURE__ */ Fe.createElement("span", {
        className: Et("".concat(d, "-show-count-suffix"), Re({}, "".concat(d, "-show-count-has-suffix"), !!b), R == null ? void 0 : R.count),
        style: ke({}, P == null ? void 0 : P.count)
      }, Se), b);
    }
    return null;
  };
  return /* @__PURE__ */ Fe.createElement(_O, gn({}, U, {
    prefixCls: d,
    className: Et(g, et),
    handleReset: be,
    value: q,
    focused: H,
    triggerFocus: Z,
    suffix: $e(),
    disabled: f,
    classes: C,
    classNames: R,
    styles: P
  }), Xe());
});
function uee(n, e) {
  return typeof Proxy < "u" && n ? new Proxy(n, {
    get: function(r, i) {
      if (e[i])
        return e[i];
      var a = r[i];
      return typeof a == "function" ? a.bind(r) : a;
    }
  }) : n;
}
function dee(n, e) {
  var t = kt(null);
  function r() {
    try {
      var a = n.selectionStart, o = n.selectionEnd, s = n.value, u = s.substring(0, a), d = s.substring(o);
      t.current = {
        start: a,
        end: o,
        value: s,
        beforeTxt: u,
        afterTxt: d
      };
    } catch {
    }
  }
  function i() {
    if (n && t.current && e)
      try {
        var a = n.value, o = t.current, s = o.beforeTxt, u = o.afterTxt, d = o.start, f = a.length;
        if (a.endsWith(u))
          f = a.length - t.current.afterTxt.length;
        else if (a.startsWith(s))
          f = s.length;
        else {
          var p = s[d - 1], g = a.indexOf(p, d - 1);
          g !== -1 && (f = g + 1);
        }
        n.setSelectionRange(f, f);
      } catch (v) {
        Yn(!1, "Something warning of cursor restore. Please fire issue about this: ".concat(v.message));
      }
  }
  return [r, i];
}
var fee = function() {
  var e = Lr(!1), t = ot(e, 2), r = t[0], i = t[1];
  return ti(function() {
    i(JA());
  }, []), r;
}, hee = 200, pee = 600;
function mee(n) {
  var e = n.prefixCls, t = n.upNode, r = n.downNode, i = n.upDisabled, a = n.downDisabled, o = n.onStep, s = O.useRef(), u = O.useRef([]), d = O.useRef();
  d.current = o;
  var f = function() {
    clearTimeout(s.current);
  }, p = function(C, R) {
    C.preventDefault(), f(), d.current(R);
    function P() {
      d.current(R), s.current = setTimeout(P, hee);
    }
    s.current = setTimeout(P, pee);
  };
  O.useEffect(function() {
    return function() {
      f(), u.current.forEach(function(w) {
        return Wr.cancel(w);
      });
    };
  }, []);
  var g = fee();
  if (g)
    return null;
  var v = "".concat(e, "-handler"), b = Et(v, "".concat(v, "-up"), Re({}, "".concat(v, "-up-disabled"), i)), E = Et(v, "".concat(v, "-down"), Re({}, "".concat(v, "-down-disabled"), a)), S = function() {
    return u.current.push(Wr(f));
  }, _ = {
    unselectable: "on",
    role: "button",
    onMouseUp: S,
    onMouseLeave: S
  };
  return /* @__PURE__ */ O.createElement("div", {
    className: "".concat(v, "-wrap")
  }, /* @__PURE__ */ O.createElement("span", gn({}, _, {
    onMouseDown: function(C) {
      p(C, !0);
    },
    "aria-label": "Increase Value",
    "aria-disabled": i,
    className: b
  }), t || /* @__PURE__ */ O.createElement("span", {
    unselectable: "on",
    className: "".concat(e, "-handler-up-inner")
  })), /* @__PURE__ */ O.createElement("span", gn({}, _, {
    onMouseDown: function(C) {
      p(C, !1);
    },
    "aria-label": "Decrease Value",
    "aria-disabled": a,
    className: E
  }), r || /* @__PURE__ */ O.createElement("span", {
    unselectable: "on",
    className: "".concat(e, "-handler-down-inner")
  })));
}
function ML(n) {
  var e = typeof n == "number" ? TE(n) : yh(n).fullStr, t = e.includes(".");
  return t ? yh(e.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr : n + "0";
}
const gee = function() {
  var n = kt(0), e = function() {
    Wr.cancel(n.current);
  };
  return In(function() {
    return e;
  }, []), function(t) {
    e(), n.current = Wr(function() {
      t();
    });
  };
};
var vee = ["prefixCls", "className", "style", "min", "max", "step", "defaultValue", "value", "disabled", "readOnly", "upHandler", "downHandler", "keyboard", "changeOnWheel", "controls", "classNames", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "changeOnBlur", "domRef"], yee = ["disabled", "style", "prefixCls", "value", "prefix", "suffix", "addonBefore", "addonAfter", "className", "classNames"], TL = function(e, t) {
  return e || t.isEmpty() ? t.toString() : t.toNumber();
}, RL = function(e) {
  var t = yl(e);
  return t.isInvalidate() ? null : t;
}, bee = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.prefixCls, r = n.className, i = n.style, a = n.min, o = n.max, s = n.step, u = s === void 0 ? 1 : s, d = n.defaultValue, f = n.value, p = n.disabled, g = n.readOnly, v = n.upHandler, b = n.downHandler, E = n.keyboard, S = n.changeOnWheel, _ = S === void 0 ? !1 : S, w = n.controls, C = w === void 0 ? !0 : w;
  n.classNames;
  var R = n.stringMode, P = n.parser, D = n.formatter, I = n.precision, U = n.decimalSeparator, L = n.onChange, N = n.onInput, H = n.onPressEnter, j = n.onStep, G = n.changeOnBlur, X = G === void 0 ? !0 : G, ae = n.domRef, Z = br(n, vee), K = "".concat(t, "-input"), B = O.useRef(null), Q = O.useState(!1), V = ot(Q, 2), q = V[0], ne = V[1], ce = O.useRef(!1), ie = O.useRef(!1), oe = O.useRef(!1), he = O.useState(function() {
    return yl(f ?? d);
  }), le = ot(he, 2), ve = le[0], Ne = le[1];
  function xe(He) {
    f === void 0 && Ne(He);
  }
  var Me = O.useCallback(function(He, ut) {
    if (!ut)
      return I >= 0 ? I : Math.max(ch(He), ch(u));
  }, [I, u]), $ = O.useCallback(function(He) {
    var ut = String(He);
    if (P)
      return P(ut);
    var vt = ut;
    return U && (vt = vt.replace(U, ".")), vt.replace(/[^\w.-]+/g, "");
  }, [P, U]), Te = O.useRef(""), se = O.useCallback(function(He, ut) {
    if (D)
      return D(He, {
        userTyping: ut,
        input: String(Te.current)
      });
    var vt = typeof He == "number" ? TE(He) : He;
    if (!ut) {
      var _t = Me(vt, ut);
      if (SO(vt) && (U || _t >= 0)) {
        var Wt = U || ".";
        vt = ex(vt, Wt, _t);
      }
    }
    return vt;
  }, [D, Me, U]), Ie = O.useState(function() {
    var He = d ?? f;
    return ve.isInvalidate() && ["string", "number"].includes(bn(He)) ? Number.isNaN(He) ? "" : He : se(ve.toString(), !1);
  }), be = ot(Ie, 2), et = be[0], Xe = be[1];
  Te.current = et;
  function $e(He, ut) {
    Xe(se(
      // Invalidate number is sometime passed by external control, we should let it go
      // Otherwise is controlled by internal interactive logic which check by userTyping
      // You can ref 'show limited value when input is not focused' test for more info.
      He.isInvalidate() ? He.toString(!1) : He.toString(!ut),
      ut
    ));
  }
  var te = O.useMemo(function() {
    return RL(o);
  }, [o, I]), Y = O.useMemo(function() {
    return RL(a);
  }, [a, I]), Se = O.useMemo(function() {
    return !te || !ve || ve.isInvalidate() ? !1 : te.lessEquals(ve);
  }, [te, ve]), Oe = O.useMemo(function() {
    return !Y || !ve || ve.isInvalidate() ? !1 : ve.lessEquals(Y);
  }, [Y, ve]), Pe = dee(B.current, q), Ve = ot(Pe, 2), Ze = Ve[0], nt = Ve[1], ht = function(ut) {
    return te && !ut.lessEquals(te) ? te : Y && !Y.lessEquals(ut) ? Y : null;
  }, pt = function(ut) {
    return !ht(ut);
  }, Be = function(ut, vt) {
    var _t = ut, Wt = pt(_t) || _t.isEmpty();
    if (!_t.isEmpty() && !vt && (_t = ht(_t) || _t, Wt = !0), !g && !p && Wt) {
      var lt = _t.toString(), Ct = Me(lt, vt);
      return Ct >= 0 && (_t = yl(ex(lt, ".", Ct)), pt(_t) || (_t = yl(ex(lt, ".", Ct, !0)))), _t.equals(ve) || (xe(_t), L == null || L(_t.isEmpty() ? null : TL(R, _t)), f === void 0 && $e(_t, vt)), _t;
    }
    return ve;
  }, ye = gee(), Ue = function He(ut) {
    if (Ze(), Te.current = ut, Xe(ut), !ie.current) {
      var vt = $(ut), _t = yl(vt);
      _t.isNaN() || Be(_t, !0);
    }
    N == null || N(ut), ye(function() {
      var Wt = ut;
      P || (Wt = ut.replace(//g, ".")), Wt !== ut && He(Wt);
    });
  }, Ye = function() {
    ie.current = !0;
  }, tt = function() {
    ie.current = !1, Ue(B.current.value);
  }, st = function(ut) {
    Ue(ut.target.value);
  }, Tt = function(ut) {
    var vt;
    if (!(ut && Se || !ut && Oe)) {
      ce.current = !1;
      var _t = yl(oe.current ? ML(u) : u);
      ut || (_t = _t.negate());
      var Wt = (ve || yl(0)).add(_t.toString()), lt = Be(Wt, !1);
      j == null || j(TL(R, lt), {
        offset: oe.current ? ML(u) : u,
        type: ut ? "up" : "down"
      }), (vt = B.current) === null || vt === void 0 || vt.focus();
    }
  }, Rt = function(ut) {
    var vt = yl($(et)), _t;
    vt.isNaN() ? _t = Be(ve, ut) : _t = Be(vt, ut), f !== void 0 ? $e(ve, !1) : _t.isNaN() || $e(_t, !1);
  }, ue = function() {
    ce.current = !0;
  }, De = function(ut) {
    var vt = ut.key, _t = ut.shiftKey;
    ce.current = !0, oe.current = _t, vt === "Enter" && (ie.current || (ce.current = !1), Rt(!1), H == null || H(ut)), E !== !1 && !ie.current && ["Up", "ArrowUp", "Down", "ArrowDown"].includes(vt) && (Tt(vt === "Up" || vt === "ArrowUp"), ut.preventDefault());
  }, Ge = function() {
    ce.current = !1, oe.current = !1;
  };
  O.useEffect(function() {
    if (_ && q) {
      var He = function(_t) {
        Tt(_t.deltaY < 0), _t.preventDefault();
      }, ut = B.current;
      if (ut)
        return ut.addEventListener("wheel", He, {
          passive: !1
        }), function() {
          return ut.removeEventListener("wheel", He);
        };
    }
  });
  var We = function() {
    X && Rt(!1), ne(!1), ce.current = !1;
  };
  return _y(function() {
    ve.isInvalidate() || $e(ve, !1);
  }, [I, D]), _y(function() {
    var He = yl(f);
    Ne(He);
    var ut = yl($(et));
    (!He.equals(ut) || !ce.current || D) && $e(He, ce.current);
  }, [f]), _y(function() {
    D && nt();
  }, [et]), /* @__PURE__ */ O.createElement("div", {
    ref: ae,
    className: Et(t, r, Re(Re(Re(Re(Re({}, "".concat(t, "-focused"), q), "".concat(t, "-disabled"), p), "".concat(t, "-readonly"), g), "".concat(t, "-not-a-number"), ve.isNaN()), "".concat(t, "-out-of-range"), !ve.isInvalidate() && !pt(ve))),
    style: i,
    onFocus: function() {
      ne(!0);
    },
    onBlur: We,
    onKeyDown: De,
    onKeyUp: Ge,
    onCompositionStart: Ye,
    onCompositionEnd: tt,
    onBeforeInput: ue
  }, C && /* @__PURE__ */ O.createElement(mee, {
    prefixCls: t,
    upNode: v,
    downNode: b,
    upDisabled: Se,
    downDisabled: Oe,
    onStep: Tt
  }), /* @__PURE__ */ O.createElement("div", {
    className: "".concat(K, "-wrap")
  }, /* @__PURE__ */ O.createElement("input", gn({
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuemin": a,
    "aria-valuemax": o,
    "aria-valuenow": ve.isInvalidate() ? null : ve.toString(),
    step: u
  }, Z, {
    ref: Ol(B, e),
    className: K,
    value: et,
    onChange: st,
    disabled: p,
    readOnly: g
  }))));
}), mV = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n.disabled, r = n.style, i = n.prefixCls, a = i === void 0 ? "rc-input-number" : i, o = n.value, s = n.prefix, u = n.suffix, d = n.addonBefore, f = n.addonAfter, p = n.className, g = n.classNames, v = br(n, yee), b = O.useRef(null), E = O.useRef(null), S = O.useRef(null), _ = function(C) {
    S.current && hV(S.current, C);
  };
  return O.useImperativeHandle(e, function() {
    return uee(S.current, {
      nativeElement: b.current.nativeElement || E.current
    });
  }), /* @__PURE__ */ O.createElement(_O, {
    className: p,
    triggerFocus: _,
    prefixCls: a,
    value: o,
    disabled: t,
    style: r,
    prefix: s,
    suffix: u,
    addonAfter: f,
    addonBefore: d,
    classNames: g,
    components: {
      affixWrapper: "div",
      groupWrapper: "div",
      wrapper: "div",
      groupAddon: "div"
    },
    ref: b
  }, /* @__PURE__ */ O.createElement(bee, gn({
    prefixCls: a,
    disabled: t,
    ref: S,
    domRef: E,
    className: g == null ? void 0 : g.input
  }, v)));
});
Ee.env.NODE_ENV !== "production" && (mV.displayName = "InputNumber");
const See = (n) => {
  var e;
  const t = (e = n.handleVisible) !== null && e !== void 0 ? e : "auto";
  return Object.assign(Object.assign({}, hO(n)), {
    controlWidth: 90,
    handleWidth: n.controlHeightSM - n.lineWidth * 2,
    handleFontSize: n.fontSize / 2,
    handleVisible: t,
    handleActiveBg: n.colorFillAlter,
    handleBg: n.colorBgContainer,
    filledHandleBg: new la(n.colorFillSecondary).onBackground(n.colorBgContainer).toHexString(),
    handleHoverColor: n.colorPrimary,
    handleBorderColor: n.colorBorder,
    handleOpacity: t === !0 ? 1 : 0
  });
}, AL = (n, e) => {
  let {
    componentCls: t,
    borderRadiusSM: r,
    borderRadiusLG: i
  } = n;
  const a = e === "lg" ? i : r;
  return {
    [`&-${e}`]: {
      [`${t}-handler-wrap`]: {
        borderStartEndRadius: a,
        borderEndEndRadius: a
      },
      [`${t}-handler-up`]: {
        borderStartEndRadius: a
      },
      [`${t}-handler-down`]: {
        borderEndEndRadius: a
      }
    }
  };
}, _ee = (n) => {
  const {
    componentCls: e,
    lineWidth: t,
    lineType: r,
    borderRadius: i,
    inputFontSizeSM: a,
    inputFontSizeLG: o,
    controlHeightLG: s,
    controlHeightSM: u,
    colorError: d,
    paddingInlineSM: f,
    paddingBlockSM: p,
    paddingBlockLG: g,
    paddingInlineLG: v,
    colorTextDescription: b,
    motionDurationMid: E,
    handleHoverColor: S,
    paddingInline: _,
    paddingBlock: w,
    handleBg: C,
    handleActiveBg: R,
    colorTextDisabled: P,
    borderRadiusSM: D,
    borderRadiusLG: I,
    controlWidth: U,
    handleOpacity: L,
    handleBorderColor: N,
    filledHandleBg: H,
    lineHeightLG: j,
    calc: G
  } = n;
  return [
    {
      [e]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Vo(n)), ME(n)), {
        display: "inline-block",
        width: U,
        margin: 0,
        padding: 0,
        borderRadius: i
      }), HH(n, {
        [`${e}-handler-wrap`]: {
          background: C,
          [`${e}-handler-down`]: {
            borderBlockStart: `${Mt(t)} ${r} ${N}`
          }
        }
      })), WH(n, {
        [`${e}-handler-wrap`]: {
          background: H,
          [`${e}-handler-down`]: {
            borderBlockStart: `${Mt(t)} ${r} ${N}`
          }
        },
        "&:focus-within": {
          [`${e}-handler-wrap`]: {
            background: C
          }
        }
      })), kH(n)), {
        "&-rtl": {
          direction: "rtl",
          [`${e}-input`]: {
            direction: "rtl"
          }
        },
        "&-lg": {
          padding: 0,
          fontSize: o,
          lineHeight: j,
          borderRadius: I,
          [`input${e}-input`]: {
            height: G(s).sub(G(t).mul(2)).equal(),
            padding: `${Mt(g)} ${Mt(v)}`
          }
        },
        "&-sm": {
          padding: 0,
          fontSize: a,
          borderRadius: D,
          [`input${e}-input`]: {
            height: G(u).sub(G(t).mul(2)).equal(),
            padding: `${Mt(p)} ${Mt(f)}`
          }
        },
        // ===================== Out Of Range =====================
        "&-out-of-range": {
          [`${e}-input-wrap`]: {
            input: {
              color: d
            }
          }
        },
        // Style for input-group: input with label, with button or dropdown...
        "&-group": Object.assign(Object.assign(Object.assign({}, Vo(n)), YH(n)), {
          "&-wrapper": Object.assign(Object.assign(Object.assign({
            display: "inline-block",
            textAlign: "start",
            verticalAlign: "top",
            [`${e}-affix-wrapper`]: {
              width: "100%"
            },
            // Size
            "&-lg": {
              [`${e}-group-addon`]: {
                borderRadius: I,
                fontSize: n.fontSizeLG
              }
            },
            "&-sm": {
              [`${e}-group-addon`]: {
                borderRadius: D
              }
            }
          }, VH(n)), jH(n)), {
            // Fix the issue of using icons in Space Compact mode
            // https://github.com/ant-design/ant-design/issues/45764
            [`&:not(${e}-compact-first-item):not(${e}-compact-last-item)${e}-compact-item`]: {
              [`${e}, ${e}-group-addon`]: {
                borderRadius: 0
              }
            },
            [`&:not(${e}-compact-last-item)${e}-compact-first-item`]: {
              [`${e}, ${e}-group-addon`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            [`&:not(${e}-compact-first-item)${e}-compact-last-item`]: {
              [`${e}, ${e}-group-addon`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          })
        }),
        [`&-disabled ${e}-input`]: {
          cursor: "not-allowed"
        },
        [e]: {
          "&-input": Object.assign(Object.assign(Object.assign(Object.assign({}, Vo(n)), {
            width: "100%",
            padding: `${Mt(w)} ${Mt(_)}`,
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius: i,
            outline: 0,
            transition: `all ${E} linear`,
            appearance: "textfield",
            fontSize: "inherit"
          }), GH(n.colorTextPlaceholder)), {
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              webkitAppearance: "none",
              appearance: "none"
            }
          })
        }
      })
    },
    // Handler
    {
      [e]: Object.assign(Object.assign(Object.assign({
        [`&:hover ${e}-handler-wrap, &-focused ${e}-handler-wrap`]: {
          opacity: 1
        },
        [`${e}-handler-wrap`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          width: n.handleWidth,
          height: "100%",
          borderStartStartRadius: 0,
          borderStartEndRadius: i,
          borderEndEndRadius: i,
          borderEndStartRadius: 0,
          opacity: L,
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          transition: `opacity ${E} linear ${E}`,
          // Fix input number inside Menu makes icon too large
          // We arise the selector priority by nest selector here
          // https://github.com/ant-design/ant-design/issues/14367
          [`${e}-handler`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flex: "auto",
            height: "40%",
            [`
              ${e}-handler-up-inner,
              ${e}-handler-down-inner
            `]: {
              marginInlineEnd: 0,
              fontSize: n.handleFontSize
            }
          }
        },
        [`${e}-handler`]: {
          height: "50%",
          overflow: "hidden",
          color: b,
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          borderInlineStart: `${Mt(t)} ${r} ${N}`,
          transition: `all ${E} linear`,
          "&:active": {
            background: R
          },
          // Hover
          "&:hover": {
            height: "60%",
            [`
              ${e}-handler-up-inner,
              ${e}-handler-down-inner
            `]: {
              color: S
            }
          },
          "&-up-inner, &-down-inner": Object.assign(Object.assign({}, b0()), {
            color: b,
            transition: `all ${E} linear`,
            userSelect: "none"
          })
        },
        [`${e}-handler-up`]: {
          borderStartEndRadius: i
        },
        [`${e}-handler-down`]: {
          borderEndEndRadius: i
        }
      }, AL(n, "lg")), AL(n, "sm")), {
        // Disabled
        "&-disabled, &-readonly": {
          [`${e}-handler-wrap`]: {
            display: "none"
          },
          [`${e}-input`]: {
            color: "inherit"
          }
        },
        [`
          ${e}-handler-up-disabled,
          ${e}-handler-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`
          ${e}-handler-up-disabled:hover &-handler-up-inner,
          ${e}-handler-down-disabled:hover &-handler-down-inner
        `]: {
          color: P
        }
      })
    }
  ];
}, xee = (n) => {
  const {
    componentCls: e,
    paddingBlock: t,
    paddingInline: r,
    inputAffixPadding: i,
    controlWidth: a,
    borderRadiusLG: o,
    borderRadiusSM: s,
    paddingInlineLG: u,
    paddingInlineSM: d,
    paddingBlockLG: f,
    paddingBlockSM: p
  } = n;
  return {
    [`${e}-affix-wrapper`]: Object.assign(Object.assign({
      [`input${e}-input`]: {
        padding: `${Mt(t)} 0`
      }
    }, ME(n)), {
      // or number handler will cover form status
      position: "relative",
      display: "inline-flex",
      width: a,
      padding: 0,
      paddingInlineStart: r,
      "&-lg": {
        borderRadius: o,
        paddingInlineStart: u,
        [`input${e}-input`]: {
          padding: `${Mt(f)} 0`
        }
      },
      "&-sm": {
        borderRadius: s,
        paddingInlineStart: d,
        [`input${e}-input`]: {
          padding: `${Mt(p)} 0`
        }
      },
      [`&:not(${e}-disabled):hover`]: {
        zIndex: 1
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`&-disabled > ${e}-disabled`]: {
        background: "transparent"
      },
      [`> div${e}`]: {
        width: "100%",
        border: "none",
        outline: "none",
        [`&${e}-focused`]: {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${e}-handler-wrap`]: {
        zIndex: 2
      },
      [e]: {
        color: "inherit",
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          pointerEvents: "none"
        },
        "&-prefix": {
          marginInlineEnd: i
        },
        "&-suffix": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: "100%",
          marginInlineEnd: r,
          marginInlineStart: i
        }
      }
    })
  };
}, Eee = $o("InputNumber", (n) => {
  const e = li(n, fO(n));
  return [
    _ee(e),
    xee(e),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    EE(e)
  ];
}, See, {
  unitless: {
    handleOpacity: !0
  }
});
var Cee = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const gV = /* @__PURE__ */ O.forwardRef((n, e) => {
  if (Ee.env.NODE_ENV !== "production") {
    const le = ci("InputNumber");
    le.deprecated(!("bordered" in n), "bordered", "variant"), le(!(n.type === "number" && n.changeOnWheel), "usage", "When `type=number` is used together with `changeOnWheel`, changeOnWheel may not work properly. Please delete `type=number` if it is not necessary.");
  }
  const {
    getPrefixCls: t,
    direction: r
  } = O.useContext(mr), i = O.useRef(null);
  O.useImperativeHandle(e, () => i.current);
  const {
    className: a,
    rootClassName: o,
    size: s,
    disabled: u,
    prefixCls: d,
    addonBefore: f,
    addonAfter: p,
    prefix: g,
    bordered: v,
    readOnly: b,
    status: E,
    controls: S,
    variant: _
  } = n, w = Cee(n, ["className", "rootClassName", "size", "disabled", "prefixCls", "addonBefore", "addonAfter", "prefix", "bordered", "readOnly", "status", "controls", "variant"]), C = t("input-number", d), R = _u(C), [P, D, I] = Eee(C, R), {
    compactSize: U,
    compactItemClassnames: L
  } = _0(C, r);
  let N = /* @__PURE__ */ O.createElement(dV, {
    className: `${C}-handler-up-inner`
  }), H = /* @__PURE__ */ O.createElement(sO, {
    className: `${C}-handler-down-inner`
  });
  const j = typeof S == "boolean" ? S : void 0;
  typeof S == "object" && (N = typeof S.upIcon > "u" ? N : /* @__PURE__ */ O.createElement("span", {
    className: `${C}-handler-up-inner`
  }, S.upIcon), H = typeof S.downIcon > "u" ? H : /* @__PURE__ */ O.createElement("span", {
    className: `${C}-handler-down-inner`
  }, S.downIcon));
  const {
    hasFeedback: G,
    status: X,
    isFormItemInput: ae,
    feedbackIcon: Z
  } = O.useContext(Ya), K = w0(X, E), B = mc((le) => {
    var ve;
    return (ve = s ?? U) !== null && ve !== void 0 ? ve : le;
  }), Q = O.useContext(fc), V = u ?? Q, [q, ne] = wE("inputNumber", _, v), ce = G && /* @__PURE__ */ O.createElement(O.Fragment, null, Z), ie = Et({
    [`${C}-lg`]: B === "large",
    [`${C}-sm`]: B === "small",
    [`${C}-rtl`]: r === "rtl",
    [`${C}-in-form-item`]: ae
  }, D), oe = `${C}-group`, he = /* @__PURE__ */ O.createElement(mV, Object.assign({
    ref: i,
    disabled: V,
    className: Et(I, R, a, o, L),
    upHandler: N,
    downHandler: H,
    prefixCls: C,
    readOnly: b,
    controls: j,
    prefix: g,
    suffix: ce,
    addonBefore: f && /* @__PURE__ */ O.createElement(rg, {
      form: !0,
      space: !0
    }, f),
    addonAfter: p && /* @__PURE__ */ O.createElement(rg, {
      form: !0,
      space: !0
    }, p),
    classNames: {
      input: ie,
      variant: Et({
        [`${C}-${q}`]: ne
      }, Ph(C, K, G)),
      affixWrapper: Et({
        [`${C}-affix-wrapper-sm`]: B === "small",
        [`${C}-affix-wrapper-lg`]: B === "large",
        [`${C}-affix-wrapper-rtl`]: r === "rtl"
      }, D),
      wrapper: Et({
        [`${oe}-rtl`]: r === "rtl"
      }, D),
      groupWrapper: Et({
        [`${C}-group-wrapper-sm`]: B === "small",
        [`${C}-group-wrapper-lg`]: B === "large",
        [`${C}-group-wrapper-rtl`]: r === "rtl",
        [`${C}-group-wrapper-${q}`]: ne
      }, Ph(`${C}-group-wrapper`, K, G), D)
    }
  }, w));
  return P(he);
}), RE = gV, wee = (n) => /* @__PURE__ */ O.createElement(Gd, {
  theme: {
    components: {
      InputNumber: {
        handleVisible: !0
      }
    }
  }
}, /* @__PURE__ */ O.createElement(gV, Object.assign({}, n)));
Ee.env.NODE_ENV !== "production" && (RE.displayName = "InputNumber");
RE._InternalPanelDoNotUseOrYouWillBeFired = wee;
const bh = (n) => {
  let {
    prefixCls: e,
    min: t = 0,
    max: r = 100,
    value: i,
    onChange: a,
    className: o,
    formatter: s
  } = n;
  const u = `${e}-steppers`, [d, f] = Lr(i);
  return In(() => {
    Number.isNaN(i) || f(i);
  }, [i]), /* @__PURE__ */ Fe.createElement(RE, {
    className: Et(u, o),
    min: t,
    max: r,
    value: d,
    formatter: s,
    size: "small",
    onChange: (p) => {
      i || f(p || 0), a == null || a(p);
    }
  });
}, Mee = (n) => {
  let {
    prefixCls: e,
    value: t,
    onChange: r
  } = n;
  const i = `${e}-alpha-input`, [a, o] = Lr(Sa(t || "#000"));
  In(() => {
    t && o(t);
  }, [t]);
  const s = (u) => {
    const d = a.toHsb();
    d.a = (u || 0) / 100;
    const f = Sa(d);
    t || o(f), r == null || r(f);
  };
  return /* @__PURE__ */ Fe.createElement(bh, {
    value: Sx(a),
    prefixCls: e,
    formatter: (u) => `${u}%`,
    className: i,
    onChange: s
  });
}, Tee = (n) => {
  const {
    getPrefixCls: e,
    direction: t
  } = ni(mr), {
    prefixCls: r,
    className: i
  } = n, a = e("input-group", r), o = e("input"), [s, u] = mO(o), d = Et(a, {
    [`${a}-lg`]: n.size === "large",
    [`${a}-sm`]: n.size === "small",
    [`${a}-compact`]: n.compact,
    [`${a}-rtl`]: t === "rtl"
  }, u, i), f = ni(Ya), p = Mr(() => Object.assign(Object.assign({}, f), {
    isFormItemInput: !1
  }), [f]);
  return Ee.env.NODE_ENV !== "production" && ci("Input.Group").deprecated(!1, "Input.Group", "Space.Compact"), s(/* @__PURE__ */ O.createElement("span", {
    className: d,
    style: n.style,
    onMouseEnter: n.onMouseEnter,
    onMouseLeave: n.onMouseLeave,
    onFocus: n.onFocus,
    onBlur: n.onBlur
  }, /* @__PURE__ */ O.createElement(Ya.Provider, {
    value: p
  }, n.children)));
}, vV = (n) => {
  let e;
  return typeof n == "object" && (n != null && n.clearIcon) ? e = n : n && (e = {
    clearIcon: /* @__PURE__ */ Fe.createElement(SE, null)
  }), e;
};
function yV(n, e) {
  const t = kt([]), r = () => {
    t.current.push(setTimeout(() => {
      var i, a, o, s;
      !((i = n.current) === null || i === void 0) && i.input && ((a = n.current) === null || a === void 0 ? void 0 : a.input.getAttribute("type")) === "password" && (!((o = n.current) === null || o === void 0) && o.input.hasAttribute("value")) && ((s = n.current) === null || s === void 0 || s.input.removeAttribute("value"));
    }));
  };
  return In(() => (e && r(), () => t.current.forEach((i) => {
    i && clearTimeout(i);
  })), []), r;
}
function Ree(n) {
  return !!(n.prefix || n.suffix || n.allowClear || n.showCount);
}
var Aee = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function Oee(n, e) {
  if (!n)
    return;
  n.focus(e);
  const {
    cursor: t
  } = e || {};
  if (t) {
    const r = n.value.length;
    switch (t) {
      case "start":
        n.setSelectionRange(0, 0);
        break;
      case "end":
        n.setSelectionRange(r, r);
        break;
      default:
        n.setSelectionRange(0, r);
    }
  }
}
const T0 = /* @__PURE__ */ Al((n, e) => {
  var t;
  const {
    prefixCls: r,
    bordered: i = !0,
    status: a,
    size: o,
    disabled: s,
    onBlur: u,
    onFocus: d,
    suffix: f,
    allowClear: p,
    addonAfter: g,
    addonBefore: v,
    className: b,
    style: E,
    styles: S,
    rootClassName: _,
    onChange: w,
    classNames: C,
    variant: R
  } = n, P = Aee(n, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
  if (Ee.env.NODE_ENV !== "production") {
    const {
      deprecated: se
    } = ci("Input");
    se(!("bordered" in n), "bordered", "variant");
  }
  const {
    getPrefixCls: D,
    direction: I,
    input: U
  } = Fe.useContext(mr), L = D("input", r), N = kt(null), H = _u(L), [j, G, X] = mO(L, H), {
    compactSize: ae,
    compactItemClassnames: Z
  } = _0(L, I), K = mc((se) => {
    var Ie;
    return (Ie = o ?? ae) !== null && Ie !== void 0 ? Ie : se;
  }), B = Fe.useContext(fc), Q = s ?? B, {
    status: V,
    hasFeedback: q,
    feedbackIcon: ne
  } = ni(Ya), ce = w0(V, a), ie = Ree(n) || !!q, oe = kt(ie);
  if (Ee.env.NODE_ENV !== "production") {
    const se = ci("Input");
    In(() => {
      var Ie;
      ie && !oe.current && Ee.env.NODE_ENV !== "production" && se(document.activeElement === ((Ie = N.current) === null || Ie === void 0 ? void 0 : Ie.input), "usage", "When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ"), oe.current = ie;
    }, [ie]);
  }
  const he = yV(N, !0), le = (se) => {
    he(), u == null || u(se);
  }, ve = (se) => {
    he(), d == null || d(se);
  }, Ne = (se) => {
    he(), w == null || w(se);
  }, xe = (q || f) && /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, f, q && ne), Me = vV(p ?? (U == null ? void 0 : U.allowClear)), [$, Te] = wE("input", R, i);
  return j(/* @__PURE__ */ Fe.createElement(cee, Object.assign({
    ref: Ol(e, N),
    prefixCls: L,
    autoComplete: U == null ? void 0 : U.autoComplete
  }, P, {
    disabled: Q,
    onBlur: le,
    onFocus: ve,
    style: Object.assign(Object.assign({}, U == null ? void 0 : U.style), E),
    styles: Object.assign(Object.assign({}, U == null ? void 0 : U.styles), S),
    suffix: xe,
    allowClear: Me,
    className: Et(b, _, X, H, Z, U == null ? void 0 : U.className),
    onChange: Ne,
    addonBefore: v && /* @__PURE__ */ Fe.createElement(rg, {
      form: !0,
      space: !0
    }, v),
    addonAfter: g && /* @__PURE__ */ Fe.createElement(rg, {
      form: !0,
      space: !0
    }, g),
    classNames: Object.assign(Object.assign(Object.assign({}, C), U == null ? void 0 : U.classNames), {
      input: Et({
        [`${L}-sm`]: K === "small",
        [`${L}-lg`]: K === "large",
        [`${L}-rtl`]: I === "rtl"
      }, C == null ? void 0 : C.input, (t = U == null ? void 0 : U.classNames) === null || t === void 0 ? void 0 : t.input, G),
      variant: Et({
        [`${L}-${$}`]: Te
      }, Ph(L, ce)),
      affixWrapper: Et({
        [`${L}-affix-wrapper-sm`]: K === "small",
        [`${L}-affix-wrapper-lg`]: K === "large",
        [`${L}-affix-wrapper-rtl`]: I === "rtl"
      }, G),
      wrapper: Et({
        [`${L}-group-rtl`]: I === "rtl"
      }, G),
      groupWrapper: Et({
        [`${L}-group-wrapper-sm`]: K === "small",
        [`${L}-group-wrapper-lg`]: K === "large",
        [`${L}-group-wrapper-rtl`]: I === "rtl",
        [`${L}-group-wrapper-${$}`]: Te
      }, Ph(`${L}-group-wrapper`, ce, q), G)
    })
  })));
});
Ee.env.NODE_ENV !== "production" && (T0.displayName = "Input");
const Pee = (n) => {
  const {
    componentCls: e,
    paddingXS: t
  } = n;
  return {
    [`${e}`]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: t,
      "&-rtl": {
        direction: "rtl"
      },
      [`${e}-input`]: {
        textAlign: "center",
        paddingInline: n.paddingXXS
      },
      // ================= Size =================
      [`&${e}-sm ${e}-input`]: {
        paddingInline: n.calc(n.paddingXXS).div(2).equal()
      },
      [`&${e}-lg ${e}-input`]: {
        paddingInline: n.paddingXS
      }
    }
  };
}, Dee = $o(["Input", "OTP"], (n) => {
  const e = li(n, fO(n));
  return [Pee(e)];
}, hO);
var Iee = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const Nee = /* @__PURE__ */ O.forwardRef((n, e) => {
  const {
    value: t,
    onChange: r,
    onActiveChange: i,
    index: a,
    mask: o
  } = n, s = Iee(n, ["value", "onChange", "onActiveChange", "index", "mask"]), u = t && typeof o == "string" ? o : t, d = (b) => {
    r(a, b.target.value);
  }, f = O.useRef(null);
  O.useImperativeHandle(e, () => f.current);
  const p = () => {
    Wr(() => {
      var b;
      const E = (b = f.current) === null || b === void 0 ? void 0 : b.input;
      document.activeElement === E && E && E.select();
    });
  }, g = (b) => {
    let {
      key: E
    } = b;
    E === "ArrowLeft" ? i(a - 1) : E === "ArrowRight" && i(a + 1), p();
  }, v = (b) => {
    b.key === "Backspace" && !t && i(a - 1), p();
  };
  return /* @__PURE__ */ O.createElement(T0, Object.assign({}, s, {
    ref: f,
    value: u,
    onInput: d,
    onFocus: p,
    onKeyDown: g,
    onKeyUp: v,
    onMouseDown: p,
    onMouseUp: p,
    type: o === !0 ? "password" : "text"
  }));
});
var Lee = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function US(n) {
  return (n || "").split("");
}
const Fee = /* @__PURE__ */ O.forwardRef((n, e) => {
  const {
    prefixCls: t,
    length: r = 6,
    size: i,
    defaultValue: a,
    value: o,
    onChange: s,
    formatter: u,
    variant: d,
    disabled: f,
    status: p,
    autoFocus: g,
    mask: v
  } = n, b = Lee(n, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "variant", "disabled", "status", "autoFocus", "mask"]);
  if (Ee.env.NODE_ENV !== "production") {
    const q = ci("Input.OTP");
    Ee.env.NODE_ENV !== "production" && q(!(typeof v == "string" && v.length > 1), "usage", "`mask` prop should be a single character.");
  }
  const {
    getPrefixCls: E,
    direction: S
  } = O.useContext(mr), _ = E("otp", t), w = ng(b, {
    aria: !0,
    data: !0,
    attr: !0
  }), C = _u(_), [R, P, D] = Dee(_, C), I = mc((q) => i ?? q), U = O.useContext(Ya), L = w0(U.status, p), N = O.useMemo(() => Object.assign(Object.assign({}, U), {
    status: L,
    hasFeedback: !1,
    feedbackIcon: null
  }), [U, L]), H = O.useRef(null), j = O.useRef({});
  O.useImperativeHandle(e, () => ({
    focus: () => {
      var q;
      (q = j.current[0]) === null || q === void 0 || q.focus();
    },
    blur: () => {
      var q;
      for (let ne = 0; ne < r; ne += 1)
        (q = j.current[ne]) === null || q === void 0 || q.blur();
    },
    nativeElement: H.current
  }));
  const G = (q) => u ? u(q) : q, [X, ae] = O.useState(US(G(a || "")));
  O.useEffect(() => {
    o !== void 0 && ae(US(o));
  }, [o]);
  const Z = Yi((q) => {
    ae(q), s && q.length === r && q.every((ne) => ne) && q.some((ne, ce) => X[ce] !== ne) && s(q.join(""));
  }), K = Yi((q, ne) => {
    let ce = jt(X);
    for (let oe = 0; oe < q; oe += 1)
      ce[oe] || (ce[oe] = "");
    ne.length <= 1 ? ce[q] = ne : ce = ce.slice(0, q).concat(US(ne)), ce = ce.slice(0, r);
    for (let oe = ce.length - 1; oe >= 0 && !ce[oe]; oe -= 1)
      ce.pop();
    const ie = G(ce.map((oe) => oe || " ").join(""));
    return ce = US(ie).map((oe, he) => oe === " " && !ce[he] ? ce[he] : oe), ce;
  }), B = (q, ne) => {
    var ce;
    const ie = K(q, ne), oe = Math.min(q + ne.length, r - 1);
    oe !== q && ((ce = j.current[oe]) === null || ce === void 0 || ce.focus()), Z(ie);
  }, Q = (q) => {
    var ne;
    (ne = j.current[q]) === null || ne === void 0 || ne.focus();
  }, V = {
    variant: d,
    disabled: f,
    status: L,
    mask: v
  };
  return R(/* @__PURE__ */ O.createElement("div", Object.assign({}, w, {
    ref: H,
    className: Et(_, {
      [`${_}-sm`]: I === "small",
      [`${_}-lg`]: I === "large",
      [`${_}-rtl`]: S === "rtl"
    }, D, P)
  }), /* @__PURE__ */ O.createElement(Ya.Provider, {
    value: N
  }, Array.from({
    length: r
  }).map((q, ne) => {
    const ce = `otp-${ne}`, ie = X[ne] || "";
    return /* @__PURE__ */ O.createElement(Nee, Object.assign({
      ref: (oe) => {
        j.current[ne] = oe;
      },
      key: ce,
      index: ne,
      size: I,
      htmlSize: 1,
      className: `${_}-input`,
      onChange: B,
      value: ie,
      onActiveChange: Q,
      autoFocus: ne === 0 && g
    }, V));
  }))));
});
var Uee = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" }, zee = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: Uee
  }));
}, bV = /* @__PURE__ */ O.forwardRef(zee);
Ee.env.NODE_ENV !== "production" && (bV.displayName = "EyeInvisibleOutlined");
var Bee = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" }, Hee = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: Bee
  }));
}, SV = /* @__PURE__ */ O.forwardRef(Hee);
Ee.env.NODE_ENV !== "production" && (SV.displayName = "EyeOutlined");
var Vee = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const kee = (n) => n ? /* @__PURE__ */ O.createElement(SV, null) : /* @__PURE__ */ O.createElement(bV, null), $ee = {
  click: "onClick",
  hover: "onMouseOver"
}, _V = /* @__PURE__ */ O.forwardRef((n, e) => {
  const {
    disabled: t,
    action: r = "click",
    visibilityToggle: i = !0,
    iconRender: a = kee
  } = n, o = typeof i == "object" && i.visible !== void 0, [s, u] = Lr(() => o ? i.visible : !1), d = kt(null);
  O.useEffect(() => {
    o && u(i.visible);
  }, [o, i]);
  const f = yV(d), p = () => {
    t || (s && f(), u((U) => {
      var L;
      const N = !U;
      return typeof i == "object" && ((L = i.onVisibleChange) === null || L === void 0 || L.call(i, N)), N;
    }));
  }, g = (U) => {
    const L = $ee[r] || "", N = a(s), H = {
      [L]: p,
      className: `${U}-icon`,
      key: "passwordIcon",
      onMouseDown: (j) => {
        j.preventDefault();
      },
      onMouseUp: (j) => {
        j.preventDefault();
      }
    };
    return /* @__PURE__ */ O.cloneElement(/* @__PURE__ */ O.isValidElement(N) ? N : /* @__PURE__ */ O.createElement("span", null, N), H);
  }, {
    className: v,
    prefixCls: b,
    inputPrefixCls: E,
    size: S
  } = n, _ = Vee(n, ["className", "prefixCls", "inputPrefixCls", "size"]), {
    getPrefixCls: w
  } = O.useContext(mr), C = w("input", E), R = w("input-password", b), P = i && g(R), D = Et(R, v, {
    [`${R}-${S}`]: !!S
  }), I = Object.assign(Object.assign({}, du(_, ["suffix", "iconRender", "visibilityToggle"])), {
    type: s ? "text" : "password",
    className: D,
    prefixCls: C,
    suffix: P
  });
  return S && (I.size = S), /* @__PURE__ */ O.createElement(T0, Object.assign({
    ref: Ol(e, d)
  }, I));
});
Ee.env.NODE_ENV !== "production" && (_V.displayName = "Input.Password");
var Wee = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const xV = /* @__PURE__ */ O.forwardRef((n, e) => {
  const {
    prefixCls: t,
    inputPrefixCls: r,
    className: i,
    size: a,
    suffix: o,
    enterButton: s = !1,
    addonAfter: u,
    loading: d,
    disabled: f,
    onSearch: p,
    onChange: g,
    onCompositionStart: v,
    onCompositionEnd: b
  } = n, E = Wee(n, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]), {
    getPrefixCls: S,
    direction: _
  } = O.useContext(mr), w = O.useRef(!1), C = S("input-search", t), R = S("input", r), {
    compactSize: P
  } = _0(C, _), D = mc((V) => {
    var q;
    return (q = a ?? P) !== null && q !== void 0 ? q : V;
  }), I = O.useRef(null), U = (V) => {
    V != null && V.target && V.type === "click" && p && p(V.target.value, V, {
      source: "clear"
    }), g == null || g(V);
  }, L = (V) => {
    var q;
    document.activeElement === ((q = I.current) === null || q === void 0 ? void 0 : q.input) && V.preventDefault();
  }, N = (V) => {
    var q, ne;
    p && p((ne = (q = I.current) === null || q === void 0 ? void 0 : q.input) === null || ne === void 0 ? void 0 : ne.value, V, {
      source: "input"
    });
  }, H = (V) => {
    w.current || d || N(V);
  }, j = typeof s == "boolean" ? /* @__PURE__ */ O.createElement(lO, null) : null, G = `${C}-button`;
  let X;
  const ae = s || {}, Z = ae.type && ae.type.__ANT_BUTTON === !0;
  Z || ae.type === "button" ? X = fu(ae, Object.assign({
    onMouseDown: L,
    onClick: (V) => {
      var q, ne;
      (ne = (q = ae == null ? void 0 : ae.props) === null || q === void 0 ? void 0 : q.onClick) === null || ne === void 0 || ne.call(q, V), N(V);
    },
    key: "enterButton"
  }, Z ? {
    className: G,
    size: D
  } : {})) : X = /* @__PURE__ */ O.createElement(kh, {
    className: G,
    type: s ? "primary" : void 0,
    size: D,
    disabled: f,
    key: "enterButton",
    onMouseDown: L,
    onClick: N,
    loading: d,
    icon: j
  }, s), u && (X = [X, fu(u, {
    key: "addonAfter"
  })]);
  const K = Et(C, {
    [`${C}-rtl`]: _ === "rtl",
    [`${C}-${D}`]: !!D,
    [`${C}-with-button`]: !!s
  }, i), B = (V) => {
    w.current = !0, v == null || v(V);
  }, Q = (V) => {
    w.current = !1, b == null || b(V);
  };
  return /* @__PURE__ */ O.createElement(T0, Object.assign({
    ref: Ol(I, e),
    onPressEnter: H
  }, E, {
    size: D,
    onCompositionStart: B,
    onCompositionEnd: Q,
    prefixCls: R,
    addonAfter: X,
    suffix: o,
    onChange: U,
    className: K,
    disabled: f
  }));
});
Ee.env.NODE_ENV !== "production" && (xV.displayName = "Search");
var jee = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, Gee = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], aM = {}, Vs;
function Xee(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, t = n.getAttribute("id") || n.getAttribute("data-reactid") || n.getAttribute("name");
  if (e && aM[t])
    return aM[t];
  var r = window.getComputedStyle(n), i = r.getPropertyValue("box-sizing") || r.getPropertyValue("-moz-box-sizing") || r.getPropertyValue("-webkit-box-sizing"), a = parseFloat(r.getPropertyValue("padding-bottom")) + parseFloat(r.getPropertyValue("padding-top")), o = parseFloat(r.getPropertyValue("border-bottom-width")) + parseFloat(r.getPropertyValue("border-top-width")), s = Gee.map(function(d) {
    return "".concat(d, ":").concat(r.getPropertyValue(d));
  }).join(";"), u = {
    sizingStyle: s,
    paddingSize: a,
    borderSize: o,
    boxSizing: i
  };
  return e && t && (aM[t] = u), u;
}
function qee(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  Vs || (Vs = document.createElement("textarea"), Vs.setAttribute("tab-index", "-1"), Vs.setAttribute("aria-hidden", "true"), document.body.appendChild(Vs)), n.getAttribute("wrap") ? Vs.setAttribute("wrap", n.getAttribute("wrap")) : Vs.removeAttribute("wrap");
  var i = Xee(n, e), a = i.paddingSize, o = i.borderSize, s = i.boxSizing, u = i.sizingStyle;
  Vs.setAttribute("style", "".concat(u, ";").concat(jee)), Vs.value = n.value || n.placeholder || "";
  var d = void 0, f = void 0, p, g = Vs.scrollHeight;
  if (s === "border-box" ? g += o : s === "content-box" && (g -= a), t !== null || r !== null) {
    Vs.value = " ";
    var v = Vs.scrollHeight - a;
    t !== null && (d = v * t, s === "border-box" && (d = d + a + o), g = Math.max(d, g)), r !== null && (f = v * r, s === "border-box" && (f = f + a + o), p = g > f ? "" : "hidden", g = Math.min(f, g));
  }
  var b = {
    height: g,
    overflowY: p,
    resize: "none"
  };
  return d && (b.minHeight = d), f && (b.maxHeight = f), b;
}
var Yee = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"], oM = 0, sM = 1, lM = 2, Kee = /* @__PURE__ */ O.forwardRef(function(n, e) {
  var t = n, r = t.prefixCls;
  t.onPressEnter;
  var i = t.defaultValue, a = t.value, o = t.autoSize, s = t.onResize, u = t.className, d = t.style, f = t.disabled, p = t.onChange, g = t.onInternalAutoSize, v = br(t, Yee), b = ko(i, {
    value: a,
    postState: function(oe) {
      return oe ?? "";
    }
  }), E = ot(b, 2), S = E[0], _ = E[1], w = function(oe) {
    _(oe.target.value), p == null || p(oe);
  }, C = O.useRef();
  O.useImperativeHandle(e, function() {
    return {
      textArea: C.current
    };
  });
  var R = O.useMemo(function() {
    return o && bn(o) === "object" ? [o.minRows, o.maxRows] : [];
  }, [o]), P = ot(R, 2), D = P[0], I = P[1], U = !!o, L = function() {
    try {
      if (document.activeElement === C.current) {
        var oe = C.current, he = oe.selectionStart, le = oe.selectionEnd, ve = oe.scrollTop;
        C.current.setSelectionRange(he, le), C.current.scrollTop = ve;
      }
    } catch {
    }
  }, N = O.useState(lM), H = ot(N, 2), j = H[0], G = H[1], X = O.useState(), ae = ot(X, 2), Z = ae[0], K = ae[1], B = function() {
    G(oM), Ee.env.NODE_ENV === "test" && (g == null || g());
  };
  ti(function() {
    U && B();
  }, [a, D, I, U]), ti(function() {
    if (j === oM)
      G(sM);
    else if (j === sM) {
      var ie = qee(C.current, !1, D, I);
      G(lM), K(ie);
    } else
      L();
  }, [j]);
  var Q = O.useRef(), V = function() {
    Wr.cancel(Q.current);
  }, q = function(oe) {
    j === lM && (s == null || s(oe), o && (V(), Q.current = Wr(function() {
      B();
    })));
  };
  O.useEffect(function() {
    return V;
  }, []);
  var ne = U ? Z : null, ce = ke(ke({}, d), ne);
  return (j === oM || j === sM) && (ce.overflowY = "hidden", ce.overflowX = "hidden"), /* @__PURE__ */ O.createElement(Su, {
    onResize: q,
    disabled: !(o || s)
  }, /* @__PURE__ */ O.createElement("textarea", gn({}, v, {
    ref: C,
    style: ce,
    className: Et(r, u, Re({}, "".concat(r, "-disabled"), f)),
    disabled: f,
    value: S,
    onChange: w
  })));
}), Zee = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize", "readOnly"], Qee = /* @__PURE__ */ Fe.forwardRef(function(n, e) {
  var t, r = n.defaultValue, i = n.value, a = n.onFocus, o = n.onBlur, s = n.onChange, u = n.allowClear, d = n.maxLength, f = n.onCompositionStart, p = n.onCompositionEnd, g = n.suffix, v = n.prefixCls, b = v === void 0 ? "rc-textarea" : v, E = n.showCount, S = n.count, _ = n.className, w = n.style, C = n.disabled, R = n.hidden, P = n.classNames, D = n.styles, I = n.onResize, U = n.readOnly, L = br(n, Zee), N = ko(r, {
    value: i,
    defaultValue: r
  }), H = ot(N, 2), j = H[0], G = H[1], X = j == null ? "" : String(j), ae = Fe.useState(!1), Z = ot(ae, 2), K = Z[0], B = Z[1], Q = Fe.useRef(!1), V = Fe.useState(null), q = ot(V, 2), ne = q[0], ce = q[1], ie = kt(null), oe = kt(null), he = function() {
    var Be;
    return (Be = oe.current) === null || Be === void 0 ? void 0 : Be.textArea;
  }, le = function() {
    he().focus();
  };
  aE(e, function() {
    var pt;
    return {
      resizableTextArea: oe.current,
      focus: le,
      blur: function() {
        he().blur();
      },
      nativeElement: ((pt = ie.current) === null || pt === void 0 ? void 0 : pt.nativeElement) || he()
    };
  }), In(function() {
    B(function(pt) {
      return !C && pt;
    });
  }, [C]);
  var ve = Fe.useState(null), Ne = ot(ve, 2), xe = Ne[0], Me = Ne[1];
  Fe.useEffect(function() {
    if (xe) {
      var pt;
      (pt = he()).setSelectionRange.apply(pt, jt(xe));
    }
  }, [xe]);
  var $ = pV(S, E), Te = (t = $.max) !== null && t !== void 0 ? t : d, se = Number(Te) > 0, Ie = $.strategy(X), be = !!Te && Ie > Te, et = function(Be, ye) {
    var Ue = ye;
    !Q.current && $.exceedFormatter && $.max && $.strategy(ye) > $.max && (Ue = $.exceedFormatter(ye, {
      max: $.max
    }), ye !== Ue && Me([he().selectionStart || 0, he().selectionEnd || 0])), G(Ue), _x(Be.currentTarget, Be, s, Ue);
  }, Xe = function(Be) {
    Q.current = !0, f == null || f(Be);
  }, $e = function(Be) {
    Q.current = !1, et(Be, Be.currentTarget.value), p == null || p(Be);
  }, te = function(Be) {
    et(Be, Be.target.value);
  }, Y = function(Be) {
    var ye = L.onPressEnter, Ue = L.onKeyDown;
    Be.key === "Enter" && ye && ye(Be), Ue == null || Ue(Be);
  }, Se = function(Be) {
    B(!0), a == null || a(Be);
  }, Oe = function(Be) {
    B(!1), o == null || o(Be);
  }, Pe = function(Be) {
    G(""), le(), _x(he(), Be, s);
  }, Ve = g, Ze;
  $.show && ($.showFormatter ? Ze = $.showFormatter({
    value: X,
    count: Ie,
    maxLength: Te
  }) : Ze = "".concat(Ie).concat(se ? " / ".concat(Te) : ""), Ve = /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, Ve, /* @__PURE__ */ Fe.createElement("span", {
    className: Et("".concat(b, "-data-count"), P == null ? void 0 : P.count),
    style: D == null ? void 0 : D.count
  }, Ze)));
  var nt = function(Be) {
    var ye;
    I == null || I(Be), (ye = he()) !== null && ye !== void 0 && ye.style.height && ce(!0);
  }, ht = !L.autoSize && !E && !u;
  return /* @__PURE__ */ Fe.createElement(_O, {
    ref: ie,
    value: X,
    allowClear: u,
    handleReset: Pe,
    suffix: Ve,
    prefixCls: b,
    classNames: ke(ke({}, P), {}, {
      affixWrapper: Et(P == null ? void 0 : P.affixWrapper, Re(Re({}, "".concat(b, "-show-count"), E), "".concat(b, "-textarea-allow-clear"), u))
    }),
    disabled: C,
    focused: K,
    className: Et(_, be && "".concat(b, "-out-of-range")),
    style: ke(ke({}, w), ne && !ht ? {
      height: "auto"
    } : {}),
    dataAttrs: {
      affixWrapper: {
        "data-count": typeof Ze == "string" ? Ze : void 0
      }
    },
    hidden: R,
    readOnly: U
  }, /* @__PURE__ */ Fe.createElement(Kee, gn({}, L, {
    maxLength: d,
    onKeyDown: Y,
    onChange: te,
    onFocus: Se,
    onBlur: Oe,
    onCompositionStart: Xe,
    onCompositionEnd: $e,
    className: Et(P == null ? void 0 : P.textarea),
    style: ke(ke({}, D == null ? void 0 : D.textarea), {}, {
      resize: w == null ? void 0 : w.resize
    }),
    disabled: C,
    prefixCls: b,
    onResize: nt,
    ref: oe,
    readOnly: U
  })));
}), Jee = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const ete = /* @__PURE__ */ Al((n, e) => {
  var t, r;
  const {
    prefixCls: i,
    bordered: a = !0,
    size: o,
    disabled: s,
    status: u,
    allowClear: d,
    classNames: f,
    rootClassName: p,
    className: g,
    style: v,
    styles: b,
    variant: E
  } = n, S = Jee(n, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
  if (Ee.env.NODE_ENV !== "production") {
    const {
      deprecated: V
    } = ci("TextArea");
    V(!("bordered" in n), "bordered", "variant");
  }
  const {
    getPrefixCls: _,
    direction: w,
    textArea: C
  } = O.useContext(mr), R = mc(o), P = O.useContext(fc), D = s ?? P, {
    status: I,
    hasFeedback: U,
    feedbackIcon: L
  } = O.useContext(Ya), N = w0(I, u), H = O.useRef(null);
  O.useImperativeHandle(e, () => {
    var V;
    return {
      resizableTextArea: (V = H.current) === null || V === void 0 ? void 0 : V.resizableTextArea,
      focus: (q) => {
        var ne, ce;
        Oee((ce = (ne = H.current) === null || ne === void 0 ? void 0 : ne.resizableTextArea) === null || ce === void 0 ? void 0 : ce.textArea, q);
      },
      blur: () => {
        var q;
        return (q = H.current) === null || q === void 0 ? void 0 : q.blur();
      }
    };
  });
  const j = _("input", i), G = _u(j), [X, ae, Z] = mO(j, G), [K, B] = wE("textArea", E, a), Q = vV(d ?? (C == null ? void 0 : C.allowClear));
  return X(/* @__PURE__ */ O.createElement(Qee, Object.assign({
    autoComplete: C == null ? void 0 : C.autoComplete
  }, S, {
    style: Object.assign(Object.assign({}, C == null ? void 0 : C.style), v),
    styles: Object.assign(Object.assign({}, C == null ? void 0 : C.styles), b),
    disabled: D,
    allowClear: Q,
    className: Et(Z, G, g, p, C == null ? void 0 : C.className),
    classNames: Object.assign(Object.assign(Object.assign({}, f), C == null ? void 0 : C.classNames), {
      textarea: Et({
        [`${j}-sm`]: R === "small",
        [`${j}-lg`]: R === "large"
      }, ae, f == null ? void 0 : f.textarea, (t = C == null ? void 0 : C.classNames) === null || t === void 0 ? void 0 : t.textarea),
      variant: Et({
        [`${j}-${K}`]: B
      }, Ph(j, N)),
      affixWrapper: Et(`${j}-textarea-affix-wrapper`, {
        [`${j}-affix-wrapper-rtl`]: w === "rtl",
        [`${j}-affix-wrapper-sm`]: R === "small",
        [`${j}-affix-wrapper-lg`]: R === "large",
        [`${j}-textarea-show-count`]: n.showCount || ((r = n.count) === null || r === void 0 ? void 0 : r.show)
      }, ae)
    }),
    prefixCls: j,
    suffix: U && /* @__PURE__ */ O.createElement("span", {
      className: `${j}-textarea-suffix`
    }, L),
    ref: H
  })));
}), yg = T0;
yg.Group = Tee;
yg.Search = xV;
yg.TextArea = ete;
yg.Password = _V;
yg.OTP = Fee;
const tte = /(^#[\da-f]{6}$)|(^#[\da-f]{8}$)/i, OL = (n) => tte.test(`#${n}`), nte = (n) => {
  let {
    prefixCls: e,
    value: t,
    onChange: r
  } = n;
  const i = `${e}-hex-input`, [a, o] = Lr(t == null ? void 0 : t.toHex());
  In(() => {
    const u = t == null ? void 0 : t.toHex();
    OL(u) && t && o(Q_(u));
  }, [t]);
  const s = (u) => {
    const d = u.target.value;
    o(Q_(d)), OL(Q_(d, !0)) && (r == null || r(Sa(d)));
  };
  return /* @__PURE__ */ Fe.createElement(yg, {
    className: i,
    value: a,
    prefix: "#",
    onChange: s,
    size: "small"
  });
}, rte = (n) => {
  let {
    prefixCls: e,
    value: t,
    onChange: r
  } = n;
  const i = `${e}-hsb-input`, [a, o] = Lr(Sa(t || "#000"));
  In(() => {
    t && o(t);
  }, [t]);
  const s = (u, d) => {
    const f = a.toHsb();
    f[d] = d === "h" ? u : (u || 0) / 100;
    const p = Sa(f);
    t || o(p), r == null || r(p);
  };
  return /* @__PURE__ */ Fe.createElement("div", {
    className: i
  }, /* @__PURE__ */ Fe.createElement(bh, {
    max: 360,
    min: 0,
    value: Number(a.toHsb().h),
    prefixCls: e,
    className: i,
    formatter: (u) => J_(u || 0).toString(),
    onChange: (u) => s(Number(u), "h")
  }), /* @__PURE__ */ Fe.createElement(bh, {
    max: 100,
    min: 0,
    value: Number(a.toHsb().s) * 100,
    prefixCls: e,
    className: i,
    formatter: (u) => `${J_(u || 0)}%`,
    onChange: (u) => s(Number(u), "s")
  }), /* @__PURE__ */ Fe.createElement(bh, {
    max: 100,
    min: 0,
    value: Number(a.toHsb().b) * 100,
    prefixCls: e,
    className: i,
    formatter: (u) => `${J_(u || 0)}%`,
    onChange: (u) => s(Number(u), "b")
  }));
}, ite = (n) => {
  let {
    prefixCls: e,
    value: t,
    onChange: r
  } = n;
  const i = `${e}-rgb-input`, [a, o] = Lr(Sa(t || "#000"));
  In(() => {
    t && o(t);
  }, [t]);
  const s = (u, d) => {
    const f = a.toRgb();
    f[d] = u || 0;
    const p = Sa(f);
    t || o(p), r == null || r(p);
  };
  return /* @__PURE__ */ Fe.createElement("div", {
    className: i
  }, /* @__PURE__ */ Fe.createElement(bh, {
    max: 255,
    min: 0,
    value: Number(a.toRgb().r),
    prefixCls: e,
    className: i,
    onChange: (u) => s(Number(u), "r")
  }), /* @__PURE__ */ Fe.createElement(bh, {
    max: 255,
    min: 0,
    value: Number(a.toRgb().g),
    prefixCls: e,
    className: i,
    onChange: (u) => s(Number(u), "g")
  }), /* @__PURE__ */ Fe.createElement(bh, {
    max: 255,
    min: 0,
    value: Number(a.toRgb().b),
    prefixCls: e,
    className: i,
    onChange: (u) => s(Number(u), "b")
  }));
}, ate = [Vd.hex, Vd.hsb, Vd.rgb].map((n) => ({
  value: n,
  label: n.toLocaleUpperCase()
})), ote = (n) => {
  const {
    prefixCls: e,
    format: t,
    value: r,
    disabledAlpha: i,
    onFormatChange: a,
    onChange: o
  } = n, [s, u] = ko(Vd.hex, {
    value: t,
    onChange: a
  }), d = `${e}-input`, f = (g) => {
    u(g);
  }, p = Mr(() => {
    const g = {
      value: r,
      prefixCls: e,
      onChange: o
    };
    switch (s) {
      case Vd.hsb:
        return /* @__PURE__ */ Fe.createElement(rte, Object.assign({}, g));
      case Vd.rgb:
        return /* @__PURE__ */ Fe.createElement(ite, Object.assign({}, g));
      default:
        return /* @__PURE__ */ Fe.createElement(nte, Object.assign({}, g));
    }
  }, [s, e, r, o]);
  return /* @__PURE__ */ Fe.createElement("div", {
    className: `${d}-container`
  }, /* @__PURE__ */ Fe.createElement($h, {
    value: s,
    variant: "borderless",
    getPopupContainer: (g) => g,
    popupMatchSelectWidth: 68,
    placement: "bottomRight",
    onChange: f,
    className: `${e}-format-select`,
    size: "small",
    options: ate
  }), /* @__PURE__ */ Fe.createElement("div", {
    className: d
  }, p), !i && /* @__PURE__ */ Fe.createElement(Mee, {
    prefixCls: e,
    value: r,
    onChange: o
  }));
};
var ste = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const PL = () => {
  const n = ni(lV), {
    prefixCls: e,
    allowClear: t,
    value: r,
    disabledAlpha: i,
    onChange: a,
    onClear: o,
    onChangeComplete: s
  } = n, u = ste(n, ["prefixCls", "allowClear", "value", "disabledAlpha", "onChange", "onClear", "onChangeComplete"]);
  return /* @__PURE__ */ Fe.createElement(Fe.Fragment, null, t && /* @__PURE__ */ Fe.createElement(uV, Object.assign({
    prefixCls: e,
    value: r,
    onChange: (d) => {
      a == null || a(d), o == null || o();
    }
  }, u)), /* @__PURE__ */ Fe.createElement(ZJ, {
    prefixCls: e,
    value: r == null ? void 0 : r.toHsb(),
    disabledAlpha: i,
    onChange: (d, f) => {
      a == null || a(Sa(d), f, !0);
    },
    onChangeComplete: (d) => {
      s == null || s(Sa(d));
    }
  }), /* @__PURE__ */ Fe.createElement(ote, Object.assign({
    value: r,
    onChange: a,
    prefixCls: e,
    disabledAlpha: i
  }, u)));
}, cM = (n) => n.map((e) => (e.colors = e.colors.map(Sa), e)), lte = (n, e) => {
  const {
    r: t,
    g: r,
    b: i,
    a
  } = n.toRgb(), o = new bx(n.toRgbString()).onBackground(e).toHsv();
  return a <= 0.5 ? o.v > 0.5 : t * 0.299 + r * 0.587 + i * 0.114 > 192;
}, DL = (n) => {
  let {
    label: e
  } = n;
  return `panel-${e}`;
}, cte = (n) => {
  let {
    prefixCls: e,
    presets: t,
    value: r,
    onChange: i
  } = n;
  const [a] = zA("ColorPicker"), [, o] = mo(), [s] = ko(cM(t), {
    value: cM(t),
    postState: cM
  }), u = `${e}-presets`, d = Mr(() => s.reduce((g, v) => {
    const {
      defaultOpen: b = !0
    } = v;
    return b && g.push(DL(v)), g;
  }, []), [s]), f = (g) => {
    i == null || i(g);
  }, p = s.map((g) => {
    var v;
    return {
      key: DL(g),
      label: /* @__PURE__ */ Fe.createElement("div", {
        className: `${u}-label`
      }, g == null ? void 0 : g.label),
      children: /* @__PURE__ */ Fe.createElement("div", {
        className: `${u}-items`
      }, Array.isArray(g == null ? void 0 : g.colors) && ((v = g.colors) === null || v === void 0 ? void 0 : v.length) > 0 ? g.colors.map((b, E) => /* @__PURE__ */ Fe.createElement(
        yO,
        {
          // eslint-disable-next-line react/no-array-index-key
          key: `preset-${E}-${b.toHexString()}`,
          color: Sa(b).toRgbString(),
          prefixCls: e,
          className: Et(`${u}-color`, {
            [`${u}-color-checked`]: b.toHexString() === (r == null ? void 0 : r.toHexString()),
            [`${u}-color-bright`]: lte(b, o.colorBgElevated)
          }),
          onClick: () => f(b)
        }
      )) : /* @__PURE__ */ Fe.createElement("span", {
        className: `${u}-empty`
      }, a.presetEmpty))
    };
  });
  return /* @__PURE__ */ Fe.createElement("div", {
    className: u
  }, /* @__PURE__ */ Fe.createElement(FJ, {
    defaultActiveKey: d,
    ghost: !0,
    items: p
  }));
}, IL = () => {
  const {
    prefixCls: n,
    value: e,
    presets: t,
    onChange: r
  } = ni(cV);
  return Array.isArray(t) ? /* @__PURE__ */ Fe.createElement(cte, {
    value: e,
    presets: t,
    prefixCls: n,
    onChange: r
  }) : null;
};
var ute = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const EV = (n) => {
  const {
    prefixCls: e,
    presets: t,
    panelRender: r,
    color: i,
    onChange: a,
    onClear: o
  } = n, s = ute(n, ["prefixCls", "presets", "panelRender", "color", "onChange", "onClear"]), u = `${e}-inner`, d = Object.assign({
    prefixCls: e,
    value: i,
    onChange: a,
    onClear: o
  }, s), f = Fe.useMemo(() => ({
    prefixCls: e,
    value: i,
    presets: t,
    onChange: a
  }), [e, i, t, a]), p = /* @__PURE__ */ Fe.createElement("div", {
    className: `${u}-content`
  }, /* @__PURE__ */ Fe.createElement(PL, null), Array.isArray(t) && /* @__PURE__ */ Fe.createElement(tV, null), /* @__PURE__ */ Fe.createElement(IL, null));
  return /* @__PURE__ */ Fe.createElement(QJ, {
    value: d
  }, /* @__PURE__ */ Fe.createElement(JJ, {
    value: f
  }, /* @__PURE__ */ Fe.createElement("div", {
    className: u
  }, typeof r == "function" ? r(p, {
    components: {
      Picker: PL,
      Presets: IL
    }
  }) : p)));
};
Ee.env.NODE_ENV !== "production" && (EV.displayName = "ColorPickerPanel");
var dte = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const fte = /* @__PURE__ */ Al((n, e) => {
  const {
    color: t,
    prefixCls: r,
    open: i,
    disabled: a,
    format: o,
    className: s,
    showText: u
  } = n, d = dte(n, ["color", "prefixCls", "open", "disabled", "format", "className", "showText"]), f = `${r}-trigger`, p = Mr(() => t.cleared ? /* @__PURE__ */ Fe.createElement(uV, {
    prefixCls: r
  }) : /* @__PURE__ */ Fe.createElement(yO, {
    prefixCls: r,
    color: t.toRgbString()
  }), [t, r]), g = () => {
    const b = t.toHexString().toUpperCase(), E = Sx(t);
    switch (o) {
      case "rgb":
        return t.toRgbString();
      case "hsb":
        return t.toHsbString();
      default:
        return E < 100 ? `${b.slice(0, 7)},${E}%` : b;
    }
  }, v = () => {
    if (typeof u == "function")
      return u(t);
    if (u)
      return g();
  };
  return /* @__PURE__ */ Fe.createElement("div", Object.assign({
    ref: e,
    className: Et(f, s, {
      [`${f}-active`]: i,
      [`${f}-disabled`]: a
    })
  }, d), p, u && /* @__PURE__ */ Fe.createElement("div", {
    className: `${f}-text`
  }, v()));
}), hte = {};
function uM(n) {
  return n !== void 0;
}
const pte = (n, e) => {
  const {
    defaultValue: t,
    value: r
  } = e, i = kt(Sa("")), [a, o] = Lr(() => {
    let d;
    uM(r) ? d = r : uM(t) ? d = t : d = n;
    const f = Sa(d || "");
    return i.current = f, f;
  }), s = (d) => {
    o(d), i.current = d;
  }, u = kt(hte);
  return In(() => {
    if (u.current === r)
      return;
    u.current = r;
    const d = Sa(uM(r) ? r || "" : i.current);
    i.current.cleared === !0 && (d.cleared = "controlled"), s(d);
  }, [r]), [a, s, i];
}, CV = (n, e) => ({
  backgroundImage: `conic-gradient(${e} 0 25%, transparent 0 50%, ${e} 0 75%, transparent 0)`,
  backgroundSize: `${n} ${n}`
}), NL = (n, e) => {
  const {
    componentCls: t,
    borderRadiusSM: r,
    colorPickerInsetShadow: i,
    lineWidth: a,
    colorFillSecondary: o
  } = n;
  return {
    [`${t}-color-block`]: Object.assign(Object.assign({
      position: "relative",
      borderRadius: r,
      width: e,
      height: e,
      boxShadow: i
    }, CV("50%", n.colorFillSecondary)), {
      [`${t}-color-block-inner`]: {
        width: "100%",
        height: "100%",
        border: `${Mt(a)} solid ${o}`,
        borderRadius: "inherit"
      }
    })
  };
}, mte = (n) => {
  const {
    componentCls: e,
    antCls: t,
    fontSizeSM: r,
    lineHeightSM: i,
    colorPickerAlphaInputWidth: a,
    marginXXS: o,
    paddingXXS: s,
    controlHeightSM: u,
    marginXS: d,
    fontSizeIcon: f,
    paddingXS: p,
    colorTextPlaceholder: g,
    colorPickerInputNumberHandleWidth: v,
    lineWidth: b
  } = n;
  return {
    [`${e}-input-container`]: {
      display: "flex",
      [`${e}-steppers${t}-input-number`]: {
        fontSize: r,
        lineHeight: i,
        [`${t}-input-number-input`]: {
          paddingInlineStart: s,
          paddingInlineEnd: 0
        },
        [`${t}-input-number-handler-wrap`]: {
          width: v
        }
      },
      [`${e}-steppers${e}-alpha-input`]: {
        flex: `0 0 ${Mt(a)}`,
        marginInlineStart: o
      },
      [`${e}-format-select${t}-select`]: {
        marginInlineEnd: d,
        width: "auto",
        "&-single": {
          [`${t}-select-selector`]: {
            padding: 0,
            border: 0
          },
          [`${t}-select-arrow`]: {
            insetInlineEnd: 0
          },
          [`${t}-select-selection-item`]: {
            paddingInlineEnd: n.calc(f).add(o).equal(),
            fontSize: r,
            lineHeight: `${Mt(u)}`
          },
          [`${t}-select-item-option-content`]: {
            fontSize: r,
            lineHeight: i
          },
          [`${t}-select-dropdown`]: {
            [`${t}-select-item`]: {
              minHeight: "auto"
            }
          }
        }
      },
      [`${e}-input`]: {
        gap: o,
        alignItems: "center",
        flex: 1,
        width: 0,
        [`${e}-hsb-input,${e}-rgb-input`]: {
          display: "flex",
          gap: o,
          alignItems: "center"
        },
        [`${e}-steppers`]: {
          flex: 1
        },
        [`${e}-hex-input${t}-input-affix-wrapper`]: {
          flex: 1,
          padding: `0 ${Mt(p)}`,
          [`${t}-input`]: {
            fontSize: r,
            textTransform: "uppercase",
            lineHeight: Mt(n.calc(u).sub(n.calc(b).mul(2)).equal())
          },
          [`${t}-input-prefix`]: {
            color: g
          }
        }
      }
    }
  };
}, gte = (n) => {
  const {
    componentCls: e,
    controlHeightLG: t,
    borderRadiusSM: r,
    colorPickerInsetShadow: i,
    marginSM: a,
    colorBgElevated: o,
    colorFillSecondary: s,
    lineWidthBold: u,
    colorPickerHandlerSize: d,
    colorPickerHandlerSizeSM: f,
    colorPickerSliderHeight: p
  } = n;
  return {
    [`${e}-select`]: {
      [`${e}-palette`]: {
        minHeight: n.calc(t).mul(4).equal(),
        overflow: "hidden",
        borderRadius: r
      },
      [`${e}-saturation`]: {
        position: "absolute",
        borderRadius: "inherit",
        boxShadow: i,
        inset: 0
      },
      marginBottom: a
    },
    [`${e}-handler`]: {
      width: d,
      height: d,
      border: `${Mt(u)} solid ${o}`,
      position: "relative",
      borderRadius: "50%",
      cursor: "pointer",
      boxShadow: `${i}, 0 0 0 1px ${s}`,
      "&-sm": {
        width: f,
        height: f
      }
    },
    [`${e}-slider`]: {
      borderRadius: n.calc(p).div(2).equal(),
      [`${e}-palette`]: {
        height: p
      },
      [`${e}-gradient`]: {
        borderRadius: n.calc(p).div(2).equal(),
        boxShadow: i
      },
      "&-alpha": CV(`${Mt(p)}`, n.colorFillSecondary),
      "&-hue": {
        marginBottom: a
      }
    },
    [`${e}-slider-container`]: {
      display: "flex",
      gap: a,
      marginBottom: a,
      [`${e}-slider-group`]: {
        flex: 1,
        "&-disabled-alpha": {
          display: "flex",
          alignItems: "center",
          [`${e}-slider`]: {
            flex: 1,
            marginBottom: 0
          }
        }
      }
    }
  };
}, vte = (n) => {
  const {
    componentCls: e,
    antCls: t,
    colorTextQuaternary: r,
    paddingXXS: i,
    colorPickerPresetColorSize: a,
    fontSizeSM: o,
    colorText: s,
    lineHeightSM: u,
    lineWidth: d,
    borderRadius: f,
    colorFill: p,
    colorWhite: g,
    marginXXS: v,
    paddingXS: b,
    fontHeightSM: E
  } = n;
  return {
    [`${e}-presets`]: {
      [`${t}-collapse-item > ${t}-collapse-header`]: {
        padding: 0,
        [`${t}-collapse-expand-icon`]: {
          height: E,
          color: r,
          paddingInlineEnd: i
        }
      },
      [`${t}-collapse`]: {
        display: "flex",
        flexDirection: "column",
        gap: v
      },
      [`${t}-collapse-item > ${t}-collapse-content > ${t}-collapse-content-box`]: {
        padding: `${Mt(b)} 0`
      },
      "&-label": {
        fontSize: o,
        color: s,
        lineHeight: u
      },
      "&-items": {
        display: "flex",
        flexWrap: "wrap",
        gap: n.calc(v).mul(1.5).equal(),
        [`${e}-presets-color`]: {
          position: "relative",
          cursor: "pointer",
          width: a,
          height: a,
          "&::before": {
            content: '""',
            pointerEvents: "none",
            width: n.calc(a).add(n.calc(d).mul(4)).equal(),
            height: n.calc(a).add(n.calc(d).mul(4)).equal(),
            position: "absolute",
            top: n.calc(d).mul(-2).equal(),
            insetInlineStart: n.calc(d).mul(-2).equal(),
            borderRadius: f,
            border: `${Mt(d)} solid transparent`,
            transition: `border-color ${n.motionDurationMid} ${n.motionEaseInBack}`
          },
          "&:hover::before": {
            borderColor: p
          },
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: n.calc(a).div(13).mul(5).equal(),
            height: n.calc(a).div(13).mul(8).equal(),
            border: `${Mt(n.lineWidthBold)} solid ${n.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${n.motionDurationFast} ${n.motionEaseInBack}, opacity ${n.motionDurationFast}`
          },
          [`&${e}-presets-color-checked`]: {
            "&::after": {
              opacity: 1,
              borderColor: g,
              transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
              transition: `transform ${n.motionDurationMid} ${n.motionEaseOutBack} ${n.motionDurationFast}`
            },
            [`&${e}-presets-color-bright`]: {
              "&::after": {
                borderColor: "rgba(0, 0, 0, 0.45)"
              }
            }
          }
        }
      },
      "&-empty": {
        fontSize: o,
        color: r
      }
    }
  };
}, kR = (n, e, t) => ({
  borderInlineEndWidth: n.lineWidth,
  borderColor: e,
  boxShadow: `0 0 0 ${Mt(n.controlOutlineWidth)} ${t}`,
  outline: 0
}), yte = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    "&-rtl": {
      [`${e}-presets-color`]: {
        "&::after": {
          direction: "ltr"
        }
      },
      [`${e}-clear`]: {
        "&::after": {
          direction: "ltr"
        }
      }
    }
  };
}, LL = (n, e, t) => {
  const {
    componentCls: r,
    borderRadiusSM: i,
    lineWidth: a,
    colorSplit: o,
    colorBorder: s,
    red6: u
  } = n;
  return {
    [`${r}-clear`]: Object.assign(Object.assign({
      width: e,
      height: e,
      borderRadius: i,
      border: `${Mt(a)} solid ${o}`,
      position: "relative",
      overflow: "hidden",
      cursor: "pointer",
      transition: `all ${n.motionDurationFast}`
    }, t), {
      "&::after": {
        content: '""',
        position: "absolute",
        insetInlineEnd: a,
        top: 0,
        display: "block",
        width: 40,
        // maximum
        height: 2,
        // fixed
        transformOrigin: "right",
        transform: "rotate(-45deg)",
        backgroundColor: u
      },
      "&:hover": {
        borderColor: s
      }
    })
  };
}, bte = (n) => {
  const {
    componentCls: e,
    colorError: t,
    colorWarning: r,
    colorErrorHover: i,
    colorWarningHover: a,
    colorErrorOutline: o,
    colorWarningOutline: s
  } = n;
  return {
    [`&${e}-status-error`]: {
      borderColor: t,
      "&:hover": {
        borderColor: i
      },
      [`&${e}-trigger-active`]: Object.assign({}, kR(n, t, o))
    },
    [`&${e}-status-warning`]: {
      borderColor: r,
      "&:hover": {
        borderColor: a
      },
      [`&${e}-trigger-active`]: Object.assign({}, kR(n, r, s))
    }
  };
}, Ste = (n) => {
  const {
    componentCls: e,
    controlHeightLG: t,
    controlHeightSM: r,
    controlHeight: i,
    controlHeightXS: a,
    borderRadius: o,
    borderRadiusSM: s,
    borderRadiusXS: u,
    borderRadiusLG: d,
    fontSizeLG: f
  } = n;
  return {
    [`&${e}-lg`]: {
      minWidth: t,
      height: t,
      borderRadius: d,
      [`${e}-color-block, ${e}-clear`]: {
        width: i,
        height: i,
        borderRadius: o
      },
      [`${e}-trigger-text`]: {
        fontSize: f
      }
    },
    [`&${e}-sm`]: {
      minWidth: r,
      height: r,
      borderRadius: s,
      [`${e}-color-block, ${e}-clear`]: {
        width: a,
        height: a,
        borderRadius: u
      }
    }
  };
}, _te = (n) => {
  const {
    antCls: e,
    componentCls: t,
    colorPickerWidth: r,
    colorPrimary: i,
    motionDurationMid: a,
    colorBgElevated: o,
    colorTextDisabled: s,
    colorText: u,
    colorBgContainerDisabled: d,
    borderRadius: f,
    marginXS: p,
    marginSM: g,
    controlHeight: v,
    controlHeightSM: b,
    colorBgTextActive: E,
    colorPickerPresetColorSize: S,
    colorPickerPreviewSize: _,
    lineWidth: w,
    colorBorder: C,
    paddingXXS: R,
    fontSize: P,
    colorPrimaryHover: D,
    controlOutline: I
  } = n;
  return [{
    [t]: Object.assign({
      [`${t}-inner`]: Object.assign(Object.assign(Object.assign(Object.assign({
        "&-content": {
          display: "flex",
          flexDirection: "column",
          width: r,
          [`& > ${e}-divider`]: {
            margin: `${Mt(g)} 0 ${Mt(p)}`
          }
        },
        [`${t}-panel`]: Object.assign({}, gte(n))
      }, NL(n, _)), mte(n)), vte(n)), LL(n, S, {
        marginInlineStart: "auto",
        marginBottom: p
      })),
      "&-trigger": Object.assign(Object.assign(Object.assign(Object.assign({
        minWidth: v,
        height: v,
        borderRadius: f,
        border: `${Mt(w)} solid ${C}`,
        cursor: "pointer",
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        transition: `all ${a}`,
        background: o,
        padding: n.calc(R).sub(w).equal(),
        [`${t}-trigger-text`]: {
          marginInlineStart: p,
          marginInlineEnd: n.calc(p).sub(n.calc(R).sub(w)).equal(),
          fontSize: P,
          color: u
        },
        "&:hover": {
          borderColor: D
        },
        [`&${t}-trigger-active`]: Object.assign({}, kR(n, i, I)),
        "&-disabled": {
          color: s,
          background: d,
          cursor: "not-allowed",
          "&:hover": {
            borderColor: E
          },
          [`${t}-trigger-text`]: {
            color: s
          }
        }
      }, LL(n, b)), NL(n, b)), bte(n)), Ste(n))
    }, yte(n))
  }];
}, xte = $o("ColorPicker", (n) => {
  const {
    colorTextQuaternary: e,
    marginSM: t
  } = n, r = 8, i = li(n, {
    colorPickerWidth: 234,
    colorPickerHandlerSize: 16,
    colorPickerHandlerSizeSM: 12,
    colorPickerAlphaInputWidth: 44,
    colorPickerInputNumberHandleWidth: 16,
    colorPickerPresetColorSize: 18,
    colorPickerInsetShadow: `inset 0 0 1px 0 ${e}`,
    colorPickerSliderHeight: r,
    colorPickerPreviewSize: n.calc(r).mul(2).add(t).equal()
  });
  return [_te(i)];
});
var Ete = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const R0 = (n) => {
  const {
    value: e,
    defaultValue: t,
    format: r,
    defaultFormat: i,
    allowClear: a = !1,
    presets: o,
    children: s,
    trigger: u = "click",
    open: d,
    disabled: f,
    placement: p = "bottomLeft",
    arrow: g = !0,
    panelRender: v,
    showText: b,
    style: E,
    className: S,
    size: _,
    rootClassName: w,
    prefixCls: C,
    styles: R,
    disabledAlpha: P = !1,
    onFormatChange: D,
    onChange: I,
    onClear: U,
    onOpenChange: L,
    onChangeComplete: N,
    getPopupContainer: H,
    autoAdjustOverflow: j = !0,
    destroyTooltipOnHide: G
  } = n, X = Ete(n, ["value", "defaultValue", "format", "defaultFormat", "allowClear", "presets", "children", "trigger", "open", "disabled", "placement", "arrow", "panelRender", "showText", "style", "className", "size", "rootClassName", "prefixCls", "styles", "disabledAlpha", "onFormatChange", "onChange", "onClear", "onOpenChange", "onChangeComplete", "getPopupContainer", "autoAdjustOverflow", "destroyTooltipOnHide"]), {
    getPrefixCls: ae,
    direction: Z,
    colorPicker: K
  } = ni(mr), B = ni(fc), Q = f ?? B, [V, q, ne] = pte("", {
    value: e,
    defaultValue: t
  }), [ce, ie] = ko(!1, {
    value: d,
    postState: (Ze) => !Q && Ze,
    onChange: L
  }), [oe, he] = ko(r, {
    value: r,
    defaultValue: i,
    onChange: D
  }), le = ae("color-picker", C), ve = Mr(() => Sx(V) < 100, [V]), {
    status: Ne
  } = Fe.useContext(Ya), xe = mc(_), Me = _u(le), [$, Te, se] = xte(le, Me), Ie = {
    [`${le}-rtl`]: Z
  }, be = Et(w, se, Me, Ie), et = Et(Ph(le, Ne), {
    [`${le}-sm`]: xe === "small",
    [`${le}-lg`]: xe === "large"
  }, K == null ? void 0 : K.className, be, S, Te), Xe = Et(le, be), $e = kt(!0);
  if (Ee.env.NODE_ENV !== "production") {
    const Ze = ci("ColorPicker");
    Ee.env.NODE_ENV !== "production" && Ze(!(P && ve), "usage", "`disabledAlpha` will make the alpha to be 100% when use alpha color.");
  }
  const te = (Ze, nt, ht) => {
    var pt;
    let Be = Sa(Ze);
    const ye = e === null || !e && t === null;
    (!((pt = ne.current) === null || pt === void 0) && pt.cleared || ye) && Sx(V) === 0 && nt !== "alpha" && (Be = iM(Be)), P && ve && (Be = iM(Be)), ht ? $e.current = !1 : N == null || N(Be), q(Be), I == null || I(Be, Be.toHexString());
  }, Y = () => {
    U == null || U();
  }, Se = (Ze) => {
    $e.current = !0;
    let nt = Sa(Ze);
    P && ve && (nt = iM(Ze)), N == null || N(nt);
  }, Oe = {
    open: ce,
    trigger: u,
    placement: p,
    arrow: g,
    rootClassName: w,
    getPopupContainer: H,
    autoAdjustOverflow: j,
    destroyTooltipOnHide: G
  }, Pe = {
    prefixCls: le,
    color: V,
    allowClear: a,
    disabled: Q,
    disabledAlpha: P,
    presets: o,
    panelRender: v,
    format: oe,
    onFormatChange: he,
    onChangeComplete: Se
  }, Ve = Object.assign(Object.assign({}, K == null ? void 0 : K.style), E);
  return $(/* @__PURE__ */ Fe.createElement(dO, Object.assign({
    style: R == null ? void 0 : R.popup,
    overlayInnerStyle: R == null ? void 0 : R.popupOverlayInner,
    onOpenChange: (Ze) => {
      $e.current && !Q && ie(Ze);
    },
    content: /* @__PURE__ */ Fe.createElement(rg, {
      form: !0
    }, /* @__PURE__ */ Fe.createElement(EV, Object.assign({}, Pe, {
      onChange: te,
      onChangeComplete: Se,
      onClear: Y
    }))),
    overlayClassName: Xe
  }, Oe), s || /* @__PURE__ */ Fe.createElement(fte, Object.assign({
    open: ce,
    className: et,
    style: Ve,
    prefixCls: le,
    disabled: Q,
    showText: b,
    format: oe
  }, X, {
    color: V
  }))));
};
Ee.env.NODE_ENV !== "production" && (R0.displayName = "ColorPicker");
const Cte = rH(
  R0,
  "color-picker",
  /* istanbul ignore next */
  (n) => n,
  (n) => Object.assign(Object.assign({}, n), {
    placement: "bottom",
    autoAdjustOverflow: !1
  })
);
R0._InternalPanelDoNotUseOrYouWillBeFired = Cte;
function xx(n) {
  const [e, t] = O.useState(n);
  return O.useEffect(() => {
    const r = setTimeout(() => {
      t(n);
    }, n.length ? 0 : 10);
    return () => {
      clearTimeout(r);
    };
  }, [n]), e;
}
const wte = (n) => {
  const {
    componentCls: e
  } = n, t = `${e}-show-help`, r = `${e}-show-help-item`;
  return {
    [t]: {
      // Explain holder
      transition: `opacity ${n.motionDurationSlow} ${n.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [r]: {
        overflow: "hidden",
        transition: `height ${n.motionDurationSlow} ${n.motionEaseInOut},
                     opacity ${n.motionDurationSlow} ${n.motionEaseInOut},
                     transform ${n.motionDurationSlow} ${n.motionEaseInOut} !important`,
        [`&${r}-appear, &${r}-enter`]: {
          transform: "translateY(-5px)",
          opacity: 0,
          "&-active": {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${r}-leave-active`]: {
          transform: "translateY(-5px)"
        }
      }
    }
  };
}, Mte = (n) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: n.marginLG,
    padding: 0,
    color: n.colorTextDescription,
    fontSize: n.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${Mt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  "input[type='file']:focus,\n  input[type='radio']:focus,\n  input[type='checkbox']:focus": {
    outline: 0,
    boxShadow: `0 0 0 ${Mt(n.controlOutlineWidth)} ${n.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: n.colorText,
    fontSize: n.fontSize,
    lineHeight: n.lineHeight
  }
}), FL = (n, e) => {
  const {
    formItemCls: t
  } = n;
  return {
    [t]: {
      [`${t}-label > label`]: {
        height: e
      },
      [`${t}-control-input`]: {
        minHeight: e
      }
    }
  };
}, Tte = (n) => {
  const {
    componentCls: e
  } = n;
  return {
    [n.componentCls]: Object.assign(Object.assign(Object.assign({}, Vo(n)), Mte(n)), {
      [`${e}-text`]: {
        display: "inline-block",
        paddingInlineEnd: n.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": Object.assign({}, FL(n, n.controlHeightSM)),
      "&-large": Object.assign({}, FL(n, n.controlHeightLG))
    })
  };
}, Rte = (n) => {
  const {
    formItemCls: e,
    iconCls: t,
    componentCls: r,
    rootPrefixCls: i,
    antCls: a,
    labelRequiredMarkColor: o,
    labelColor: s,
    labelFontSize: u,
    labelHeight: d,
    labelColonMarginInlineStart: f,
    labelColonMarginInlineEnd: p,
    itemMarginBottom: g
  } = n;
  return {
    [e]: Object.assign(Object.assign({}, Vo(n)), {
      marginBottom: g,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden${a}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${e}-split`]: {
          color: n.colorError
        }
      },
      "&-has-error": {
        [`${e}-split`]: {
          color: n.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${e}-label`]: {
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: n.lineHeight,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: d,
          color: s,
          fontSize: u,
          [`> ${t}`]: {
            fontSize: n.fontSize,
            verticalAlign: "top"
          },
          // Required mark
          [`&${e}-required:not(${e}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: n.marginXXS,
            color: o,
            fontSize: n.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${r}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${e}-optional`]: {
            display: "inline-block",
            marginInlineStart: n.marginXXS,
            color: n.colorTextDescription,
            [`${r}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${e}-tooltip`]: {
            color: n.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: n.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: f,
            marginInlineEnd: p
          },
          [`&${e}-no-colon::after`]: {
            content: '"\\a0"'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${e}-control`]: {
        "--ant-display": "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${i}-col-'"]):not([class*="' ${i}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: n.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%",
            lineHeight: "100%"
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [e]: {
        "&-explain, &-extra": {
          clear: "both",
          color: n.colorTextDescription,
          fontSize: n.fontSize,
          lineHeight: n.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: n.controlHeightSM,
          transition: `color ${n.motionDurationMid} ${n.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: n.colorError
          },
          "&-warning": {
            color: n.colorWarning
          }
        }
      },
      [`&-with-help ${e}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${e}-feedback-icon`]: {
        fontSize: n.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: QA,
        animationDuration: n.motionDurationMid,
        animationTimingFunction: n.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: n.colorSuccess
        },
        "&-error": {
          color: n.colorError
        },
        "&-warning": {
          color: n.colorWarning
        },
        "&-validating": {
          color: n.colorPrimary
        }
      }
    })
  };
}, UL = (n, e) => {
  const {
    formItemCls: t
  } = n;
  return {
    [`${e}-horizontal`]: {
      [`${t}-label`]: {
        flexGrow: 0
      },
      [`${t}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // Do not change this to `ant-col-24`! `-24` match all the responsive rules
      // https://github.com/ant-design/ant-design/issues/32980
      // https://github.com/ant-design/ant-design/issues/34903
      // https://github.com/ant-design/ant-design/issues/44538
      [`${t}-label[class$='-24'], ${t}-label[class*='-24 ']`]: {
        [`& + ${t}-control`]: {
          minWidth: "unset"
        }
      }
    }
  };
}, Ate = (n) => {
  const {
    componentCls: e,
    formItemCls: t,
    inlineItemMarginBottom: r
  } = n;
  return {
    [`${e}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [t]: {
        flex: "none",
        marginInlineEnd: n.margin,
        marginBottom: r,
        "&-row": {
          flexWrap: "nowrap"
        },
        [`> ${t}-label,
        > ${t}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${t}-label`]: {
          flex: "none"
        },
        [`${e}-text`]: {
          display: "inline-block"
        },
        [`${t}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
}, El = (n) => ({
  padding: n.verticalLabelPadding,
  margin: n.verticalLabelMargin,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/43538
      visibility: "hidden"
    }
  }
}), wV = (n) => {
  const {
    componentCls: e,
    formItemCls: t,
    rootPrefixCls: r
  } = n;
  return {
    [`${t} ${t}-label`]: El(n),
    // ref: https://github.com/ant-design/ant-design/issues/45122
    [`${e}:not(${e}-inline)`]: {
      [t]: {
        flexWrap: "wrap",
        [`${t}-label, ${t}-control`]: {
          // When developer pass `xs: { span }`,
          // It should follow the `xs` screen config
          // ref: https://github.com/ant-design/ant-design/issues/44386
          [`&:not([class*=" ${r}-col-xs"])`]: {
            flex: "0 0 100%",
            maxWidth: "100%"
          }
        }
      }
    }
  };
}, Ote = (n) => {
  const {
    componentCls: e,
    formItemCls: t,
    antCls: r
  } = n;
  return {
    [`${e}-vertical`]: {
      [`${t}:not(${t}-horizontal)`]: {
        [`${t}-row`]: {
          flexDirection: "column"
        },
        [`${t}-label > label`]: {
          height: "auto"
        },
        [`${t}-control`]: {
          width: "100%"
        },
        [`${t}-label,
        ${r}-col-24${t}-label,
        ${r}-col-xl-24${t}-label`]: El(n)
      }
    },
    [`@media (max-width: ${Mt(n.screenXSMax)})`]: [wV(n), {
      [e]: {
        [`${t}:not(${t}-horizontal)`]: {
          [`${r}-col-xs-24${t}-label`]: El(n)
        }
      }
    }],
    [`@media (max-width: ${Mt(n.screenSMMax)})`]: {
      [e]: {
        [`${t}:not(${t}-horizontal)`]: {
          [`${r}-col-sm-24${t}-label`]: El(n)
        }
      }
    },
    [`@media (max-width: ${Mt(n.screenMDMax)})`]: {
      [e]: {
        [`${t}:not(${t}-horizontal)`]: {
          [`${r}-col-md-24${t}-label`]: El(n)
        }
      }
    },
    [`@media (max-width: ${Mt(n.screenLGMax)})`]: {
      [e]: {
        [`${t}:not(${t}-horizontal)`]: {
          [`${r}-col-lg-24${t}-label`]: El(n)
        }
      }
    }
  };
}, Pte = (n) => {
  const {
    formItemCls: e,
    antCls: t
  } = n;
  return {
    [`${e}-vertical`]: {
      [`${e}-row`]: {
        flexDirection: "column"
      },
      [`${e}-label > label`]: {
        height: "auto"
      },
      [`${e}-control`]: {
        width: "100%"
      }
    },
    [`${e}-vertical ${e}-label,
      ${t}-col-24${e}-label,
      ${t}-col-xl-24${e}-label`]: El(n),
    [`@media (max-width: ${Mt(n.screenXSMax)})`]: [wV(n), {
      [e]: {
        [`${t}-col-xs-24${e}-label`]: El(n)
      }
    }],
    [`@media (max-width: ${Mt(n.screenSMMax)})`]: {
      [e]: {
        [`${t}-col-sm-24${e}-label`]: El(n)
      }
    },
    [`@media (max-width: ${Mt(n.screenMDMax)})`]: {
      [e]: {
        [`${t}-col-md-24${e}-label`]: El(n)
      }
    },
    [`@media (max-width: ${Mt(n.screenLGMax)})`]: {
      [e]: {
        [`${t}-col-lg-24${e}-label`]: El(n)
      }
    }
  };
}, Dte = (n) => ({
  labelRequiredMarkColor: n.colorError,
  labelColor: n.colorTextHeading,
  labelFontSize: n.fontSize,
  labelHeight: n.controlHeight,
  labelColonMarginInlineStart: n.marginXXS / 2,
  labelColonMarginInlineEnd: n.marginXS,
  itemMarginBottom: n.marginLG,
  verticalLabelPadding: `0 0 ${n.paddingXS}px`,
  verticalLabelMargin: 0,
  inlineItemMarginBottom: 0
}), MV = (n, e) => li(n, {
  formItemCls: `${n.componentCls}-item`,
  rootPrefixCls: e
}), xO = $o("Form", (n, e) => {
  let {
    rootPrefixCls: t
  } = e;
  const r = MV(n, t);
  return [Tte(r), Rte(r), wte(r), UL(r, r.componentCls), UL(r, r.formItemCls), Ate(r), Ote(r), Pte(r), ZB(r), QA];
}, Dte, {
  // Let From style before the Grid
  // ref https://github.com/ant-design/ant-design/issues/44386
  order: -1e3
}), zL = [];
function dM(n, e, t) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  return {
    key: typeof n == "string" ? n : `${e}-${r}`,
    error: n,
    errorStatus: t
  };
}
const TV = (n) => {
  let {
    help: e,
    helpStatus: t,
    errors: r = zL,
    warnings: i = zL,
    className: a,
    fieldId: o,
    onVisibleChanged: s
  } = n;
  const {
    prefixCls: u
  } = O.useContext(KA), d = `${u}-item-explain`, f = _u(u), [p, g, v] = xO(u, f), b = Mr(() => CR(u), [u]), E = xx(r), S = xx(i), _ = O.useMemo(() => e != null ? [dM(e, "help", t)] : [].concat(jt(E.map((C, R) => dM(C, "error", "error", R))), jt(S.map((C, R) => dM(C, "warning", "warning", R)))), [e, t, E, S]), w = {};
  return o && (w.id = `${o}_help`), p(/* @__PURE__ */ O.createElement(Hh, {
    motionDeadline: b.motionDeadline,
    motionName: `${u}-show-help`,
    visible: !!_.length,
    onVisibleChanged: s
  }, (C) => {
    const {
      className: R,
      style: P
    } = C;
    return /* @__PURE__ */ O.createElement("div", Object.assign({}, w, {
      className: Et(d, R, v, f, a, g),
      style: P,
      role: "alert"
    }), /* @__PURE__ */ O.createElement(hX, Object.assign({
      keys: _
    }, CR(u), {
      motionName: `${u}-show-help-item`,
      component: !1
    }), (D) => {
      const {
        key: I,
        error: U,
        errorStatus: L,
        className: N,
        style: H
      } = D;
      return /* @__PURE__ */ O.createElement("div", {
        key: I,
        className: Et(N, {
          [`${d}-${L}`]: L
        }),
        style: H
      }, U);
    }));
  }));
}, Ite = ["parentNode"], Nte = "form_item";
function My(n) {
  return n === void 0 || n === !1 ? [] : Array.isArray(n) ? n : [n];
}
function RV(n, e) {
  if (!n.length)
    return;
  const t = n.join("_");
  return e ? `${e}_${t}` : Ite.includes(t) ? `${Nte}_${t}` : t;
}
function AV(n, e, t, r, i, a) {
  let o = r;
  return a !== void 0 ? o = a : t.validating ? o = "validating" : n.length ? o = "error" : e.length ? o = "warning" : (t.touched || i && t.validated) && (o = "success"), o;
}
function BL(n) {
  return My(n).join("_");
}
function Lte(n, e) {
  const t = e.getFieldInstance(n), r = ZU(t);
  if (r)
    return r;
  const i = RV(My(n), e.__INTERNAL__.name);
  if (i)
    return document.getElementById(i);
}
function OV(n) {
  const [e] = YA(), t = O.useRef({}), r = O.useMemo(() => n ?? Object.assign(Object.assign({}, e), {
    __INTERNAL__: {
      itemRef: (i) => (a) => {
        const o = BL(i);
        a ? t.current[o] = a : delete t.current[o];
      }
    },
    scrollToField: function(i) {
      let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const o = Lte(i, r);
      o && qX(o, Object.assign({
        scrollMode: "if-needed",
        block: "nearest"
      }, a));
    },
    getFieldInstance: (i) => {
      const a = BL(i);
      return t.current[a];
    }
  }), [n, e]);
  return [r];
}
const zS = {};
function Fte(n) {
  let {
    name: e
  } = n;
  const t = ci("Form");
  In(() => {
    if (e)
      return zS[e] = (zS[e] || 0) + 1, Ee.env.NODE_ENV !== "production" && t(zS[e] <= 1, "usage", "There exist multiple Form with same `name`."), () => {
        zS[e] -= 1;
      };
  }, [e]);
}
var Ute = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const zte = (n, e) => {
  const t = O.useContext(fc), {
    getPrefixCls: r,
    direction: i,
    form: a
  } = O.useContext(mr), {
    prefixCls: o,
    className: s,
    rootClassName: u,
    size: d,
    disabled: f = t,
    form: p,
    colon: g,
    labelAlign: v,
    labelWrap: b,
    labelCol: E,
    wrapperCol: S,
    hideRequiredMark: _,
    layout: w = "horizontal",
    scrollToFirstError: C,
    requiredMark: R,
    onFinishFailed: P,
    name: D,
    style: I,
    feedbackIcons: U,
    variant: L
  } = n, N = Ute(n, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name", "style", "feedbackIcons", "variant"]), H = mc(d), j = O.useContext(Vz);
  Ee.env.NODE_ENV !== "production" && Fte(n);
  const G = Mr(() => R !== void 0 ? R : _ ? !1 : a && a.requiredMark !== void 0 ? a.requiredMark : !0, [_, R, a]), X = g ?? (a == null ? void 0 : a.colon), ae = r("form", o), Z = _u(ae), [K, B, Q] = xO(ae, Z), V = Et(ae, `${ae}-${w}`, {
    [`${ae}-hide-required-mark`]: G === !1,
    [`${ae}-rtl`]: i === "rtl",
    [`${ae}-${H}`]: H
  }, Q, Z, B, a == null ? void 0 : a.className, s, u), [q] = OV(p), {
    __INTERNAL__: ne
  } = q;
  ne.name = D;
  const ce = Mr(() => ({
    name: D,
    labelAlign: v,
    labelCol: E,
    labelWrap: b,
    wrapperCol: S,
    vertical: w === "vertical",
    colon: X,
    requiredMark: G,
    itemRef: ne.itemRef,
    form: q,
    feedbackIcons: U
  }), [D, v, E, S, w, X, G, q, U]), ie = O.useRef(null);
  O.useImperativeHandle(e, () => {
    var le;
    return Object.assign(Object.assign({}, q), {
      nativeElement: (le = ie.current) === null || le === void 0 ? void 0 : le.nativeElement
    });
  });
  const oe = (le, ve) => {
    if (le) {
      let Ne = {
        block: "nearest"
      };
      typeof le == "object" && (Ne = le), q.scrollToField(ve, Ne);
    }
  }, he = (le) => {
    if (P == null || P(le), le.errorFields.length) {
      const ve = le.errorFields[0].name;
      if (C !== void 0) {
        oe(C, ve);
        return;
      }
      a && a.scrollToFirstError !== void 0 && oe(a.scrollToFirstError, ve);
    }
  };
  return K(/* @__PURE__ */ O.createElement(KB.Provider, {
    value: L
  }, /* @__PURE__ */ O.createElement(Qz, {
    disabled: f
  }, /* @__PURE__ */ O.createElement(Ah.Provider, {
    value: H
  }, /* @__PURE__ */ O.createElement(YB, {
    // This is not list in API, we pass with spread
    validateMessages: j
  }, /* @__PURE__ */ O.createElement(pu.Provider, {
    value: ce
  }, /* @__PURE__ */ O.createElement(vg, Object.assign({
    id: D
  }, N, {
    name: D,
    onFinishFailed: he,
    form: q,
    ref: ie,
    style: Object.assign(Object.assign({}, a == null ? void 0 : a.style), I),
    className: V
  }))))))));
}, PV = /* @__PURE__ */ O.forwardRef(zte);
Ee.env.NODE_ENV !== "production" && (PV.displayName = "Form");
function Bte(n) {
  if (typeof n == "function")
    return n;
  const e = dc(n);
  return e.length <= 1 ? e[0] : e;
}
const DV = () => {
  const {
    status: n,
    errors: e = [],
    warnings: t = []
  } = ni(Ya);
  if (Ee.env.NODE_ENV !== "production") {
    const r = ci("Form.Item");
    Ee.env.NODE_ENV !== "production" && r(n !== void 0, "usage", "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus");
  }
  return {
    status: n,
    errors: e,
    warnings: t
  };
};
DV.Context = Ya;
function Hte(n) {
  const [e, t] = O.useState(n), r = kt(null), i = kt([]), a = kt(!1);
  O.useEffect(() => (a.current = !1, () => {
    a.current = !0, Wr.cancel(r.current), r.current = null;
  }), []);
  function o(s) {
    a.current || (r.current === null && (i.current = [], r.current = Wr(() => {
      r.current = null, t((u) => {
        let d = u;
        return i.current.forEach((f) => {
          d = f(d);
        }), d;
      });
    })), i.current.push(s));
  }
  return [e, o];
}
function Vte() {
  const {
    itemRef: n
  } = O.useContext(pu), e = O.useRef({});
  function t(r, i) {
    const a = i && typeof i == "object" && i.ref, o = r.join("_");
    return (e.current.name !== o || e.current.originRef !== a) && (e.current.name = o, e.current.originRef = a, e.current.ref = Ol(n(r), a)), e.current.ref;
  }
  return t;
}
const kte = (n) => {
  const {
    formItemCls: e
  } = n;
  return {
    "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
      // Fallback for IE, safe to remove we not support it anymore
      [`${e}-control`]: {
        display: "flex"
      }
    }
  };
}, $te = sB(["Form", "item-item"], (n, e) => {
  let {
    rootPrefixCls: t
  } = e;
  const r = MV(n, t);
  return [kte(r)];
}), Wte = (n) => {
  const {
    prefixCls: e,
    status: t,
    wrapperCol: r,
    children: i,
    errors: a,
    warnings: o,
    _internalItemRender: s,
    extra: u,
    help: d,
    fieldId: f,
    marginBottom: p,
    onErrorVisibleChanged: g
  } = n, v = `${e}-item`, b = O.useContext(pu), E = r || b.wrapperCol || {}, S = Et(`${v}-control`, E.className), _ = O.useMemo(() => Object.assign({}, b), [b]);
  delete _.labelCol, delete _.wrapperCol;
  const w = /* @__PURE__ */ O.createElement("div", {
    className: `${v}-control-input`
  }, /* @__PURE__ */ O.createElement("div", {
    className: `${v}-control-input-content`
  }, i)), C = O.useMemo(() => ({
    prefixCls: e,
    status: t
  }), [e, t]), R = p !== null || a.length || o.length ? /* @__PURE__ */ O.createElement("div", {
    style: {
      display: "flex",
      flexWrap: "nowrap"
    }
  }, /* @__PURE__ */ O.createElement(KA.Provider, {
    value: C
  }, /* @__PURE__ */ O.createElement(TV, {
    fieldId: f,
    errors: a,
    warnings: o,
    help: d,
    helpStatus: t,
    className: `${v}-explain-connected`,
    onVisibleChanged: g
  })), !!p && /* @__PURE__ */ O.createElement("div", {
    style: {
      width: 0,
      height: p
    }
  })) : null, P = {};
  f && (P.id = `${f}_extra`);
  const D = u ? /* @__PURE__ */ O.createElement("div", Object.assign({}, P, {
    className: `${v}-extra`
  }), u) : null, I = s && s.mark === "pro_table_render" && s.render ? s.render(n, {
    input: w,
    errorList: R,
    extra: D
  }) : /* @__PURE__ */ O.createElement(O.Fragment, null, w, R, D);
  return /* @__PURE__ */ O.createElement(pu.Provider, {
    value: _
  }, /* @__PURE__ */ O.createElement(gO, Object.assign({}, E, {
    className: S
  }), I), /* @__PURE__ */ O.createElement($te, {
    prefixCls: e
  }));
};
var jte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, name: "question-circle", theme: "outlined" }, Gte = function(e, t) {
  return /* @__PURE__ */ O.createElement(Ka, gn({}, e, {
    ref: t,
    icon: jte
  }));
}, IV = /* @__PURE__ */ O.forwardRef(Gte);
Ee.env.NODE_ENV !== "production" && (IV.displayName = "QuestionCircleOutlined");
var Xte = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function qte(n) {
  return n ? typeof n == "object" && !/* @__PURE__ */ O.isValidElement(n) ? n : {
    title: n
  } : null;
}
const Yte = (n) => {
  let {
    prefixCls: e,
    label: t,
    htmlFor: r,
    labelCol: i,
    labelAlign: a,
    colon: o,
    required: s,
    requiredMark: u,
    tooltip: d,
    vertical: f
  } = n;
  var p;
  const [g] = zA("Form"), {
    labelAlign: v,
    labelCol: b,
    labelWrap: E,
    colon: S
  } = O.useContext(pu);
  if (!t)
    return null;
  const _ = i || b || {}, w = a || v, C = `${e}-item-label`, R = Et(C, w === "left" && `${C}-left`, _.className, {
    [`${C}-wrap`]: !!E
  });
  let P = t;
  const D = o === !0 || S !== !1 && o !== !1;
  D && !f && typeof t == "string" && t.trim() && (P = t.replace(/[:|]\s*$/, ""));
  const U = qte(d);
  if (U) {
    const {
      icon: j = /* @__PURE__ */ O.createElement(IV, null)
    } = U, G = Xte(U, ["icon"]), X = /* @__PURE__ */ O.createElement(M0, Object.assign({}, G), /* @__PURE__ */ O.cloneElement(j, {
      className: `${e}-item-tooltip`,
      title: "",
      onClick: (ae) => {
        ae.preventDefault();
      },
      tabIndex: null
    }));
    P = /* @__PURE__ */ O.createElement(O.Fragment, null, P, X);
  }
  const L = u === "optional", N = typeof u == "function";
  N ? P = u(P, {
    required: !!s
  }) : L && !s && (P = /* @__PURE__ */ O.createElement(O.Fragment, null, P, /* @__PURE__ */ O.createElement("span", {
    className: `${e}-item-optional`,
    title: ""
  }, (g == null ? void 0 : g.optional) || ((p = Rh.Form) === null || p === void 0 ? void 0 : p.optional))));
  const H = Et({
    [`${e}-item-required`]: s,
    [`${e}-item-required-mark-optional`]: L || N,
    [`${e}-item-no-colon`]: !D
  });
  return /* @__PURE__ */ O.createElement(gO, Object.assign({}, _, {
    className: R
  }), /* @__PURE__ */ O.createElement("label", {
    htmlFor: r,
    className: H,
    title: typeof t == "string" ? t : ""
  }, P));
}, Kte = {
  success: CB,
  warning: MB,
  error: SE,
  validating: _E
};
function NV(n) {
  let {
    children: e,
    errors: t,
    warnings: r,
    hasFeedback: i,
    validateStatus: a,
    prefixCls: o,
    meta: s,
    noStyle: u
  } = n;
  const d = `${o}-item`, {
    feedbackIcons: f
  } = O.useContext(pu), p = AV(t, r, s, null, !!i, a), {
    isFormItemInput: g,
    status: v,
    hasFeedback: b,
    feedbackIcon: E
  } = O.useContext(Ya), S = O.useMemo(() => {
    var _;
    let w;
    if (i) {
      const R = i !== !0 && i.icons || f, P = p && ((_ = R == null ? void 0 : R({
        status: p,
        errors: t,
        warnings: r
      })) === null || _ === void 0 ? void 0 : _[p]), D = p && Kte[p];
      w = P !== !1 && D ? /* @__PURE__ */ O.createElement("span", {
        className: Et(`${d}-feedback-icon`, `${d}-feedback-icon-${p}`)
      }, P || /* @__PURE__ */ O.createElement(D, null)) : null;
    }
    const C = {
      status: p || "",
      errors: t,
      warnings: r,
      hasFeedback: !!i,
      feedbackIcon: w,
      isFormItemInput: !0
    };
    return u && (C.status = (p ?? v) || "", C.isFormItemInput = g, C.hasFeedback = !!(i ?? b), C.feedbackIcon = i !== void 0 ? C.feedbackIcon : E), C;
  }, [p, i, u, g, v]);
  return /* @__PURE__ */ O.createElement(Ya.Provider, {
    value: S
  }, e);
}
var Zte = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
function Qte(n) {
  const {
    prefixCls: e,
    className: t,
    rootClassName: r,
    style: i,
    help: a,
    errors: o,
    warnings: s,
    validateStatus: u,
    meta: d,
    hasFeedback: f,
    hidden: p,
    children: g,
    fieldId: v,
    required: b,
    isRequired: E,
    onSubItemMetaChange: S,
    layout: _
  } = n, w = Zte(n, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "required", "isRequired", "onSubItemMetaChange", "layout"]), C = `${e}-item`, {
    requiredMark: R,
    vertical: P
  } = O.useContext(pu), D = P || _ === "vertical", I = O.useRef(null), U = xx(o), L = xx(s), N = a != null, H = !!(N || o.length || s.length), j = !!I.current && $A(I.current), [G, X] = O.useState(null);
  ti(() => {
    if (H && I.current) {
      const Q = getComputedStyle(I.current);
      X(parseInt(Q.marginBottom, 10));
    }
  }, [H, j]);
  const ae = (Q) => {
    Q || X(null);
  }, K = function() {
    let Q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const V = Q ? U : d.errors, q = Q ? L : d.warnings;
    return AV(V, q, d, "", !!f, u);
  }(), B = Et(C, t, r, {
    [`${C}-with-help`]: N || U.length || L.length,
    // Status
    [`${C}-has-feedback`]: K && f,
    [`${C}-has-success`]: K === "success",
    [`${C}-has-warning`]: K === "warning",
    [`${C}-has-error`]: K === "error",
    [`${C}-is-validating`]: K === "validating",
    [`${C}-hidden`]: p,
    // Layout
    [`${C}-${_}`]: _
  });
  return /* @__PURE__ */ O.createElement("div", {
    className: B,
    style: i,
    ref: I
  }, /* @__PURE__ */ O.createElement(ZH, Object.assign({
    className: `${C}-row`
  }, du(w, [
    "_internalItemRender",
    "colon",
    "dependencies",
    "extra",
    "fieldKey",
    "getValueFromEvent",
    "getValueProps",
    "htmlFor",
    "id",
    // It is deprecated because `htmlFor` is its replacement.
    "initialValue",
    "isListField",
    "label",
    "labelAlign",
    "labelCol",
    "labelWrap",
    "messageVariables",
    "name",
    "normalize",
    "noStyle",
    "preserve",
    "requiredMark",
    "rules",
    "shouldUpdate",
    "trigger",
    "tooltip",
    "validateFirst",
    "validateTrigger",
    "valuePropName",
    "wrapperCol",
    "validateDebounce"
  ])), /* @__PURE__ */ O.createElement(Yte, Object.assign({
    htmlFor: v
  }, n, {
    requiredMark: R,
    required: b ?? E,
    prefixCls: e,
    vertical: D
  })), /* @__PURE__ */ O.createElement(Wte, Object.assign({}, n, d, {
    errors: U,
    warnings: L,
    prefixCls: e,
    status: K,
    help: a,
    marginBottom: G,
    onErrorVisibleChanged: ae
  }), /* @__PURE__ */ O.createElement(qB.Provider, {
    value: S
  }, /* @__PURE__ */ O.createElement(NV, {
    prefixCls: e,
    meta: d,
    errors: d.errors,
    warnings: d.warnings,
    hasFeedback: f,
    // Already calculated
    validateStatus: K
  }, g)))), !!G && /* @__PURE__ */ O.createElement("div", {
    className: `${C}-margin-offset`,
    style: {
      marginBottom: -G
    }
  }));
}
const Jte = "__SPLIT__";
function ene(n, e) {
  const t = Object.keys(n), r = Object.keys(e);
  return t.length === r.length && t.every((i) => {
    const a = n[i], o = e[i];
    return a === o || typeof a == "function" || typeof o == "function";
  });
}
const tne = /* @__PURE__ */ O.memo((n) => {
  let {
    children: e
  } = n;
  return e;
}, (n, e) => ene(n.control, e.control) && n.update === e.update && n.childProps.length === e.childProps.length && n.childProps.every((t, r) => t === e.childProps[r]));
function HL() {
  return {
    errors: [],
    warnings: [],
    touched: !1,
    validating: !1,
    name: [],
    validated: !1
  };
}
function nne(n) {
  const {
    name: e,
    noStyle: t,
    className: r,
    dependencies: i,
    prefixCls: a,
    shouldUpdate: o,
    rules: s,
    children: u,
    required: d,
    label: f,
    messageVariables: p,
    trigger: g = "onChange",
    validateTrigger: v,
    hidden: b,
    help: E,
    layout: S
  } = n, {
    getPrefixCls: _
  } = O.useContext(mr), {
    name: w
  } = O.useContext(pu), C = Bte(u), R = typeof C == "function", P = O.useContext(qB), {
    validateTrigger: D
  } = O.useContext(Oh), I = v !== void 0 ? v : D, U = e != null, L = _("form", a), N = _u(L), [H, j, G] = xO(L, N), X = ci("Form.Item");
  Ee.env.NODE_ENV !== "production" && Ee.env.NODE_ENV !== "production" && X(e !== null, "usage", "`null` is passed as `name` property");
  const ae = O.useContext(qy), Z = O.useRef(), [K, B] = Hte({}), [Q, V] = tg(() => HL()), q = (ve) => {
    const Ne = ae == null ? void 0 : ae.getKey(ve.name);
    if (V(ve.destroy ? HL() : ve, !0), t && E !== !1 && P) {
      let xe = ve.name;
      if (ve.destroy)
        xe = Z.current || xe;
      else if (Ne !== void 0) {
        const [Me, $] = Ne;
        xe = [Me].concat(jt($)), Z.current = xe;
      }
      P(ve, xe);
    }
  }, ne = (ve, Ne) => {
    B((xe) => {
      const Me = Object.assign({}, xe), Te = [].concat(jt(ve.name.slice(0, -1)), jt(Ne)).join(Jte);
      return ve.destroy ? delete Me[Te] : Me[Te] = ve, Me;
    });
  }, [ce, ie] = O.useMemo(() => {
    const ve = jt(Q.errors), Ne = jt(Q.warnings);
    return Object.values(K).forEach((xe) => {
      ve.push.apply(ve, jt(xe.errors || [])), Ne.push.apply(Ne, jt(xe.warnings || []));
    }), [ve, Ne];
  }, [K, Q.errors, Q.warnings]), oe = Vte();
  function he(ve, Ne, xe) {
    return t && !b ? /* @__PURE__ */ O.createElement(NV, {
      prefixCls: L,
      hasFeedback: n.hasFeedback,
      validateStatus: n.validateStatus,
      meta: Q,
      errors: ce,
      warnings: ie,
      noStyle: !0
    }, ve) : /* @__PURE__ */ O.createElement(Qte, Object.assign({
      key: "row"
    }, n, {
      className: Et(r, G, N, j),
      prefixCls: L,
      fieldId: Ne,
      isRequired: xe,
      errors: ce,
      warnings: ie,
      meta: Q,
      onSubItemMetaChange: ne,
      layout: S
    }), ve);
  }
  if (!U && !R && !i)
    return H(he(C));
  let le = {};
  return typeof f == "string" ? le.label = f : e && (le.label = String(e)), p && (le = Object.assign(Object.assign({}, le), p)), H(/* @__PURE__ */ O.createElement(qA, Object.assign({}, n, {
    messageVariables: le,
    trigger: g,
    validateTrigger: I,
    onMetaChange: q
  }), (ve, Ne, xe) => {
    const Me = My(e).length && Ne ? Ne.name : [], $ = RV(Me, w), Te = d !== void 0 ? d : !!(s != null && s.some((be) => {
      if (be && typeof be == "object" && be.required && !be.warningOnly)
        return !0;
      if (typeof be == "function") {
        const et = be(xe);
        return (et == null ? void 0 : et.required) && !(et != null && et.warningOnly);
      }
      return !1;
    })), se = Object.assign({}, ve);
    let Ie = null;
    if (Ee.env.NODE_ENV !== "production" && X(!(o && i), "usage", "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps."), Array.isArray(C) && U)
      Ee.env.NODE_ENV !== "production" && X(!1, "usage", "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item."), Ie = C;
    else if (R && (!(o || i) || U))
      Ee.env.NODE_ENV !== "production" && X(!!(o || i), "usage", "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`."), Ee.env.NODE_ENV !== "production" && X(!U, "usage", "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop.");
    else if (i && !R && !U)
      Ee.env.NODE_ENV !== "production" && X(!1, "usage", "Must set `name` or use a render function when `dependencies` is set.");
    else if (/* @__PURE__ */ O.isValidElement(C)) {
      Ee.env.NODE_ENV !== "production" && X(C.props.defaultValue === void 0, "usage", "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead.");
      const be = Object.assign(Object.assign({}, C.props), se);
      if (be.id || (be.id = $), E || ce.length > 0 || ie.length > 0 || n.extra) {
        const $e = [];
        (E || ce.length > 0) && $e.push(`${$}_help`), n.extra && $e.push(`${$}_extra`), be["aria-describedby"] = $e.join(" ");
      }
      ce.length > 0 && (be["aria-invalid"] = "true"), Te && (be["aria-required"] = "true"), pg(C) && (be.ref = oe(Me, C)), new Set([].concat(jt(My(g)), jt(My(I)))).forEach(($e) => {
        be[$e] = function() {
          for (var te, Y, Se, Oe, Pe, Ve = arguments.length, Ze = new Array(Ve), nt = 0; nt < Ve; nt++)
            Ze[nt] = arguments[nt];
          (Se = se[$e]) === null || Se === void 0 || (te = Se).call.apply(te, [se].concat(Ze)), (Pe = (Oe = C.props)[$e]) === null || Pe === void 0 || (Y = Pe).call.apply(Y, [Oe].concat(Ze));
        };
      });
      const Xe = [be["aria-required"], be["aria-invalid"], be["aria-describedby"]];
      Ie = /* @__PURE__ */ O.createElement(tne, {
        control: se,
        update: C,
        childProps: Xe
      }, fu(C, be));
    } else R && (o || i) && !U ? Ie = C(xe) : (Ee.env.NODE_ENV !== "production" && X(!Me.length || !!t, "usage", "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead."), Ie = C);
    return he(Ie, $, Te);
  }));
}
const LV = nne;
LV.useStatus = DV;
var rne = function(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
    e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
};
const ine = (n) => {
  var {
    prefixCls: e,
    children: t
  } = n, r = rne(n, ["prefixCls", "children"]);
  if (Ee.env.NODE_ENV !== "production") {
    const s = ci("Form.List");
    Ee.env.NODE_ENV !== "production" && s(typeof r.name == "number" || (Array.isArray(r.name) ? !!r.name.length : !!r.name), "usage", "Miss `name` prop.");
  }
  const {
    getPrefixCls: i
  } = O.useContext(mr), a = i("form", e), o = O.useMemo(() => ({
    prefixCls: a,
    status: "error"
  }), [a]);
  return /* @__PURE__ */ O.createElement(WB, Object.assign({}, r), (s, u, d) => /* @__PURE__ */ O.createElement(KA.Provider, {
    value: o
  }, t(s.map((f) => Object.assign(Object.assign({}, f), {
    fieldKey: f.key
  })), u, {
    errors: d.errors,
    warnings: d.warnings
  })));
};
function ane() {
  const {
    form: n
  } = ni(pu);
  return n;
}
const ms = PV;
ms.Item = LV;
ms.List = ine;
ms.ErrorList = TV;
ms.useForm = OV;
ms.useFormInstance = ane;
ms.useWatch = XB;
ms.Provider = YB;
ms.create = () => {
  Ee.env.NODE_ENV !== "production" && Bh(!1, "Form", "antd v4 removed `Form.create`. Please remove or use `@ant-design/compatible` instead.");
};
var Bo = function() {
  return Bo = Object.assign || function(e) {
    for (var t, r = 1, i = arguments.length; r < i; r++) {
      t = arguments[r];
      for (var a in t) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
    }
    return e;
  }, Bo.apply(this, arguments);
};
function ig(n, e, t) {
  if (t || arguments.length === 2) for (var r = 0, i = e.length, a; r < i; r++)
    (a || !(r in e)) && (a || (a = Array.prototype.slice.call(e, 0, r)), a[r] = e[r]);
  return n.concat(a || Array.prototype.slice.call(e));
}
function one(n) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(t) {
    return e[t] === void 0 && (e[t] = n(t)), e[t];
  };
}
var sne = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, lne = /* @__PURE__ */ one(
  function(n) {
    return sne.test(n) || n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) < 91;
  }
  /* Z+1 */
), cne = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Dh = typeof Ee < "u" && Ee.env !== void 0 && (Ee.env.REACT_APP_SC_ATTR || Ee.env.SC_ATTR) || "data-styled", FV = "active", UV = "data-styled-version", AE = "6.1.12", EO = `/*!sc*/
`, Ex = typeof window < "u" && "HTMLElement" in window, une = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof Ee < "u" && Ee.env !== void 0 && Ee.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && Ee.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? Ee.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && Ee.env.REACT_APP_SC_DISABLE_SPEEDY : typeof Ee < "u" && Ee.env !== void 0 && Ee.env.SC_DISABLE_SPEEDY !== void 0 && Ee.env.SC_DISABLE_SPEEDY !== "" ? Ee.env.SC_DISABLE_SPEEDY !== "false" && Ee.env.SC_DISABLE_SPEEDY : Ee.env.NODE_ENV !== "production"), VL = /invalid hook call/i, BS = /* @__PURE__ */ new Set(), dne = function(n, e) {
  if (Ee.env.NODE_ENV !== "production") {
    var t = e ? ' with the id of "'.concat(e, '"') : "", r = "The component ".concat(n).concat(t, ` has been created dynamically.
`) + `You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, i = console.error;
    try {
      var a = !0;
      console.error = function(o) {
        for (var s = [], u = 1; u < arguments.length; u++) s[u - 1] = arguments[u];
        VL.test(o) ? (a = !1, BS.delete(r)) : i.apply(void 0, ig([o], s, !1));
      }, kt(), a && !BS.has(r) && (console.warn(r), BS.add(r));
    } catch (o) {
      VL.test(o.message) && BS.delete(r);
    } finally {
      console.error = i;
    }
  }
}, OE = Object.freeze([]), ag = Object.freeze({});
function fne(n, e, t) {
  return t === void 0 && (t = ag), n.theme !== t.theme && n.theme || e || t.theme;
}
var $R = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), hne = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, pne = /(^-|-$)/g;
function kL(n) {
  return n.replace(hne, "-").replace(pne, "");
}
var mne = /(a)(d)/gi, HS = 52, $L = function(n) {
  return String.fromCharCode(n + (n > 25 ? 39 : 97));
};
function WR(n) {
  var e, t = "";
  for (e = Math.abs(n); e > HS; e = e / HS | 0) t = $L(e % HS) + t;
  return ($L(e % HS) + t).replace(mne, "$1-$2");
}
var fM, zV = 5381, ih = function(n, e) {
  for (var t = e.length; t; ) n = 33 * n ^ e.charCodeAt(--t);
  return n;
}, BV = function(n) {
  return ih(zV, n);
};
function gne(n) {
  return WR(BV(n) >>> 0);
}
function HV(n) {
  return Ee.env.NODE_ENV !== "production" && typeof n == "string" && n || n.displayName || n.name || "Component";
}
function hM(n) {
  return typeof n == "string" && (Ee.env.NODE_ENV === "production" || n.charAt(0) === n.charAt(0).toLowerCase());
}
var VV = typeof Symbol == "function" && Symbol.for, kV = VV ? Symbol.for("react.memo") : 60115, vne = VV ? Symbol.for("react.forward_ref") : 60112, yne = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, bne = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, $V = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, Sne = ((fM = {})[vne] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, fM[kV] = $V, fM);
function WL(n) {
  return ("type" in (e = n) && e.type.$$typeof) === kV ? $V : "$$typeof" in n ? Sne[n.$$typeof] : yne;
  var e;
}
var _ne = Object.defineProperty, xne = Object.getOwnPropertyNames, jL = Object.getOwnPropertySymbols, Ene = Object.getOwnPropertyDescriptor, Cne = Object.getPrototypeOf, GL = Object.prototype;
function WV(n, e, t) {
  if (typeof e != "string") {
    if (GL) {
      var r = Cne(e);
      r && r !== GL && WV(n, r, t);
    }
    var i = xne(e);
    jL && (i = i.concat(jL(e)));
    for (var a = WL(n), o = WL(e), s = 0; s < i.length; ++s) {
      var u = i[s];
      if (!(u in bne || t && t[u] || o && u in o || a && u in a)) {
        var d = Ene(e, u);
        try {
          _ne(n, u, d);
        } catch {
        }
      }
    }
  }
  return n;
}
function og(n) {
  return typeof n == "function";
}
function CO(n) {
  return typeof n == "object" && "styledComponentId" in n;
}
function uh(n, e) {
  return n && e ? "".concat(n, " ").concat(e) : n || e || "";
}
function XL(n, e) {
  if (n.length === 0) return "";
  for (var t = n[0], r = 1; r < n.length; r++) t += n[r];
  return t;
}
function sg(n) {
  return n !== null && typeof n == "object" && n.constructor.name === Object.name && !("props" in n && n.$$typeof);
}
function jR(n, e, t) {
  if (t === void 0 && (t = !1), !t && !sg(n) && !Array.isArray(n)) return e;
  if (Array.isArray(e)) for (var r = 0; r < e.length; r++) n[r] = jR(n[r], e[r]);
  else if (sg(e)) for (var r in e) n[r] = jR(n[r], e[r]);
  return n;
}
function wO(n, e) {
  Object.defineProperty(n, "toString", { value: e });
}
var wne = Ee.env.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
`, 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function Mne() {
  for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
  for (var t = n[0], r = [], i = 1, a = n.length; i < a; i += 1) r.push(n[i]);
  return r.forEach(function(o) {
    t = t.replace(/%[a-z]/, o);
  }), t;
}
function bg(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  return Ee.env.NODE_ENV === "production" ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(n, " for more information.").concat(e.length > 0 ? " Args: ".concat(e.join(", ")) : "")) : new Error(Mne.apply(void 0, ig([wne[n]], e, !1)).trim());
}
var Tne = function() {
  function n(e) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e;
  }
  return n.prototype.indexOfGroup = function(e) {
    for (var t = 0, r = 0; r < e; r++) t += this.groupSizes[r];
    return t;
  }, n.prototype.insertRules = function(e, t) {
    if (e >= this.groupSizes.length) {
      for (var r = this.groupSizes, i = r.length, a = i; e >= a; ) if ((a <<= 1) < 0) throw bg(16, "".concat(e));
      this.groupSizes = new Uint32Array(a), this.groupSizes.set(r), this.length = a;
      for (var o = i; o < a; o++) this.groupSizes[o] = 0;
    }
    for (var s = this.indexOfGroup(e + 1), u = (o = 0, t.length); o < u; o++) this.tag.insertRule(s, t[o]) && (this.groupSizes[e]++, s++);
  }, n.prototype.clearGroup = function(e) {
    if (e < this.length) {
      var t = this.groupSizes[e], r = this.indexOfGroup(e), i = r + t;
      this.groupSizes[e] = 0;
      for (var a = r; a < i; a++) this.tag.deleteRule(r);
    }
  }, n.prototype.getGroup = function(e) {
    var t = "";
    if (e >= this.length || this.groupSizes[e] === 0) return t;
    for (var r = this.groupSizes[e], i = this.indexOfGroup(e), a = i + r, o = i; o < a; o++) t += "".concat(this.tag.getRule(o)).concat(EO);
    return t;
  }, n;
}(), Rne = 1 << 30, tx = /* @__PURE__ */ new Map(), Cx = /* @__PURE__ */ new Map(), nx = 1, VS = function(n) {
  if (tx.has(n)) return tx.get(n);
  for (; Cx.has(nx); ) nx++;
  var e = nx++;
  if (Ee.env.NODE_ENV !== "production" && ((0 | e) < 0 || e > Rne)) throw bg(16, "".concat(e));
  return tx.set(n, e), Cx.set(e, n), e;
}, Ane = function(n, e) {
  nx = e + 1, tx.set(n, e), Cx.set(e, n);
}, One = "style[".concat(Dh, "][").concat(UV, '="').concat(AE, '"]'), Pne = new RegExp("^".concat(Dh, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), Dne = function(n, e, t) {
  for (var r, i = t.split(","), a = 0, o = i.length; a < o; a++) (r = i[a]) && n.registerName(e, r);
}, Ine = function(n, e) {
  for (var t, r = ((t = e.textContent) !== null && t !== void 0 ? t : "").split(EO), i = [], a = 0, o = r.length; a < o; a++) {
    var s = r[a].trim();
    if (s) {
      var u = s.match(Pne);
      if (u) {
        var d = 0 | parseInt(u[1], 10), f = u[2];
        d !== 0 && (Ane(f, d), Dne(n, f, u[3]), n.getTag().insertRules(d, i)), i.length = 0;
      } else i.push(s);
    }
  }
}, qL = function(n) {
  for (var e = document.querySelectorAll(One), t = 0, r = e.length; t < r; t++) {
    var i = e[t];
    i && i.getAttribute(Dh) !== FV && (Ine(n, i), i.parentNode && i.parentNode.removeChild(i));
  }
};
function Nne() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var jV = function(n) {
  var e = document.head, t = n || e, r = document.createElement("style"), i = function(s) {
    var u = Array.from(s.querySelectorAll("style[".concat(Dh, "]")));
    return u[u.length - 1];
  }(t), a = i !== void 0 ? i.nextSibling : null;
  r.setAttribute(Dh, FV), r.setAttribute(UV, AE);
  var o = Nne();
  return o && r.setAttribute("nonce", o), t.insertBefore(r, a), r;
}, Lne = function() {
  function n(e) {
    this.element = jV(e), this.element.appendChild(document.createTextNode("")), this.sheet = function(t) {
      if (t.sheet) return t.sheet;
      for (var r = document.styleSheets, i = 0, a = r.length; i < a; i++) {
        var o = r[i];
        if (o.ownerNode === t) return o;
      }
      throw bg(17);
    }(this.element), this.length = 0;
  }
  return n.prototype.insertRule = function(e, t) {
    try {
      return this.sheet.insertRule(t, e), this.length++, !0;
    } catch {
      return !1;
    }
  }, n.prototype.deleteRule = function(e) {
    this.sheet.deleteRule(e), this.length--;
  }, n.prototype.getRule = function(e) {
    var t = this.sheet.cssRules[e];
    return t && t.cssText ? t.cssText : "";
  }, n;
}(), Fne = function() {
  function n(e) {
    this.element = jV(e), this.nodes = this.element.childNodes, this.length = 0;
  }
  return n.prototype.insertRule = function(e, t) {
    if (e <= this.length && e >= 0) {
      var r = document.createTextNode(t);
      return this.element.insertBefore(r, this.nodes[e] || null), this.length++, !0;
    }
    return !1;
  }, n.prototype.deleteRule = function(e) {
    this.element.removeChild(this.nodes[e]), this.length--;
  }, n.prototype.getRule = function(e) {
    return e < this.length ? this.nodes[e].textContent : "";
  }, n;
}(), Une = function() {
  function n(e) {
    this.rules = [], this.length = 0;
  }
  return n.prototype.insertRule = function(e, t) {
    return e <= this.length && (this.rules.splice(e, 0, t), this.length++, !0);
  }, n.prototype.deleteRule = function(e) {
    this.rules.splice(e, 1), this.length--;
  }, n.prototype.getRule = function(e) {
    return e < this.length ? this.rules[e] : "";
  }, n;
}(), YL = Ex, zne = { isServer: !Ex, useCSSOMInjection: !une }, GV = function() {
  function n(e, t, r) {
    e === void 0 && (e = ag), t === void 0 && (t = {});
    var i = this;
    this.options = Bo(Bo({}, zne), e), this.gs = t, this.names = new Map(r), this.server = !!e.isServer, !this.server && Ex && YL && (YL = !1, qL(this)), wO(this, function() {
      return function(a) {
        for (var o = a.getTag(), s = o.length, u = "", d = function(p) {
          var g = function(_) {
            return Cx.get(_);
          }(p);
          if (g === void 0) return "continue";
          var v = a.names.get(g), b = o.getGroup(p);
          if (v === void 0 || !v.size || b.length === 0) return "continue";
          var E = "".concat(Dh, ".g").concat(p, '[id="').concat(g, '"]'), S = "";
          v !== void 0 && v.forEach(function(_) {
            _.length > 0 && (S += "".concat(_, ","));
          }), u += "".concat(b).concat(E, '{content:"').concat(S, '"}').concat(EO);
        }, f = 0; f < s; f++) d(f);
        return u;
      }(i);
    });
  }
  return n.registerId = function(e) {
    return VS(e);
  }, n.prototype.rehydrate = function() {
    !this.server && Ex && qL(this);
  }, n.prototype.reconstructWithOptions = function(e, t) {
    return t === void 0 && (t = !0), new n(Bo(Bo({}, this.options), e), this.gs, t && this.names || void 0);
  }, n.prototype.allocateGSInstance = function(e) {
    return this.gs[e] = (this.gs[e] || 0) + 1;
  }, n.prototype.getTag = function() {
    return this.tag || (this.tag = (e = function(t) {
      var r = t.useCSSOMInjection, i = t.target;
      return t.isServer ? new Une(i) : r ? new Lne(i) : new Fne(i);
    }(this.options), new Tne(e)));
    var e;
  }, n.prototype.hasNameForId = function(e, t) {
    return this.names.has(e) && this.names.get(e).has(t);
  }, n.prototype.registerName = function(e, t) {
    if (VS(e), this.names.has(e)) this.names.get(e).add(t);
    else {
      var r = /* @__PURE__ */ new Set();
      r.add(t), this.names.set(e, r);
    }
  }, n.prototype.insertRules = function(e, t, r) {
    this.registerName(e, t), this.getTag().insertRules(VS(e), r);
  }, n.prototype.clearNames = function(e) {
    this.names.has(e) && this.names.get(e).clear();
  }, n.prototype.clearRules = function(e) {
    this.getTag().clearGroup(VS(e)), this.clearNames(e);
  }, n.prototype.clearTag = function() {
    this.tag = void 0;
  }, n;
}(), Bne = /&/g, Hne = /^\s*\/\/.*$/gm;
function XV(n, e) {
  return n.map(function(t) {
    return t.type === "rule" && (t.value = "".concat(e, " ").concat(t.value), t.value = t.value.replaceAll(",", ",".concat(e, " ")), t.props = t.props.map(function(r) {
      return "".concat(e, " ").concat(r);
    })), Array.isArray(t.children) && t.type !== "@keyframes" && (t.children = XV(t.children, e)), t;
  });
}
function Vne(n) {
  var e, t, r, i = ag, a = i.options, o = a === void 0 ? ag : a, s = i.plugins, u = s === void 0 ? OE : s, d = function(g, v, b) {
    return b.startsWith(t) && b.endsWith(t) && b.replaceAll(t, "").length > 0 ? ".".concat(e) : g;
  }, f = u.slice();
  f.push(function(g) {
    g.type === gE && g.value.includes("&") && (g.props[0] = g.props[0].replace(Bne, t).replace(r, d));
  }), o.prefix && f.push(T9), f.push(Rz);
  var p = function(g, v, b, E) {
    v === void 0 && (v = ""), b === void 0 && (b = ""), E === void 0 && (E = "&"), e = E, t = v, r = new RegExp("\\".concat(t, "\\b"), "g");
    var S = g.replace(Hne, ""), _ = Mz(b || v ? "".concat(b, " ").concat(v, " { ").concat(S, " }") : S);
    o.namespace && (_ = XV(_, o.namespace));
    var w = [];
    return $y(_, w9(f.concat(M9(function(C) {
      return w.push(C);
    })))), w;
  };
  return p.hash = u.length ? u.reduce(function(g, v) {
    return v.name || bg(15), ih(g, v.name);
  }, zV).toString() : "", p;
}
var kne = new GV(), GR = Vne(), qV = Fe.createContext({ shouldForwardProp: void 0, styleSheet: kne, stylis: GR });
qV.Consumer;
Fe.createContext(void 0);
function KL() {
  return ni(qV);
}
var ZL = function() {
  function n(e, t) {
    var r = this;
    this.inject = function(i, a) {
      a === void 0 && (a = GR);
      var o = r.name + a.hash;
      i.hasNameForId(r.id, o) || i.insertRules(r.id, o, a(r.rules, o, "@keyframes"));
    }, this.name = e, this.id = "sc-keyframes-".concat(e), this.rules = t, wO(this, function() {
      throw bg(12, String(r.name));
    });
  }
  return n.prototype.getName = function(e) {
    return e === void 0 && (e = GR), this.name + e.hash;
  }, n;
}(), $ne = function(n) {
  return n >= "A" && n <= "Z";
};
function QL(n) {
  for (var e = "", t = 0; t < n.length; t++) {
    var r = n[t];
    if (t === 1 && r === "-" && n[0] === "-") return n;
    $ne(r) ? e += "-" + r.toLowerCase() : e += r;
  }
  return e.startsWith("ms-") ? "-" + e : e;
}
var YV = function(n) {
  return n == null || n === !1 || n === "";
}, KV = function(n) {
  var e, t, r = [];
  for (var i in n) {
    var a = n[i];
    n.hasOwnProperty(i) && !YV(a) && (Array.isArray(a) && a.isCss || og(a) ? r.push("".concat(QL(i), ":"), a, ";") : sg(a) ? r.push.apply(r, ig(ig(["".concat(i, " {")], KV(a), !1), ["}"], !1)) : r.push("".concat(QL(i), ": ").concat((e = i, (t = a) == null || typeof t == "boolean" || t === "" ? "" : typeof t != "number" || t === 0 || e in cne || e.startsWith("--") ? String(t).trim() : "".concat(t, "px")), ";")));
  }
  return r;
};
function Sh(n, e, t, r) {
  if (YV(n)) return [];
  if (CO(n)) return [".".concat(n.styledComponentId)];
  if (og(n)) {
    if (!og(a = n) || a.prototype && a.prototype.isReactComponent || !e) return [n];
    var i = n(e);
    return Ee.env.NODE_ENV === "production" || typeof i != "object" || Array.isArray(i) || i instanceof ZL || sg(i) || i === null || console.error("".concat(HV(n), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Sh(i, e, t, r);
  }
  var a;
  return n instanceof ZL ? t ? (n.inject(t, r), [n.getName(r)]) : [n] : sg(n) ? KV(n) : Array.isArray(n) ? Array.prototype.concat.apply(OE, n.map(function(o) {
    return Sh(o, e, t, r);
  })) : [n.toString()];
}
function Wne(n) {
  for (var e = 0; e < n.length; e += 1) {
    var t = n[e];
    if (og(t) && !CO(t)) return !1;
  }
  return !0;
}
var jne = BV(AE), Gne = function() {
  function n(e, t, r) {
    this.rules = e, this.staticRulesId = "", this.isStatic = Ee.env.NODE_ENV === "production" && (r === void 0 || r.isStatic) && Wne(e), this.componentId = t, this.baseHash = ih(jne, t), this.baseStyle = r, GV.registerId(t);
  }
  return n.prototype.generateAndInjectStyles = function(e, t, r) {
    var i = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e, t, r) : "";
    if (this.isStatic && !r.hash) if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId)) i = uh(i, this.staticRulesId);
    else {
      var a = XL(Sh(this.rules, e, t, r)), o = WR(ih(this.baseHash, a) >>> 0);
      if (!t.hasNameForId(this.componentId, o)) {
        var s = r(a, ".".concat(o), void 0, this.componentId);
        t.insertRules(this.componentId, o, s);
      }
      i = uh(i, o), this.staticRulesId = o;
    }
    else {
      for (var u = ih(this.baseHash, r.hash), d = "", f = 0; f < this.rules.length; f++) {
        var p = this.rules[f];
        if (typeof p == "string") d += p, Ee.env.NODE_ENV !== "production" && (u = ih(u, p));
        else if (p) {
          var g = XL(Sh(p, e, t, r));
          u = ih(u, g + f), d += g;
        }
      }
      if (d) {
        var v = WR(u >>> 0);
        t.hasNameForId(this.componentId, v) || t.insertRules(this.componentId, v, r(d, ".".concat(v), void 0, this.componentId)), i = uh(i, v);
      }
    }
    return i;
  }, n;
}(), ZV = Fe.createContext(void 0);
ZV.Consumer;
var pM = {}, JL = /* @__PURE__ */ new Set();
function Xne(n, e, t) {
  var r = CO(n), i = n, a = !hM(n), o = e.attrs, s = o === void 0 ? OE : o, u = e.componentId, d = u === void 0 ? function(R, P) {
    var D = typeof R != "string" ? "sc" : kL(R);
    pM[D] = (pM[D] || 0) + 1;
    var I = "".concat(D, "-").concat(gne(AE + D + pM[D]));
    return P ? "".concat(P, "-").concat(I) : I;
  }(e.displayName, e.parentComponentId) : u, f = e.displayName, p = f === void 0 ? function(R) {
    return hM(R) ? "styled.".concat(R) : "Styled(".concat(HV(R), ")");
  }(n) : f, g = e.displayName && e.componentId ? "".concat(kL(e.displayName), "-").concat(e.componentId) : e.componentId || d, v = r && i.attrs ? i.attrs.concat(s).filter(Boolean) : s, b = e.shouldForwardProp;
  if (r && i.shouldForwardProp) {
    var E = i.shouldForwardProp;
    if (e.shouldForwardProp) {
      var S = e.shouldForwardProp;
      b = function(R, P) {
        return E(R, P) && S(R, P);
      };
    } else b = E;
  }
  var _ = new Gne(t, g, r ? i.componentStyle : void 0);
  function w(R, P) {
    return function(D, I, U) {
      var L = D.attrs, N = D.componentStyle, H = D.defaultProps, j = D.foldedComponentIds, G = D.styledComponentId, X = D.target, ae = Fe.useContext(ZV), Z = KL(), K = D.shouldForwardProp || Z.shouldForwardProp;
      Ee.env.NODE_ENV !== "production" && PT(G);
      var B = fne(I, ae, H) || ag, Q = function(oe, he, le) {
        for (var ve, Ne = Bo(Bo({}, he), { className: void 0, theme: le }), xe = 0; xe < oe.length; xe += 1) {
          var Me = og(ve = oe[xe]) ? ve(Ne) : ve;
          for (var $ in Me) Ne[$] = $ === "className" ? uh(Ne[$], Me[$]) : $ === "style" ? Bo(Bo({}, Ne[$]), Me[$]) : Me[$];
        }
        return he.className && (Ne.className = uh(Ne.className, he.className)), Ne;
      }(L, I, B), V = Q.as || X, q = {};
      for (var ne in Q) Q[ne] === void 0 || ne[0] === "$" || ne === "as" || ne === "theme" && Q.theme === B || (ne === "forwardedAs" ? q.as = Q.forwardedAs : K && !K(ne, V) || (q[ne] = Q[ne], K || Ee.env.NODE_ENV !== "development" || lne(ne) || JL.has(ne) || !$R.has(V) || (JL.add(ne), console.warn('styled-components: it looks like an unknown prop "'.concat(ne, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var ce = function(oe, he) {
        var le = KL(), ve = oe.generateAndInjectStyles(he, le.styleSheet, le.stylis);
        return Ee.env.NODE_ENV !== "production" && PT(ve), ve;
      }(N, Q);
      Ee.env.NODE_ENV !== "production" && D.warnTooManyClasses && D.warnTooManyClasses(ce);
      var ie = uh(j, G);
      return ce && (ie += " " + ce), Q.className && (ie += " " + Q.className), q[hM(V) && !$R.has(V) ? "class" : "className"] = ie, q.ref = U, B8(V, q);
    }(C, R, P);
  }
  w.displayName = p;
  var C = Fe.forwardRef(w);
  return C.attrs = v, C.componentStyle = _, C.displayName = p, C.shouldForwardProp = b, C.foldedComponentIds = r ? uh(i.foldedComponentIds, i.styledComponentId) : "", C.styledComponentId = g, C.target = r ? i.target : n, Object.defineProperty(C, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(R) {
    this._foldedDefaultProps = r ? function(P) {
      for (var D = [], I = 1; I < arguments.length; I++) D[I - 1] = arguments[I];
      for (var U = 0, L = D; U < L.length; U++) jR(P, L[U], !0);
      return P;
    }({}, i.defaultProps, R) : R;
  } }), Ee.env.NODE_ENV !== "production" && (dne(p, g), C.warnTooManyClasses = /* @__PURE__ */ function(R, P) {
    var D = {}, I = !1;
    return function(U) {
      if (!I && (D[U] = !0, Object.keys(D).length >= 200)) {
        var L = P ? ' with the id of "'.concat(P, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(R).concat(L, `.
`) + `Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), I = !0, D = {};
      }
    };
  }(p, g)), wO(C, function() {
    return ".".concat(C.styledComponentId);
  }), a && WV(C, n, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), C;
}
function e3(n, e) {
  for (var t = [n[0]], r = 0, i = e.length; r < i; r += 1) t.push(e[r], n[r + 1]);
  return t;
}
var t3 = function(n) {
  return Object.assign(n, { isCss: !0 });
};
function qne(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  if (og(n) || sg(n)) return t3(Sh(e3(OE, ig([n], e, !0))));
  var r = n;
  return e.length === 0 && r.length === 1 && typeof r[0] == "string" ? Sh(r) : t3(Sh(e3(r, e)));
}
function XR(n, e, t) {
  if (t === void 0 && (t = ag), !e) throw bg(1, e);
  var r = function(i) {
    for (var a = [], o = 1; o < arguments.length; o++) a[o - 1] = arguments[o];
    return n(e, t, qne.apply(void 0, ig([i], a, !1)));
  };
  return r.attrs = function(i) {
    return XR(n, e, Bo(Bo({}, t), { attrs: Array.prototype.concat(t.attrs, i).filter(Boolean) }));
  }, r.withConfig = function(i) {
    return XR(n, e, Bo(Bo({}, t), i));
  }, r;
}
var QV = function(n) {
  return XR(Xne, n);
}, Ai = QV;
$R.forEach(function(n) {
  Ai[n] = QV(n);
});
Ee.env.NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`);
var kS = "__sc-".concat(Dh, "__");
Ee.env.NODE_ENV !== "production" && Ee.env.NODE_ENV !== "test" && typeof window < "u" && (window[kS] || (window[kS] = 0), window[kS] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window[kS] += 1);
const Yne = Ai.div`
  display: ${(n) => n.$open ? "flex" : "none"};
  z-index: 1000;
  cursor: move;
  background-color: #fff;
  padding: 12px 12px;
  border-radius: 6px;
  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.15);
  position: absolute;
  top: ${(n) => `calc(50% - ${n.$height / 2}px)`};
  width: ${(n) => `${n.$width}px`};
  height: ${(n) => `${n.$height}px`};
  left: ${(n) => `calc(85% - ${n.$width / 2}px)`};

  flex-direction: column;
  gap: 1rem;
`, Kne = Ai.div`
  display: flex;
  align-items: center;
  gap: 1rem;
  justify-content: space-between;
`, Zne = Ai.div`
  // overflow-y: auto;
  // padding: 0.5rem;

  // &::-webkit-scrollbar {
  //   width: 6px;
  // }

  // &::-webkit-scrollbar-thumb {
  //   background-color: #ccc;
  //   border-radius: 4px;
  // }

  // &::-webkit-scrollbar-track {
  //   background-color: #f1f1f1;
  // }
`, MO = Ai.div`
  margin-top: 1rem;
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  justify-content: flex-end;
`, Qne = Ai.div`
  display: flex;
  align-items: flex-start;
  flex-direction: column;
`, Jne = Ai.h4`
  text-align: left;
  margin: 0;
`, ere = Ai.h5`
  text-align: left;
  font-weight: 400;
  margin: 0;
`, _h = Ai(kh)``;
Ai(kh)``;
Ai(kh)``;
const JV = Ai(RE)`
  width: 100% !important;
`, e4 = Ai(ms.Item)`
  .ant-form-item-control-input-content {
    display: flex;
  }
`, t4 = Ai.div`
  overflow-y: auto;
  max-height: ${(n) => `${n.$maxHeight}px`};
  padding: 0.5rem;

  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-thumb {
    background-color: #ccc;
    border-radius: 4px;
  }

  &::-webkit-scrollbar-track {
    background-color: #f1f1f1;
  }
`, tre = Ai.div`
  display: block;
  display: -webkit-box;
  -webkit-line-clamp: ${(n) => n.$line || 1};
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  word-break: break-word;
`, n3 = (n) => {
  const { isShowTooltip: e = !0 } = n, [t, r] = Lr(!1), i = kt(null), a = () => {
    if (i.current) {
      const o = i.current.scrollHeight > i.current.clientHeight;
      r(o), typeof n.children == "string" && n.textLength && n.children.length > n.textLength && r(!0);
    }
  };
  return In(() => {
    a();
  }, [n.children]), In(() => {
    n != null && n.triggerReRender && a();
  }, [n == null ? void 0 : n.triggerReRender]), /* @__PURE__ */ zt.jsx(
    M0,
    {
      title: t && e ? n.children : "",
      placement: n == null ? void 0 : n.placement,
      children: /* @__PURE__ */ zt.jsx(
        tre,
        {
          style: {
            width: n.width,
            ...n.styleText ?? {}
          },
          ref: i,
          $line: n.line || 1,
          children: n.children
        }
      )
    }
  );
}, n4 = (n) => {
  const {
    open: e = !1,
    title: t,
    subTitle: r,
    width: i = 400,
    height: a = 600,
    children: o,
    okText: s = "OK",
    cancelText: u = "Cancel",
    footer: d,
    onCancel: f,
    onOk: p,
    closeIcon: g,
    maxLineTitle: v = 1,
    maxLineSubTitle: b = 2
  } = n, [E, S] = Lr(e), _ = kt(null), w = () => {
    if (p) {
      p();
      return;
    }
    S(!1);
  }, C = () => {
    if (f) {
      f();
      return;
    }
    S(!1);
  };
  return In(() => {
    S(e);
  }, [e]), /* @__PURE__ */ zt.jsx(
    jj,
    {
      axis: "both",
      handle: ".dialog-container",
      defaultPosition: {
        x: 0,
        y: 0
      },
      children: /* @__PURE__ */ zt.jsxs(
        Yne,
        {
          ref: _,
          $open: E,
          className: "dialog-container",
          $width: i,
          $height: a,
          children: [
            /* @__PURE__ */ zt.jsxs(Kne, { children: [
              /* @__PURE__ */ zt.jsxs(Qne, { children: [
                /* @__PURE__ */ zt.jsx(n3, { line: v, children: /* @__PURE__ */ zt.jsx(Jne, { children: t }) }),
                r && /* @__PURE__ */ zt.jsx(n3, { line: b, children: /* @__PURE__ */ zt.jsx(ere, { children: r }) })
              ] }),
              /* @__PURE__ */ zt.jsx(_h, { type: "text", onClick: C, children: g || "" })
            ] }),
            /* @__PURE__ */ zt.jsx(Zne, { children: o }),
            d !== void 0 ? d !== null && d : /* @__PURE__ */ zt.jsxs(MO, { children: [
              /* @__PURE__ */ zt.jsx(_h, { onClick: C, children: u }),
              /* @__PURE__ */ zt.jsx(_h, { type: "primary", onClick: w, children: s })
            ] })
          ]
        }
      )
    }
  );
}, nre = [-0.6, 0, 3.7], r4 = [
  {
    label: "Length Of Wooden",
    name: "lengthOfWooden",
    required: !0,
    initialValue: "1000",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid length of wooden",
      // len: 4,
      max: 5e3,
      min: 1e3
    }
  },
  {
    label: "Width Of Wooden",
    name: "widthOfWooden",
    required: !0,
    initialValue: "200",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Width Of Wooden",
      // len: 4,
      max: 1e3,
      min: 200
    }
  },
  {
    label: "Thickness Of Wooden",
    name: "thicknessOfWooden",
    required: !0,
    initialValue: "50",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Thickness Of Wooden",
      // len: 4,
      max: 1e3,
      min: 50
    }
  },
  {
    label: "Color Wooden",
    name: "colorWooden",
    required: !0,
    initialValue: "#694C3F",
    hidden: !1,
    type: "color",
    rules: {
      required: !0,
      pattern: /^[a-zA-Z0-9]+$/,
      message: "Please enter valid Color Wooden",
      len: 7
      // max: 7,
      // min: 7
    }
  },
  {
    label: "Count Wooden",
    name: "countWooden",
    required: !0,
    initialValue: "15",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Count Wooden",
      // len: 8,
      max: 100,
      min: 10
    }
  },
  {
    label: "Gap Spacing Wooden",
    name: "gapSpacingWooden",
    required: !0,
    initialValue: "30",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Gap Spacing Wooden",
      // len: 8,
      max: 1e3,
      min: 10
    }
  },
  {
    label: "Height Of Column",
    name: "heightOfColumn",
    required: !0,
    initialValue: "400",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Height Of Column",
      // len: 8,
      max: 1e3,
      min: 100
    }
  },
  {
    label: "Column Count",
    name: "columnCount",
    required: !0,
    initialValue: "4",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Column Count",
      // len: 8,
      max: 24,
      min: 4
    }
  },
  {
    label: "Thickness Of Column",
    name: "thicknessOfColumn",
    required: !0,
    initialValue: "100",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Thickness Of Column",
      // len: 8,
      max: 1e3,
      min: 100
    }
  }
], i4 = [
  {
    label: "Length Of Wooden",
    name: "lengthOfWooden",
    required: !0,
    initialValue: "1000",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid length of wooden",
      // len: 4,
      max: 5e3,
      min: 1e3
    }
  },
  {
    label: "Width Of Wooden",
    name: "widthOfWooden",
    required: !0,
    initialValue: "200",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Width Of Wooden",
      // len: 4,
      max: 1e3,
      min: 200
    }
  },
  {
    label: "Thickness Of Wooden",
    name: "thicknessOfWooden",
    required: !0,
    initialValue: "50",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Thickness Of Wooden",
      // len: 4,
      max: 1e3,
      min: 50
    }
  },
  {
    label: "Color Wooden",
    name: "colorWooden",
    required: !0,
    initialValue: "#694C3F",
    hidden: !1,
    type: "color",
    rules: {
      required: !0,
      pattern: /^[a-zA-Z0-9]+$/,
      message: "Please enter valid Color Wooden",
      len: 7
      // max: 7,
      // min: 7
    }
  },
  {
    label: "Count Wooden",
    name: "countWooden",
    required: !0,
    initialValue: "15",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Count Wooden",
      // len: 8,
      max: 100,
      min: 10
    }
  },
  {
    label: "Gap Spacing Wooden",
    name: "gapSpacingWooden",
    required: !0,
    initialValue: "30",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Gap Spacing Wooden",
      // len: 8,
      max: 1e3,
      min: 10
    }
  },
  {
    label: "Height Of Column",
    name: "heightOfColumn",
    required: !0,
    initialValue: "400",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Height Of Column",
      // len: 8,
      max: 1e3,
      min: 100
    }
  },
  {
    label: "Column Count",
    name: "columnCount",
    required: !0,
    initialValue: "4",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Column Count",
      // len: 8,
      max: 24,
      min: 4
    }
  },
  {
    label: "Thickness Of Column",
    name: "thicknessOfColumn",
    required: !0,
    initialValue: "100",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Thickness Of Column",
      // len: 8,
      max: 1e3,
      min: 100
    }
  },
  {
    label: "Start Point Of L Shape",
    name: "startPointOfLShape",
    required: !0,
    initialValue: "10",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Start Point Of L Shape",
      // len: 8,
      max: 96,
      min: 6
    }
  },
  {
    label: "Count L Column",
    name: "countLColumn",
    required: !0,
    initialValue: "10",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid Count L Column",
      // len: 8,
      max: 24,
      min: 4
    }
  },
  {
    label: "Length Of L Wooden",
    name: "lengthOfLWooden",
    required: !0,
    initialValue: "4000",
    hidden: !1,
    type: "text",
    rules: {
      required: !0,
      pattern: /^[0-9]+$/,
      message: "Please enter valid lengthOfLWooden",
      // len: 8,
      max: 1e4,
      min: 2e3
    }
  }
], rre = (n) => ({
  lengthOfWooden: 1e3,
  widthOfWooden: 200,
  thicknessOfWooden: 50,
  colorWooden: "#694C3F",
  countWooden: 15,
  gapSpacingWooden: 30,
  heightOfColumn: 400,
  columnCount: 4,
  thicknessOfColumn: 100,
  isLShape: n || !1,
  startPointOfLShape: 10,
  countLColumn: 4,
  lengthOfLWooden: 4e3,
  startX: 0,
  startY: 0,
  startZ: 0
}), ire = (n) => {
  const {
    isOpen: e,
    title: t,
    onClose: r,
    onFinish: i,
    // footer,
    subTitle: a,
    width: o = 400,
    height: s = 600,
    okText: u = "Save",
    cancelText: d = "Cancel",
    closeIcon: f,
    maxLineTitle: p = 1,
    maxLineSubTitle: g = 2
  } = n, [v] = ms.useForm();
  return /* @__PURE__ */ zt.jsx(
    n4,
    {
      open: e,
      onCancel: r,
      title: t,
      subTitle: a,
      footer: null,
      height: s,
      width: o,
      closeIcon: f,
      maxLineTitle: p,
      maxLineSubTitle: g,
      children: /* @__PURE__ */ zt.jsxs(
        ms,
        {
          layout: "vertical",
          form: v,
          onFinish: (b) => {
            i(b);
          },
          children: [
            /* @__PURE__ */ zt.jsx(t4, { $maxHeight: s - 140, children: r4.map((b, E) => {
              var S, _;
              return /* @__PURE__ */ zt.jsx(
                e4,
                {
                  required: b.required,
                  label: b.label,
                  name: b.name,
                  initialValue: b.initialValue,
                  hidden: b.hidden,
                  rules: b.type !== "color" ? [b.rules] : [],
                  children: b.type === "color" ? /* @__PURE__ */ zt.jsx(
                    R0,
                    {
                      onChange: (w, C) => {
                        v.setFieldsValue({ [b.name]: C });
                      },
                      size: "small",
                      showText: !0
                    }
                  ) : /* @__PURE__ */ zt.jsx(
                    JV,
                    {
                      max: (S = b.rules) == null ? void 0 : S.max,
                      min: (_ = b.rules) == null ? void 0 : _.min
                    }
                  )
                },
                E
              );
            }) }),
            /* @__PURE__ */ zt.jsxs(MO, { children: [
              /* @__PURE__ */ zt.jsx(_h, { onClick: r, children: d }),
              /* @__PURE__ */ zt.jsx(_h, { type: "primary", htmlType: "submit", children: u })
            ] })
          ]
        }
      )
    }
  );
}, are = (n) => {
  const {
    isOpen: e,
    title: t,
    onClose: r,
    onFinish: i,
    // footer,
    subTitle: a,
    width: o = 400,
    height: s = 600,
    okText: u = "Save",
    cancelText: d = "Cancel",
    closeIcon: f,
    maxLineTitle: p = 1,
    maxLineSubTitle: g = 2
  } = n, [v] = ms.useForm();
  return /* @__PURE__ */ zt.jsx(
    n4,
    {
      open: e,
      onCancel: r,
      title: t,
      footer: null,
      subTitle: a,
      height: s,
      width: o,
      closeIcon: f,
      maxLineTitle: p,
      maxLineSubTitle: g,
      children: /* @__PURE__ */ zt.jsxs(
        ms,
        {
          layout: "vertical",
          form: v,
          onFinish: (b) => {
            i(b);
          },
          children: [
            /* @__PURE__ */ zt.jsx(t4, { $maxHeight: s - 140, children: i4.map((b, E) => {
              var S, _;
              return /* @__PURE__ */ zt.jsx(
                e4,
                {
                  required: b.required,
                  label: b.label,
                  name: b.name,
                  initialValue: b.initialValue,
                  hidden: b.hidden,
                  rules: b.type !== "color" ? [b.rules] : [],
                  children: b.type === "color" ? /* @__PURE__ */ zt.jsx(
                    R0,
                    {
                      onChange: (w, C) => {
                        v.setFieldsValue({ [b.name]: C });
                      },
                      size: "small",
                      showText: !0
                    }
                  ) : /* @__PURE__ */ zt.jsx(
                    JV,
                    {
                      max: (S = b.rules) == null ? void 0 : S.max,
                      min: (_ = b.rules) == null ? void 0 : _.min
                    }
                  )
                },
                E
              );
            }) }),
            /* @__PURE__ */ zt.jsxs(MO, { children: [
              /* @__PURE__ */ zt.jsx(_h, { onClick: r, children: d }),
              /* @__PURE__ */ zt.jsx(_h, { type: "primary", htmlType: "submit", children: u })
            ] })
          ]
        }
      )
    }
  );
};
function a4(n) {
  let e = null;
  return () => (e == null && (e = n()), e);
}
function ore(n, e) {
  return n.filter(
    (t) => t !== e
  );
}
function sre(n, e) {
  const t = /* @__PURE__ */ new Set(), r = (a) => t.add(a);
  n.forEach(r), e.forEach(r);
  const i = [];
  return t.forEach(
    (a) => i.push(a)
  ), i;
}
class lre {
  enter(e) {
    const t = this.entered.length, r = (i) => this.isNodeInDocument(i) && (!i.contains || i.contains(e));
    return this.entered = sre(this.entered.filter(r), [
      e
    ]), t === 0 && this.entered.length > 0;
  }
  leave(e) {
    const t = this.entered.length;
    return this.entered = ore(this.entered.filter(this.isNodeInDocument), e), t > 0 && this.entered.length === 0;
  }
  reset() {
    this.entered = [];
  }
  constructor(e) {
    this.entered = [], this.isNodeInDocument = e;
  }
}
class cre {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((e) => {
      Object.defineProperty(this.item, e, {
        configurable: !0,
        enumerable: !0,
        get() {
          return console.warn(`Browser doesn't allow reading "${e}" until the drop event.`), null;
        }
      });
    });
  }
  loadDataTransfer(e) {
    if (e) {
      const t = {};
      Object.keys(this.config.exposeProperties).forEach((r) => {
        const i = this.config.exposeProperties[r];
        i != null && (t[r] = {
          value: i(e, this.config.matchesTypes),
          configurable: !0,
          enumerable: !0
        });
      }), Object.defineProperties(this.item, t);
    }
  }
  canDrag() {
    return !0;
  }
  beginDrag() {
    return this.item;
  }
  isDragging(e, t) {
    return t === e.getSourceId();
  }
  endDrag() {
  }
  constructor(e) {
    this.config = e, this.item = {}, this.initializeExposedProperties();
  }
}
const o4 = "__NATIVE_FILE__", s4 = "__NATIVE_URL__", l4 = "__NATIVE_TEXT__", c4 = "__NATIVE_HTML__", r3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FILE: o4,
  HTML: c4,
  TEXT: l4,
  URL: s4
}, Symbol.toStringTag, { value: "Module" }));
function mM(n, e, t) {
  const r = e.reduce(
    (i, a) => i || n.getData(a),
    ""
  );
  return r ?? t;
}
const qR = {
  [o4]: {
    exposeProperties: {
      files: (n) => Array.prototype.slice.call(n.files),
      items: (n) => n.items,
      dataTransfer: (n) => n
    },
    matchesTypes: [
      "Files"
    ]
  },
  [c4]: {
    exposeProperties: {
      html: (n, e) => mM(n, e, ""),
      dataTransfer: (n) => n
    },
    matchesTypes: [
      "Html",
      "text/html"
    ]
  },
  [s4]: {
    exposeProperties: {
      urls: (n, e) => mM(n, e, "").split(`
`),
      dataTransfer: (n) => n
    },
    matchesTypes: [
      "Url",
      "text/uri-list"
    ]
  },
  [l4]: {
    exposeProperties: {
      text: (n, e) => mM(n, e, ""),
      dataTransfer: (n) => n
    },
    matchesTypes: [
      "Text",
      "text/plain"
    ]
  }
};
function ure(n, e) {
  const t = qR[n];
  if (!t)
    throw new Error(`native type ${n} has no configuration`);
  const r = new cre(t);
  return r.loadDataTransfer(e), r;
}
function gM(n) {
  if (!n)
    return null;
  const e = Array.prototype.slice.call(n.types || []);
  return Object.keys(qR).filter((t) => {
    const r = qR[t];
    return r != null && r.matchesTypes ? r.matchesTypes.some(
      (i) => e.indexOf(i) > -1
    ) : !1;
  })[0] || null;
}
const dre = a4(
  () => /firefox/i.test(navigator.userAgent)
), u4 = a4(
  () => !!window.safari
);
class i3 {
  interpolate(e) {
    const { xs: t, ys: r, c1s: i, c2s: a, c3s: o } = this;
    let s = t.length - 1;
    if (e === t[s])
      return r[s];
    let u = 0, d = o.length - 1, f;
    for (; u <= d; ) {
      f = Math.floor(0.5 * (u + d));
      const v = t[f];
      if (v < e)
        u = f + 1;
      else if (v > e)
        d = f - 1;
      else
        return r[f];
    }
    s = Math.max(0, d);
    const p = e - t[s], g = p * p;
    return r[s] + i[s] * p + a[s] * g + o[s] * p * g;
  }
  constructor(e, t) {
    const { length: r } = e, i = [];
    for (let v = 0; v < r; v++)
      i.push(v);
    i.sort(
      (v, b) => e[v] < e[b] ? -1 : 1
    );
    const a = [], o = [];
    let s, u;
    for (let v = 0; v < r - 1; v++)
      s = e[v + 1] - e[v], u = t[v + 1] - t[v], a.push(s), o.push(u / s);
    const d = [
      o[0]
    ];
    for (let v = 0; v < a.length - 1; v++) {
      const b = o[v], E = o[v + 1];
      if (b * E <= 0)
        d.push(0);
      else {
        s = a[v];
        const S = a[v + 1], _ = s + S;
        d.push(3 * _ / ((_ + S) / b + (_ + s) / E));
      }
    }
    d.push(o[o.length - 1]);
    const f = [], p = [];
    let g;
    for (let v = 0; v < d.length - 1; v++) {
      g = o[v];
      const b = d[v], E = 1 / a[v], S = b + d[v + 1] - g - g;
      f.push((g - b - S) * E), p.push(S * E * E);
    }
    this.xs = e, this.ys = t, this.c1s = d, this.c2s = f, this.c3s = p;
  }
}
const fre = 1;
function d4(n) {
  const e = n.nodeType === fre ? n : n.parentElement;
  if (!e)
    return null;
  const { top: t, left: r } = e.getBoundingClientRect();
  return {
    x: r,
    y: t
  };
}
function $S(n) {
  return {
    x: n.clientX,
    y: n.clientY
  };
}
function hre(n) {
  var e;
  return n.nodeName === "IMG" && (dre() || !(!((e = document.documentElement) === null || e === void 0) && e.contains(n)));
}
function pre(n, e, t, r) {
  let i = n ? e.width : t, a = n ? e.height : r;
  return u4() && n && (a /= window.devicePixelRatio, i /= window.devicePixelRatio), {
    dragPreviewWidth: i,
    dragPreviewHeight: a
  };
}
function mre(n, e, t, r, i) {
  const a = hre(e), s = d4(a ? n : e), u = {
    x: t.x - s.x,
    y: t.y - s.y
  }, { offsetWidth: d, offsetHeight: f } = n, { anchorX: p, anchorY: g } = r, { dragPreviewWidth: v, dragPreviewHeight: b } = pre(a, e, d, f), E = () => {
    let D = new i3([
      0,
      0.5,
      1
    ], [
      // Dock to the top
      u.y,
      // Align at the center
      u.y / f * b,
      // Dock to the bottom
      u.y + b - f
    ]).interpolate(g);
    return u4() && a && (D += (window.devicePixelRatio - 1) * b), D;
  }, S = () => new i3([
    0,
    0.5,
    1
  ], [
    // Dock to the left
    u.x,
    // Align at the center
    u.x / d * v,
    // Dock to the right
    u.x + v - d
  ]).interpolate(p), { offsetX: _, offsetY: w } = i, C = _ === 0 || _, R = w === 0 || w;
  return {
    x: C ? _ : S(),
    y: R ? w : E()
  };
}
class gre {
  get window() {
    if (this.globalContext)
      return this.globalContext;
    if (typeof window < "u")
      return window;
  }
  get document() {
    var e;
    return !((e = this.globalContext) === null || e === void 0) && e.document ? this.globalContext.document : this.window ? this.window.document : void 0;
  }
  get rootElement() {
    var e;
    return ((e = this.optionsArgs) === null || e === void 0 ? void 0 : e.rootElement) || this.window;
  }
  constructor(e, t) {
    this.ownerDocument = null, this.globalContext = e, this.optionsArgs = t;
  }
}
function vre(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function a3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}, r = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(t).filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    }))), r.forEach(function(i) {
      vre(n, i, t[i]);
    });
  }
  return n;
}
class yre {
  /**
  * Generate profiling statistics for the HTML5Backend.
  */
  profile() {
    var e, t;
    return {
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      sourceNodeOptions: this.sourceNodeOptions.size,
      sourceNodes: this.sourceNodes.size,
      dragStartSourceIds: ((e = this.dragStartSourceIds) === null || e === void 0 ? void 0 : e.length) || 0,
      dropTargetIds: this.dropTargetIds.length,
      dragEnterTargetIds: this.dragEnterTargetIds.length,
      dragOverTargetIds: ((t = this.dragOverTargetIds) === null || t === void 0 ? void 0 : t.length) || 0
    };
  }
  // public for test
  get window() {
    return this.options.window;
  }
  get document() {
    return this.options.document;
  }
  /**
  * Get the root element to use for event subscriptions
  */
  get rootElement() {
    return this.options.rootElement;
  }
  setup() {
    const e = this.rootElement;
    if (e !== void 0) {
      if (e.__isReactDndBackendSetUp)
        throw new Error("Cannot have two HTML5 backends at the same time.");
      e.__isReactDndBackendSetUp = !0, this.addEventListeners(e);
    }
  }
  teardown() {
    const e = this.rootElement;
    if (e !== void 0 && (e.__isReactDndBackendSetUp = !1, this.removeEventListeners(this.rootElement), this.clearCurrentDragSourceNode(), this.asyncEndDragFrameId)) {
      var t;
      (t = this.window) === null || t === void 0 || t.cancelAnimationFrame(this.asyncEndDragFrameId);
    }
  }
  connectDragPreview(e, t, r) {
    return this.sourcePreviewNodeOptions.set(e, r), this.sourcePreviewNodes.set(e, t), () => {
      this.sourcePreviewNodes.delete(e), this.sourcePreviewNodeOptions.delete(e);
    };
  }
  connectDragSource(e, t, r) {
    this.sourceNodes.set(e, t), this.sourceNodeOptions.set(e, r);
    const i = (o) => this.handleDragStart(o, e), a = (o) => this.handleSelectStart(o);
    return t.setAttribute("draggable", "true"), t.addEventListener("dragstart", i), t.addEventListener("selectstart", a), () => {
      this.sourceNodes.delete(e), this.sourceNodeOptions.delete(e), t.removeEventListener("dragstart", i), t.removeEventListener("selectstart", a), t.setAttribute("draggable", "false");
    };
  }
  connectDropTarget(e, t) {
    const r = (o) => this.handleDragEnter(o, e), i = (o) => this.handleDragOver(o, e), a = (o) => this.handleDrop(o, e);
    return t.addEventListener("dragenter", r), t.addEventListener("dragover", i), t.addEventListener("drop", a), () => {
      t.removeEventListener("dragenter", r), t.removeEventListener("dragover", i), t.removeEventListener("drop", a);
    };
  }
  addEventListeners(e) {
    e.addEventListener && (e.addEventListener("dragstart", this.handleTopDragStart), e.addEventListener("dragstart", this.handleTopDragStartCapture, !0), e.addEventListener("dragend", this.handleTopDragEndCapture, !0), e.addEventListener("dragenter", this.handleTopDragEnter), e.addEventListener("dragenter", this.handleTopDragEnterCapture, !0), e.addEventListener("dragleave", this.handleTopDragLeaveCapture, !0), e.addEventListener("dragover", this.handleTopDragOver), e.addEventListener("dragover", this.handleTopDragOverCapture, !0), e.addEventListener("drop", this.handleTopDrop), e.addEventListener("drop", this.handleTopDropCapture, !0));
  }
  removeEventListeners(e) {
    e.removeEventListener && (e.removeEventListener("dragstart", this.handleTopDragStart), e.removeEventListener("dragstart", this.handleTopDragStartCapture, !0), e.removeEventListener("dragend", this.handleTopDragEndCapture, !0), e.removeEventListener("dragenter", this.handleTopDragEnter), e.removeEventListener("dragenter", this.handleTopDragEnterCapture, !0), e.removeEventListener("dragleave", this.handleTopDragLeaveCapture, !0), e.removeEventListener("dragover", this.handleTopDragOver), e.removeEventListener("dragover", this.handleTopDragOverCapture, !0), e.removeEventListener("drop", this.handleTopDrop), e.removeEventListener("drop", this.handleTopDropCapture, !0));
  }
  getCurrentSourceNodeOptions() {
    const e = this.monitor.getSourceId(), t = this.sourceNodeOptions.get(e);
    return a3({
      dropEffect: this.altKeyPressed ? "copy" : "move"
    }, t || {});
  }
  getCurrentDropEffect() {
    return this.isDraggingNativeItem() ? "copy" : this.getCurrentSourceNodeOptions().dropEffect;
  }
  getCurrentSourcePreviewNodeOptions() {
    const e = this.monitor.getSourceId(), t = this.sourcePreviewNodeOptions.get(e);
    return a3({
      anchorX: 0.5,
      anchorY: 0.5,
      captureDraggingState: !1
    }, t || {});
  }
  isDraggingNativeItem() {
    const e = this.monitor.getItemType();
    return Object.keys(r3).some(
      (t) => r3[t] === e
    );
  }
  beginDragNativeItem(e, t) {
    this.clearCurrentDragSourceNode(), this.currentNativeSource = ure(e, t), this.currentNativeHandle = this.registry.addSource(e, this.currentNativeSource), this.actions.beginDrag([
      this.currentNativeHandle
    ]);
  }
  setCurrentDragSourceNode(e) {
    this.clearCurrentDragSourceNode(), this.currentDragSourceNode = e;
    const t = 1e3;
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var r;
      return (r = this.rootElement) === null || r === void 0 ? void 0 : r.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, !0);
    }, t);
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      if (this.currentDragSourceNode = null, this.rootElement) {
        var e;
        (e = this.window) === null || e === void 0 || e.clearTimeout(this.mouseMoveTimeoutTimer || void 0), this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, !0);
      }
      return this.mouseMoveTimeoutTimer = null, !0;
    }
    return !1;
  }
  handleDragStart(e, t) {
    e.defaultPrevented || (this.dragStartSourceIds || (this.dragStartSourceIds = []), this.dragStartSourceIds.unshift(t));
  }
  handleDragEnter(e, t) {
    this.dragEnterTargetIds.unshift(t);
  }
  handleDragOver(e, t) {
    this.dragOverTargetIds === null && (this.dragOverTargetIds = []), this.dragOverTargetIds.unshift(t);
  }
  handleDrop(e, t) {
    this.dropTargetIds.unshift(t);
  }
  constructor(e, t, r) {
    this.sourcePreviewNodes = /* @__PURE__ */ new Map(), this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map(), this.sourceNodes = /* @__PURE__ */ new Map(), this.sourceNodeOptions = /* @__PURE__ */ new Map(), this.dragStartSourceIds = null, this.dropTargetIds = [], this.dragEnterTargetIds = [], this.currentNativeSource = null, this.currentNativeHandle = null, this.currentDragSourceNode = null, this.altKeyPressed = !1, this.mouseMoveTimeoutTimer = null, this.asyncEndDragFrameId = null, this.dragOverTargetIds = null, this.lastClientOffset = null, this.hoverRafId = null, this.getSourceClientOffset = (i) => {
      const a = this.sourceNodes.get(i);
      return a && d4(a) || null;
    }, this.endDragNativeItem = () => {
      this.isDraggingNativeItem() && (this.actions.endDrag(), this.currentNativeHandle && this.registry.removeSource(this.currentNativeHandle), this.currentNativeHandle = null, this.currentNativeSource = null);
    }, this.isNodeInDocument = (i) => !!(i && this.document && this.document.body && this.document.body.contains(i)), this.endDragIfSourceWasRemovedFromDOM = () => {
      const i = this.currentDragSourceNode;
      i == null || this.isNodeInDocument(i) || (this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover());
    }, this.scheduleHover = (i) => {
      this.hoverRafId === null && typeof requestAnimationFrame < "u" && (this.hoverRafId = requestAnimationFrame(() => {
        this.monitor.isDragging() && this.actions.hover(i || [], {
          clientOffset: this.lastClientOffset
        }), this.hoverRafId = null;
      }));
    }, this.cancelHover = () => {
      this.hoverRafId !== null && typeof cancelAnimationFrame < "u" && (cancelAnimationFrame(this.hoverRafId), this.hoverRafId = null);
    }, this.handleTopDragStartCapture = () => {
      this.clearCurrentDragSourceNode(), this.dragStartSourceIds = [];
    }, this.handleTopDragStart = (i) => {
      if (i.defaultPrevented)
        return;
      const { dragStartSourceIds: a } = this;
      this.dragStartSourceIds = null;
      const o = $S(i);
      this.monitor.isDragging() && (this.actions.endDrag(), this.cancelHover()), this.actions.beginDrag(a || [], {
        publishSource: !1,
        getSourceClientOffset: this.getSourceClientOffset,
        clientOffset: o
      });
      const { dataTransfer: s } = i, u = gM(s);
      if (this.monitor.isDragging()) {
        if (s && typeof s.setDragImage == "function") {
          const f = this.monitor.getSourceId(), p = this.sourceNodes.get(f), g = this.sourcePreviewNodes.get(f) || p;
          if (g) {
            const { anchorX: v, anchorY: b, offsetX: E, offsetY: S } = this.getCurrentSourcePreviewNodeOptions(), C = mre(p, g, o, {
              anchorX: v,
              anchorY: b
            }, {
              offsetX: E,
              offsetY: S
            });
            s.setDragImage(g, C.x, C.y);
          }
        }
        try {
          s == null || s.setData("application/json", {});
        } catch {
        }
        this.setCurrentDragSourceNode(i.target);
        const { captureDraggingState: d } = this.getCurrentSourcePreviewNodeOptions();
        d ? this.actions.publishDragSource() : setTimeout(
          () => this.actions.publishDragSource(),
          0
        );
      } else if (u)
        this.beginDragNativeItem(u);
      else {
        if (s && !s.types && (i.target && !i.target.hasAttribute || !i.target.hasAttribute("draggable")))
          return;
        i.preventDefault();
      }
    }, this.handleTopDragEndCapture = () => {
      this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover();
    }, this.handleTopDragEnterCapture = (i) => {
      if (this.dragEnterTargetIds = [], this.isDraggingNativeItem()) {
        var a;
        (a = this.currentNativeSource) === null || a === void 0 || a.loadDataTransfer(i.dataTransfer);
      }
      if (!this.enterLeaveCounter.enter(i.target) || this.monitor.isDragging())
        return;
      const { dataTransfer: s } = i, u = gM(s);
      u && this.beginDragNativeItem(u, s);
    }, this.handleTopDragEnter = (i) => {
      const { dragEnterTargetIds: a } = this;
      if (this.dragEnterTargetIds = [], !this.monitor.isDragging())
        return;
      this.altKeyPressed = i.altKey, a.length > 0 && this.actions.hover(a, {
        clientOffset: $S(i)
      }), a.some(
        (s) => this.monitor.canDropOnTarget(s)
      ) && (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect()));
    }, this.handleTopDragOverCapture = (i) => {
      if (this.dragOverTargetIds = [], this.isDraggingNativeItem()) {
        var a;
        (a = this.currentNativeSource) === null || a === void 0 || a.loadDataTransfer(i.dataTransfer);
      }
    }, this.handleTopDragOver = (i) => {
      const { dragOverTargetIds: a } = this;
      if (this.dragOverTargetIds = [], !this.monitor.isDragging()) {
        i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "none");
        return;
      }
      this.altKeyPressed = i.altKey, this.lastClientOffset = $S(i), this.scheduleHover(a), (a || []).some(
        (s) => this.monitor.canDropOnTarget(s)
      ) ? (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect())) : this.isDraggingNativeItem() ? i.preventDefault() : (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "none"));
    }, this.handleTopDragLeaveCapture = (i) => {
      this.isDraggingNativeItem() && i.preventDefault(), this.enterLeaveCounter.leave(i.target) && (this.isDraggingNativeItem() && setTimeout(
        () => this.endDragNativeItem(),
        0
      ), this.cancelHover());
    }, this.handleTopDropCapture = (i) => {
      if (this.dropTargetIds = [], this.isDraggingNativeItem()) {
        var a;
        i.preventDefault(), (a = this.currentNativeSource) === null || a === void 0 || a.loadDataTransfer(i.dataTransfer);
      } else gM(i.dataTransfer) && i.preventDefault();
      this.enterLeaveCounter.reset();
    }, this.handleTopDrop = (i) => {
      const { dropTargetIds: a } = this;
      this.dropTargetIds = [], this.actions.hover(a, {
        clientOffset: $S(i)
      }), this.actions.drop({
        dropEffect: this.getCurrentDropEffect()
      }), this.isDraggingNativeItem() ? this.endDragNativeItem() : this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover();
    }, this.handleSelectStart = (i) => {
      const a = i.target;
      typeof a.dragDrop == "function" && (a.tagName === "INPUT" || a.tagName === "SELECT" || a.tagName === "TEXTAREA" || a.isContentEditable || (i.preventDefault(), a.dragDrop()));
    }, this.options = new gre(t, r), this.actions = e.getActions(), this.monitor = e.getMonitor(), this.registry = e.getRegistry(), this.enterLeaveCounter = new lre(this.isNodeInDocument);
  }
}
const bre = function(e, t, r) {
  return new yre(e, t, r);
}, f4 = hg({
  dragDropManager: void 0
});
function ks(n) {
  return "Minified Redux error #" + n + "; visit https://redux.js.org/Errors?code=" + n + " for the full message or use the non-minified dev environment for full errors. ";
}
var o3 = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}(), vM = function() {
  return Math.random().toString(36).substring(7).split("").join(".");
}, s3 = {
  INIT: "@@redux/INIT" + vM(),
  REPLACE: "@@redux/REPLACE" + vM(),
  PROBE_UNKNOWN_ACTION: function() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + vM();
  }
};
function Sre(n) {
  if (typeof n != "object" || n === null) return !1;
  for (var e = n; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(n) === e;
}
function _re(n) {
  if (n === void 0) return "undefined";
  if (n === null) return "null";
  var e = typeof n;
  switch (e) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return e;
  }
  if (Array.isArray(n)) return "array";
  if (Cre(n)) return "date";
  if (Ere(n)) return "error";
  var t = xre(n);
  switch (t) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return t;
  }
  return e.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function xre(n) {
  return typeof n.constructor == "function" ? n.constructor.name : null;
}
function Ere(n) {
  return n instanceof Error || typeof n.message == "string" && n.constructor && typeof n.constructor.stackTraceLimit == "number";
}
function Cre(n) {
  return n instanceof Date ? !0 : typeof n.toDateString == "function" && typeof n.getDate == "function" && typeof n.setDate == "function";
}
function om(n) {
  var e = typeof n;
  return Ee.env.NODE_ENV !== "production" && (e = _re(n)), e;
}
function h4(n, e, t) {
  var r;
  if (typeof e == "function" && typeof t == "function" || typeof t == "function" && typeof arguments[3] == "function")
    throw new Error(Ee.env.NODE_ENV === "production" ? ks(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof e == "function" && typeof t > "u" && (t = e, e = void 0), typeof t < "u") {
    if (typeof t != "function")
      throw new Error(Ee.env.NODE_ENV === "production" ? ks(1) : "Expected the enhancer to be a function. Instead, received: '" + om(t) + "'");
    return t(h4)(n, e);
  }
  if (typeof n != "function")
    throw new Error(Ee.env.NODE_ENV === "production" ? ks(2) : "Expected the root reducer to be a function. Instead, received: '" + om(n) + "'");
  var i = n, a = e, o = [], s = o, u = !1;
  function d() {
    s === o && (s = o.slice());
  }
  function f() {
    if (u)
      throw new Error(Ee.env.NODE_ENV === "production" ? ks(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return a;
  }
  function p(E) {
    if (typeof E != "function")
      throw new Error(Ee.env.NODE_ENV === "production" ? ks(4) : "Expected the listener to be a function. Instead, received: '" + om(E) + "'");
    if (u)
      throw new Error(Ee.env.NODE_ENV === "production" ? ks(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    var S = !0;
    return d(), s.push(E), function() {
      if (S) {
        if (u)
          throw new Error(Ee.env.NODE_ENV === "production" ? ks(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        S = !1, d();
        var w = s.indexOf(E);
        s.splice(w, 1), o = null;
      }
    };
  }
  function g(E) {
    if (!Sre(E))
      throw new Error(Ee.env.NODE_ENV === "production" ? ks(7) : "Actions must be plain objects. Instead, the actual type was: '" + om(E) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    if (typeof E.type > "u")
      throw new Error(Ee.env.NODE_ENV === "production" ? ks(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (u)
      throw new Error(Ee.env.NODE_ENV === "production" ? ks(9) : "Reducers may not dispatch actions.");
    try {
      u = !0, a = i(a, E);
    } finally {
      u = !1;
    }
    for (var S = o = s, _ = 0; _ < S.length; _++) {
      var w = S[_];
      w();
    }
    return E;
  }
  function v(E) {
    if (typeof E != "function")
      throw new Error(Ee.env.NODE_ENV === "production" ? ks(10) : "Expected the nextReducer to be a function. Instead, received: '" + om(E));
    i = E, g({
      type: s3.REPLACE
    });
  }
  function b() {
    var E, S = p;
    return E = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function(w) {
        if (typeof w != "object" || w === null)
          throw new Error(Ee.env.NODE_ENV === "production" ? ks(11) : "Expected the observer to be an object. Instead, received: '" + om(w) + "'");
        function C() {
          w.next && w.next(f());
        }
        C();
        var R = S(C);
        return {
          unsubscribe: R
        };
      }
    }, E[o3] = function() {
      return this;
    }, E;
  }
  return g({
    type: s3.INIT
  }), r = {
    dispatch: g,
    subscribe: p,
    getState: f,
    replaceReducer: v
  }, r[o3] = b, r;
}
function Hn(n, e, ...t) {
  if (wre() && e === void 0)
    throw new Error("invariant requires an error message argument");
  if (!n) {
    let r;
    if (e === void 0)
      r = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      let i = 0;
      r = new Error(e.replace(/%s/g, function() {
        return t[i++];
      })), r.name = "Invariant Violation";
    }
    throw r.framesToPop = 1, r;
  }
}
function wre() {
  return typeof Ee < "u" && Ee.env.NODE_ENV === "production";
}
function Mre(n, e, t) {
  return e.split(".").reduce(
    (r, i) => r && r[i] ? r[i] : t || null,
    n
  );
}
function Tre(n, e) {
  return n.filter(
    (t) => t !== e
  );
}
function p4(n) {
  return typeof n == "object";
}
function Rre(n, e) {
  const t = /* @__PURE__ */ new Map(), r = (a) => {
    t.set(a, t.has(a) ? t.get(a) + 1 : 1);
  };
  n.forEach(r), e.forEach(r);
  const i = [];
  return t.forEach((a, o) => {
    a === 1 && i.push(o);
  }), i;
}
function Are(n, e) {
  return n.filter(
    (t) => e.indexOf(t) > -1
  );
}
const TO = "dnd-core/INIT_COORDS", PE = "dnd-core/BEGIN_DRAG", RO = "dnd-core/PUBLISH_DRAG_SOURCE", DE = "dnd-core/HOVER", IE = "dnd-core/DROP", NE = "dnd-core/END_DRAG";
function l3(n, e) {
  return {
    type: TO,
    payload: {
      sourceClientOffset: e || null,
      clientOffset: n || null
    }
  };
}
const Ore = {
  type: TO,
  payload: {
    clientOffset: null,
    sourceClientOffset: null
  }
};
function Pre(n) {
  return function(t = [], r = {
    publishSource: !0
  }) {
    const { publishSource: i = !0, clientOffset: a, getSourceClientOffset: o } = r, s = n.getMonitor(), u = n.getRegistry();
    n.dispatch(l3(a)), Dre(t, s, u);
    const d = Lre(t, s);
    if (d == null) {
      n.dispatch(Ore);
      return;
    }
    let f = null;
    if (a) {
      if (!o)
        throw new Error("getSourceClientOffset must be defined");
      Ire(o), f = o(d);
    }
    n.dispatch(l3(a, f));
    const g = u.getSource(d).beginDrag(s, d);
    if (g == null)
      return;
    Nre(g), u.pinSource(d);
    const v = u.getSourceType(d);
    return {
      type: PE,
      payload: {
        itemType: v,
        item: g,
        sourceId: d,
        clientOffset: a || null,
        sourceClientOffset: f || null,
        isSourcePublic: !!i
      }
    };
  };
}
function Dre(n, e, t) {
  Hn(!e.isDragging(), "Cannot call beginDrag while dragging."), n.forEach(function(r) {
    Hn(t.getSource(r), "Expected sourceIds to be registered.");
  });
}
function Ire(n) {
  Hn(typeof n == "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
}
function Nre(n) {
  Hn(p4(n), "Item must be an object.");
}
function Lre(n, e) {
  let t = null;
  for (let r = n.length - 1; r >= 0; r--)
    if (e.canDragSource(n[r])) {
      t = n[r];
      break;
    }
  return t;
}
function Fre(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Ure(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}, r = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(t).filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    }))), r.forEach(function(i) {
      Fre(n, i, t[i]);
    });
  }
  return n;
}
function zre(n) {
  return function(t = {}) {
    const r = n.getMonitor(), i = n.getRegistry();
    Bre(r), kre(r).forEach((o, s) => {
      const u = Hre(o, s, i, r), d = {
        type: IE,
        payload: {
          dropResult: Ure({}, t, u)
        }
      };
      n.dispatch(d);
    });
  };
}
function Bre(n) {
  Hn(n.isDragging(), "Cannot call drop while not dragging."), Hn(!n.didDrop(), "Cannot call drop twice during one drag operation.");
}
function Hre(n, e, t, r) {
  const i = t.getTarget(n);
  let a = i ? i.drop(r, n) : void 0;
  return Vre(a), typeof a > "u" && (a = e === 0 ? {} : r.getDropResult()), a;
}
function Vre(n) {
  Hn(typeof n > "u" || p4(n), "Drop result must either be an object or undefined.");
}
function kre(n) {
  const e = n.getTargetIds().filter(n.canDropOnTarget, n);
  return e.reverse(), e;
}
function $re(n) {
  return function() {
    const t = n.getMonitor(), r = n.getRegistry();
    Wre(t);
    const i = t.getSourceId();
    return i != null && (r.getSource(i, !0).endDrag(t, i), r.unpinSource()), {
      type: NE
    };
  };
}
function Wre(n) {
  Hn(n.isDragging(), "Cannot call endDrag while not dragging.");
}
function YR(n, e) {
  return e === null ? n === null : Array.isArray(n) ? n.some(
    (t) => t === e
  ) : n === e;
}
function jre(n) {
  return function(t, { clientOffset: r } = {}) {
    Gre(t);
    const i = t.slice(0), a = n.getMonitor(), o = n.getRegistry(), s = a.getItemType();
    return qre(i, o, s), Xre(i, a, o), Yre(i, a, o), {
      type: DE,
      payload: {
        targetIds: i,
        clientOffset: r || null
      }
    };
  };
}
function Gre(n) {
  Hn(Array.isArray(n), "Expected targetIds to be an array.");
}
function Xre(n, e, t) {
  Hn(e.isDragging(), "Cannot call hover while not dragging."), Hn(!e.didDrop(), "Cannot call hover after drop.");
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    Hn(n.lastIndexOf(i) === r, "Expected targetIds to be unique in the passed array.");
    const a = t.getTarget(i);
    Hn(a, "Expected targetIds to be registered.");
  }
}
function qre(n, e, t) {
  for (let r = n.length - 1; r >= 0; r--) {
    const i = n[r], a = e.getTargetType(i);
    YR(a, t) || n.splice(r, 1);
  }
}
function Yre(n, e, t) {
  n.forEach(function(r) {
    t.getTarget(r).hover(e, r);
  });
}
function Kre(n) {
  return function() {
    if (n.getMonitor().isDragging())
      return {
        type: RO
      };
  };
}
function Zre(n) {
  return {
    beginDrag: Pre(n),
    publishDragSource: Kre(n),
    hover: jre(n),
    drop: zre(n),
    endDrag: $re(n)
  };
}
class Qre {
  receiveBackend(e) {
    this.backend = e;
  }
  getMonitor() {
    return this.monitor;
  }
  getBackend() {
    return this.backend;
  }
  getRegistry() {
    return this.monitor.registry;
  }
  getActions() {
    const e = this, { dispatch: t } = this.store;
    function r(a) {
      return (...o) => {
        const s = a.apply(e, o);
        typeof s < "u" && t(s);
      };
    }
    const i = Zre(this);
    return Object.keys(i).reduce((a, o) => {
      const s = i[o];
      return a[o] = r(s), a;
    }, {});
  }
  dispatch(e) {
    this.store.dispatch(e);
  }
  constructor(e, t) {
    this.isSetUp = !1, this.handleRefCountChange = () => {
      const r = this.store.getState().refCount > 0;
      this.backend && (r && !this.isSetUp ? (this.backend.setup(), this.isSetUp = !0) : !r && this.isSetUp && (this.backend.teardown(), this.isSetUp = !1));
    }, this.store = e, this.monitor = t, e.subscribe(this.handleRefCountChange);
  }
}
function Jre(n, e) {
  return {
    x: n.x + e.x,
    y: n.y + e.y
  };
}
function m4(n, e) {
  return {
    x: n.x - e.x,
    y: n.y - e.y
  };
}
function eie(n) {
  const { clientOffset: e, initialClientOffset: t, initialSourceClientOffset: r } = n;
  return !e || !t || !r ? null : m4(Jre(e, r), t);
}
function tie(n) {
  const { clientOffset: e, initialClientOffset: t } = n;
  return !e || !t ? null : m4(e, t);
}
const Ty = [], AO = [];
Ty.__IS_NONE__ = !0;
AO.__IS_ALL__ = !0;
function nie(n, e) {
  return n === Ty ? !1 : n === AO || typeof e > "u" ? !0 : Are(e, n).length > 0;
}
class rie {
  subscribeToStateChange(e, t = {}) {
    const { handlerIds: r } = t;
    Hn(typeof e == "function", "listener must be a function."), Hn(typeof r > "u" || Array.isArray(r), "handlerIds, when specified, must be an array of strings.");
    let i = this.store.getState().stateId;
    const a = () => {
      const o = this.store.getState(), s = o.stateId;
      try {
        s === i || s === i + 1 && !nie(o.dirtyHandlerIds, r) || e();
      } finally {
        i = s;
      }
    };
    return this.store.subscribe(a);
  }
  subscribeToOffsetChange(e) {
    Hn(typeof e == "function", "listener must be a function.");
    let t = this.store.getState().dragOffset;
    const r = () => {
      const i = this.store.getState().dragOffset;
      i !== t && (t = i, e());
    };
    return this.store.subscribe(r);
  }
  canDragSource(e) {
    if (!e)
      return !1;
    const t = this.registry.getSource(e);
    return Hn(t, `Expected to find a valid source. sourceId=${e}`), this.isDragging() ? !1 : t.canDrag(this, e);
  }
  canDropOnTarget(e) {
    if (!e)
      return !1;
    const t = this.registry.getTarget(e);
    if (Hn(t, `Expected to find a valid target. targetId=${e}`), !this.isDragging() || this.didDrop())
      return !1;
    const r = this.registry.getTargetType(e), i = this.getItemType();
    return YR(r, i) && t.canDrop(this, e);
  }
  isDragging() {
    return !!this.getItemType();
  }
  isDraggingSource(e) {
    if (!e)
      return !1;
    const t = this.registry.getSource(e, !0);
    if (Hn(t, `Expected to find a valid source. sourceId=${e}`), !this.isDragging() || !this.isSourcePublic())
      return !1;
    const r = this.registry.getSourceType(e), i = this.getItemType();
    return r !== i ? !1 : t.isDragging(this, e);
  }
  isOverTarget(e, t = {
    shallow: !1
  }) {
    if (!e)
      return !1;
    const { shallow: r } = t;
    if (!this.isDragging())
      return !1;
    const i = this.registry.getTargetType(e), a = this.getItemType();
    if (a && !YR(i, a))
      return !1;
    const o = this.getTargetIds();
    if (!o.length)
      return !1;
    const s = o.indexOf(e);
    return r ? s === o.length - 1 : s > -1;
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType;
  }
  getItem() {
    return this.store.getState().dragOperation.item;
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId;
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds;
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult;
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop;
  }
  isSourcePublic() {
    return !!this.store.getState().dragOperation.isSourcePublic;
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset;
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset;
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset;
  }
  getSourceClientOffset() {
    return eie(this.store.getState().dragOffset);
  }
  getDifferenceFromInitialOffset() {
    return tie(this.store.getState().dragOffset);
  }
  constructor(e, t) {
    this.store = e, this.registry = t;
  }
}
const c3 = typeof mh < "u" ? mh : self, g4 = c3.MutationObserver || c3.WebKitMutationObserver;
function v4(n) {
  return function() {
    const t = setTimeout(i, 0), r = setInterval(i, 50);
    function i() {
      clearTimeout(t), clearInterval(r), n();
    }
  };
}
function iie(n) {
  let e = 1;
  const t = new g4(n), r = document.createTextNode("");
  return t.observe(r, {
    characterData: !0
  }), function() {
    e = -e, r.data = e;
  };
}
const aie = typeof g4 == "function" ? (
  // reliably everywhere they are implemented.
  // They are implemented in all modern browsers.
  //
  // - Android 4-4.3
  // - Chrome 26-34
  // - Firefox 14-29
  // - Internet Explorer 11
  // - iPad Safari 6-7.1
  // - iPhone Safari 7-7.1
  // - Safari 6-7
  iie
) : (
  // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
  // 11-12, and in web workers in many engines.
  // Although message channels yield to any queued rendering and IO tasks, they
  // would be better than imposing the 4ms delay of timers.
  // However, they do not work reliably in Internet Explorer or Safari.
  // Internet Explorer 10 is the only browser that has setImmediate but does
  // not have MutationObservers.
  // Although setImmediate yields to the browser's renderer, it would be
  // preferrable to falling back to setTimeout since it does not have
  // the minimum 4ms penalty.
  // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
  // Desktop to a lesser extent) that renders both setImmediate and
  // MessageChannel useless for the purposes of ASAP.
  // https://github.com/kriskowal/q/issues/396
  // Timers are implemented universally.
  // We fall back to timers in workers in most engines, and in foreground
  // contexts in the following browsers.
  // However, note that even this simple case requires nuances to operate in a
  // broad spectrum of browsers.
  //
  // - Firefox 3-13
  // - Internet Explorer 6-9
  // - iPad Safari 4.3
  // - Lynx 2.8.7
  v4
);
class oie {
  // Use the fastest means possible to execute a task in its own turn, with
  // priority over other events including IO, animation, reflow, and redraw
  // events in browsers.
  //
  // An exception thrown by a task will permanently interrupt the processing of
  // subsequent tasks. The higher level `asap` function ensures that if an
  // exception is thrown by a task, that the task queue will continue flushing as
  // soon as possible, but if you use `rawAsap` directly, you are responsible to
  // either ensure that no exceptions are thrown from your task, or to manually
  // call `rawAsap.requestFlush` if an exception is thrown.
  enqueueTask(e) {
    const { queue: t, requestFlush: r } = this;
    t.length || (r(), this.flushing = !0), t[t.length] = e;
  }
  constructor() {
    this.queue = [], this.pendingErrors = [], this.flushing = !1, this.index = 0, this.capacity = 1024, this.flush = () => {
      const { queue: e } = this;
      for (; this.index < e.length; ) {
        const t = this.index;
        if (this.index++, e[t].call(), this.index > this.capacity) {
          for (let r = 0, i = e.length - this.index; r < i; r++)
            e[r] = e[r + this.index];
          e.length -= this.index, this.index = 0;
        }
      }
      e.length = 0, this.index = 0, this.flushing = !1;
    }, this.registerPendingError = (e) => {
      this.pendingErrors.push(e), this.requestErrorThrow();
    }, this.requestFlush = aie(this.flush), this.requestErrorThrow = v4(() => {
      if (this.pendingErrors.length)
        throw this.pendingErrors.shift();
    });
  }
}
class sie {
  call() {
    try {
      this.task && this.task();
    } catch (e) {
      this.onError(e);
    } finally {
      this.task = null, this.release(this);
    }
  }
  constructor(e, t) {
    this.onError = e, this.release = t, this.task = null;
  }
}
class lie {
  create(e) {
    const t = this.freeTasks, r = t.length ? t.pop() : new sie(
      this.onError,
      (i) => t[t.length] = i
    );
    return r.task = e, r;
  }
  constructor(e) {
    this.onError = e, this.freeTasks = [];
  }
}
const y4 = new oie(), cie = new lie(y4.registerPendingError);
function uie(n) {
  y4.enqueueTask(cie.create(n));
}
const OO = "dnd-core/ADD_SOURCE", PO = "dnd-core/ADD_TARGET", DO = "dnd-core/REMOVE_SOURCE", LE = "dnd-core/REMOVE_TARGET";
function die(n) {
  return {
    type: OO,
    payload: {
      sourceId: n
    }
  };
}
function fie(n) {
  return {
    type: PO,
    payload: {
      targetId: n
    }
  };
}
function hie(n) {
  return {
    type: DO,
    payload: {
      sourceId: n
    }
  };
}
function pie(n) {
  return {
    type: LE,
    payload: {
      targetId: n
    }
  };
}
function mie(n) {
  Hn(typeof n.canDrag == "function", "Expected canDrag to be a function."), Hn(typeof n.beginDrag == "function", "Expected beginDrag to be a function."), Hn(typeof n.endDrag == "function", "Expected endDrag to be a function.");
}
function gie(n) {
  Hn(typeof n.canDrop == "function", "Expected canDrop to be a function."), Hn(typeof n.hover == "function", "Expected hover to be a function."), Hn(typeof n.drop == "function", "Expected beginDrag to be a function.");
}
function KR(n, e) {
  if (e && Array.isArray(n)) {
    n.forEach(
      (t) => KR(t, !1)
    );
    return;
  }
  Hn(typeof n == "string" || typeof n == "symbol", e ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var Gs;
(function(n) {
  n.SOURCE = "SOURCE", n.TARGET = "TARGET";
})(Gs || (Gs = {}));
let vie = 0;
function yie() {
  return vie++;
}
function bie(n) {
  const e = yie().toString();
  switch (n) {
    case Gs.SOURCE:
      return `S${e}`;
    case Gs.TARGET:
      return `T${e}`;
    default:
      throw new Error(`Unknown Handler Role: ${n}`);
  }
}
function u3(n) {
  switch (n[0]) {
    case "S":
      return Gs.SOURCE;
    case "T":
      return Gs.TARGET;
    default:
      throw new Error(`Cannot parse handler ID: ${n}`);
  }
}
function d3(n, e) {
  const t = n.entries();
  let r = !1;
  do {
    const { done: i, value: [, a] } = t.next();
    if (a === e)
      return !0;
    r = !!i;
  } while (!r);
  return !1;
}
class Sie {
  addSource(e, t) {
    KR(e), mie(t);
    const r = this.addHandler(Gs.SOURCE, e, t);
    return this.store.dispatch(die(r)), r;
  }
  addTarget(e, t) {
    KR(e, !0), gie(t);
    const r = this.addHandler(Gs.TARGET, e, t);
    return this.store.dispatch(fie(r)), r;
  }
  containsHandler(e) {
    return d3(this.dragSources, e) || d3(this.dropTargets, e);
  }
  getSource(e, t = !1) {
    return Hn(this.isSourceId(e), "Expected a valid source ID."), t && e === this.pinnedSourceId ? this.pinnedSource : this.dragSources.get(e);
  }
  getTarget(e) {
    return Hn(this.isTargetId(e), "Expected a valid target ID."), this.dropTargets.get(e);
  }
  getSourceType(e) {
    return Hn(this.isSourceId(e), "Expected a valid source ID."), this.types.get(e);
  }
  getTargetType(e) {
    return Hn(this.isTargetId(e), "Expected a valid target ID."), this.types.get(e);
  }
  isSourceId(e) {
    return u3(e) === Gs.SOURCE;
  }
  isTargetId(e) {
    return u3(e) === Gs.TARGET;
  }
  removeSource(e) {
    Hn(this.getSource(e), "Expected an existing source."), this.store.dispatch(hie(e)), uie(() => {
      this.dragSources.delete(e), this.types.delete(e);
    });
  }
  removeTarget(e) {
    Hn(this.getTarget(e), "Expected an existing target."), this.store.dispatch(pie(e)), this.dropTargets.delete(e), this.types.delete(e);
  }
  pinSource(e) {
    const t = this.getSource(e);
    Hn(t, "Expected an existing source."), this.pinnedSourceId = e, this.pinnedSource = t;
  }
  unpinSource() {
    Hn(this.pinnedSource, "No source is pinned at the time."), this.pinnedSourceId = null, this.pinnedSource = null;
  }
  addHandler(e, t, r) {
    const i = bie(e);
    return this.types.set(i, t), e === Gs.SOURCE ? this.dragSources.set(i, r) : e === Gs.TARGET && this.dropTargets.set(i, r), i;
  }
  constructor(e) {
    this.types = /* @__PURE__ */ new Map(), this.dragSources = /* @__PURE__ */ new Map(), this.dropTargets = /* @__PURE__ */ new Map(), this.pinnedSourceId = null, this.pinnedSource = null, this.store = e;
  }
}
const _ie = (n, e) => n === e;
function xie(n, e) {
  return !n && !e ? !0 : !n || !e ? !1 : n.x === e.x && n.y === e.y;
}
function Eie(n, e, t = _ie) {
  if (n.length !== e.length)
    return !1;
  for (let r = 0; r < n.length; ++r)
    if (!t(n[r], e[r]))
      return !1;
  return !0;
}
function Cie(n = Ty, e) {
  switch (e.type) {
    case DE:
      break;
    case OO:
    case PO:
    case LE:
    case DO:
      return Ty;
    case PE:
    case RO:
    case NE:
    case IE:
    default:
      return AO;
  }
  const { targetIds: t = [], prevTargetIds: r = [] } = e.payload, i = Rre(t, r);
  if (!(i.length > 0 || !Eie(t, r)))
    return Ty;
  const o = r[r.length - 1], s = t[t.length - 1];
  return o !== s && (o && i.push(o), s && i.push(s)), i;
}
function wie(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Mie(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}, r = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(t).filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    }))), r.forEach(function(i) {
      wie(n, i, t[i]);
    });
  }
  return n;
}
const f3 = {
  initialSourceClientOffset: null,
  initialClientOffset: null,
  clientOffset: null
};
function Tie(n = f3, e) {
  const { payload: t } = e;
  switch (e.type) {
    case TO:
    case PE:
      return {
        initialSourceClientOffset: t.sourceClientOffset,
        initialClientOffset: t.clientOffset,
        clientOffset: t.clientOffset
      };
    case DE:
      return xie(n.clientOffset, t.clientOffset) ? n : Mie({}, n, {
        clientOffset: t.clientOffset
      });
    case NE:
    case IE:
      return f3;
    default:
      return n;
  }
}
function Rie(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function sm(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}, r = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(t).filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    }))), r.forEach(function(i) {
      Rie(n, i, t[i]);
    });
  }
  return n;
}
const Aie = {
  itemType: null,
  item: null,
  sourceId: null,
  targetIds: [],
  dropResult: null,
  didDrop: !1,
  isSourcePublic: null
};
function Oie(n = Aie, e) {
  const { payload: t } = e;
  switch (e.type) {
    case PE:
      return sm({}, n, {
        itemType: t.itemType,
        item: t.item,
        sourceId: t.sourceId,
        isSourcePublic: t.isSourcePublic,
        dropResult: null,
        didDrop: !1
      });
    case RO:
      return sm({}, n, {
        isSourcePublic: !0
      });
    case DE:
      return sm({}, n, {
        targetIds: t.targetIds
      });
    case LE:
      return n.targetIds.indexOf(t.targetId) === -1 ? n : sm({}, n, {
        targetIds: Tre(n.targetIds, t.targetId)
      });
    case IE:
      return sm({}, n, {
        dropResult: t.dropResult,
        didDrop: !0,
        targetIds: []
      });
    case NE:
      return sm({}, n, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: !1,
        isSourcePublic: null,
        targetIds: []
      });
    default:
      return n;
  }
}
function Pie(n = 0, e) {
  switch (e.type) {
    case OO:
    case PO:
      return n + 1;
    case DO:
    case LE:
      return n - 1;
    default:
      return n;
  }
}
function Die(n = 0) {
  return n + 1;
}
function Iie(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Nie(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}, r = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(t).filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    }))), r.forEach(function(i) {
      Iie(n, i, t[i]);
    });
  }
  return n;
}
function Lie(n = {}, e) {
  return {
    dirtyHandlerIds: Cie(n.dirtyHandlerIds, {
      type: e.type,
      payload: Nie({}, e.payload, {
        prevTargetIds: Mre(n, "dragOperation.targetIds", [])
      })
    }),
    dragOffset: Tie(n.dragOffset, e),
    refCount: Pie(n.refCount, e),
    dragOperation: Oie(n.dragOperation, e),
    stateId: Die(n.stateId)
  };
}
function Fie(n, e = void 0, t = {}, r = !1) {
  const i = Uie(r), a = new rie(i, new Sie(i)), o = new Qre(i, a), s = n(o, e, t);
  return o.receiveBackend(s), o;
}
function Uie(n) {
  const e = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION__;
  return h4(Lie, n && e && e({
    name: "dnd-core",
    instanceId: "dnd-core"
  }));
}
function zie(n, e) {
  if (n == null) return {};
  var t = Bie(n, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(n);
    for (i = 0; i < a.length; i++)
      r = a[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
function Bie(n, e) {
  if (n == null) return {};
  var t = {}, r = Object.keys(n), i, a;
  for (a = 0; a < r.length; a++)
    i = r[a], !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
let h3 = 0;
const rx = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var Hie = /* @__PURE__ */ H8(function(e) {
  var { children: t } = e, r = zie(e, [
    "children"
  ]);
  const [i, a] = Vie(r);
  return In(() => {
    if (a) {
      const o = b4();
      return ++h3, () => {
        --h3 === 0 && (o[rx] = null);
      };
    }
  }, []), /* @__PURE__ */ zt.jsx(f4.Provider, {
    value: i,
    children: t
  });
});
function Vie(n) {
  if ("manager" in n)
    return [
      {
        dragDropManager: n.manager
      },
      !1
    ];
  const e = kie(n.backend, n.context, n.options, n.debugMode), t = !n.context;
  return [
    e,
    t
  ];
}
function kie(n, e = b4(), t, r) {
  const i = e;
  return i[rx] || (i[rx] = {
    dragDropManager: Fie(n, e, t, r)
  }), i[rx];
}
function b4() {
  return typeof mh < "u" ? mh : window;
}
var $ie = function n(e, t) {
  if (e === t) return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor) return !1;
    var r, i, a;
    if (Array.isArray(e)) {
      if (r = e.length, r != t.length) return !1;
      for (i = r; i-- !== 0; )
        if (!n(e[i], t[i])) return !1;
      return !0;
    }
    if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString) return e.toString() === t.toString();
    if (a = Object.keys(e), r = a.length, r !== Object.keys(t).length) return !1;
    for (i = r; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, a[i])) return !1;
    for (i = r; i-- !== 0; ) {
      var o = a[i];
      if (!n(e[o], t[o])) return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
};
const Wie = /* @__PURE__ */ y0($ie), Ih = typeof window < "u" ? xA : In;
function jie(n, e, t) {
  const [r, i] = Lr(
    () => e(n)
  ), a = Mh(() => {
    const o = e(n);
    Wie(r, o) || (i(o), t && t());
  }, [
    r,
    n,
    t
  ]);
  return Ih(a), [
    r,
    a
  ];
}
function Gie(n, e, t) {
  const [r, i] = jie(n, e, t);
  return Ih(function() {
    const o = n.getHandlerId();
    if (o != null)
      return n.subscribeToStateChange(i, {
        handlerIds: [
          o
        ]
      });
  }, [
    n,
    i
  ]), r;
}
function S4(n, e, t) {
  return Gie(
    e,
    n || (() => ({})),
    () => t.reconnect()
  );
}
function _4(n, e) {
  const t = [];
  return typeof n != "function" && t.push(n), Mr(() => typeof n == "function" ? n() : n, t);
}
function Xie(n) {
  return Mr(
    () => n.hooks.dragSource(),
    [
      n
    ]
  );
}
function qie(n) {
  return Mr(
    () => n.hooks.dragPreview(),
    [
      n
    ]
  );
}
let yM = !1, bM = !1;
class Yie {
  receiveHandlerId(e) {
    this.sourceId = e;
  }
  getHandlerId() {
    return this.sourceId;
  }
  canDrag() {
    Hn(!yM, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      return yM = !0, this.internalMonitor.canDragSource(this.sourceId);
    } finally {
      yM = !1;
    }
  }
  isDragging() {
    if (!this.sourceId)
      return !1;
    Hn(!bM, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      return bM = !0, this.internalMonitor.isDraggingSource(this.sourceId);
    } finally {
      bM = !1;
    }
  }
  subscribeToStateChange(e, t) {
    return this.internalMonitor.subscribeToStateChange(e, t);
  }
  isDraggingSource(e) {
    return this.internalMonitor.isDraggingSource(e);
  }
  isOverTarget(e, t) {
    return this.internalMonitor.isOverTarget(e, t);
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds();
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic();
  }
  getSourceId() {
    return this.internalMonitor.getSourceId();
  }
  subscribeToOffsetChange(e) {
    return this.internalMonitor.subscribeToOffsetChange(e);
  }
  canDragSource(e) {
    return this.internalMonitor.canDragSource(e);
  }
  canDropOnTarget(e) {
    return this.internalMonitor.canDropOnTarget(e);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(e) {
    this.sourceId = null, this.internalMonitor = e.getMonitor();
  }
}
let SM = !1;
class Kie {
  receiveHandlerId(e) {
    this.targetId = e;
  }
  getHandlerId() {
    return this.targetId;
  }
  subscribeToStateChange(e, t) {
    return this.internalMonitor.subscribeToStateChange(e, t);
  }
  canDrop() {
    if (!this.targetId)
      return !1;
    Hn(!SM, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    try {
      return SM = !0, this.internalMonitor.canDropOnTarget(this.targetId);
    } finally {
      SM = !1;
    }
  }
  isOver(e) {
    return this.targetId ? this.internalMonitor.isOverTarget(this.targetId, e) : !1;
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(e) {
    this.targetId = null, this.internalMonitor = e.getMonitor();
  }
}
function Zie(n, e, t) {
  const r = t.getRegistry(), i = r.addTarget(n, e);
  return [
    i,
    () => r.removeTarget(i)
  ];
}
function Qie(n, e, t) {
  const r = t.getRegistry(), i = r.addSource(n, e);
  return [
    i,
    () => r.removeSource(i)
  ];
}
function ZR(n, e, t, r) {
  let i;
  if (i !== void 0)
    return !!i;
  if (n === e)
    return !0;
  if (typeof n != "object" || !n || typeof e != "object" || !e)
    return !1;
  const a = Object.keys(n), o = Object.keys(e);
  if (a.length !== o.length)
    return !1;
  const s = Object.prototype.hasOwnProperty.bind(e);
  for (let u = 0; u < a.length; u++) {
    const d = a[u];
    if (!s(d))
      return !1;
    const f = n[d], p = e[d];
    if (i = void 0, i === !1 || i === void 0 && f !== p)
      return !1;
  }
  return !0;
}
function QR(n) {
  return (
    // eslint-disable-next-line no-prototype-builtins
    n !== null && typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
  );
}
function Jie(n) {
  if (typeof n.type == "string")
    return;
  const e = n.type.displayName || n.type.name || "the component";
  throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${e} into a <div>, or turn it into a drag source or a drop target itself.`);
}
function eae(n) {
  return (e = null, t = null) => {
    if (!AU(e)) {
      const a = e;
      return n(a, t), a;
    }
    const r = e;
    return Jie(r), tae(r, t ? (a) => n(a, t) : n);
  };
}
function x4(n) {
  const e = {};
  return Object.keys(n).forEach((t) => {
    const r = n[t];
    if (t.endsWith("Ref"))
      e[t] = n[t];
    else {
      const i = eae(r);
      e[t] = () => i;
    }
  }), e;
}
function p3(n, e) {
  typeof n == "function" ? n(e) : n.current = e;
}
function tae(n, e) {
  const t = n.ref;
  return Hn(typeof t != "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"), t ? OT(n, {
    ref: (r) => {
      p3(t, r), p3(e, r);
    }
  }) : OT(n, {
    ref: e
  });
}
class nae {
  receiveHandlerId(e) {
    this.handlerId !== e && (this.handlerId = e, this.reconnect());
  }
  get connectTarget() {
    return this.dragSource;
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal;
  }
  set dragSourceOptions(e) {
    this.dragSourceOptionsInternal = e;
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal;
  }
  set dragPreviewOptions(e) {
    this.dragPreviewOptionsInternal = e;
  }
  reconnect() {
    const e = this.reconnectDragSource();
    this.reconnectDragPreview(e);
  }
  reconnectDragSource() {
    const e = this.dragSource, t = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
    return t && this.disconnectDragSource(), this.handlerId ? e ? (t && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragSource = e, this.lastConnectedDragSourceOptions = this.dragSourceOptions, this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, e, this.dragSourceOptions)), t) : (this.lastConnectedDragSource = e, t) : t;
  }
  reconnectDragPreview(e = !1) {
    const t = this.dragPreview, r = e || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
    if (r && this.disconnectDragPreview(), !!this.handlerId) {
      if (!t) {
        this.lastConnectedDragPreview = t;
        return;
      }
      r && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragPreview = t, this.lastConnectedDragPreviewOptions = this.dragPreviewOptions, this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, t, this.dragPreviewOptions));
    }
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource;
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview;
  }
  didDragSourceOptionsChange() {
    return !ZR(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
  }
  didDragPreviewOptionsChange() {
    return !ZR(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
  }
  disconnectDragSource() {
    this.dragSourceUnsubscribe && (this.dragSourceUnsubscribe(), this.dragSourceUnsubscribe = void 0);
  }
  disconnectDragPreview() {
    this.dragPreviewUnsubscribe && (this.dragPreviewUnsubscribe(), this.dragPreviewUnsubscribe = void 0, this.dragPreviewNode = null, this.dragPreviewRef = null);
  }
  get dragSource() {
    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
  }
  get dragPreview() {
    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
  }
  clearDragSource() {
    this.dragSourceNode = null, this.dragSourceRef = null;
  }
  clearDragPreview() {
    this.dragPreviewNode = null, this.dragPreviewRef = null;
  }
  constructor(e) {
    this.hooks = x4({
      dragSource: (t, r) => {
        this.clearDragSource(), this.dragSourceOptions = r || null, QR(t) ? this.dragSourceRef = t : this.dragSourceNode = t, this.reconnectDragSource();
      },
      dragPreview: (t, r) => {
        this.clearDragPreview(), this.dragPreviewOptions = r || null, QR(t) ? this.dragPreviewRef = t : this.dragPreviewNode = t, this.reconnectDragPreview();
      }
    }), this.handlerId = null, this.dragSourceRef = null, this.dragSourceOptionsInternal = null, this.dragPreviewRef = null, this.dragPreviewOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDragSource = null, this.lastConnectedDragSourceOptions = null, this.lastConnectedDragPreview = null, this.lastConnectedDragPreviewOptions = null, this.backend = e;
  }
}
class rae {
  get connectTarget() {
    return this.dropTarget;
  }
  reconnect() {
    const e = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
    e && this.disconnectDropTarget();
    const t = this.dropTarget;
    if (this.handlerId) {
      if (!t) {
        this.lastConnectedDropTarget = t;
        return;
      }
      e && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDropTarget = t, this.lastConnectedDropTargetOptions = this.dropTargetOptions, this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, t, this.dropTargetOptions));
    }
  }
  receiveHandlerId(e) {
    e !== this.handlerId && (this.handlerId = e, this.reconnect());
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal;
  }
  set dropTargetOptions(e) {
    this.dropTargetOptionsInternal = e;
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget;
  }
  didOptionsChange() {
    return !ZR(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
  }
  disconnectDropTarget() {
    this.unsubscribeDropTarget && (this.unsubscribeDropTarget(), this.unsubscribeDropTarget = void 0);
  }
  get dropTarget() {
    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
  }
  clearDropTarget() {
    this.dropTargetRef = null, this.dropTargetNode = null;
  }
  constructor(e) {
    this.hooks = x4({
      dropTarget: (t, r) => {
        this.clearDropTarget(), this.dropTargetOptions = r, QR(t) ? this.dropTargetRef = t : this.dropTargetNode = t, this.reconnect();
      }
    }), this.handlerId = null, this.dropTargetRef = null, this.dropTargetOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDropTarget = null, this.lastConnectedDropTargetOptions = null, this.backend = e;
  }
}
function Sg() {
  const { dragDropManager: n } = ni(f4);
  return Hn(n != null, "Expected drag drop context"), n;
}
function iae(n, e) {
  const t = Sg(), r = Mr(
    () => new nae(t.getBackend()),
    [
      t
    ]
  );
  return Ih(() => (r.dragSourceOptions = n || null, r.reconnect(), () => r.disconnectDragSource()), [
    r,
    n
  ]), Ih(() => (r.dragPreviewOptions = e || null, r.reconnect(), () => r.disconnectDragPreview()), [
    r,
    e
  ]), r;
}
function aae() {
  const n = Sg();
  return Mr(
    () => new Yie(n),
    [
      n
    ]
  );
}
class oae {
  beginDrag() {
    const e = this.spec, t = this.monitor;
    let r = null;
    return typeof e.item == "object" ? r = e.item : typeof e.item == "function" ? r = e.item(t) : r = {}, r ?? null;
  }
  canDrag() {
    const e = this.spec, t = this.monitor;
    return typeof e.canDrag == "boolean" ? e.canDrag : typeof e.canDrag == "function" ? e.canDrag(t) : !0;
  }
  isDragging(e, t) {
    const r = this.spec, i = this.monitor, { isDragging: a } = r;
    return a ? a(i) : t === e.getSourceId();
  }
  endDrag() {
    const e = this.spec, t = this.monitor, r = this.connector, { end: i } = e;
    i && i(t.getItem(), t), r.reconnect();
  }
  constructor(e, t, r) {
    this.spec = e, this.monitor = t, this.connector = r;
  }
}
function sae(n, e, t) {
  const r = Mr(
    () => new oae(n, e, t),
    [
      e,
      t
    ]
  );
  return In(() => {
    r.spec = n;
  }, [
    n
  ]), r;
}
function lae(n) {
  return Mr(() => {
    const e = n.type;
    return Hn(e != null, "spec.type must be defined"), e;
  }, [
    n
  ]);
}
function cae(n, e, t) {
  const r = Sg(), i = sae(n, e, t), a = lae(n);
  Ih(function() {
    if (a != null) {
      const [s, u] = Qie(a, i, r);
      return e.receiveHandlerId(s), t.receiveHandlerId(s), u;
    }
  }, [
    r,
    e,
    t,
    i,
    a
  ]);
}
function uae(n, e) {
  const t = _4(n);
  Hn(!t.begin, "useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");
  const r = aae(), i = iae(t.options, t.previewOptions);
  return cae(t, r, i), [
    S4(t.collect, r, i),
    Xie(i),
    qie(i)
  ];
}
function dae(n) {
  return Mr(
    () => n.hooks.dropTarget(),
    [
      n
    ]
  );
}
function fae(n) {
  const e = Sg(), t = Mr(
    () => new rae(e.getBackend()),
    [
      e
    ]
  );
  return Ih(() => (t.dropTargetOptions = n || null, t.reconnect(), () => t.disconnectDropTarget()), [
    n
  ]), t;
}
function hae() {
  const n = Sg();
  return Mr(
    () => new Kie(n),
    [
      n
    ]
  );
}
function pae(n) {
  const { accept: e } = n;
  return Mr(() => (Hn(n.accept != null, "accept must be defined"), Array.isArray(e) ? e : [
    e
  ]), [
    e
  ]);
}
class mae {
  canDrop() {
    const e = this.spec, t = this.monitor;
    return e.canDrop ? e.canDrop(t.getItem(), t) : !0;
  }
  hover() {
    const e = this.spec, t = this.monitor;
    e.hover && e.hover(t.getItem(), t);
  }
  drop() {
    const e = this.spec, t = this.monitor;
    if (e.drop)
      return e.drop(t.getItem(), t);
  }
  constructor(e, t) {
    this.spec = e, this.monitor = t;
  }
}
function gae(n, e) {
  const t = Mr(
    () => new mae(n, e),
    [
      e
    ]
  );
  return In(() => {
    t.spec = n;
  }, [
    n
  ]), t;
}
function vae(n, e, t) {
  const r = Sg(), i = gae(n, e), a = pae(n);
  Ih(function() {
    const [s, u] = Zie(a, i, r);
    return e.receiveHandlerId(s), t.receiveHandlerId(s), u;
  }, [
    r,
    e,
    i,
    t,
    a.map(
      (o) => o.toString()
    ).join("|")
  ]);
}
function yae(n, e) {
  const t = _4(n), r = hae(), i = fae(t.options);
  return vae(t, r, i), [
    S4(t.collect, r, i),
    dae(i)
  ];
}
const bae = ({ children: n }) => /* @__PURE__ */ zt.jsx(Hie, { backend: bre, children: n }), Sae = Ai.div`
  height: fit-content;
`, E4 = (n) => {
  const { object3D: e, children: t } = n, { objectTypeId: r } = e, [{ isDragging: i }, a] = uae({
    type: r,
    item: e,
    collect: (o) => ({
      isDragging: o.isDragging()
    })
  });
  return /* @__PURE__ */ zt.jsx(
    Sae,
    {
      ref: a,
      style: { opacity: i ? 0.5 : 1 },
      children: t
    }
  );
};
var Aa = [];
for (var _M = 0; _M < 256; ++_M)
  Aa.push((_M + 256).toString(16).slice(1));
function _ae(n, e = 0) {
  return (Aa[n[e + 0]] + Aa[n[e + 1]] + Aa[n[e + 2]] + Aa[n[e + 3]] + "-" + Aa[n[e + 4]] + Aa[n[e + 5]] + "-" + Aa[n[e + 6]] + Aa[n[e + 7]] + "-" + Aa[n[e + 8]] + Aa[n[e + 9]] + "-" + Aa[n[e + 10]] + Aa[n[e + 11]] + Aa[n[e + 12]] + Aa[n[e + 13]] + Aa[n[e + 14]] + Aa[n[e + 15]]).toLowerCase();
}
var WS, xae = new Uint8Array(16);
function Eae() {
  if (!WS && (WS = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !WS))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return WS(xae);
}
var Cae = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const m3 = {
  randomUUID: Cae
};
function C4(n, e, t) {
  if (m3.randomUUID && !e && !n)
    return m3.randomUUID();
  n = n || {};
  var r = n.random || (n.rng || Eae)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, _ae(r);
}
const wae = C4(), Mae = C4(), Tae = {
  id: wae,
  objectTypeId: "WOOD_DECK",
  title: "RectWoodDeck",
  objectImage: "/images/2d_deck.png",
  onParameterChanged: (n) => n,
  dialogParameters: r4
}, Rae = {
  id: Mae,
  objectTypeId: "L_WOOD_DECK",
  title: "LWoodDeck",
  objectImage: "/images/l_2d_deck.png",
  onParameterChanged: (n) => n,
  dialogParameters: i4
}, Aae = () => [Tae, Rae], Oae = (n) => n.dialogParameters, w4 = {
  getListObject: Aae,
  getDialogParameter: Oae
}, Pae = {
  colors: {
    primary: "#561C24",
    selectedBackground: "#F5EEE6"
  },
  adminHeaderHeight: 60,
  generalSpace: 20,
  adminSidebarWidth: 200,
  headerHeight: 67,
  footerHeight: 140,
  formWidth: 325,
  boxShadow: "0px 4px 22px rgba(0, 0, 0, 0.2)"
}, Dae = Ai.div`
  display: flex;
`, Iae = Ai.div`
  width: 20%;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  background-color: rgb(242, 239, 234);
`, Nae = Ai.img`
  width: 100%;
  cursor: pointer;
  object-fit: contain;
  border-radius: 6px;
  border: 1px solid;
  &:hover {
    box-shadow: ${Pae.boxShadow};
  }
`;
Ai.div`
  width: 80%;
`;
const Lae = Ai.div`
  width: 100%;
  height: 100vh;
`, nme = () => {
  const e = w4.getListObject();
  return /* @__PURE__ */ zt.jsxs(Dae, { children: [
    /* @__PURE__ */ zt.jsx(Iae, { children: e == null ? void 0 : e.map((t) => /* @__PURE__ */ zt.jsx(E4, { object3D: t, children: /* @__PURE__ */ zt.jsx(Nae, { alt: "#", src: t.objectImage }) }, t.id)) }),
    /* @__PURE__ */ zt.jsx("hr", {})
  ] });
}, M4 = (n) => {
  const [e, t] = Lr({ width: 0, height: 0 }), r = Mh(() => {
    setTimeout(() => {
      n.current && t({
        width: n.current.offsetWidth,
        height: n.current.offsetHeight
      });
    }, 1);
  }, [n]);
  return In(() => {
    r();
    const i = new ResizeObserver(r);
    if (n.current) {
      const a = n.current;
      return i.observe(a), () => {
        i.unobserve(a);
      };
    }
  }, [n, r]), e;
};
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const FE = "166", Fae = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Uae = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, T4 = 0, JR = 1, R4 = 2, zae = 3, A4 = 0, UE = 1, Ry = 2, bl = 3, mu = 0, ho = 1, ic = 2, cu = 0, xh = 1, eA = 2, tA = 3, nA = 4, O4 = 5, Ud = 100, P4 = 101, D4 = 102, I4 = 103, N4 = 104, L4 = 200, F4 = 201, U4 = 202, z4 = 203, wx = 204, Mx = 205, B4 = 206, H4 = 207, V4 = 208, k4 = 209, $4 = 210, W4 = 211, j4 = 212, G4 = 213, X4 = 214, q4 = 0, Y4 = 1, K4 = 2, Zy = 3, Z4 = 4, Q4 = 5, J4 = 6, ek = 7, A0 = 0, tk = 1, nk = 2, lc = 0, rk = 1, ik = 2, ak = 3, IO = 4, ok = 5, sk = 6, lk = 7, rA = "attached", ck = "detached", zE = 300, gu = 301, kd = 302, Qy = 303, Jy = 304, _g = 306, e0 = 1e3, Xs = 1001, t0 = 1002, ba = 1003, NO = 1004, Bae = 1004, km = 1005, Hae = 1005, Ki = 1006, Ay = 1007, Vae = 1007, oc = 1008, kae = 1008, Ml = 1009, LO = 1010, FO = 1011, lg = 1012, BE = 1013, vu = 1014, Ho = 1015, xg = 1016, HE = 1017, VE = 1018, Nh = 1020, UO = 35902, zO = 1021, BO = 1022, Xa = 1023, HO = 1024, VO = 1025, Eh = 1026, Lh = 1027, kE = 1028, O0 = 1029, kO = 1030, $E = 1031, $ae = 1032, WE = 1033, Oy = 33776, Py = 33777, Dy = 33778, Iy = 33779, Tx = 35840, Rx = 35841, Ax = 35842, Ox = 35843, Px = 36196, Dx = 37492, Ix = 37496, Nx = 37808, Lx = 37809, Fx = 37810, Ux = 37811, zx = 37812, Bx = 37813, Hx = 37814, Vx = 37815, kx = 37816, $x = 37817, Wx = 37818, jx = 37819, Gx = 37820, Xx = 37821, Ny = 36492, qx = 36494, Yx = 36495, $O = 36283, Kx = 36284, Zx = 36285, Qx = 36286, uk = 2200, dk = 2201, fk = 2202, n0 = 2300, Jx = 2301, ix = 2302, dh = 2400, fh = 2401, r0 = 2402, jE = 2500, WO = 2501, Wae = 0, jae = 1, Gae = 2, hk = 3200, pk = 3201, Xd = 0, mk = 1, ru = "", js = "srgb", xu = "srgb-linear", GE = "display-p3", P0 = "display-p3-linear", i0 = "linear", ei = "srgb", a0 = "rec709", o0 = "p3", Xae = 0, th = 7680, qae = 7681, Yae = 7682, Kae = 7683, Zae = 34055, Qae = 34056, Jae = 5386, eoe = 512, toe = 513, noe = 514, roe = 515, ioe = 516, aoe = 517, ooe = 518, iA = 519, gk = 512, vk = 513, yk = 514, jO = 515, bk = 516, Sk = 517, _k = 518, xk = 519, s0 = 35044, soe = 35048, loe = 35040, coe = 35045, uoe = 35049, doe = 35041, foe = 35046, hoe = 35050, poe = 35042, moe = "100", aA = "300 es", sc = 2e3, l0 = 2001;
let Eu = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const a = i.indexOf(t);
      a !== -1 && i.splice(a, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let a = 0, o = i.length; a < o; a++)
        i[a].call(this, e);
      e.target = null;
    }
  }
};
const Wa = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let g3 = 1234567;
const Ch = Math.PI / 180, cg = 180 / Math.PI;
function ps() {
  const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Wa[n & 255] + Wa[n >> 8 & 255] + Wa[n >> 16 & 255] + Wa[n >> 24 & 255] + "-" + Wa[e & 255] + Wa[e >> 8 & 255] + "-" + Wa[e >> 16 & 15 | 64] + Wa[e >> 24 & 255] + "-" + Wa[t & 63 | 128] + Wa[t >> 8 & 255] + "-" + Wa[t >> 16 & 255] + Wa[t >> 24 & 255] + Wa[r & 255] + Wa[r >> 8 & 255] + Wa[r >> 16 & 255] + Wa[r >> 24 & 255]).toLowerCase();
}
function Ti(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function GO(n, e) {
  return (n % e + e) % e;
}
function goe(n, e, t, r, i) {
  return r + (n - e) * (i - r) / (t - e);
}
function voe(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function Ly(n, e, t) {
  return (1 - t) * n + t * e;
}
function yoe(n, e, t, r) {
  return Ly(n, e, 1 - Math.exp(-t * r));
}
function boe(n, e = 1) {
  return e - Math.abs(GO(n, e * 2) - e);
}
function Soe(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n));
}
function _oe(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10));
}
function xoe(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function Eoe(n, e) {
  return n + Math.random() * (e - n);
}
function Coe(n) {
  return n * (0.5 - Math.random());
}
function woe(n) {
  n !== void 0 && (g3 = n);
  let e = g3 += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function Moe(n) {
  return n * Ch;
}
function Toe(n) {
  return n * cg;
}
function Roe(n) {
  return (n & n - 1) === 0 && n !== 0;
}
function Aoe(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function Ooe(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function Poe(n, e, t, r, i) {
  const a = Math.cos, o = Math.sin, s = a(t / 2), u = o(t / 2), d = a((e + r) / 2), f = o((e + r) / 2), p = a((e - r) / 2), g = o((e - r) / 2), v = a((r - e) / 2), b = o((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(s * f, u * p, u * g, s * d);
      break;
    case "YZY":
      n.set(u * g, s * f, u * p, s * d);
      break;
    case "ZXZ":
      n.set(u * p, u * g, s * f, s * d);
      break;
    case "XZX":
      n.set(s * f, u * b, u * v, s * d);
      break;
    case "YXY":
      n.set(u * v, s * f, u * b, s * d);
      break;
    case "ZYZ":
      n.set(u * b, u * v, s * f, s * d);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function uo(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Bn(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Ek = {
  DEG2RAD: Ch,
  RAD2DEG: cg,
  generateUUID: ps,
  clamp: Ti,
  euclideanModulo: GO,
  mapLinear: goe,
  inverseLerp: voe,
  lerp: Ly,
  damp: yoe,
  pingpong: boe,
  smoothstep: Soe,
  smootherstep: _oe,
  randInt: xoe,
  randFloat: Eoe,
  randFloatSpread: Coe,
  seededRandom: woe,
  degToRad: Moe,
  radToDeg: Toe,
  isPowerOfTwo: Roe,
  ceilPowerOfTwo: Aoe,
  floorPowerOfTwo: Ooe,
  setQuaternionFromProperEuler: Poe,
  normalize: Bn,
  denormalize: uo
};
class St {
  constructor(e = 0, t = 0) {
    St.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * r + i[6], this.y = i[1] * t + i[4] * r + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Ti(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), i = Math.sin(t), a = this.x - e.x, o = this.y - e.y;
    return this.x = a * r - o * i + e.x, this.y = a * i + o * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class zn {
  constructor(e, t, r, i, a, o, s, u, d) {
    zn.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, i, a, o, s, u, d);
  }
  set(e, t, r, i, a, o, s, u, d) {
    const f = this.elements;
    return f[0] = e, f[1] = i, f[2] = s, f[3] = t, f[4] = a, f[5] = u, f[6] = r, f[7] = o, f[8] = d, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, i = t.elements, a = this.elements, o = r[0], s = r[3], u = r[6], d = r[1], f = r[4], p = r[7], g = r[2], v = r[5], b = r[8], E = i[0], S = i[3], _ = i[6], w = i[1], C = i[4], R = i[7], P = i[2], D = i[5], I = i[8];
    return a[0] = o * E + s * w + u * P, a[3] = o * S + s * C + u * D, a[6] = o * _ + s * R + u * I, a[1] = d * E + f * w + p * P, a[4] = d * S + f * C + p * D, a[7] = d * _ + f * R + p * I, a[2] = g * E + v * w + b * P, a[5] = g * S + v * C + b * D, a[8] = g * _ + v * R + b * I, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], u = e[6], d = e[7], f = e[8];
    return t * o * f - t * s * d - r * a * f + r * s * u + i * a * d - i * o * u;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], u = e[6], d = e[7], f = e[8], p = f * o - s * d, g = s * u - f * a, v = d * a - o * u, b = t * p + r * g + i * v;
    if (b === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const E = 1 / b;
    return e[0] = p * E, e[1] = (i * d - f * r) * E, e[2] = (s * r - i * o) * E, e[3] = g * E, e[4] = (f * t - i * u) * E, e[5] = (i * a - s * t) * E, e[6] = v * E, e[7] = (r * u - d * t) * E, e[8] = (o * t - r * a) * E, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, i, a, o, s) {
    const u = Math.cos(a), d = Math.sin(a);
    return this.set(
      r * u,
      r * d,
      -r * (u * o + d * s) + o + e,
      -i * d,
      i * u,
      -i * (-d * o + u * s) + s + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(xM.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(xM.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(xM.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      r,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const xM = /* @__PURE__ */ new zn();
function Ck(n) {
  for (let e = n.length - 1; e >= 0; --e)
    if (n[e] >= 65535) return !0;
  return !1;
}
const Doe = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function $m(n, e) {
  return new Doe[n](e);
}
function c0(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function wk() {
  const n = c0("canvas");
  return n.style.display = "block", n;
}
const v3 = {};
function XO(n) {
  n in v3 || (v3[n] = !0, console.warn(n));
}
function Ioe(n, e, t) {
  return new Promise(function(r, i) {
    function a() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          i();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(a, t);
          break;
        default:
          r();
      }
    }
    setTimeout(a, t);
  });
}
const y3 = /* @__PURE__ */ new zn().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), b3 = /* @__PURE__ */ new zn().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), jS = {
  [xu]: {
    transfer: i0,
    primaries: a0,
    toReference: (n) => n,
    fromReference: (n) => n
  },
  [js]: {
    transfer: ei,
    primaries: a0,
    toReference: (n) => n.convertSRGBToLinear(),
    fromReference: (n) => n.convertLinearToSRGB()
  },
  [P0]: {
    transfer: i0,
    primaries: o0,
    toReference: (n) => n.applyMatrix3(b3),
    fromReference: (n) => n.applyMatrix3(y3)
  },
  [GE]: {
    transfer: ei,
    primaries: o0,
    toReference: (n) => n.convertSRGBToLinear().applyMatrix3(b3),
    fromReference: (n) => n.applyMatrix3(y3).convertLinearToSRGB()
  }
}, Noe = /* @__PURE__ */ new Set([xu, P0]), Cr = {
  enabled: !0,
  _workingColorSpace: xu,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(n) {
    if (!Noe.has(n))
      throw new Error(`Unsupported working color space, "${n}".`);
    this._workingColorSpace = n;
  },
  convert: function(n, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return n;
    const r = jS[e].toReference, i = jS[t].fromReference;
    return i(r(n));
  },
  fromWorkingColorSpace: function(n, e) {
    return this.convert(n, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(n, e) {
    return this.convert(n, e, this._workingColorSpace);
  },
  getPrimaries: function(n) {
    return jS[n].primaries;
  },
  getTransfer: function(n) {
    return n === ru ? i0 : jS[n].transfer;
  }
};
function Km(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function EM(n) {
  return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let lm;
class Mk {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      lm === void 0 && (lm = c0("canvas")), lm.width = e.width, lm.height = e.height;
      const r = lm.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = lm;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = c0("canvas");
      t.width = e.width, t.height = e.height;
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height), a = i.data;
      for (let o = 0; o < a.length; o++)
        a[o] = Km(a[o] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(Km(t[r] / 255) * 255) : t[r] = Km(t[r]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let Loe = 0;
class hh {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: Loe++ }), this.uuid = ps(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const r = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let a;
      if (Array.isArray(i)) {
        a = [];
        for (let o = 0, s = i.length; o < s; o++)
          i[o].isDataTexture ? a.push(CM(i[o].image)) : a.push(CM(i[o]));
      } else
        a = CM(i);
      r.url = a;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function CM(n) {
  return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? Mk.getDataURL(n) : n.data ? {
    data: Array.from(n.data),
    width: n.width,
    height: n.height,
    type: n.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Foe = 0;
class Ei extends Eu {
  constructor(e = Ei.DEFAULT_IMAGE, t = Ei.DEFAULT_MAPPING, r = Xs, i = Xs, a = Ki, o = oc, s = Xa, u = Ml, d = Ei.DEFAULT_ANISOTROPY, f = ru) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Foe++ }), this.uuid = ps(), this.name = "", this.source = new hh(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = r, this.wrapT = i, this.magFilter = a, this.minFilter = o, this.anisotropy = d, this.format = s, this.internalFormat = null, this.type = u, this.offset = new St(0, 0), this.repeat = new St(1, 1), this.center = new St(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new zn(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = f, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const r = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== zE) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case e0:
          e.x = e.x - Math.floor(e.x);
          break;
        case Xs:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case t0:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case e0:
          e.y = e.y - Math.floor(e.y);
          break;
        case Xs:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case t0:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Ei.DEFAULT_IMAGE = null;
Ei.DEFAULT_MAPPING = zE;
Ei.DEFAULT_ANISOTROPY = 1;
class wr {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    wr.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = r, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return this.x = e, this.y = t, this.z = r, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, i = this.z, a = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * r + o[8] * i + o[12] * a, this.y = o[1] * t + o[5] * r + o[9] * i + o[13] * a, this.z = o[2] * t + o[6] * r + o[10] * i + o[14] * a, this.w = o[3] * t + o[7] * r + o[11] * i + o[15] * a, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, a;
    const u = e.elements, d = u[0], f = u[4], p = u[8], g = u[1], v = u[5], b = u[9], E = u[2], S = u[6], _ = u[10];
    if (Math.abs(f - g) < 0.01 && Math.abs(p - E) < 0.01 && Math.abs(b - S) < 0.01) {
      if (Math.abs(f + g) < 0.1 && Math.abs(p + E) < 0.1 && Math.abs(b + S) < 0.1 && Math.abs(d + v + _ - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const C = (d + 1) / 2, R = (v + 1) / 2, P = (_ + 1) / 2, D = (f + g) / 4, I = (p + E) / 4, U = (b + S) / 4;
      return C > R && C > P ? C < 0.01 ? (r = 0, i = 0.707106781, a = 0.707106781) : (r = Math.sqrt(C), i = D / r, a = I / r) : R > P ? R < 0.01 ? (r = 0.707106781, i = 0, a = 0.707106781) : (i = Math.sqrt(R), r = D / i, a = U / i) : P < 0.01 ? (r = 0.707106781, i = 0.707106781, a = 0) : (a = Math.sqrt(P), r = I / a, i = U / a), this.set(r, i, a, t), this;
    }
    let w = Math.sqrt((S - b) * (S - b) + (p - E) * (p - E) + (g - f) * (g - f));
    return Math.abs(w) < 1e-3 && (w = 1), this.x = (S - b) / w, this.y = (p - E) / w, this.z = (g - f) / w, this.w = Math.acos((d + v + _ - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Tk extends Eu {
  constructor(e = 1, t = 1, r = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new wr(0, 0, e, t), this.scissorTest = !1, this.viewport = new wr(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    r = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Ki,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, r);
    const a = new Ei(i, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.colorSpace);
    a.flipY = !1, a.generateMipmaps = r.generateMipmaps, a.internalFormat = r.internalFormat, this.textures = [];
    const o = r.count;
    for (let s = 0; s < o; s++)
      this.textures[s] = a.clone(), this.textures[s].isRenderTargetTexture = !0;
    this.depthBuffer = r.depthBuffer, this.stencilBuffer = r.stencilBuffer, this.resolveDepthBuffer = r.resolveDepthBuffer, this.resolveStencilBuffer = r.resolveStencilBuffer, this.depthTexture = r.depthTexture, this.samples = r.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      this.width = e, this.height = t, this.depth = r;
      for (let i = 0, a = this.textures.length; i < a; i++)
        this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = r;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let r = 0, i = e.textures.length; r < i; r++)
      this.textures[r] = e.textures[r].clone(), this.textures[r].isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new hh(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Tl extends Tk {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), this.isWebGLRenderTarget = !0;
  }
}
class XE extends Ei {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = ba, this.minFilter = ba, this.wrapR = Xs, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Uoe extends Tl {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new XE(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class qO extends Ei {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = ba, this.minFilter = ba, this.wrapR = Xs, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class zoe extends Tl {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new qO(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class po {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = i;
  }
  static slerpFlat(e, t, r, i, a, o, s) {
    let u = r[i + 0], d = r[i + 1], f = r[i + 2], p = r[i + 3];
    const g = a[o + 0], v = a[o + 1], b = a[o + 2], E = a[o + 3];
    if (s === 0) {
      e[t + 0] = u, e[t + 1] = d, e[t + 2] = f, e[t + 3] = p;
      return;
    }
    if (s === 1) {
      e[t + 0] = g, e[t + 1] = v, e[t + 2] = b, e[t + 3] = E;
      return;
    }
    if (p !== E || u !== g || d !== v || f !== b) {
      let S = 1 - s;
      const _ = u * g + d * v + f * b + p * E, w = _ >= 0 ? 1 : -1, C = 1 - _ * _;
      if (C > Number.EPSILON) {
        const P = Math.sqrt(C), D = Math.atan2(P, _ * w);
        S = Math.sin(S * D) / P, s = Math.sin(s * D) / P;
      }
      const R = s * w;
      if (u = u * S + g * R, d = d * S + v * R, f = f * S + b * R, p = p * S + E * R, S === 1 - s) {
        const P = 1 / Math.sqrt(u * u + d * d + f * f + p * p);
        u *= P, d *= P, f *= P, p *= P;
      }
    }
    e[t] = u, e[t + 1] = d, e[t + 2] = f, e[t + 3] = p;
  }
  static multiplyQuaternionsFlat(e, t, r, i, a, o) {
    const s = r[i], u = r[i + 1], d = r[i + 2], f = r[i + 3], p = a[o], g = a[o + 1], v = a[o + 2], b = a[o + 3];
    return e[t] = s * b + f * p + u * v - d * g, e[t + 1] = u * b + f * g + d * p - s * v, e[t + 2] = d * b + f * v + s * g - u * p, e[t + 3] = f * b - s * p - u * g - d * v, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, i) {
    return this._x = e, this._y = t, this._z = r, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const r = e._x, i = e._y, a = e._z, o = e._order, s = Math.cos, u = Math.sin, d = s(r / 2), f = s(i / 2), p = s(a / 2), g = u(r / 2), v = u(i / 2), b = u(a / 2);
    switch (o) {
      case "XYZ":
        this._x = g * f * p + d * v * b, this._y = d * v * p - g * f * b, this._z = d * f * b + g * v * p, this._w = d * f * p - g * v * b;
        break;
      case "YXZ":
        this._x = g * f * p + d * v * b, this._y = d * v * p - g * f * b, this._z = d * f * b - g * v * p, this._w = d * f * p + g * v * b;
        break;
      case "ZXY":
        this._x = g * f * p - d * v * b, this._y = d * v * p + g * f * b, this._z = d * f * b + g * v * p, this._w = d * f * p - g * v * b;
        break;
      case "ZYX":
        this._x = g * f * p - d * v * b, this._y = d * v * p + g * f * b, this._z = d * f * b - g * v * p, this._w = d * f * p + g * v * b;
        break;
      case "YZX":
        this._x = g * f * p + d * v * b, this._y = d * v * p + g * f * b, this._z = d * f * b - g * v * p, this._w = d * f * p - g * v * b;
        break;
      case "XZY":
        this._x = g * f * p - d * v * b, this._y = d * v * p - g * f * b, this._z = d * f * b + g * v * p, this._w = d * f * p + g * v * b;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, i = Math.sin(r);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], i = t[4], a = t[8], o = t[1], s = t[5], u = t[9], d = t[2], f = t[6], p = t[10], g = r + s + p;
    if (g > 0) {
      const v = 0.5 / Math.sqrt(g + 1);
      this._w = 0.25 / v, this._x = (f - u) * v, this._y = (a - d) * v, this._z = (o - i) * v;
    } else if (r > s && r > p) {
      const v = 2 * Math.sqrt(1 + r - s - p);
      this._w = (f - u) / v, this._x = 0.25 * v, this._y = (i + o) / v, this._z = (a + d) / v;
    } else if (s > p) {
      const v = 2 * Math.sqrt(1 + s - r - p);
      this._w = (a - d) / v, this._x = (i + o) / v, this._y = 0.25 * v, this._z = (u + f) / v;
    } else {
      const v = 2 * Math.sqrt(1 + p - r - s);
      this._w = (o - i) / v, this._x = (a + d) / v, this._y = (u + f) / v, this._z = 0.25 * v;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Ti(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, i = e._y, a = e._z, o = e._w, s = t._x, u = t._y, d = t._z, f = t._w;
    return this._x = r * f + o * s + i * d - a * u, this._y = i * f + o * u + a * s - r * d, this._z = a * f + o * d + r * u - i * s, this._w = o * f - r * s - i * u - a * d, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x, i = this._y, a = this._z, o = this._w;
    let s = o * e._w + r * e._x + i * e._y + a * e._z;
    if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1)
      return this._w = o, this._x = r, this._y = i, this._z = a, this;
    const u = 1 - s * s;
    if (u <= Number.EPSILON) {
      const v = 1 - t;
      return this._w = v * o + t * this._w, this._x = v * r + t * this._x, this._y = v * i + t * this._y, this._z = v * a + t * this._z, this.normalize(), this;
    }
    const d = Math.sqrt(u), f = Math.atan2(d, s), p = Math.sin((1 - t) * f) / d, g = Math.sin(t * f) / d;
    return this._w = o * p + this._w * g, this._x = r * p + this._x * g, this._y = i * p + this._y * g, this._z = a * p + this._z * g, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), r = Math.random(), i = Math.sqrt(1 - r), a = Math.sqrt(r);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      a * Math.sin(t),
      a * Math.cos(t)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class de {
  constructor(e = 0, t = 0, r = 0) {
    de.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(S3.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(S3.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, i = this.z, a = e.elements;
    return this.x = a[0] * t + a[3] * r + a[6] * i, this.y = a[1] * t + a[4] * r + a[7] * i, this.z = a[2] * t + a[5] * r + a[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, i = this.z, a = e.elements, o = 1 / (a[3] * t + a[7] * r + a[11] * i + a[15]);
    return this.x = (a[0] * t + a[4] * r + a[8] * i + a[12]) * o, this.y = (a[1] * t + a[5] * r + a[9] * i + a[13]) * o, this.z = (a[2] * t + a[6] * r + a[10] * i + a[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, i = this.z, a = e.x, o = e.y, s = e.z, u = e.w, d = 2 * (o * i - s * r), f = 2 * (s * t - a * i), p = 2 * (a * r - o * t);
    return this.x = t + u * d + o * p - s * f, this.y = r + u * f + s * d - a * p, this.z = i + u * p + a * f - o * d, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, i = this.z, a = e.elements;
    return this.x = a[0] * t + a[4] * r + a[8] * i, this.y = a[1] * t + a[5] * r + a[9] * i, this.z = a[2] * t + a[6] * r + a[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, i = e.y, a = e.z, o = t.x, s = t.y, u = t.z;
    return this.x = i * u - a * s, this.y = a * o - r * u, this.z = r * s - i * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return wM.copy(this).projectOnVector(e), this.sub(wM);
  }
  reflect(e) {
    return this.sub(wM.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Ti(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(r), this.y = Math.cos(t) * e, this.z = i * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, r = Math.sqrt(1 - t * t);
    return this.x = r * Math.cos(e), this.y = t, this.z = r * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const wM = /* @__PURE__ */ new de(), S3 = /* @__PURE__ */ new po();
class qa {
  constructor(e = new de(1 / 0, 1 / 0, 1 / 0), t = new de(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(fl.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(fl.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = fl.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const a = r.getAttribute("position");
      if (t === !0 && a !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, s = a.count; o < s; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, fl) : fl.fromBufferAttribute(a, o), fl.applyMatrix4(e.matrixWorld), this.expandByPoint(fl);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), GS.copy(e.boundingBox)) : (r.boundingBox === null && r.computeBoundingBox(), GS.copy(r.boundingBox)), GS.applyMatrix4(e.matrixWorld), this.union(GS);
    }
    const i = e.children;
    for (let a = 0, o = i.length; a < o; a++)
      this.expandByObject(i[a], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, fl), fl.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Yv), XS.subVectors(this.max, Yv), cm.subVectors(e.a, Yv), um.subVectors(e.b, Yv), dm.subVectors(e.c, Yv), xd.subVectors(um, cm), Ed.subVectors(dm, um), Bf.subVectors(cm, dm);
    let t = [
      0,
      -xd.z,
      xd.y,
      0,
      -Ed.z,
      Ed.y,
      0,
      -Bf.z,
      Bf.y,
      xd.z,
      0,
      -xd.x,
      Ed.z,
      0,
      -Ed.x,
      Bf.z,
      0,
      -Bf.x,
      -xd.y,
      xd.x,
      0,
      -Ed.y,
      Ed.x,
      0,
      -Bf.y,
      Bf.x,
      0
    ];
    return !MM(t, cm, um, dm, XS) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !MM(t, cm, um, dm, XS)) ? !1 : (qS.crossVectors(xd, Ed), t = [qS.x, qS.y, qS.z], MM(t, cm, um, dm, XS));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, fl).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(fl).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (qc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), qc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), qc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), qc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), qc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), qc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), qc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), qc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(qc), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const qc = [
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de()
], fl = /* @__PURE__ */ new de(), GS = /* @__PURE__ */ new qa(), cm = /* @__PURE__ */ new de(), um = /* @__PURE__ */ new de(), dm = /* @__PURE__ */ new de(), xd = /* @__PURE__ */ new de(), Ed = /* @__PURE__ */ new de(), Bf = /* @__PURE__ */ new de(), Yv = /* @__PURE__ */ new de(), XS = /* @__PURE__ */ new de(), qS = /* @__PURE__ */ new de(), Hf = /* @__PURE__ */ new de();
function MM(n, e, t, r, i) {
  for (let a = 0, o = n.length - 3; a <= o; a += 3) {
    Hf.fromArray(n, a);
    const s = i.x * Math.abs(Hf.x) + i.y * Math.abs(Hf.y) + i.z * Math.abs(Hf.z), u = e.dot(Hf), d = t.dot(Hf), f = r.dot(Hf);
    if (Math.max(-Math.max(u, d, f), Math.min(u, d, f)) > s)
      return !1;
  }
  return !0;
}
const Boe = /* @__PURE__ */ new qa(), Kv = /* @__PURE__ */ new de(), TM = /* @__PURE__ */ new de();
class Pa {
  constructor(e = new de(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : Boe.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let a = 0, o = e.length; a < o; a++)
      i = Math.max(i, r.distanceToSquared(e[a]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Kv.subVectors(e, this.center);
    const t = Kv.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), i = (r - this.radius) * 0.5;
      this.center.addScaledVector(Kv, i / r), this.radius += i;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (TM.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Kv.copy(e.center).add(TM)), this.expandByPoint(Kv.copy(e.center).sub(TM))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Yc = /* @__PURE__ */ new de(), RM = /* @__PURE__ */ new de(), YS = /* @__PURE__ */ new de(), Cd = /* @__PURE__ */ new de(), AM = /* @__PURE__ */ new de(), KS = /* @__PURE__ */ new de(), OM = /* @__PURE__ */ new de();
class Eg {
  constructor(e = new de(), t = new de(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Yc)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Yc.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Yc.copy(this.origin).addScaledVector(this.direction, t), Yc.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    RM.copy(e).add(t).multiplyScalar(0.5), YS.copy(t).sub(e).normalize(), Cd.copy(this.origin).sub(RM);
    const a = e.distanceTo(t) * 0.5, o = -this.direction.dot(YS), s = Cd.dot(this.direction), u = -Cd.dot(YS), d = Cd.lengthSq(), f = Math.abs(1 - o * o);
    let p, g, v, b;
    if (f > 0)
      if (p = o * u - s, g = o * s - u, b = a * f, p >= 0)
        if (g >= -b)
          if (g <= b) {
            const E = 1 / f;
            p *= E, g *= E, v = p * (p + o * g + 2 * s) + g * (o * p + g + 2 * u) + d;
          } else
            g = a, p = Math.max(0, -(o * g + s)), v = -p * p + g * (g + 2 * u) + d;
        else
          g = -a, p = Math.max(0, -(o * g + s)), v = -p * p + g * (g + 2 * u) + d;
      else
        g <= -b ? (p = Math.max(0, -(-o * a + s)), g = p > 0 ? -a : Math.min(Math.max(-a, -u), a), v = -p * p + g * (g + 2 * u) + d) : g <= b ? (p = 0, g = Math.min(Math.max(-a, -u), a), v = g * (g + 2 * u) + d) : (p = Math.max(0, -(o * a + s)), g = p > 0 ? a : Math.min(Math.max(-a, -u), a), v = -p * p + g * (g + 2 * u) + d);
    else
      g = o > 0 ? -a : a, p = Math.max(0, -(o * g + s)), v = -p * p + g * (g + 2 * u) + d;
    return r && r.copy(this.origin).addScaledVector(this.direction, p), i && i.copy(RM).addScaledVector(YS, g), v;
  }
  intersectSphere(e, t) {
    Yc.subVectors(e.center, this.origin);
    const r = Yc.dot(this.direction), i = Yc.dot(Yc) - r * r, a = e.radius * e.radius;
    if (i > a) return null;
    const o = Math.sqrt(a - i), s = r - o, u = r + o;
    return u < 0 ? null : s < 0 ? this.at(u, t) : this.at(s, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, a, o, s, u;
    const d = 1 / this.direction.x, f = 1 / this.direction.y, p = 1 / this.direction.z, g = this.origin;
    return d >= 0 ? (r = (e.min.x - g.x) * d, i = (e.max.x - g.x) * d) : (r = (e.max.x - g.x) * d, i = (e.min.x - g.x) * d), f >= 0 ? (a = (e.min.y - g.y) * f, o = (e.max.y - g.y) * f) : (a = (e.max.y - g.y) * f, o = (e.min.y - g.y) * f), r > o || a > i || ((a > r || isNaN(r)) && (r = a), (o < i || isNaN(i)) && (i = o), p >= 0 ? (s = (e.min.z - g.z) * p, u = (e.max.z - g.z) * p) : (s = (e.max.z - g.z) * p, u = (e.min.z - g.z) * p), r > u || s > i) || ((s > r || r !== r) && (r = s), (u < i || i !== i) && (i = u), i < 0) ? null : this.at(r >= 0 ? r : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Yc) !== null;
  }
  intersectTriangle(e, t, r, i, a) {
    AM.subVectors(t, e), KS.subVectors(r, e), OM.crossVectors(AM, KS);
    let o = this.direction.dot(OM), s;
    if (o > 0) {
      if (i) return null;
      s = 1;
    } else if (o < 0)
      s = -1, o = -o;
    else
      return null;
    Cd.subVectors(this.origin, e);
    const u = s * this.direction.dot(KS.crossVectors(Cd, KS));
    if (u < 0)
      return null;
    const d = s * this.direction.dot(AM.cross(Cd));
    if (d < 0 || u + d > o)
      return null;
    const f = -s * Cd.dot(OM);
    return f < 0 ? null : this.at(f / o, a);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class wn {
  constructor(e, t, r, i, a, o, s, u, d, f, p, g, v, b, E, S) {
    wn.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, r, i, a, o, s, u, d, f, p, g, v, b, E, S);
  }
  set(e, t, r, i, a, o, s, u, d, f, p, g, v, b, E, S) {
    const _ = this.elements;
    return _[0] = e, _[4] = t, _[8] = r, _[12] = i, _[1] = a, _[5] = o, _[9] = s, _[13] = u, _[2] = d, _[6] = f, _[10] = p, _[14] = g, _[3] = v, _[7] = b, _[11] = E, _[15] = S, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new wn().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, i = 1 / fm.setFromMatrixColumn(e, 0).length(), a = 1 / fm.setFromMatrixColumn(e, 1).length(), o = 1 / fm.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * i, t[1] = r[1] * i, t[2] = r[2] * i, t[3] = 0, t[4] = r[4] * a, t[5] = r[5] * a, t[6] = r[6] * a, t[7] = 0, t[8] = r[8] * o, t[9] = r[9] * o, t[10] = r[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, i = e.y, a = e.z, o = Math.cos(r), s = Math.sin(r), u = Math.cos(i), d = Math.sin(i), f = Math.cos(a), p = Math.sin(a);
    if (e.order === "XYZ") {
      const g = o * f, v = o * p, b = s * f, E = s * p;
      t[0] = u * f, t[4] = -u * p, t[8] = d, t[1] = v + b * d, t[5] = g - E * d, t[9] = -s * u, t[2] = E - g * d, t[6] = b + v * d, t[10] = o * u;
    } else if (e.order === "YXZ") {
      const g = u * f, v = u * p, b = d * f, E = d * p;
      t[0] = g + E * s, t[4] = b * s - v, t[8] = o * d, t[1] = o * p, t[5] = o * f, t[9] = -s, t[2] = v * s - b, t[6] = E + g * s, t[10] = o * u;
    } else if (e.order === "ZXY") {
      const g = u * f, v = u * p, b = d * f, E = d * p;
      t[0] = g - E * s, t[4] = -o * p, t[8] = b + v * s, t[1] = v + b * s, t[5] = o * f, t[9] = E - g * s, t[2] = -o * d, t[6] = s, t[10] = o * u;
    } else if (e.order === "ZYX") {
      const g = o * f, v = o * p, b = s * f, E = s * p;
      t[0] = u * f, t[4] = b * d - v, t[8] = g * d + E, t[1] = u * p, t[5] = E * d + g, t[9] = v * d - b, t[2] = -d, t[6] = s * u, t[10] = o * u;
    } else if (e.order === "YZX") {
      const g = o * u, v = o * d, b = s * u, E = s * d;
      t[0] = u * f, t[4] = E - g * p, t[8] = b * p + v, t[1] = p, t[5] = o * f, t[9] = -s * f, t[2] = -d * f, t[6] = v * p + b, t[10] = g - E * p;
    } else if (e.order === "XZY") {
      const g = o * u, v = o * d, b = s * u, E = s * d;
      t[0] = u * f, t[4] = -p, t[8] = d * f, t[1] = g * p + E, t[5] = o * f, t[9] = v * p - b, t[2] = b * p - v, t[6] = s * f, t[10] = E * p + g;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Hoe, e, Voe);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return ss.subVectors(e, t), ss.lengthSq() === 0 && (ss.z = 1), ss.normalize(), wd.crossVectors(r, ss), wd.lengthSq() === 0 && (Math.abs(r.z) === 1 ? ss.x += 1e-4 : ss.z += 1e-4, ss.normalize(), wd.crossVectors(r, ss)), wd.normalize(), ZS.crossVectors(ss, wd), i[0] = wd.x, i[4] = ZS.x, i[8] = ss.x, i[1] = wd.y, i[5] = ZS.y, i[9] = ss.y, i[2] = wd.z, i[6] = ZS.z, i[10] = ss.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, i = t.elements, a = this.elements, o = r[0], s = r[4], u = r[8], d = r[12], f = r[1], p = r[5], g = r[9], v = r[13], b = r[2], E = r[6], S = r[10], _ = r[14], w = r[3], C = r[7], R = r[11], P = r[15], D = i[0], I = i[4], U = i[8], L = i[12], N = i[1], H = i[5], j = i[9], G = i[13], X = i[2], ae = i[6], Z = i[10], K = i[14], B = i[3], Q = i[7], V = i[11], q = i[15];
    return a[0] = o * D + s * N + u * X + d * B, a[4] = o * I + s * H + u * ae + d * Q, a[8] = o * U + s * j + u * Z + d * V, a[12] = o * L + s * G + u * K + d * q, a[1] = f * D + p * N + g * X + v * B, a[5] = f * I + p * H + g * ae + v * Q, a[9] = f * U + p * j + g * Z + v * V, a[13] = f * L + p * G + g * K + v * q, a[2] = b * D + E * N + S * X + _ * B, a[6] = b * I + E * H + S * ae + _ * Q, a[10] = b * U + E * j + S * Z + _ * V, a[14] = b * L + E * G + S * K + _ * q, a[3] = w * D + C * N + R * X + P * B, a[7] = w * I + C * H + R * ae + P * Q, a[11] = w * U + C * j + R * Z + P * V, a[15] = w * L + C * G + R * K + P * q, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], i = e[8], a = e[12], o = e[1], s = e[5], u = e[9], d = e[13], f = e[2], p = e[6], g = e[10], v = e[14], b = e[3], E = e[7], S = e[11], _ = e[15];
    return b * (+a * u * p - i * d * p - a * s * g + r * d * g + i * s * v - r * u * v) + E * (+t * u * v - t * d * g + a * o * g - i * o * v + i * d * f - a * u * f) + S * (+t * d * p - t * s * v - a * o * p + r * o * v + a * s * f - r * d * f) + _ * (-i * s * f - t * u * p + t * s * g + i * o * p - r * o * g + r * u * f);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], u = e[6], d = e[7], f = e[8], p = e[9], g = e[10], v = e[11], b = e[12], E = e[13], S = e[14], _ = e[15], w = p * S * d - E * g * d + E * u * v - s * S * v - p * u * _ + s * g * _, C = b * g * d - f * S * d - b * u * v + o * S * v + f * u * _ - o * g * _, R = f * E * d - b * p * d + b * s * v - o * E * v - f * s * _ + o * p * _, P = b * p * u - f * E * u - b * s * g + o * E * g + f * s * S - o * p * S, D = t * w + r * C + i * R + a * P;
    if (D === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const I = 1 / D;
    return e[0] = w * I, e[1] = (E * g * a - p * S * a - E * i * v + r * S * v + p * i * _ - r * g * _) * I, e[2] = (s * S * a - E * u * a + E * i * d - r * S * d - s * i * _ + r * u * _) * I, e[3] = (p * u * a - s * g * a - p * i * d + r * g * d + s * i * v - r * u * v) * I, e[4] = C * I, e[5] = (f * S * a - b * g * a + b * i * v - t * S * v - f * i * _ + t * g * _) * I, e[6] = (b * u * a - o * S * a - b * i * d + t * S * d + o * i * _ - t * u * _) * I, e[7] = (o * g * a - f * u * a + f * i * d - t * g * d - o * i * v + t * u * v) * I, e[8] = R * I, e[9] = (b * p * a - f * E * a - b * r * v + t * E * v + f * r * _ - t * p * _) * I, e[10] = (o * E * a - b * s * a + b * r * d - t * E * d - o * r * _ + t * s * _) * I, e[11] = (f * s * a - o * p * a - f * r * d + t * p * d + o * r * v - t * s * v) * I, e[12] = P * I, e[13] = (f * E * i - b * p * i + b * r * g - t * E * g - f * r * S + t * p * S) * I, e[14] = (b * s * i - o * E * i - b * r * u + t * E * u + o * r * S - t * s * S) * I, e[15] = (o * p * i - f * s * i + f * r * u - t * p * u - o * r * g + t * s * g) * I, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, i = e.y, a = e.z;
    return t[0] *= r, t[4] *= i, t[8] *= a, t[1] *= r, t[5] *= i, t[9] *= a, t[2] *= r, t[6] *= i, t[10] *= a, t[3] *= r, t[7] *= i, t[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), i = Math.sin(t), a = 1 - r, o = e.x, s = e.y, u = e.z, d = a * o, f = a * s;
    return this.set(
      d * o + r,
      d * s - i * u,
      d * u + i * s,
      0,
      d * s + i * u,
      f * s + r,
      f * u - i * o,
      0,
      d * u - i * s,
      f * u + i * o,
      a * u * u + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, i, a, o) {
    return this.set(
      1,
      r,
      a,
      0,
      e,
      1,
      o,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const i = this.elements, a = t._x, o = t._y, s = t._z, u = t._w, d = a + a, f = o + o, p = s + s, g = a * d, v = a * f, b = a * p, E = o * f, S = o * p, _ = s * p, w = u * d, C = u * f, R = u * p, P = r.x, D = r.y, I = r.z;
    return i[0] = (1 - (E + _)) * P, i[1] = (v + R) * P, i[2] = (b - C) * P, i[3] = 0, i[4] = (v - R) * D, i[5] = (1 - (g + _)) * D, i[6] = (S + w) * D, i[7] = 0, i[8] = (b + C) * I, i[9] = (S - w) * I, i[10] = (1 - (g + E)) * I, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, r) {
    const i = this.elements;
    let a = fm.set(i[0], i[1], i[2]).length();
    const o = fm.set(i[4], i[5], i[6]).length(), s = fm.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (a = -a), e.x = i[12], e.y = i[13], e.z = i[14], hl.copy(this);
    const d = 1 / a, f = 1 / o, p = 1 / s;
    return hl.elements[0] *= d, hl.elements[1] *= d, hl.elements[2] *= d, hl.elements[4] *= f, hl.elements[5] *= f, hl.elements[6] *= f, hl.elements[8] *= p, hl.elements[9] *= p, hl.elements[10] *= p, t.setFromRotationMatrix(hl), r.x = a, r.y = o, r.z = s, this;
  }
  makePerspective(e, t, r, i, a, o, s = sc) {
    const u = this.elements, d = 2 * a / (t - e), f = 2 * a / (r - i), p = (t + e) / (t - e), g = (r + i) / (r - i);
    let v, b;
    if (s === sc)
      v = -(o + a) / (o - a), b = -2 * o * a / (o - a);
    else if (s === l0)
      v = -o / (o - a), b = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
    return u[0] = d, u[4] = 0, u[8] = p, u[12] = 0, u[1] = 0, u[5] = f, u[9] = g, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = v, u[14] = b, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, t, r, i, a, o, s = sc) {
    const u = this.elements, d = 1 / (t - e), f = 1 / (r - i), p = 1 / (o - a), g = (t + e) * d, v = (r + i) * f;
    let b, E;
    if (s === sc)
      b = (o + a) * p, E = -2 * p;
    else if (s === l0)
      b = a * p, E = -1 * p;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
    return u[0] = 2 * d, u[4] = 0, u[8] = 0, u[12] = -g, u[1] = 0, u[5] = 2 * f, u[9] = 0, u[13] = -v, u[2] = 0, u[6] = 0, u[10] = E, u[14] = -b, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const fm = /* @__PURE__ */ new de(), hl = /* @__PURE__ */ new wn(), Hoe = /* @__PURE__ */ new de(0, 0, 0), Voe = /* @__PURE__ */ new de(1, 1, 1), wd = /* @__PURE__ */ new de(), ZS = /* @__PURE__ */ new de(), ss = /* @__PURE__ */ new de(), _3 = /* @__PURE__ */ new wn(), x3 = /* @__PURE__ */ new po();
class gs {
  constructor(e = 0, t = 0, r = 0, i = gs.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements, a = i[0], o = i[4], s = i[8], u = i[1], d = i[5], f = i[9], p = i[2], g = i[6], v = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Ti(s, -1, 1)), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(-f, v), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(g, d), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Ti(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(s, v), this._z = Math.atan2(u, d)) : (this._y = Math.atan2(-p, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Ti(g, -1, 1)), Math.abs(g) < 0.9999999 ? (this._y = Math.atan2(-p, v), this._z = Math.atan2(-o, d)) : (this._y = 0, this._z = Math.atan2(u, a));
        break;
      case "ZYX":
        this._y = Math.asin(-Ti(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(g, v), this._z = Math.atan2(u, a)) : (this._x = 0, this._z = Math.atan2(-o, d));
        break;
      case "YZX":
        this._z = Math.asin(Ti(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-f, d), this._y = Math.atan2(-p, a)) : (this._x = 0, this._y = Math.atan2(s, v));
        break;
      case "XZY":
        this._z = Math.asin(-Ti(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(g, d), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-f, v), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return _3.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_3, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return x3.setFromEuler(this), this.setFromQuaternion(x3, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
gs.DEFAULT_ORDER = "XYZ";
class wh {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let koe = 0;
const E3 = /* @__PURE__ */ new de(), hm = /* @__PURE__ */ new po(), Kc = /* @__PURE__ */ new wn(), QS = /* @__PURE__ */ new de(), Zv = /* @__PURE__ */ new de(), $oe = /* @__PURE__ */ new de(), Woe = /* @__PURE__ */ new po(), C3 = /* @__PURE__ */ new de(1, 0, 0), w3 = /* @__PURE__ */ new de(0, 1, 0), M3 = /* @__PURE__ */ new de(0, 0, 1), T3 = { type: "added" }, joe = { type: "removed" }, pm = { type: "childadded", child: null }, PM = { type: "childremoved", child: null };
class pr extends Eu {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: koe++ }), this.uuid = ps(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = pr.DEFAULT_UP.clone();
    const e = new de(), t = new gs(), r = new po(), i = new de(1, 1, 1);
    function a() {
      r.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(a), r._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new wn()
      },
      normalMatrix: {
        value: new zn()
      }
    }), this.matrix = new wn(), this.matrixWorld = new wn(), this.matrixAutoUpdate = pr.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = pr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new wh(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return hm.setFromAxisAngle(e, t), this.quaternion.multiply(hm), this;
  }
  rotateOnWorldAxis(e, t) {
    return hm.setFromAxisAngle(e, t), this.quaternion.premultiply(hm), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(C3, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(w3, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(M3, e);
  }
  translateOnAxis(e, t) {
    return E3.copy(e).applyQuaternion(this.quaternion), this.position.add(E3.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(C3, e);
  }
  translateY(e) {
    return this.translateOnAxis(w3, e);
  }
  translateZ(e) {
    return this.translateOnAxis(M3, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Kc.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? QS.copy(e) : QS.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), Zv.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Kc.lookAt(Zv, QS, this.up) : Kc.lookAt(QS, Zv, this.up), this.quaternion.setFromRotationMatrix(Kc), i && (Kc.extractRotation(i.matrixWorld), hm.setFromRotationMatrix(Kc), this.quaternion.premultiply(hm.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(T3), pm.child = e, this.dispatchEvent(pm), pm.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(joe), PM.child = e, this.dispatchEvent(PM), PM.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Kc.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Kc.multiply(e.parent.matrixWorld)), e.applyMatrix4(Kc), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(T3), pm.child = e, this.dispatchEvent(pm), pm.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const o = this.children[r].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(e, t, r = []) {
    this[e] === t && r.push(this);
    const i = this.children;
    for (let a = 0, o = i.length; a < o; a++)
      i[a].getObjectsByProperty(e, t, r);
    return r;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zv, e, $oe), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zv, Woe, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
      const i = this.children;
      for (let a = 0, o = i.length; a < o; a++)
        i[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((s) => ({
      boxInitialized: s.boxInitialized,
      boxMin: s.box.min.toArray(),
      boxMax: s.box.max.toArray(),
      sphereInitialized: s.sphereInitialized,
      sphereRadius: s.sphere.radius,
      sphereCenter: s.sphere.center.toArray()
    })), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function a(s, u) {
      return s[u.uuid] === void 0 && (s[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = a(e.geometries, this.geometry);
      const s = this.geometry.parameters;
      if (s !== void 0 && s.shapes !== void 0) {
        const u = s.shapes;
        if (Array.isArray(u))
          for (let d = 0, f = u.length; d < f; d++) {
            const p = u[d];
            a(e.shapes, p);
          }
        else
          a(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const s = [];
        for (let u = 0, d = this.material.length; u < d; u++)
          s.push(a(e.materials, this.material[u]));
        i.material = s;
      } else
        i.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let s = 0; s < this.children.length; s++)
        i.children.push(this.children[s].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let s = 0; s < this.animations.length; s++) {
        const u = this.animations[s];
        i.animations.push(a(e.animations, u));
      }
    }
    if (t) {
      const s = o(e.geometries), u = o(e.materials), d = o(e.textures), f = o(e.images), p = o(e.shapes), g = o(e.skeletons), v = o(e.animations), b = o(e.nodes);
      s.length > 0 && (r.geometries = s), u.length > 0 && (r.materials = u), d.length > 0 && (r.textures = d), f.length > 0 && (r.images = f), p.length > 0 && (r.shapes = p), g.length > 0 && (r.skeletons = g), v.length > 0 && (r.animations = v), b.length > 0 && (r.nodes = b);
    }
    return r.object = i, r;
    function o(s) {
      const u = [];
      for (const d in s) {
        const f = s[d];
        delete f.metadata, u.push(f);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
pr.DEFAULT_UP = /* @__PURE__ */ new de(0, 1, 0);
pr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
pr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const pl = /* @__PURE__ */ new de(), Zc = /* @__PURE__ */ new de(), DM = /* @__PURE__ */ new de(), Qc = /* @__PURE__ */ new de(), mm = /* @__PURE__ */ new de(), gm = /* @__PURE__ */ new de(), R3 = /* @__PURE__ */ new de(), IM = /* @__PURE__ */ new de(), NM = /* @__PURE__ */ new de(), LM = /* @__PURE__ */ new de();
class ds {
  constructor(e = new de(), t = new de(), r = new de()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), pl.subVectors(e, t), i.cross(pl);
    const a = i.lengthSq();
    return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, r, i, a) {
    pl.subVectors(i, t), Zc.subVectors(r, t), DM.subVectors(e, t);
    const o = pl.dot(pl), s = pl.dot(Zc), u = pl.dot(DM), d = Zc.dot(Zc), f = Zc.dot(DM), p = o * d - s * s;
    if (p === 0)
      return a.set(0, 0, 0), null;
    const g = 1 / p, v = (d * u - s * f) * g, b = (o * f - s * u) * g;
    return a.set(1 - v - b, b, v);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, Qc) === null ? !1 : Qc.x >= 0 && Qc.y >= 0 && Qc.x + Qc.y <= 1;
  }
  static getInterpolation(e, t, r, i, a, o, s, u) {
    return this.getBarycoord(e, t, r, i, Qc) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(a, Qc.x), u.addScaledVector(o, Qc.y), u.addScaledVector(s, Qc.z), u);
  }
  static isFrontFacing(e, t, r, i) {
    return pl.subVectors(r, t), Zc.subVectors(e, t), pl.cross(Zc).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return pl.subVectors(this.c, this.b), Zc.subVectors(this.a, this.b), pl.cross(Zc).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ds.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ds.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, r, i, a) {
    return ds.getInterpolation(e, this.a, this.b, this.c, t, r, i, a);
  }
  containsPoint(e) {
    return ds.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ds.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, i = this.b, a = this.c;
    let o, s;
    mm.subVectors(i, r), gm.subVectors(a, r), IM.subVectors(e, r);
    const u = mm.dot(IM), d = gm.dot(IM);
    if (u <= 0 && d <= 0)
      return t.copy(r);
    NM.subVectors(e, i);
    const f = mm.dot(NM), p = gm.dot(NM);
    if (f >= 0 && p <= f)
      return t.copy(i);
    const g = u * p - f * d;
    if (g <= 0 && u >= 0 && f <= 0)
      return o = u / (u - f), t.copy(r).addScaledVector(mm, o);
    LM.subVectors(e, a);
    const v = mm.dot(LM), b = gm.dot(LM);
    if (b >= 0 && v <= b)
      return t.copy(a);
    const E = v * d - u * b;
    if (E <= 0 && d >= 0 && b <= 0)
      return s = d / (d - b), t.copy(r).addScaledVector(gm, s);
    const S = f * b - v * p;
    if (S <= 0 && p - f >= 0 && v - b >= 0)
      return R3.subVectors(a, i), s = (p - f) / (p - f + (v - b)), t.copy(i).addScaledVector(R3, s);
    const _ = 1 / (S + E + g);
    return o = E * _, s = g * _, t.copy(r).addScaledVector(mm, o).addScaledVector(gm, s);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Rk = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Md = { h: 0, s: 0, l: 0 }, JS = { h: 0, s: 0, l: 0 };
function FM(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n;
}
class an {
  constructor(e, t, r) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, r);
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = js) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Cr.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, r, i = Cr.workingColorSpace) {
    return this.r = e, this.g = t, this.b = r, Cr.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, r, i = Cr.workingColorSpace) {
    if (e = GO(e, 1), t = Ti(t, 0, 1), r = Ti(r, 0, 1), t === 0)
      this.r = this.g = this.b = r;
    else {
      const a = r <= 0.5 ? r * (1 + t) : r + t - r * t, o = 2 * r - a;
      this.r = FM(o, a, e + 1 / 3), this.g = FM(o, a, e), this.b = FM(o, a, e - 1 / 3);
    }
    return Cr.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = js) {
    function r(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let a;
      const o = i[1], s = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return r(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              t
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return r(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return r(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const a = i[1], o = a.length;
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          t
        );
      if (o === 6)
        return this.setHex(parseInt(a, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = js) {
    const r = Rk[e.toLowerCase()];
    return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Km(e.r), this.g = Km(e.g), this.b = Km(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = EM(e.r), this.g = EM(e.g), this.b = EM(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = js) {
    return Cr.fromWorkingColorSpace(ja.copy(this), e), Math.round(Ti(ja.r * 255, 0, 255)) * 65536 + Math.round(Ti(ja.g * 255, 0, 255)) * 256 + Math.round(Ti(ja.b * 255, 0, 255));
  }
  getHexString(e = js) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Cr.workingColorSpace) {
    Cr.fromWorkingColorSpace(ja.copy(this), t);
    const r = ja.r, i = ja.g, a = ja.b, o = Math.max(r, i, a), s = Math.min(r, i, a);
    let u, d;
    const f = (s + o) / 2;
    if (s === o)
      u = 0, d = 0;
    else {
      const p = o - s;
      switch (d = f <= 0.5 ? p / (o + s) : p / (2 - o - s), o) {
        case r:
          u = (i - a) / p + (i < a ? 6 : 0);
          break;
        case i:
          u = (a - r) / p + 2;
          break;
        case a:
          u = (r - i) / p + 4;
          break;
      }
      u /= 6;
    }
    return e.h = u, e.s = d, e.l = f, e;
  }
  getRGB(e, t = Cr.workingColorSpace) {
    return Cr.fromWorkingColorSpace(ja.copy(this), t), e.r = ja.r, e.g = ja.g, e.b = ja.b, e;
  }
  getStyle(e = js) {
    Cr.fromWorkingColorSpace(ja.copy(this), e);
    const t = ja.r, r = ja.g, i = ja.b;
    return e !== js ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(Md), this.setHSL(Md.h + e, Md.s + t, Md.l + r);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, r) {
    return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this;
  }
  lerpHSL(e, t) {
    this.getHSL(Md), e.getHSL(JS);
    const r = Ly(Md.h, JS.h, t), i = Ly(Md.s, JS.s, t), a = Ly(Md.l, JS.l, t);
    return this.setHSL(r, i, a), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, r = this.g, i = this.b, a = e.elements;
    return this.r = a[0] * t + a[3] * r + a[6] * i, this.g = a[1] * t + a[4] * r + a[7] * i, this.b = a[2] * t + a[5] * r + a[8] * i, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ja = /* @__PURE__ */ new an();
an.NAMES = Rk;
let Goe = 0;
class Da extends Eu {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Goe++ }), this.uuid = ps(), this.name = "", this.type = "Material", this.blending = xh, this.side = mu, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = wx, this.blendDst = Mx, this.blendEquation = Ud, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new an(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Zy, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = iA, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = th, this.stencilZFail = th, this.stencilZPass = th, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (r.dispersion = this.dispersion), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapRotation !== void 0 && (r.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== xh && (r.blending = this.blending), this.side !== mu && (r.side = this.side), this.vertexColors === !0 && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = !0), this.blendSrc !== wx && (r.blendSrc = this.blendSrc), this.blendDst !== Mx && (r.blendDst = this.blendDst), this.blendEquation !== Ud && (r.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (r.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (r.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha), this.depthFunc !== Zy && (r.depthFunc = this.depthFunc), this.depthTest === !1 && (r.depthTest = this.depthTest), this.depthWrite === !1 && (r.depthWrite = this.depthWrite), this.colorWrite === !1 && (r.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (r.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== iA && (r.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (r.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (r.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== th && (r.stencilFail = this.stencilFail), this.stencilZFail !== th && (r.stencilZFail = this.stencilZFail), this.stencilZPass !== th && (r.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaHash === !0 && (r.alphaHash = !0), this.alphaToCoverage === !0 && (r.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0), this.forceSinglePass === !0 && (r.forceSinglePass = !0), this.wireframe === !0 && (r.wireframe = !0), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = !0), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(a) {
      const o = [];
      for (const s in a) {
        const u = a[s];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (t) {
      const a = i(e.textures), o = i(e.images);
      a.length > 0 && (r.textures = a), o.length > 0 && (r.images = o);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let a = 0; a !== i; ++a)
        r[a] = t[a].clone();
    }
    return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
  onBeforeRender() {
    console.warn("Material: onBeforeRender() has been removed.");
  }
}
class qd extends Da {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new an(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new gs(), this.combine = A0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const iu = /* @__PURE__ */ Xoe();
function Xoe() {
  const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), r = new Uint32Array(512), i = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const d = u - 127;
    d < -27 ? (r[u] = 0, r[u | 256] = 32768, i[u] = 24, i[u | 256] = 24) : d < -14 ? (r[u] = 1024 >> -d - 14, r[u | 256] = 1024 >> -d - 14 | 32768, i[u] = -d - 1, i[u | 256] = -d - 1) : d <= 15 ? (r[u] = d + 15 << 10, r[u | 256] = d + 15 << 10 | 32768, i[u] = 13, i[u | 256] = 13) : d < 128 ? (r[u] = 31744, r[u | 256] = 64512, i[u] = 24, i[u | 256] = 24) : (r[u] = 31744, r[u | 256] = 64512, i[u] = 13, i[u | 256] = 13);
  }
  const a = new Uint32Array(2048), o = new Uint32Array(64), s = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let d = u << 13, f = 0;
    for (; !(d & 8388608); )
      d <<= 1, f -= 8388608;
    d &= -8388609, f += 947912704, a[u] = d | f;
  }
  for (let u = 1024; u < 2048; ++u)
    a[u] = 939524096 + (u - 1024 << 13);
  for (let u = 1; u < 31; ++u)
    o[u] = u << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let u = 33; u < 63; ++u)
    o[u] = 2147483648 + (u - 32 << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u)
    u !== 32 && (s[u] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: a,
    exponentTable: o,
    offsetTable: s
  };
}
function zo(n) {
  Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = Ti(n, -65504, 65504), iu.floatView[0] = n;
  const e = iu.uint32View[0], t = e >> 23 & 511;
  return iu.baseTable[t] + ((e & 8388607) >> iu.shiftTable[t]);
}
function gy(n) {
  const e = n >> 10;
  return iu.uint32View[0] = iu.mantissaTable[iu.offsetTable[e] + (n & 1023)] + iu.exponentTable[e], iu.floatView[0];
}
const qoe = {
  toHalfFloat: zo,
  fromHalfFloat: gy
}, Xi = /* @__PURE__ */ new de(), e_ = /* @__PURE__ */ new St();
class jr {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = s0, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = Ho, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return XO("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let i = 0, a = this.itemSize; i < a; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        e_.fromBufferAttribute(this, t), e_.applyMatrix3(e), this.setXY(t, e_.x, e_.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        Xi.fromBufferAttribute(this, t), Xi.applyMatrix3(e), this.setXYZ(t, Xi.x, Xi.y, Xi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Xi.fromBufferAttribute(this, t), Xi.applyMatrix4(e), this.setXYZ(t, Xi.x, Xi.y, Xi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Xi.fromBufferAttribute(this, t), Xi.applyNormalMatrix(e), this.setXYZ(t, Xi.x, Xi.y, Xi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Xi.fromBufferAttribute(this, t), Xi.transformDirection(e), this.setXYZ(t, Xi.x, Xi.y, Xi.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = uo(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return this.normalized && (r = Bn(r, this.array)), this.array[e * this.itemSize + t] = r, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, i) {
    return e *= this.itemSize, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array), i = Bn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, r, i, a) {
    return e *= this.itemSize, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array), i = Bn(i, this.array), a = Bn(a, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = a, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== s0 && (e.usage = this.usage), e;
  }
}
class Yoe extends jr {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class Koe extends jr {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class Zoe extends jr {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class Qoe extends jr {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class YO extends jr {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class Joe extends jr {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class KO extends jr {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class ese extends jr {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = gy(this.array[e * this.itemSize]);
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.array[e * this.itemSize] = zo(t), this;
  }
  getY(e) {
    let t = gy(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.array[e * this.itemSize + 1] = zo(t), this;
  }
  getZ(e) {
    let t = gy(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.array[e * this.itemSize + 2] = zo(t), this;
  }
  getW(e) {
    let t = gy(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.array[e * this.itemSize + 3] = zo(t), this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array)), this.array[e + 0] = zo(t), this.array[e + 1] = zo(r), this;
  }
  setXYZ(e, t, r, i) {
    return e *= this.itemSize, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array), i = Bn(i, this.array)), this.array[e + 0] = zo(t), this.array[e + 1] = zo(r), this.array[e + 2] = zo(i), this;
  }
  setXYZW(e, t, r, i, a) {
    return e *= this.itemSize, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array), i = Bn(i, this.array), a = Bn(a, this.array)), this.array[e + 0] = zo(t), this.array[e + 1] = zo(r), this.array[e + 2] = zo(i), this.array[e + 3] = zo(a), this;
  }
}
class fn extends jr {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
let tse = 0;
const $s = /* @__PURE__ */ new wn(), UM = /* @__PURE__ */ new pr(), vm = /* @__PURE__ */ new de(), ls = /* @__PURE__ */ new qa(), Qv = /* @__PURE__ */ new qa(), va = /* @__PURE__ */ new de();
class Xn extends Eu {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: tse++ }), this.uuid = ps(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Ck(e) ? KO : YO)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const a = new zn().getNormalMatrix(e);
      r.applyNormalMatrix(a), r.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return $s.makeRotationFromQuaternion(e), this.applyMatrix4($s), this;
  }
  rotateX(e) {
    return $s.makeRotationX(e), this.applyMatrix4($s), this;
  }
  rotateY(e) {
    return $s.makeRotationY(e), this.applyMatrix4($s), this;
  }
  rotateZ(e) {
    return $s.makeRotationZ(e), this.applyMatrix4($s), this;
  }
  translate(e, t, r) {
    return $s.makeTranslation(e, t, r), this.applyMatrix4($s), this;
  }
  scale(e, t, r) {
    return $s.makeScale(e, t, r), this.applyMatrix4($s), this;
  }
  lookAt(e) {
    return UM.lookAt(e), UM.updateMatrix(), this.applyMatrix4(UM.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(vm).negate(), this.translate(vm.x, vm.y, vm.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const a = e[r];
      t.push(a.x, a.y, a.z || 0);
    }
    return this.setAttribute("position", new fn(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new qa());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new de(-1 / 0, -1 / 0, -1 / 0),
        new de(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, i = t.length; r < i; r++) {
          const a = t[r];
          ls.setFromBufferAttribute(a), this.morphTargetsRelative ? (va.addVectors(this.boundingBox.min, ls.min), this.boundingBox.expandByPoint(va), va.addVectors(this.boundingBox.max, ls.max), this.boundingBox.expandByPoint(va)) : (this.boundingBox.expandByPoint(ls.min), this.boundingBox.expandByPoint(ls.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Pa());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new de(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (ls.setFromBufferAttribute(e), t)
        for (let a = 0, o = t.length; a < o; a++) {
          const s = t[a];
          Qv.setFromBufferAttribute(s), this.morphTargetsRelative ? (va.addVectors(ls.min, Qv.min), ls.expandByPoint(va), va.addVectors(ls.max, Qv.max), ls.expandByPoint(va)) : (ls.expandByPoint(Qv.min), ls.expandByPoint(Qv.max));
        }
      ls.getCenter(r);
      let i = 0;
      for (let a = 0, o = e.count; a < o; a++)
        va.fromBufferAttribute(e, a), i = Math.max(i, r.distanceToSquared(va));
      if (t)
        for (let a = 0, o = t.length; a < o; a++) {
          const s = t[a], u = this.morphTargetsRelative;
          for (let d = 0, f = s.count; d < f; d++)
            va.fromBufferAttribute(s, d), u && (vm.fromBufferAttribute(e, d), va.add(vm)), i = Math.max(i, r.distanceToSquared(va));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = t.position, i = t.normal, a = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new jr(new Float32Array(4 * r.count), 4));
    const o = this.getAttribute("tangent"), s = [], u = [];
    for (let U = 0; U < r.count; U++)
      s[U] = new de(), u[U] = new de();
    const d = new de(), f = new de(), p = new de(), g = new St(), v = new St(), b = new St(), E = new de(), S = new de();
    function _(U, L, N) {
      d.fromBufferAttribute(r, U), f.fromBufferAttribute(r, L), p.fromBufferAttribute(r, N), g.fromBufferAttribute(a, U), v.fromBufferAttribute(a, L), b.fromBufferAttribute(a, N), f.sub(d), p.sub(d), v.sub(g), b.sub(g);
      const H = 1 / (v.x * b.y - b.x * v.y);
      isFinite(H) && (E.copy(f).multiplyScalar(b.y).addScaledVector(p, -v.y).multiplyScalar(H), S.copy(p).multiplyScalar(v.x).addScaledVector(f, -b.x).multiplyScalar(H), s[U].add(E), s[L].add(E), s[N].add(E), u[U].add(S), u[L].add(S), u[N].add(S));
    }
    let w = this.groups;
    w.length === 0 && (w = [{
      start: 0,
      count: e.count
    }]);
    for (let U = 0, L = w.length; U < L; ++U) {
      const N = w[U], H = N.start, j = N.count;
      for (let G = H, X = H + j; G < X; G += 3)
        _(
          e.getX(G + 0),
          e.getX(G + 1),
          e.getX(G + 2)
        );
    }
    const C = new de(), R = new de(), P = new de(), D = new de();
    function I(U) {
      P.fromBufferAttribute(i, U), D.copy(P);
      const L = s[U];
      C.copy(L), C.sub(P.multiplyScalar(P.dot(L))).normalize(), R.crossVectors(D, L);
      const H = R.dot(u[U]) < 0 ? -1 : 1;
      o.setXYZW(U, C.x, C.y, C.z, H);
    }
    for (let U = 0, L = w.length; U < L; ++U) {
      const N = w[U], H = N.start, j = N.count;
      for (let G = H, X = H + j; G < X; G += 3)
        I(e.getX(G + 0)), I(e.getX(G + 1)), I(e.getX(G + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new jr(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let g = 0, v = r.count; g < v; g++)
          r.setXYZ(g, 0, 0, 0);
      const i = new de(), a = new de(), o = new de(), s = new de(), u = new de(), d = new de(), f = new de(), p = new de();
      if (e)
        for (let g = 0, v = e.count; g < v; g += 3) {
          const b = e.getX(g + 0), E = e.getX(g + 1), S = e.getX(g + 2);
          i.fromBufferAttribute(t, b), a.fromBufferAttribute(t, E), o.fromBufferAttribute(t, S), f.subVectors(o, a), p.subVectors(i, a), f.cross(p), s.fromBufferAttribute(r, b), u.fromBufferAttribute(r, E), d.fromBufferAttribute(r, S), s.add(f), u.add(f), d.add(f), r.setXYZ(b, s.x, s.y, s.z), r.setXYZ(E, u.x, u.y, u.z), r.setXYZ(S, d.x, d.y, d.z);
        }
      else
        for (let g = 0, v = t.count; g < v; g += 3)
          i.fromBufferAttribute(t, g + 0), a.fromBufferAttribute(t, g + 1), o.fromBufferAttribute(t, g + 2), f.subVectors(o, a), p.subVectors(i, a), f.cross(p), r.setXYZ(g + 0, f.x, f.y, f.z), r.setXYZ(g + 1, f.x, f.y, f.z), r.setXYZ(g + 2, f.x, f.y, f.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      va.fromBufferAttribute(e, t), va.normalize(), e.setXYZ(t, va.x, va.y, va.z);
  }
  toNonIndexed() {
    function e(s, u) {
      const d = s.array, f = s.itemSize, p = s.normalized, g = new d.constructor(u.length * f);
      let v = 0, b = 0;
      for (let E = 0, S = u.length; E < S; E++) {
        s.isInterleavedBufferAttribute ? v = u[E] * s.data.stride + s.offset : v = u[E] * f;
        for (let _ = 0; _ < f; _++)
          g[b++] = d[v++];
      }
      return new jr(g, f, p);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Xn(), r = this.index.array, i = this.attributes;
    for (const s in i) {
      const u = i[s], d = e(u, r);
      t.setAttribute(s, d);
    }
    const a = this.morphAttributes;
    for (const s in a) {
      const u = [], d = a[s];
      for (let f = 0, p = d.length; f < p; f++) {
        const g = d[f], v = e(g, r);
        u.push(v);
      }
      t.morphAttributes[s] = u;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let s = 0, u = o.length; s < u; s++) {
      const d = o[s];
      t.addGroup(d.start, d.count, d.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const d in u)
        u[d] !== void 0 && (e[d] = u[d]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const u in r) {
      const d = r[u];
      e.data.attributes[u] = d.toJSON(e.data);
    }
    const i = {};
    let a = !1;
    for (const u in this.morphAttributes) {
      const d = this.morphAttributes[u], f = [];
      for (let p = 0, g = d.length; p < g; p++) {
        const v = d[p];
        f.push(v.toJSON(e.data));
      }
      f.length > 0 && (i[u] = f, a = !0);
    }
    a && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const s = this.boundingSphere;
    return s !== null && (e.data.boundingSphere = {
      center: s.center.toArray(),
      radius: s.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const d in i) {
      const f = i[d];
      this.setAttribute(d, f.clone(t));
    }
    const a = e.morphAttributes;
    for (const d in a) {
      const f = [], p = a[d];
      for (let g = 0, v = p.length; g < v; g++)
        f.push(p[g].clone(t));
      this.morphAttributes[d] = f;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let d = 0, f = o.length; d < f; d++) {
      const p = o[d];
      this.addGroup(p.start, p.count, p.materialIndex);
    }
    const s = e.boundingBox;
    s !== null && (this.boundingBox = s.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const A3 = /* @__PURE__ */ new wn(), Vf = /* @__PURE__ */ new Eg(), t_ = /* @__PURE__ */ new Pa(), O3 = /* @__PURE__ */ new de(), ym = /* @__PURE__ */ new de(), bm = /* @__PURE__ */ new de(), Sm = /* @__PURE__ */ new de(), zM = /* @__PURE__ */ new de(), n_ = /* @__PURE__ */ new de(), r_ = /* @__PURE__ */ new St(), i_ = /* @__PURE__ */ new St(), a_ = /* @__PURE__ */ new St(), P3 = /* @__PURE__ */ new de(), D3 = /* @__PURE__ */ new de(), I3 = /* @__PURE__ */ new de(), o_ = /* @__PURE__ */ new de(), s_ = /* @__PURE__ */ new de();
class Zi extends pr {
  constructor(e = new Xn(), t = new qd()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = a;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry, i = r.attributes.position, a = r.morphAttributes.position, o = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const s = this.morphTargetInfluences;
    if (a && s) {
      n_.set(0, 0, 0);
      for (let u = 0, d = a.length; u < d; u++) {
        const f = s[u], p = a[u];
        f !== 0 && (zM.fromBufferAttribute(p, e), o ? n_.addScaledVector(zM, f) : n_.addScaledVector(zM.sub(t), f));
      }
      t.add(n_);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.material, a = this.matrixWorld;
    i !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), t_.copy(r.boundingSphere), t_.applyMatrix4(a), Vf.copy(e.ray).recast(e.near), !(t_.containsPoint(Vf.origin) === !1 && (Vf.intersectSphere(t_, O3) === null || Vf.origin.distanceToSquared(O3) > (e.far - e.near) ** 2)) && (A3.copy(a).invert(), Vf.copy(e.ray).applyMatrix4(A3), !(r.boundingBox !== null && Vf.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, t, Vf)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const a = this.geometry, o = this.material, s = a.index, u = a.attributes.position, d = a.attributes.uv, f = a.attributes.uv1, p = a.attributes.normal, g = a.groups, v = a.drawRange;
    if (s !== null)
      if (Array.isArray(o))
        for (let b = 0, E = g.length; b < E; b++) {
          const S = g[b], _ = o[S.materialIndex], w = Math.max(S.start, v.start), C = Math.min(s.count, Math.min(S.start + S.count, v.start + v.count));
          for (let R = w, P = C; R < P; R += 3) {
            const D = s.getX(R), I = s.getX(R + 1), U = s.getX(R + 2);
            i = l_(this, _, e, r, d, f, p, D, I, U), i && (i.faceIndex = Math.floor(R / 3), i.face.materialIndex = S.materialIndex, t.push(i));
          }
        }
      else {
        const b = Math.max(0, v.start), E = Math.min(s.count, v.start + v.count);
        for (let S = b, _ = E; S < _; S += 3) {
          const w = s.getX(S), C = s.getX(S + 1), R = s.getX(S + 2);
          i = l_(this, o, e, r, d, f, p, w, C, R), i && (i.faceIndex = Math.floor(S / 3), t.push(i));
        }
      }
    else if (u !== void 0)
      if (Array.isArray(o))
        for (let b = 0, E = g.length; b < E; b++) {
          const S = g[b], _ = o[S.materialIndex], w = Math.max(S.start, v.start), C = Math.min(u.count, Math.min(S.start + S.count, v.start + v.count));
          for (let R = w, P = C; R < P; R += 3) {
            const D = R, I = R + 1, U = R + 2;
            i = l_(this, _, e, r, d, f, p, D, I, U), i && (i.faceIndex = Math.floor(R / 3), i.face.materialIndex = S.materialIndex, t.push(i));
          }
        }
      else {
        const b = Math.max(0, v.start), E = Math.min(u.count, v.start + v.count);
        for (let S = b, _ = E; S < _; S += 3) {
          const w = S, C = S + 1, R = S + 2;
          i = l_(this, o, e, r, d, f, p, w, C, R), i && (i.faceIndex = Math.floor(S / 3), t.push(i));
        }
      }
  }
}
function nse(n, e, t, r, i, a, o, s) {
  let u;
  if (e.side === ho ? u = r.intersectTriangle(o, a, i, !0, s) : u = r.intersectTriangle(i, a, o, e.side === mu, s), u === null) return null;
  s_.copy(s), s_.applyMatrix4(n.matrixWorld);
  const d = t.ray.origin.distanceTo(s_);
  return d < t.near || d > t.far ? null : {
    distance: d,
    point: s_.clone(),
    object: n
  };
}
function l_(n, e, t, r, i, a, o, s, u, d) {
  n.getVertexPosition(s, ym), n.getVertexPosition(u, bm), n.getVertexPosition(d, Sm);
  const f = nse(n, e, t, r, ym, bm, Sm, o_);
  if (f) {
    i && (r_.fromBufferAttribute(i, s), i_.fromBufferAttribute(i, u), a_.fromBufferAttribute(i, d), f.uv = ds.getInterpolation(o_, ym, bm, Sm, r_, i_, a_, new St())), a && (r_.fromBufferAttribute(a, s), i_.fromBufferAttribute(a, u), a_.fromBufferAttribute(a, d), f.uv1 = ds.getInterpolation(o_, ym, bm, Sm, r_, i_, a_, new St())), o && (P3.fromBufferAttribute(o, s), D3.fromBufferAttribute(o, u), I3.fromBufferAttribute(o, d), f.normal = ds.getInterpolation(o_, ym, bm, Sm, P3, D3, I3, new de()), f.normal.dot(r.direction) > 0 && f.normal.multiplyScalar(-1));
    const p = {
      a: s,
      b: u,
      c: d,
      normal: new de(),
      materialIndex: 0
    };
    ds.getNormal(ym, bm, Sm, p.normal), f.face = p;
  }
  return f;
}
class Cu extends Xn {
  constructor(e = 1, t = 1, r = 1, i = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: i,
      heightSegments: a,
      depthSegments: o
    };
    const s = this;
    i = Math.floor(i), a = Math.floor(a), o = Math.floor(o);
    const u = [], d = [], f = [], p = [];
    let g = 0, v = 0;
    b("z", "y", "x", -1, -1, r, t, e, o, a, 0), b("z", "y", "x", 1, -1, r, t, -e, o, a, 1), b("x", "z", "y", 1, 1, e, r, t, i, o, 2), b("x", "z", "y", 1, -1, e, r, -t, i, o, 3), b("x", "y", "z", 1, -1, e, t, r, i, a, 4), b("x", "y", "z", -1, -1, e, t, -r, i, a, 5), this.setIndex(u), this.setAttribute("position", new fn(d, 3)), this.setAttribute("normal", new fn(f, 3)), this.setAttribute("uv", new fn(p, 2));
    function b(E, S, _, w, C, R, P, D, I, U, L) {
      const N = R / I, H = P / U, j = R / 2, G = P / 2, X = D / 2, ae = I + 1, Z = U + 1;
      let K = 0, B = 0;
      const Q = new de();
      for (let V = 0; V < Z; V++) {
        const q = V * H - G;
        for (let ne = 0; ne < ae; ne++) {
          const ce = ne * N - j;
          Q[E] = ce * w, Q[S] = q * C, Q[_] = X, d.push(Q.x, Q.y, Q.z), Q[E] = 0, Q[S] = 0, Q[_] = D > 0 ? 1 : -1, f.push(Q.x, Q.y, Q.z), p.push(ne / I), p.push(1 - V / U), K += 1;
        }
      }
      for (let V = 0; V < U; V++)
        for (let q = 0; q < I; q++) {
          const ne = g + q + ae * V, ce = g + q + ae * (V + 1), ie = g + (q + 1) + ae * (V + 1), oe = g + (q + 1) + ae * V;
          u.push(ne, ce, oe), u.push(ce, ie, oe), B += 6;
        }
      s.addGroup(v, B, L), v += B, g += K;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Cu(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function ug(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][r] = null) : e[t][r] = i.clone() : Array.isArray(i) ? e[t][r] = i.slice() : e[t][r] = i;
    }
  }
  return e;
}
function lo(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = ug(n[t]);
    for (const i in r)
      e[i] = r[i];
  }
  return e;
}
function rse(n) {
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n[t].clone());
  return e;
}
function Ak(n) {
  const e = n.getRenderTarget();
  return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Cr.workingColorSpace;
}
const Ok = { clone: ug, merge: lo };
var ise = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, ase = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Rl extends Da {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = ise, this.fragmentShader = ase, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ug(e.uniforms), this.uniformsGroups = rse(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture ? t.uniforms[i] = {
        type: "t",
        value: o.toJSON(e).uuid
      } : o && o.isColor ? t.uniforms[i] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: o.toArray()
      } : t.uniforms[i] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const r = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class D0 extends pr {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new wn(), this.projectionMatrix = new wn(), this.projectionMatrixInverse = new wn(), this.coordinateSystem = sc;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Td = /* @__PURE__ */ new de(), N3 = /* @__PURE__ */ new St(), L3 = /* @__PURE__ */ new St();
class sa extends D0 {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = cg * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(Ch * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return cg * 2 * Math.atan(
      Math.tan(Ch * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, t, r) {
    Td.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Td.x, Td.y).multiplyScalar(-e / Td.z), Td.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), r.set(Td.x, Td.y).multiplyScalar(-e / Td.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, N3, L3), t.subVectors(L3, N3);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, r, i, a, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Ch * 0.5 * this.fov) / this.zoom, r = 2 * t, i = this.aspect * r, a = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth, d = o.fullHeight;
      a += o.offsetX * i / u, t -= o.offsetY * r / d, i *= o.width / u, r *= o.height / d;
    }
    const s = this.filmOffset;
    s !== 0 && (a += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + i, t, t - r, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const _m = -90, xm = 1;
class Pk extends pr {
  constructor(e, t, r) {
    super(), this.type = "CubeCamera", this.renderTarget = r, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new sa(_m, xm, e, t);
    i.layers = this.layers, this.add(i);
    const a = new sa(_m, xm, e, t);
    a.layers = this.layers, this.add(a);
    const o = new sa(_m, xm, e, t);
    o.layers = this.layers, this.add(o);
    const s = new sa(_m, xm, e, t);
    s.layers = this.layers, this.add(s);
    const u = new sa(_m, xm, e, t);
    u.layers = this.layers, this.add(u);
    const d = new sa(_m, xm, e, t);
    d.layers = this.layers, this.add(d);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [r, i, a, o, s, u] = t;
    for (const d of t) this.remove(d);
    if (e === sc)
      r.up.set(0, 1, 0), r.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), s.up.set(0, 1, 0), s.lookAt(0, 0, 1), u.up.set(0, 1, 0), u.lookAt(0, 0, -1);
    else if (e === l0)
      r.up.set(0, -1, 0), r.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), s.up.set(0, -1, 0), s.lookAt(0, 0, 1), u.up.set(0, -1, 0), u.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const d of t)
      this.add(d), d.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [a, o, s, u, d, f] = this.children, p = e.getRenderTarget(), g = e.getActiveCubeFace(), v = e.getActiveMipmapLevel(), b = e.xr.enabled;
    e.xr.enabled = !1;
    const E = r.texture.generateMipmaps;
    r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0, i), e.render(t, a), e.setRenderTarget(r, 1, i), e.render(t, o), e.setRenderTarget(r, 2, i), e.render(t, s), e.setRenderTarget(r, 3, i), e.render(t, u), e.setRenderTarget(r, 4, i), e.render(t, d), r.texture.generateMipmaps = E, e.setRenderTarget(r, 5, i), e.render(t, f), e.setRenderTarget(p, g, v), e.xr.enabled = b, r.texture.needsPMREMUpdate = !0;
  }
}
class I0 extends Ei {
  constructor(e, t, r, i, a, o, s, u, d, f) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : gu, super(e, t, r, i, a, o, s, u, d, f), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Dk extends Tl {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const r = { width: e, height: e, depth: 1 }, i = [r, r, r, r, r, r];
    this.texture = new I0(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ki;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const r = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new Cu(5, 5, 5), a = new Rl({
      name: "CubemapFromEquirect",
      uniforms: ug(r.uniforms),
      vertexShader: r.vertexShader,
      fragmentShader: r.fragmentShader,
      side: ho,
      blending: cu
    });
    a.uniforms.tEquirect.value = t;
    const o = new Zi(i, a), s = t.minFilter;
    return t.minFilter === oc && (t.minFilter = Ki), new Pk(1, 10, this).update(e, o), t.minFilter = s, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, r, i) {
    const a = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(t, r, i);
    e.setRenderTarget(a);
  }
}
const BM = /* @__PURE__ */ new de(), ose = /* @__PURE__ */ new de(), sse = /* @__PURE__ */ new zn();
class Ld {
  constructor(e = new de(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = BM.subVectors(r, t).cross(ose.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(BM), i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / i;
    return a < 0 || a > 1 ? null : t.copy(e.start).addScaledVector(r, a);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return t < 0 && r > 0 || r < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || sse.getNormalMatrix(e), i = this.coplanarPoint(BM).applyMatrix4(e), a = this.normal.applyMatrix3(r).normalize();
    return this.constant = -i.dot(a), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kf = /* @__PURE__ */ new Pa(), c_ = /* @__PURE__ */ new de();
class N0 {
  constructor(e = new Ld(), t = new Ld(), r = new Ld(), i = new Ld(), a = new Ld(), o = new Ld()) {
    this.planes = [e, t, r, i, a, o];
  }
  set(e, t, r, i, a, o) {
    const s = this.planes;
    return s[0].copy(e), s[1].copy(t), s[2].copy(r), s[3].copy(i), s[4].copy(a), s[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = sc) {
    const r = this.planes, i = e.elements, a = i[0], o = i[1], s = i[2], u = i[3], d = i[4], f = i[5], p = i[6], g = i[7], v = i[8], b = i[9], E = i[10], S = i[11], _ = i[12], w = i[13], C = i[14], R = i[15];
    if (r[0].setComponents(u - a, g - d, S - v, R - _).normalize(), r[1].setComponents(u + a, g + d, S + v, R + _).normalize(), r[2].setComponents(u + o, g + f, S + b, R + w).normalize(), r[3].setComponents(u - o, g - f, S - b, R - w).normalize(), r[4].setComponents(u - s, g - p, S - E, R - C).normalize(), t === sc)
      r[5].setComponents(u + s, g + p, S + E, R + C).normalize();
    else if (t === l0)
      r[5].setComponents(s, p, E, C).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), kf.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), kf.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(kf);
  }
  intersectsSprite(e) {
    return kf.center.set(0, 0, 0), kf.radius = 0.7071067811865476, kf.applyMatrix4(e.matrixWorld), this.intersectsSphere(kf);
  }
  intersectsSphere(e) {
    const t = this.planes, r = e.center, i = -e.radius;
    for (let a = 0; a < 6; a++)
      if (t[a].distanceToPoint(r) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (c_.x = i.normal.x > 0 ? e.max.x : e.min.x, c_.y = i.normal.y > 0 ? e.max.y : e.min.y, c_.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(c_) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Ik() {
  let n = null, e = !1, t = null, r = null;
  function i(a, o) {
    t(a, o), r = n.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (r = n.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      n.cancelAnimationFrame(r), e = !1;
    },
    setAnimationLoop: function(a) {
      t = a;
    },
    setContext: function(a) {
      n = a;
    }
  };
}
function lse(n) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(s, u) {
    const d = s.array, f = s.usage, p = d.byteLength, g = n.createBuffer();
    n.bindBuffer(u, g), n.bufferData(u, d, f), s.onUploadCallback();
    let v;
    if (d instanceof Float32Array)
      v = n.FLOAT;
    else if (d instanceof Uint16Array)
      s.isFloat16BufferAttribute ? v = n.HALF_FLOAT : v = n.UNSIGNED_SHORT;
    else if (d instanceof Int16Array)
      v = n.SHORT;
    else if (d instanceof Uint32Array)
      v = n.UNSIGNED_INT;
    else if (d instanceof Int32Array)
      v = n.INT;
    else if (d instanceof Int8Array)
      v = n.BYTE;
    else if (d instanceof Uint8Array)
      v = n.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray)
      v = n.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
    return {
      buffer: g,
      type: v,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: s.version,
      size: p
    };
  }
  function r(s, u, d) {
    const f = u.array, p = u._updateRange, g = u.updateRanges;
    if (n.bindBuffer(d, s), p.count === -1 && g.length === 0 && n.bufferSubData(d, 0, f), g.length !== 0) {
      for (let v = 0, b = g.length; v < b; v++) {
        const E = g[v];
        n.bufferSubData(
          d,
          E.start * f.BYTES_PER_ELEMENT,
          f,
          E.start,
          E.count
        );
      }
      u.clearUpdateRanges();
    }
    p.count !== -1 && (n.bufferSubData(
      d,
      p.offset * f.BYTES_PER_ELEMENT,
      f,
      p.offset,
      p.count
    ), p.count = -1), u.onUploadCallback();
  }
  function i(s) {
    return s.isInterleavedBufferAttribute && (s = s.data), e.get(s);
  }
  function a(s) {
    s.isInterleavedBufferAttribute && (s = s.data);
    const u = e.get(s);
    u && (n.deleteBuffer(u.buffer), e.delete(s));
  }
  function o(s, u) {
    if (s.isGLBufferAttribute) {
      const f = e.get(s);
      (!f || f.version < s.version) && e.set(s, {
        buffer: s.buffer,
        type: s.type,
        bytesPerElement: s.elementSize,
        version: s.version
      });
      return;
    }
    s.isInterleavedBufferAttribute && (s = s.data);
    const d = e.get(s);
    if (d === void 0)
      e.set(s, t(s, u));
    else if (d.version < s.version) {
      if (d.size !== s.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      r(d.buffer, s, u), d.version = s.version;
    }
  }
  return {
    get: i,
    remove: a,
    update: o
  };
}
class Cg extends Xn {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: i
    };
    const a = e / 2, o = t / 2, s = Math.floor(r), u = Math.floor(i), d = s + 1, f = u + 1, p = e / s, g = t / u, v = [], b = [], E = [], S = [];
    for (let _ = 0; _ < f; _++) {
      const w = _ * g - o;
      for (let C = 0; C < d; C++) {
        const R = C * p - a;
        b.push(R, -w, 0), E.push(0, 0, 1), S.push(C / s), S.push(1 - _ / u);
      }
    }
    for (let _ = 0; _ < u; _++)
      for (let w = 0; w < s; w++) {
        const C = w + d * _, R = w + d * (_ + 1), P = w + 1 + d * (_ + 1), D = w + 1 + d * _;
        v.push(C, R, D), v.push(R, P, D);
      }
    this.setIndex(v), this.setAttribute("position", new fn(b, 3)), this.setAttribute("normal", new fn(E, 3)), this.setAttribute("uv", new fn(S, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Cg(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var cse = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, use = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, dse = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, fse = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, hse = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, pse = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, mse = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, gse = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, vse = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, yse = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, bse = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Sse = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, _se = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, xse = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Ese = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Cse = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, wse = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Mse = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Tse = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Rse = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Ase = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Ose = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, Pse = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, Dse = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Ise = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Nse = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Lse = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Fse = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Use = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, zse = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Bse = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Hse = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, Vse = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, kse = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, $se = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Wse = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, jse = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Gse = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Xse = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, qse = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Yse = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Kse = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Zse = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Qse = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Jse = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, ele = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, tle = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, nle = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, rle = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, ile = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, ale = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, ole = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, sle = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lle = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, cle = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, ule = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, dle = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, fle = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, hle = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, ple = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, mle = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, gle = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, vle = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, yle = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, ble = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Sle = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, _le = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, xle = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Ele = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Cle = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, wle = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Mle = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Tle = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Rle = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Ale = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Ole = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Ple = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Dle = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Ile = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Nle = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Lle = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Fle = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Ule = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, zle = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Ble = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Hle = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Vle = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, kle = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, $le = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Wle = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, jle = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Gle = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Xle = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, qle = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Yle = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Kle = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Zle = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Qle = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Jle = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, ece = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tce = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, nce = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, rce = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, ice = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, ace = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, oce = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, sce = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const lce = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, cce = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, uce = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, dce = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, fce = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, hce = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, pce = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, mce = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, gce = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, vce = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, yce = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, bce = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Sce = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, _ce = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, xce = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Ece = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Cce = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, wce = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Mce = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Tce = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Rce = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Ace = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Oce = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Pce = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Dce = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Ice = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Nce = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Lce = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Fce = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Uce = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, zce = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Bce = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Hce = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Vce = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Gn = {
  alphahash_fragment: cse,
  alphahash_pars_fragment: use,
  alphamap_fragment: dse,
  alphamap_pars_fragment: fse,
  alphatest_fragment: hse,
  alphatest_pars_fragment: pse,
  aomap_fragment: mse,
  aomap_pars_fragment: gse,
  batching_pars_vertex: vse,
  batching_vertex: yse,
  begin_vertex: bse,
  beginnormal_vertex: Sse,
  bsdfs: _se,
  iridescence_fragment: xse,
  bumpmap_pars_fragment: Ese,
  clipping_planes_fragment: Cse,
  clipping_planes_pars_fragment: wse,
  clipping_planes_pars_vertex: Mse,
  clipping_planes_vertex: Tse,
  color_fragment: Rse,
  color_pars_fragment: Ase,
  color_pars_vertex: Ose,
  color_vertex: Pse,
  common: Dse,
  cube_uv_reflection_fragment: Ise,
  defaultnormal_vertex: Nse,
  displacementmap_pars_vertex: Lse,
  displacementmap_vertex: Fse,
  emissivemap_fragment: Use,
  emissivemap_pars_fragment: zse,
  colorspace_fragment: Bse,
  colorspace_pars_fragment: Hse,
  envmap_fragment: Vse,
  envmap_common_pars_fragment: kse,
  envmap_pars_fragment: $se,
  envmap_pars_vertex: Wse,
  envmap_physical_pars_fragment: tle,
  envmap_vertex: jse,
  fog_vertex: Gse,
  fog_pars_vertex: Xse,
  fog_fragment: qse,
  fog_pars_fragment: Yse,
  gradientmap_pars_fragment: Kse,
  lightmap_pars_fragment: Zse,
  lights_lambert_fragment: Qse,
  lights_lambert_pars_fragment: Jse,
  lights_pars_begin: ele,
  lights_toon_fragment: nle,
  lights_toon_pars_fragment: rle,
  lights_phong_fragment: ile,
  lights_phong_pars_fragment: ale,
  lights_physical_fragment: ole,
  lights_physical_pars_fragment: sle,
  lights_fragment_begin: lle,
  lights_fragment_maps: cle,
  lights_fragment_end: ule,
  logdepthbuf_fragment: dle,
  logdepthbuf_pars_fragment: fle,
  logdepthbuf_pars_vertex: hle,
  logdepthbuf_vertex: ple,
  map_fragment: mle,
  map_pars_fragment: gle,
  map_particle_fragment: vle,
  map_particle_pars_fragment: yle,
  metalnessmap_fragment: ble,
  metalnessmap_pars_fragment: Sle,
  morphinstance_vertex: _le,
  morphcolor_vertex: xle,
  morphnormal_vertex: Ele,
  morphtarget_pars_vertex: Cle,
  morphtarget_vertex: wle,
  normal_fragment_begin: Mle,
  normal_fragment_maps: Tle,
  normal_pars_fragment: Rle,
  normal_pars_vertex: Ale,
  normal_vertex: Ole,
  normalmap_pars_fragment: Ple,
  clearcoat_normal_fragment_begin: Dle,
  clearcoat_normal_fragment_maps: Ile,
  clearcoat_pars_fragment: Nle,
  iridescence_pars_fragment: Lle,
  opaque_fragment: Fle,
  packing: Ule,
  premultiplied_alpha_fragment: zle,
  project_vertex: Ble,
  dithering_fragment: Hle,
  dithering_pars_fragment: Vle,
  roughnessmap_fragment: kle,
  roughnessmap_pars_fragment: $le,
  shadowmap_pars_fragment: Wle,
  shadowmap_pars_vertex: jle,
  shadowmap_vertex: Gle,
  shadowmask_pars_fragment: Xle,
  skinbase_vertex: qle,
  skinning_pars_vertex: Yle,
  skinning_vertex: Kle,
  skinnormal_vertex: Zle,
  specularmap_fragment: Qle,
  specularmap_pars_fragment: Jle,
  tonemapping_fragment: ece,
  tonemapping_pars_fragment: tce,
  transmission_fragment: nce,
  transmission_pars_fragment: rce,
  uv_pars_fragment: ice,
  uv_pars_vertex: ace,
  uv_vertex: oce,
  worldpos_vertex: sce,
  background_vert: lce,
  background_frag: cce,
  backgroundCube_vert: uce,
  backgroundCube_frag: dce,
  cube_vert: fce,
  cube_frag: hce,
  depth_vert: pce,
  depth_frag: mce,
  distanceRGBA_vert: gce,
  distanceRGBA_frag: vce,
  equirect_vert: yce,
  equirect_frag: bce,
  linedashed_vert: Sce,
  linedashed_frag: _ce,
  meshbasic_vert: xce,
  meshbasic_frag: Ece,
  meshlambert_vert: Cce,
  meshlambert_frag: wce,
  meshmatcap_vert: Mce,
  meshmatcap_frag: Tce,
  meshnormal_vert: Rce,
  meshnormal_frag: Ace,
  meshphong_vert: Oce,
  meshphong_frag: Pce,
  meshphysical_vert: Dce,
  meshphysical_frag: Ice,
  meshtoon_vert: Nce,
  meshtoon_frag: Lce,
  points_vert: Fce,
  points_frag: Uce,
  shadow_vert: zce,
  shadow_frag: Bce,
  sprite_vert: Hce,
  sprite_frag: Vce
}, Yt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new an(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new zn() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new zn() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new zn() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new zn() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new zn() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new zn() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new zn() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new zn() },
    normalScale: { value: /* @__PURE__ */ new St(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new zn() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new zn() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new zn() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new zn() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new an(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new an(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new zn() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new zn() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new an(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new St(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new zn() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new zn() },
    alphaTest: { value: 0 }
  }
}, xl = {
  basic: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.specularmap,
      Yt.envmap,
      Yt.aomap,
      Yt.lightmap,
      Yt.fog
    ]),
    vertexShader: Gn.meshbasic_vert,
    fragmentShader: Gn.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.specularmap,
      Yt.envmap,
      Yt.aomap,
      Yt.lightmap,
      Yt.emissivemap,
      Yt.bumpmap,
      Yt.normalmap,
      Yt.displacementmap,
      Yt.fog,
      Yt.lights,
      {
        emissive: { value: /* @__PURE__ */ new an(0) }
      }
    ]),
    vertexShader: Gn.meshlambert_vert,
    fragmentShader: Gn.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.specularmap,
      Yt.envmap,
      Yt.aomap,
      Yt.lightmap,
      Yt.emissivemap,
      Yt.bumpmap,
      Yt.normalmap,
      Yt.displacementmap,
      Yt.fog,
      Yt.lights,
      {
        emissive: { value: /* @__PURE__ */ new an(0) },
        specular: { value: /* @__PURE__ */ new an(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Gn.meshphong_vert,
    fragmentShader: Gn.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.envmap,
      Yt.aomap,
      Yt.lightmap,
      Yt.emissivemap,
      Yt.bumpmap,
      Yt.normalmap,
      Yt.displacementmap,
      Yt.roughnessmap,
      Yt.metalnessmap,
      Yt.fog,
      Yt.lights,
      {
        emissive: { value: /* @__PURE__ */ new an(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Gn.meshphysical_vert,
    fragmentShader: Gn.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.aomap,
      Yt.lightmap,
      Yt.emissivemap,
      Yt.bumpmap,
      Yt.normalmap,
      Yt.displacementmap,
      Yt.gradientmap,
      Yt.fog,
      Yt.lights,
      {
        emissive: { value: /* @__PURE__ */ new an(0) }
      }
    ]),
    vertexShader: Gn.meshtoon_vert,
    fragmentShader: Gn.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.bumpmap,
      Yt.normalmap,
      Yt.displacementmap,
      Yt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Gn.meshmatcap_vert,
    fragmentShader: Gn.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ lo([
      Yt.points,
      Yt.fog
    ]),
    vertexShader: Gn.points_vert,
    fragmentShader: Gn.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Gn.linedashed_vert,
    fragmentShader: Gn.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.displacementmap
    ]),
    vertexShader: Gn.depth_vert,
    fragmentShader: Gn.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.bumpmap,
      Yt.normalmap,
      Yt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Gn.meshnormal_vert,
    fragmentShader: Gn.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ lo([
      Yt.sprite,
      Yt.fog
    ]),
    vertexShader: Gn.sprite_vert,
    fragmentShader: Gn.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new zn() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Gn.background_vert,
    fragmentShader: Gn.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new zn() }
    },
    vertexShader: Gn.backgroundCube_vert,
    fragmentShader: Gn.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Gn.cube_vert,
    fragmentShader: Gn.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Gn.equirect_vert,
    fragmentShader: Gn.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ lo([
      Yt.common,
      Yt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new de() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Gn.distanceRGBA_vert,
    fragmentShader: Gn.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ lo([
      Yt.lights,
      Yt.fog,
      {
        color: { value: /* @__PURE__ */ new an(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Gn.shadow_vert,
    fragmentShader: Gn.shadow_frag
  }
};
xl.physical = {
  uniforms: /* @__PURE__ */ lo([
    xl.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new zn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new zn() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new St(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new zn() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new zn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new zn() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new an(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new zn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new zn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new zn() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new St() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new zn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new an(0) },
      specularColor: { value: /* @__PURE__ */ new an(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new zn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new zn() },
      anisotropyVector: { value: /* @__PURE__ */ new St() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new zn() }
    }
  ]),
  vertexShader: Gn.meshphysical_vert,
  fragmentShader: Gn.meshphysical_frag
};
const u_ = { r: 0, b: 0, g: 0 }, $f = /* @__PURE__ */ new gs(), kce = /* @__PURE__ */ new wn();
function $ce(n, e, t, r, i, a, o) {
  const s = new an(0);
  let u = a === !0 ? 0 : 1, d, f, p = null, g = 0, v = null;
  function b(w) {
    let C = w.isScene === !0 ? w.background : null;
    return C && C.isTexture && (C = (w.backgroundBlurriness > 0 ? t : e).get(C)), C;
  }
  function E(w) {
    let C = !1;
    const R = b(w);
    R === null ? _(s, u) : R && R.isColor && (_(R, 1), C = !0);
    const P = n.xr.getEnvironmentBlendMode();
    P === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, o) : P === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, o), (n.autoClear || C) && (r.buffers.depth.setTest(!0), r.buffers.depth.setMask(!0), r.buffers.color.setMask(!0), n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }
  function S(w, C) {
    const R = b(C);
    R && (R.isCubeTexture || R.mapping === _g) ? (f === void 0 && (f = new Zi(
      new Cu(1, 1, 1),
      new Rl({
        name: "BackgroundCubeMaterial",
        uniforms: ug(xl.backgroundCube.uniforms),
        vertexShader: xl.backgroundCube.vertexShader,
        fragmentShader: xl.backgroundCube.fragmentShader,
        side: ho,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), f.geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function(P, D, I) {
      this.matrixWorld.copyPosition(I.matrixWorld);
    }, Object.defineProperty(f.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(f)), $f.copy(C.backgroundRotation), $f.x *= -1, $f.y *= -1, $f.z *= -1, R.isCubeTexture && R.isRenderTargetTexture === !1 && ($f.y *= -1, $f.z *= -1), f.material.uniforms.envMap.value = R, f.material.uniforms.flipEnvMap.value = R.isCubeTexture && R.isRenderTargetTexture === !1 ? -1 : 1, f.material.uniforms.backgroundBlurriness.value = C.backgroundBlurriness, f.material.uniforms.backgroundIntensity.value = C.backgroundIntensity, f.material.uniforms.backgroundRotation.value.setFromMatrix4(kce.makeRotationFromEuler($f)), f.material.toneMapped = Cr.getTransfer(R.colorSpace) !== ei, (p !== R || g !== R.version || v !== n.toneMapping) && (f.material.needsUpdate = !0, p = R, g = R.version, v = n.toneMapping), f.layers.enableAll(), w.unshift(f, f.geometry, f.material, 0, 0, null)) : R && R.isTexture && (d === void 0 && (d = new Zi(
      new Cg(2, 2),
      new Rl({
        name: "BackgroundMaterial",
        uniforms: ug(xl.background.uniforms),
        vertexShader: xl.background.vertexShader,
        fragmentShader: xl.background.fragmentShader,
        side: mu,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), d.geometry.deleteAttribute("normal"), Object.defineProperty(d.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(d)), d.material.uniforms.t2D.value = R, d.material.uniforms.backgroundIntensity.value = C.backgroundIntensity, d.material.toneMapped = Cr.getTransfer(R.colorSpace) !== ei, R.matrixAutoUpdate === !0 && R.updateMatrix(), d.material.uniforms.uvTransform.value.copy(R.matrix), (p !== R || g !== R.version || v !== n.toneMapping) && (d.material.needsUpdate = !0, p = R, g = R.version, v = n.toneMapping), d.layers.enableAll(), w.unshift(d, d.geometry, d.material, 0, 0, null));
  }
  function _(w, C) {
    w.getRGB(u_, Ak(n)), r.buffers.color.setClear(u_.r, u_.g, u_.b, C, o);
  }
  return {
    getClearColor: function() {
      return s;
    },
    setClearColor: function(w, C = 1) {
      s.set(w), u = C, _(s, u);
    },
    getClearAlpha: function() {
      return u;
    },
    setClearAlpha: function(w) {
      u = w, _(s, u);
    },
    render: E,
    addToRenderList: S
  };
}
function Wce(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS), r = {}, i = g(null);
  let a = i, o = !1;
  function s(N, H, j, G, X) {
    let ae = !1;
    const Z = p(G, j, H);
    a !== Z && (a = Z, d(a.object)), ae = v(N, G, j, X), ae && b(N, G, j, X), X !== null && e.update(X, n.ELEMENT_ARRAY_BUFFER), (ae || o) && (o = !1, R(N, H, j, G), X !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(X).buffer));
  }
  function u() {
    return n.createVertexArray();
  }
  function d(N) {
    return n.bindVertexArray(N);
  }
  function f(N) {
    return n.deleteVertexArray(N);
  }
  function p(N, H, j) {
    const G = j.wireframe === !0;
    let X = r[N.id];
    X === void 0 && (X = {}, r[N.id] = X);
    let ae = X[H.id];
    ae === void 0 && (ae = {}, X[H.id] = ae);
    let Z = ae[G];
    return Z === void 0 && (Z = g(u()), ae[G] = Z), Z;
  }
  function g(N) {
    const H = [], j = [], G = [];
    for (let X = 0; X < t; X++)
      H[X] = 0, j[X] = 0, G[X] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: H,
      enabledAttributes: j,
      attributeDivisors: G,
      object: N,
      attributes: {},
      index: null
    };
  }
  function v(N, H, j, G) {
    const X = a.attributes, ae = H.attributes;
    let Z = 0;
    const K = j.getAttributes();
    for (const B in K)
      if (K[B].location >= 0) {
        const V = X[B];
        let q = ae[B];
        if (q === void 0 && (B === "instanceMatrix" && N.instanceMatrix && (q = N.instanceMatrix), B === "instanceColor" && N.instanceColor && (q = N.instanceColor)), V === void 0 || V.attribute !== q || q && V.data !== q.data) return !0;
        Z++;
      }
    return a.attributesNum !== Z || a.index !== G;
  }
  function b(N, H, j, G) {
    const X = {}, ae = H.attributes;
    let Z = 0;
    const K = j.getAttributes();
    for (const B in K)
      if (K[B].location >= 0) {
        let V = ae[B];
        V === void 0 && (B === "instanceMatrix" && N.instanceMatrix && (V = N.instanceMatrix), B === "instanceColor" && N.instanceColor && (V = N.instanceColor));
        const q = {};
        q.attribute = V, V && V.data && (q.data = V.data), X[B] = q, Z++;
      }
    a.attributes = X, a.attributesNum = Z, a.index = G;
  }
  function E() {
    const N = a.newAttributes;
    for (let H = 0, j = N.length; H < j; H++)
      N[H] = 0;
  }
  function S(N) {
    _(N, 0);
  }
  function _(N, H) {
    const j = a.newAttributes, G = a.enabledAttributes, X = a.attributeDivisors;
    j[N] = 1, G[N] === 0 && (n.enableVertexAttribArray(N), G[N] = 1), X[N] !== H && (n.vertexAttribDivisor(N, H), X[N] = H);
  }
  function w() {
    const N = a.newAttributes, H = a.enabledAttributes;
    for (let j = 0, G = H.length; j < G; j++)
      H[j] !== N[j] && (n.disableVertexAttribArray(j), H[j] = 0);
  }
  function C(N, H, j, G, X, ae, Z) {
    Z === !0 ? n.vertexAttribIPointer(N, H, j, X, ae) : n.vertexAttribPointer(N, H, j, G, X, ae);
  }
  function R(N, H, j, G) {
    E();
    const X = G.attributes, ae = j.getAttributes(), Z = H.defaultAttributeValues;
    for (const K in ae) {
      const B = ae[K];
      if (B.location >= 0) {
        let Q = X[K];
        if (Q === void 0 && (K === "instanceMatrix" && N.instanceMatrix && (Q = N.instanceMatrix), K === "instanceColor" && N.instanceColor && (Q = N.instanceColor)), Q !== void 0) {
          const V = Q.normalized, q = Q.itemSize, ne = e.get(Q);
          if (ne === void 0) continue;
          const ce = ne.buffer, ie = ne.type, oe = ne.bytesPerElement, he = ie === n.INT || ie === n.UNSIGNED_INT || Q.gpuType === BE;
          if (Q.isInterleavedBufferAttribute) {
            const le = Q.data, ve = le.stride, Ne = Q.offset;
            if (le.isInstancedInterleavedBuffer) {
              for (let xe = 0; xe < B.locationSize; xe++)
                _(B.location + xe, le.meshPerAttribute);
              N.isInstancedMesh !== !0 && G._maxInstanceCount === void 0 && (G._maxInstanceCount = le.meshPerAttribute * le.count);
            } else
              for (let xe = 0; xe < B.locationSize; xe++)
                S(B.location + xe);
            n.bindBuffer(n.ARRAY_BUFFER, ce);
            for (let xe = 0; xe < B.locationSize; xe++)
              C(
                B.location + xe,
                q / B.locationSize,
                ie,
                V,
                ve * oe,
                (Ne + q / B.locationSize * xe) * oe,
                he
              );
          } else {
            if (Q.isInstancedBufferAttribute) {
              for (let le = 0; le < B.locationSize; le++)
                _(B.location + le, Q.meshPerAttribute);
              N.isInstancedMesh !== !0 && G._maxInstanceCount === void 0 && (G._maxInstanceCount = Q.meshPerAttribute * Q.count);
            } else
              for (let le = 0; le < B.locationSize; le++)
                S(B.location + le);
            n.bindBuffer(n.ARRAY_BUFFER, ce);
            for (let le = 0; le < B.locationSize; le++)
              C(
                B.location + le,
                q / B.locationSize,
                ie,
                V,
                q * oe,
                q / B.locationSize * le * oe,
                he
              );
          }
        } else if (Z !== void 0) {
          const V = Z[K];
          if (V !== void 0)
            switch (V.length) {
              case 2:
                n.vertexAttrib2fv(B.location, V);
                break;
              case 3:
                n.vertexAttrib3fv(B.location, V);
                break;
              case 4:
                n.vertexAttrib4fv(B.location, V);
                break;
              default:
                n.vertexAttrib1fv(B.location, V);
            }
        }
      }
    }
    w();
  }
  function P() {
    U();
    for (const N in r) {
      const H = r[N];
      for (const j in H) {
        const G = H[j];
        for (const X in G)
          f(G[X].object), delete G[X];
        delete H[j];
      }
      delete r[N];
    }
  }
  function D(N) {
    if (r[N.id] === void 0) return;
    const H = r[N.id];
    for (const j in H) {
      const G = H[j];
      for (const X in G)
        f(G[X].object), delete G[X];
      delete H[j];
    }
    delete r[N.id];
  }
  function I(N) {
    for (const H in r) {
      const j = r[H];
      if (j[N.id] === void 0) continue;
      const G = j[N.id];
      for (const X in G)
        f(G[X].object), delete G[X];
      delete j[N.id];
    }
  }
  function U() {
    L(), o = !0, a !== i && (a = i, d(a.object));
  }
  function L() {
    i.geometry = null, i.program = null, i.wireframe = !1;
  }
  return {
    setup: s,
    reset: U,
    resetDefaultState: L,
    dispose: P,
    releaseStatesOfGeometry: D,
    releaseStatesOfProgram: I,
    initAttributes: E,
    enableAttribute: S,
    disableUnusedAttributes: w
  };
}
function jce(n, e, t) {
  let r;
  function i(d) {
    r = d;
  }
  function a(d, f) {
    n.drawArrays(r, d, f), t.update(f, r, 1);
  }
  function o(d, f, p) {
    p !== 0 && (n.drawArraysInstanced(r, d, f, p), t.update(f, r, p));
  }
  function s(d, f, p) {
    if (p === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, d, 0, f, 0, p);
    let v = 0;
    for (let b = 0; b < p; b++)
      v += f[b];
    t.update(v, r, 1);
  }
  function u(d, f, p, g) {
    if (p === 0) return;
    const v = e.get("WEBGL_multi_draw");
    if (v === null)
      for (let b = 0; b < d.length; b++)
        o(d[b], f[b], g[b]);
    else {
      v.multiDrawArraysInstancedWEBGL(r, d, 0, f, 0, g, 0, p);
      let b = 0;
      for (let E = 0; E < p; E++)
        b += f[E];
      for (let E = 0; E < g.length; E++)
        t.update(b, r, g[E]);
    }
  }
  this.setMode = i, this.render = a, this.renderInstances = o, this.renderMultiDraw = s, this.renderMultiDrawInstances = u;
}
function Gce(n, e, t, r) {
  let i;
  function a() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const D = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function o(D) {
    return !(D !== Xa && r.convert(D) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function s(D) {
    const I = D === xg && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(D !== Ml && r.convert(D) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    D !== Ho && !I);
  }
  function u(D) {
    if (D === "highp") {
      if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
        return "highp";
      D = "mediump";
    }
    return D === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let d = t.precision !== void 0 ? t.precision : "highp";
  const f = u(d);
  f !== d && (console.warn("THREE.WebGLRenderer:", d, "not supported, using", f, "instead."), d = f);
  const p = t.logarithmicDepthBuffer === !0, g = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), v = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), b = n.getParameter(n.MAX_TEXTURE_SIZE), E = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), S = n.getParameter(n.MAX_VERTEX_ATTRIBS), _ = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), w = n.getParameter(n.MAX_VARYING_VECTORS), C = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), R = v > 0, P = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: a,
    getMaxPrecision: u,
    textureFormatReadable: o,
    textureTypeReadable: s,
    precision: d,
    logarithmicDepthBuffer: p,
    maxTextures: g,
    maxVertexTextures: v,
    maxTextureSize: b,
    maxCubemapSize: E,
    maxAttributes: S,
    maxVertexUniforms: _,
    maxVaryings: w,
    maxFragmentUniforms: C,
    vertexTextures: R,
    maxSamples: P
  };
}
function Xce(n) {
  const e = this;
  let t = null, r = 0, i = !1, a = !1;
  const o = new Ld(), s = new zn(), u = { value: null, needsUpdate: !1 };
  this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(p, g) {
    const v = p.length !== 0 || g || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    r !== 0 || i;
    return i = g, r = p.length, v;
  }, this.beginShadows = function() {
    a = !0, f(null);
  }, this.endShadows = function() {
    a = !1;
  }, this.setGlobalState = function(p, g) {
    t = f(p, g, 0);
  }, this.setState = function(p, g, v) {
    const b = p.clippingPlanes, E = p.clipIntersection, S = p.clipShadows, _ = n.get(p);
    if (!i || b === null || b.length === 0 || a && !S)
      a ? f(null) : d();
    else {
      const w = a ? 0 : r, C = w * 4;
      let R = _.clippingState || null;
      u.value = R, R = f(b, g, C, v);
      for (let P = 0; P !== C; ++P)
        R[P] = t[P];
      _.clippingState = R, this.numIntersection = E ? this.numPlanes : 0, this.numPlanes += w;
    }
  };
  function d() {
    u.value !== t && (u.value = t, u.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function f(p, g, v, b) {
    const E = p !== null ? p.length : 0;
    let S = null;
    if (E !== 0) {
      if (S = u.value, b !== !0 || S === null) {
        const _ = v + E * 4, w = g.matrixWorldInverse;
        s.getNormalMatrix(w), (S === null || S.length < _) && (S = new Float32Array(_));
        for (let C = 0, R = v; C !== E; ++C, R += 4)
          o.copy(p[C]).applyMatrix4(w, s), o.normal.toArray(S, R), S[R + 3] = o.constant;
      }
      u.value = S, u.needsUpdate = !0;
    }
    return e.numPlanes = E, e.numIntersection = 0, S;
  }
}
function qce(n) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, s) {
    return s === Qy ? o.mapping = gu : s === Jy && (o.mapping = kd), o;
  }
  function r(o) {
    if (o && o.isTexture) {
      const s = o.mapping;
      if (s === Qy || s === Jy)
        if (e.has(o)) {
          const u = e.get(o).texture;
          return t(u, o.mapping);
        } else {
          const u = o.image;
          if (u && u.height > 0) {
            const d = new Dk(u.height);
            return d.fromEquirectangularTexture(n, o), e.set(o, d), o.addEventListener("dispose", i), t(d.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function i(o) {
    const s = o.target;
    s.removeEventListener("dispose", i);
    const u = e.get(s);
    u !== void 0 && (e.delete(s), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: a
  };
}
class L0 extends D0 {
  constructor(e = -1, t = 1, r = 1, i = -1, a = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = i, this.near = a, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, r, i, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let a = r - e, o = r + e, s = i + t, u = i - t;
    if (this.view !== null && this.view.enabled) {
      const d = (this.right - this.left) / this.view.fullWidth / this.zoom, f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += d * this.view.offsetX, o = a + d * this.view.width, s -= f * this.view.offsetY, u = s - f * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, s, u, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Wm = 4, F3 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], ah = 20, HM = /* @__PURE__ */ new L0(), U3 = /* @__PURE__ */ new an();
let VM = null, kM = 0, $M = 0, WM = !1;
const nh = (1 + Math.sqrt(5)) / 2, Em = 1 / nh, z3 = [
  /* @__PURE__ */ new de(-nh, Em, 0),
  /* @__PURE__ */ new de(nh, Em, 0),
  /* @__PURE__ */ new de(-Em, 0, nh),
  /* @__PURE__ */ new de(Em, 0, nh),
  /* @__PURE__ */ new de(0, nh, -Em),
  /* @__PURE__ */ new de(0, nh, Em),
  /* @__PURE__ */ new de(-1, 1, -1),
  /* @__PURE__ */ new de(1, 1, -1),
  /* @__PURE__ */ new de(-1, 1, 1),
  /* @__PURE__ */ new de(1, 1, 1)
];
class oA {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, r = 0.1, i = 100) {
    VM = this._renderer.getRenderTarget(), kM = this._renderer.getActiveCubeFace(), $M = this._renderer.getActiveMipmapLevel(), WM = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const a = this._allocateTargets();
    return a.depthBuffer = !0, this._sceneToCubeUV(e, r, i, a), t > 0 && this._blur(a, 0, 0, t), this._applyPMREM(a), this._cleanup(a), a;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = V3(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = H3(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(VM, kM, $M), this._renderer.xr.enabled = WM, e.scissorTest = !1, d_(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === gu || e.mapping === kd ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), VM = this._renderer.getRenderTarget(), kM = this._renderer.getActiveCubeFace(), $M = this._renderer.getActiveMipmapLevel(), WM = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const r = t || this._allocateTargets();
    return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, r = {
      magFilter: Ki,
      minFilter: Ki,
      generateMipmaps: !1,
      type: xg,
      format: Xa,
      colorSpace: xu,
      depthBuffer: !1
    }, i = B3(e, t, r);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = B3(e, t, r);
      const { _lodMax: a } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Yce(a)), this._blurMaterial = Kce(a, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Zi(this._lodPlanes[0], e);
    this._renderer.compile(t, HM);
  }
  _sceneToCubeUV(e, t, r, i) {
    const s = new sa(90, 1, t, r), u = [1, -1, 1, 1, 1, 1], d = [1, 1, 1, -1, -1, -1], f = this._renderer, p = f.autoClear, g = f.toneMapping;
    f.getClearColor(U3), f.toneMapping = lc, f.autoClear = !1;
    const v = new qd({
      name: "PMREM.Background",
      side: ho,
      depthWrite: !1,
      depthTest: !1
    }), b = new Zi(new Cu(), v);
    let E = !1;
    const S = e.background;
    S ? S.isColor && (v.color.copy(S), e.background = null, E = !0) : (v.color.copy(U3), E = !0);
    for (let _ = 0; _ < 6; _++) {
      const w = _ % 3;
      w === 0 ? (s.up.set(0, u[_], 0), s.lookAt(d[_], 0, 0)) : w === 1 ? (s.up.set(0, 0, u[_]), s.lookAt(0, d[_], 0)) : (s.up.set(0, u[_], 0), s.lookAt(0, 0, d[_]));
      const C = this._cubeSize;
      d_(i, w * C, _ > 2 ? C : 0, C, C), f.setRenderTarget(i), E && f.render(b, s), f.render(e, s);
    }
    b.geometry.dispose(), b.material.dispose(), f.toneMapping = g, f.autoClear = p, e.background = S;
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer, i = e.mapping === gu || e.mapping === kd;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = V3()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = H3());
    const a = i ? this._cubemapMaterial : this._equirectMaterial, o = new Zi(this._lodPlanes[0], a), s = a.uniforms;
    s.envMap.value = e;
    const u = this._cubeSize;
    d_(t, 0, 0, 3 * u, 2 * u), r.setRenderTarget(t), r.render(o, HM);
  }
  _applyPMREM(e) {
    const t = this._renderer, r = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let a = 1; a < i; a++) {
      const o = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), s = z3[(i - a - 1) % z3.length];
      this._blur(e, a - 1, a, o, s);
    }
    t.autoClear = r;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, r, i, a) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      r,
      i,
      "latitudinal",
      a
    ), this._halfBlur(
      o,
      e,
      r,
      r,
      i,
      "longitudinal",
      a
    );
  }
  _halfBlur(e, t, r, i, a, o, s) {
    const u = this._renderer, d = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const f = 3, p = new Zi(this._lodPlanes[i], d), g = d.uniforms, v = this._sizeLods[r] - 1, b = isFinite(a) ? Math.PI / (2 * v) : 2 * Math.PI / (2 * ah - 1), E = a / b, S = isFinite(a) ? 1 + Math.floor(f * E) : ah;
    S > ah && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${ah}`);
    const _ = [];
    let w = 0;
    for (let I = 0; I < ah; ++I) {
      const U = I / E, L = Math.exp(-U * U / 2);
      _.push(L), I === 0 ? w += L : I < S && (w += 2 * L);
    }
    for (let I = 0; I < _.length; I++)
      _[I] = _[I] / w;
    g.envMap.value = e.texture, g.samples.value = S, g.weights.value = _, g.latitudinal.value = o === "latitudinal", s && (g.poleAxis.value = s);
    const { _lodMax: C } = this;
    g.dTheta.value = b, g.mipInt.value = C - r;
    const R = this._sizeLods[i], P = 3 * R * (i > C - Wm ? i - C + Wm : 0), D = 4 * (this._cubeSize - R);
    d_(t, P, D, 3 * R, 2 * R), u.setRenderTarget(t), u.render(p, HM);
  }
}
function Yce(n) {
  const e = [], t = [], r = [];
  let i = n;
  const a = n - Wm + 1 + F3.length;
  for (let o = 0; o < a; o++) {
    const s = Math.pow(2, i);
    t.push(s);
    let u = 1 / s;
    o > n - Wm ? u = F3[o - n + Wm - 1] : o === 0 && (u = 0), r.push(u);
    const d = 1 / (s - 2), f = -d, p = 1 + d, g = [f, f, p, f, p, p, f, f, p, p, f, p], v = 6, b = 6, E = 3, S = 2, _ = 1, w = new Float32Array(E * b * v), C = new Float32Array(S * b * v), R = new Float32Array(_ * b * v);
    for (let D = 0; D < v; D++) {
      const I = D % 3 * 2 / 3 - 1, U = D > 2 ? 0 : -1, L = [
        I,
        U,
        0,
        I + 2 / 3,
        U,
        0,
        I + 2 / 3,
        U + 1,
        0,
        I,
        U,
        0,
        I + 2 / 3,
        U + 1,
        0,
        I,
        U + 1,
        0
      ];
      w.set(L, E * b * D), C.set(g, S * b * D);
      const N = [D, D, D, D, D, D];
      R.set(N, _ * b * D);
    }
    const P = new Xn();
    P.setAttribute("position", new jr(w, E)), P.setAttribute("uv", new jr(C, S)), P.setAttribute("faceIndex", new jr(R, _)), e.push(P), i > Wm && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function B3(n, e, t) {
  const r = new Tl(n, e, t);
  return r.texture.mapping = _g, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r;
}
function d_(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function Kce(n, e, t) {
  const r = new Float32Array(ah), i = new de(0, 1, 0);
  return new Rl({
    name: "SphericalGaussianBlur",
    defines: {
      n: ah,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: ZO(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: cu,
    depthTest: !1,
    depthWrite: !1
  });
}
function H3() {
  return new Rl({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: ZO(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: cu,
    depthTest: !1,
    depthWrite: !1
  });
}
function V3() {
  return new Rl({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: ZO(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: cu,
    depthTest: !1,
    depthWrite: !1
  });
}
function ZO() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function Zce(n) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function r(s) {
    if (s && s.isTexture) {
      const u = s.mapping, d = u === Qy || u === Jy, f = u === gu || u === kd;
      if (d || f) {
        let p = e.get(s);
        const g = p !== void 0 ? p.texture.pmremVersion : 0;
        if (s.isRenderTargetTexture && s.pmremVersion !== g)
          return t === null && (t = new oA(n)), p = d ? t.fromEquirectangular(s, p) : t.fromCubemap(s, p), p.texture.pmremVersion = s.pmremVersion, e.set(s, p), p.texture;
        if (p !== void 0)
          return p.texture;
        {
          const v = s.image;
          return d && v && v.height > 0 || f && v && i(v) ? (t === null && (t = new oA(n)), p = d ? t.fromEquirectangular(s) : t.fromCubemap(s), p.texture.pmremVersion = s.pmremVersion, e.set(s, p), s.addEventListener("dispose", a), p.texture) : null;
        }
      }
    }
    return s;
  }
  function i(s) {
    let u = 0;
    const d = 6;
    for (let f = 0; f < d; f++)
      s[f] !== void 0 && u++;
    return u === d;
  }
  function a(s) {
    const u = s.target;
    u.removeEventListener("dispose", a);
    const d = e.get(u);
    d !== void 0 && (e.delete(u), d.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: r,
    dispose: o
  };
}
function Qce(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0)
      return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return e[r] = i, i;
  }
  return {
    has: function(r) {
      return t(r) !== null;
    },
    init: function() {
      t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
    },
    get: function(r) {
      const i = t(r);
      return i === null && XO("THREE.WebGLRenderer: " + r + " extension not supported."), i;
    }
  };
}
function Jce(n, e, t, r) {
  const i = {}, a = /* @__PURE__ */ new WeakMap();
  function o(p) {
    const g = p.target;
    g.index !== null && e.remove(g.index);
    for (const b in g.attributes)
      e.remove(g.attributes[b]);
    for (const b in g.morphAttributes) {
      const E = g.morphAttributes[b];
      for (let S = 0, _ = E.length; S < _; S++)
        e.remove(E[S]);
    }
    g.removeEventListener("dispose", o), delete i[g.id];
    const v = a.get(g);
    v && (e.remove(v), a.delete(g)), r.releaseStatesOfGeometry(g), g.isInstancedBufferGeometry === !0 && delete g._maxInstanceCount, t.memory.geometries--;
  }
  function s(p, g) {
    return i[g.id] === !0 || (g.addEventListener("dispose", o), i[g.id] = !0, t.memory.geometries++), g;
  }
  function u(p) {
    const g = p.attributes;
    for (const b in g)
      e.update(g[b], n.ARRAY_BUFFER);
    const v = p.morphAttributes;
    for (const b in v) {
      const E = v[b];
      for (let S = 0, _ = E.length; S < _; S++)
        e.update(E[S], n.ARRAY_BUFFER);
    }
  }
  function d(p) {
    const g = [], v = p.index, b = p.attributes.position;
    let E = 0;
    if (v !== null) {
      const w = v.array;
      E = v.version;
      for (let C = 0, R = w.length; C < R; C += 3) {
        const P = w[C + 0], D = w[C + 1], I = w[C + 2];
        g.push(P, D, D, I, I, P);
      }
    } else if (b !== void 0) {
      const w = b.array;
      E = b.version;
      for (let C = 0, R = w.length / 3 - 1; C < R; C += 3) {
        const P = C + 0, D = C + 1, I = C + 2;
        g.push(P, D, D, I, I, P);
      }
    } else
      return;
    const S = new (Ck(g) ? KO : YO)(g, 1);
    S.version = E;
    const _ = a.get(p);
    _ && e.remove(_), a.set(p, S);
  }
  function f(p) {
    const g = a.get(p);
    if (g) {
      const v = p.index;
      v !== null && g.version < v.version && d(p);
    } else
      d(p);
    return a.get(p);
  }
  return {
    get: s,
    update: u,
    getWireframeAttribute: f
  };
}
function eue(n, e, t) {
  let r;
  function i(g) {
    r = g;
  }
  let a, o;
  function s(g) {
    a = g.type, o = g.bytesPerElement;
  }
  function u(g, v) {
    n.drawElements(r, v, a, g * o), t.update(v, r, 1);
  }
  function d(g, v, b) {
    b !== 0 && (n.drawElementsInstanced(r, v, a, g * o, b), t.update(v, r, b));
  }
  function f(g, v, b) {
    if (b === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, v, 0, a, g, 0, b);
    let S = 0;
    for (let _ = 0; _ < b; _++)
      S += v[_];
    t.update(S, r, 1);
  }
  function p(g, v, b, E) {
    if (b === 0) return;
    const S = e.get("WEBGL_multi_draw");
    if (S === null)
      for (let _ = 0; _ < g.length; _++)
        d(g[_] / o, v[_], E[_]);
    else {
      S.multiDrawElementsInstancedWEBGL(r, v, 0, a, g, 0, E, 0, b);
      let _ = 0;
      for (let w = 0; w < b; w++)
        _ += v[w];
      for (let w = 0; w < E.length; w++)
        t.update(_, r, E[w]);
    }
  }
  this.setMode = i, this.setIndex = s, this.render = u, this.renderInstances = d, this.renderMultiDraw = f, this.renderMultiDrawInstances = p;
}
function tue(n) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function r(a, o, s) {
    switch (t.calls++, o) {
      case n.TRIANGLES:
        t.triangles += s * (a / 3);
        break;
      case n.LINES:
        t.lines += s * (a / 2);
        break;
      case n.LINE_STRIP:
        t.lines += s * (a - 1);
        break;
      case n.LINE_LOOP:
        t.lines += s * a;
        break;
      case n.POINTS:
        t.points += s * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r
  };
}
function nue(n, e, t) {
  const r = /* @__PURE__ */ new WeakMap(), i = new wr();
  function a(o, s, u) {
    const d = o.morphTargetInfluences, f = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color, p = f !== void 0 ? f.length : 0;
    let g = r.get(s);
    if (g === void 0 || g.count !== p) {
      let L = function() {
        I.dispose(), r.delete(s), s.removeEventListener("dispose", L);
      };
      g !== void 0 && g.texture.dispose();
      const v = s.morphAttributes.position !== void 0, b = s.morphAttributes.normal !== void 0, E = s.morphAttributes.color !== void 0, S = s.morphAttributes.position || [], _ = s.morphAttributes.normal || [], w = s.morphAttributes.color || [];
      let C = 0;
      v === !0 && (C = 1), b === !0 && (C = 2), E === !0 && (C = 3);
      let R = s.attributes.position.count * C, P = 1;
      R > e.maxTextureSize && (P = Math.ceil(R / e.maxTextureSize), R = e.maxTextureSize);
      const D = new Float32Array(R * P * 4 * p), I = new XE(D, R, P, p);
      I.type = Ho, I.needsUpdate = !0;
      const U = C * 4;
      for (let N = 0; N < p; N++) {
        const H = S[N], j = _[N], G = w[N], X = R * P * 4 * N;
        for (let ae = 0; ae < H.count; ae++) {
          const Z = ae * U;
          v === !0 && (i.fromBufferAttribute(H, ae), D[X + Z + 0] = i.x, D[X + Z + 1] = i.y, D[X + Z + 2] = i.z, D[X + Z + 3] = 0), b === !0 && (i.fromBufferAttribute(j, ae), D[X + Z + 4] = i.x, D[X + Z + 5] = i.y, D[X + Z + 6] = i.z, D[X + Z + 7] = 0), E === !0 && (i.fromBufferAttribute(G, ae), D[X + Z + 8] = i.x, D[X + Z + 9] = i.y, D[X + Z + 10] = i.z, D[X + Z + 11] = G.itemSize === 4 ? i.w : 1);
        }
      }
      g = {
        count: p,
        texture: I,
        size: new St(R, P)
      }, r.set(s, g), s.addEventListener("dispose", L);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      u.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
    else {
      let v = 0;
      for (let E = 0; E < d.length; E++)
        v += d[E];
      const b = s.morphTargetsRelative ? 1 : 1 - v;
      u.getUniforms().setValue(n, "morphTargetBaseInfluence", b), u.getUniforms().setValue(n, "morphTargetInfluences", d);
    }
    u.getUniforms().setValue(n, "morphTargetsTexture", g.texture, t), u.getUniforms().setValue(n, "morphTargetsTextureSize", g.size);
  }
  return {
    update: a
  };
}
function rue(n, e, t, r) {
  let i = /* @__PURE__ */ new WeakMap();
  function a(u) {
    const d = r.render.frame, f = u.geometry, p = e.get(u, f);
    if (i.get(p) !== d && (e.update(p), i.set(p, d)), u.isInstancedMesh && (u.hasEventListener("dispose", s) === !1 && u.addEventListener("dispose", s), i.get(u) !== d && (t.update(u.instanceMatrix, n.ARRAY_BUFFER), u.instanceColor !== null && t.update(u.instanceColor, n.ARRAY_BUFFER), i.set(u, d))), u.isSkinnedMesh) {
      const g = u.skeleton;
      i.get(g) !== d && (g.update(), i.set(g, d));
    }
    return p;
  }
  function o() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function s(u) {
    const d = u.target;
    d.removeEventListener("dispose", s), t.remove(d.instanceMatrix), d.instanceColor !== null && t.remove(d.instanceColor);
  }
  return {
    update: a,
    dispose: o
  };
}
class QO extends Ei {
  constructor(e, t, r, i, a, o, s, u, d, f = Eh) {
    if (f !== Eh && f !== Lh)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    r === void 0 && f === Eh && (r = vu), r === void 0 && f === Lh && (r = Nh), super(null, i, a, o, s, u, f, r, d), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = s !== void 0 ? s : ba, this.minFilter = u !== void 0 ? u : ba, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const Nk = /* @__PURE__ */ new Ei(), k3 = /* @__PURE__ */ new QO(1, 1), Lk = /* @__PURE__ */ new XE(), Fk = /* @__PURE__ */ new qO(), Uk = /* @__PURE__ */ new I0(), $3 = [], W3 = [], j3 = new Float32Array(16), G3 = new Float32Array(9), X3 = new Float32Array(4);
function wg(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const i = e * t;
  let a = $3[i];
  if (a === void 0 && (a = new Float32Array(i), $3[i] = a), e !== 0) {
    r.toArray(a, 0);
    for (let o = 1, s = 0; o !== e; ++o)
      s += t, n[o].toArray(a, s);
  }
  return a;
}
function ua(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++)
    if (n[t] !== e[t]) return !1;
  return !0;
}
function da(n, e) {
  for (let t = 0, r = e.length; t < r; t++)
    n[t] = e[t];
}
function qE(n, e) {
  let t = W3[e];
  t === void 0 && (t = new Int32Array(e), W3[e] = t);
  for (let r = 0; r !== e; ++r)
    t[r] = n.allocateTextureUnit();
  return t;
}
function iue(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e);
}
function aue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (ua(t, e)) return;
    n.uniform2fv(this.addr, e), da(t, e);
  }
}
function oue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (ua(t, e)) return;
    n.uniform3fv(this.addr, e), da(t, e);
  }
}
function sue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (ua(t, e)) return;
    n.uniform4fv(this.addr, e), da(t, e);
  }
}
function lue(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (ua(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), da(t, e);
  } else {
    if (ua(t, r)) return;
    X3.set(r), n.uniformMatrix2fv(this.addr, !1, X3), da(t, r);
  }
}
function cue(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (ua(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), da(t, e);
  } else {
    if (ua(t, r)) return;
    G3.set(r), n.uniformMatrix3fv(this.addr, !1, G3), da(t, r);
  }
}
function uue(n, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (ua(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), da(t, e);
  } else {
    if (ua(t, r)) return;
    j3.set(r), n.uniformMatrix4fv(this.addr, !1, j3), da(t, r);
  }
}
function due(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e);
}
function fue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (ua(t, e)) return;
    n.uniform2iv(this.addr, e), da(t, e);
  }
}
function hue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (ua(t, e)) return;
    n.uniform3iv(this.addr, e), da(t, e);
  }
}
function pue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (ua(t, e)) return;
    n.uniform4iv(this.addr, e), da(t, e);
  }
}
function mue(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e);
}
function gue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (ua(t, e)) return;
    n.uniform2uiv(this.addr, e), da(t, e);
  }
}
function vue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (ua(t, e)) return;
    n.uniform3uiv(this.addr, e), da(t, e);
  }
}
function yue(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (ua(t, e)) return;
    n.uniform4uiv(this.addr, e), da(t, e);
  }
}
function bue(n, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i);
  let a;
  this.type === n.SAMPLER_2D_SHADOW ? (k3.compareFunction = jO, a = k3) : a = Nk, t.setTexture2D(e || a, i);
}
function Sue(n, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture3D(e || Fk, i);
}
function _ue(n, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTextureCube(e || Uk, i);
}
function xue(n, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture2DArray(e || Lk, i);
}
function Eue(n) {
  switch (n) {
    case 5126:
      return iue;
    case 35664:
      return aue;
    case 35665:
      return oue;
    case 35666:
      return sue;
    case 35674:
      return lue;
    case 35675:
      return cue;
    case 35676:
      return uue;
    case 5124:
    case 35670:
      return due;
    case 35667:
    case 35671:
      return fue;
    case 35668:
    case 35672:
      return hue;
    case 35669:
    case 35673:
      return pue;
    case 5125:
      return mue;
    case 36294:
      return gue;
    case 36295:
      return vue;
    case 36296:
      return yue;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return bue;
    case 35679:
    case 36299:
    case 36307:
      return Sue;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return _ue;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return xue;
  }
}
function Cue(n, e) {
  n.uniform1fv(this.addr, e);
}
function wue(n, e) {
  const t = wg(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function Mue(n, e) {
  const t = wg(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Tue(n, e) {
  const t = wg(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function Rue(n, e) {
  const t = wg(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function Aue(n, e) {
  const t = wg(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function Oue(n, e) {
  const t = wg(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function Pue(n, e) {
  n.uniform1iv(this.addr, e);
}
function Due(n, e) {
  n.uniform2iv(this.addr, e);
}
function Iue(n, e) {
  n.uniform3iv(this.addr, e);
}
function Nue(n, e) {
  n.uniform4iv(this.addr, e);
}
function Lue(n, e) {
  n.uniform1uiv(this.addr, e);
}
function Fue(n, e) {
  n.uniform2uiv(this.addr, e);
}
function Uue(n, e) {
  n.uniform3uiv(this.addr, e);
}
function zue(n, e) {
  n.uniform4uiv(this.addr, e);
}
function Bue(n, e, t) {
  const r = this.cache, i = e.length, a = qE(t, i);
  ua(r, a) || (n.uniform1iv(this.addr, a), da(r, a));
  for (let o = 0; o !== i; ++o)
    t.setTexture2D(e[o] || Nk, a[o]);
}
function Hue(n, e, t) {
  const r = this.cache, i = e.length, a = qE(t, i);
  ua(r, a) || (n.uniform1iv(this.addr, a), da(r, a));
  for (let o = 0; o !== i; ++o)
    t.setTexture3D(e[o] || Fk, a[o]);
}
function Vue(n, e, t) {
  const r = this.cache, i = e.length, a = qE(t, i);
  ua(r, a) || (n.uniform1iv(this.addr, a), da(r, a));
  for (let o = 0; o !== i; ++o)
    t.setTextureCube(e[o] || Uk, a[o]);
}
function kue(n, e, t) {
  const r = this.cache, i = e.length, a = qE(t, i);
  ua(r, a) || (n.uniform1iv(this.addr, a), da(r, a));
  for (let o = 0; o !== i; ++o)
    t.setTexture2DArray(e[o] || Lk, a[o]);
}
function $ue(n) {
  switch (n) {
    case 5126:
      return Cue;
    case 35664:
      return wue;
    case 35665:
      return Mue;
    case 35666:
      return Tue;
    case 35674:
      return Rue;
    case 35675:
      return Aue;
    case 35676:
      return Oue;
    case 5124:
    case 35670:
      return Pue;
    case 35667:
    case 35671:
      return Due;
    case 35668:
    case 35672:
      return Iue;
    case 35669:
    case 35673:
      return Nue;
    case 5125:
      return Lue;
    case 36294:
      return Fue;
    case 36295:
      return Uue;
    case 36296:
      return zue;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Bue;
    case 35679:
    case 36299:
    case 36307:
      return Hue;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Vue;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return kue;
  }
}
class Wue {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.type = t.type, this.setValue = Eue(t.type);
  }
}
class jue {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = $ue(t.type);
  }
}
class Gue {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let a = 0, o = i.length; a !== o; ++a) {
      const s = i[a];
      s.setValue(e, t[s.id], r);
    }
  }
}
const jM = /(\w+)(\])?(\[|\.)?/g;
function q3(n, e) {
  n.seq.push(e), n.map[e.id] = e;
}
function Xue(n, e, t) {
  const r = n.name, i = r.length;
  for (jM.lastIndex = 0; ; ) {
    const a = jM.exec(r), o = jM.lastIndex;
    let s = a[1];
    const u = a[2] === "]", d = a[3];
    if (u && (s = s | 0), d === void 0 || d === "[" && o + 2 === i) {
      q3(t, d === void 0 ? new Wue(s, n, e) : new jue(s, n, e));
      break;
    } else {
      let p = t.map[s];
      p === void 0 && (p = new Gue(s), q3(t, p)), t = p;
    }
  }
}
class ax {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const a = e.getActiveUniform(t, i), o = e.getUniformLocation(t, a.name);
      Xue(a, o, this);
    }
  }
  setValue(e, t, r, i) {
    const a = this.map[t];
    a !== void 0 && a.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let a = 0, o = t.length; a !== o; ++a) {
      const s = t[a], u = r[s.id];
      u.needsUpdate !== !1 && s.setValue(e, u.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, a = e.length; i !== a; ++i) {
      const o = e[i];
      o.id in t && r.push(o);
    }
    return r;
  }
}
function Y3(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
const que = 37297;
let Yue = 0;
function Kue(n, e) {
  const t = n.split(`
`), r = [], i = Math.max(e - 6, 0), a = Math.min(e + 6, t.length);
  for (let o = i; o < a; o++) {
    const s = o + 1;
    r.push(`${s === e ? ">" : " "} ${s}: ${t[o]}`);
  }
  return r.join(`
`);
}
function Zue(n) {
  const e = Cr.getPrimaries(Cr.workingColorSpace), t = Cr.getPrimaries(n);
  let r;
  switch (e === t ? r = "" : e === o0 && t === a0 ? r = "LinearDisplayP3ToLinearSRGB" : e === a0 && t === o0 && (r = "LinearSRGBToLinearDisplayP3"), n) {
    case xu:
    case P0:
      return [r, "LinearTransferOETF"];
    case js:
    case GE:
      return [r, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", n), [r, "LinearTransferOETF"];
  }
}
function K3(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS), i = n.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const a = /ERROR: 0:(\d+)/.exec(i);
  if (a) {
    const o = parseInt(a[1]);
    return t.toUpperCase() + `

` + i + `

` + Kue(n.getShaderSource(e), o);
  } else
    return i;
}
function Que(n, e) {
  const t = Zue(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function Jue(n, e) {
  let t;
  switch (e) {
    case rk:
      t = "Linear";
      break;
    case ik:
      t = "Reinhard";
      break;
    case ak:
      t = "OptimizedCineon";
      break;
    case IO:
      t = "ACESFilmic";
      break;
    case sk:
      t = "AgX";
      break;
    case lk:
      t = "Neutral";
      break;
    case ok:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function ede(n) {
  return [
    n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(vy).join(`
`);
}
function tde(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function nde(n, e) {
  const t = {}, r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const a = n.getActiveAttrib(e, i), o = a.name;
    let s = 1;
    a.type === n.FLOAT_MAT2 && (s = 2), a.type === n.FLOAT_MAT3 && (s = 3), a.type === n.FLOAT_MAT4 && (s = 4), t[o] = {
      type: a.type,
      location: n.getAttribLocation(e, o),
      locationSize: s
    };
  }
  return t;
}
function vy(n) {
  return n !== "";
}
function Z3(n, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Q3(n, e) {
  return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const rde = /^[ \t]*#include +<([\w\d./]+)>/gm;
function sA(n) {
  return n.replace(rde, ade);
}
const ide = /* @__PURE__ */ new Map();
function ade(n, e) {
  let t = Gn[e];
  if (t === void 0) {
    const r = ide.get(e);
    if (r !== void 0)
      t = Gn[r], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return sA(t);
}
const ode = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function J3(n) {
  return n.replace(ode, sde);
}
function sde(n, e, t, r) {
  let i = "";
  for (let a = parseInt(e); a < parseInt(t); a++)
    i += r.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
  return i;
}
function eF(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function lde(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return n.shadowMapType === UE ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Ry ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === bl && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function cde(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case gu:
      case kd:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case _g:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function ude(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case kd:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function dde(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case A0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case tk:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case nk:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function fde(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, r = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: r, maxMip: t };
}
function hde(n, e, t, r) {
  const i = n.getContext(), a = t.defines;
  let o = t.vertexShader, s = t.fragmentShader;
  const u = lde(t), d = cde(t), f = ude(t), p = dde(t), g = fde(t), v = ede(t), b = tde(a), E = i.createProgram();
  let S, _, w = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (S = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    b
  ].filter(vy).join(`
`), S.length > 0 && (S += `
`), _ = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    b
  ].filter(vy).join(`
`), _.length > 0 && (_ += `
`)) : (S = [
    eF(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    b,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + f : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + u : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(vy).join(`
`), _ = [
    eF(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    b,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + d : "",
    t.envMap ? "#define " + f : "",
    t.envMap ? "#define " + p : "",
    g ? "#define CUBEUV_TEXEL_WIDTH " + g.texelWidth : "",
    g ? "#define CUBEUV_TEXEL_HEIGHT " + g.texelHeight : "",
    g ? "#define CUBEUV_MAX_MIP " + g.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.dispersion ? "#define USE_DISPERSION" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + u : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== lc ? "#define TONE_MAPPING" : "",
    t.toneMapping !== lc ? Gn.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== lc ? Jue("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Gn.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    Que("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(vy).join(`
`)), o = sA(o), o = Z3(o, t), o = Q3(o, t), s = sA(s), s = Z3(s, t), s = Q3(s, t), o = J3(o), s = J3(s), t.isRawShaderMaterial !== !0 && (w = `#version 300 es
`, S = [
    v,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + S, _ = [
    "#define varying in",
    t.glslVersion === aA ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === aA ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + _);
  const C = w + S + o, R = w + _ + s, P = Y3(i, i.VERTEX_SHADER, C), D = Y3(i, i.FRAGMENT_SHADER, R);
  i.attachShader(E, P), i.attachShader(E, D), t.index0AttributeName !== void 0 ? i.bindAttribLocation(E, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(E, 0, "position"), i.linkProgram(E);
  function I(H) {
    if (n.debug.checkShaderErrors) {
      const j = i.getProgramInfoLog(E).trim(), G = i.getShaderInfoLog(P).trim(), X = i.getShaderInfoLog(D).trim();
      let ae = !0, Z = !0;
      if (i.getProgramParameter(E, i.LINK_STATUS) === !1)
        if (ae = !1, typeof n.debug.onShaderError == "function")
          n.debug.onShaderError(i, E, P, D);
        else {
          const K = K3(i, P, "vertex"), B = K3(i, D, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(E, i.VALIDATE_STATUS) + `

Material Name: ` + H.name + `
Material Type: ` + H.type + `

Program Info Log: ` + j + `
` + K + `
` + B
          );
        }
      else j !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", j) : (G === "" || X === "") && (Z = !1);
      Z && (H.diagnostics = {
        runnable: ae,
        programLog: j,
        vertexShader: {
          log: G,
          prefix: S
        },
        fragmentShader: {
          log: X,
          prefix: _
        }
      });
    }
    i.deleteShader(P), i.deleteShader(D), U = new ax(i, E), L = nde(i, E);
  }
  let U;
  this.getUniforms = function() {
    return U === void 0 && I(this), U;
  };
  let L;
  this.getAttributes = function() {
    return L === void 0 && I(this), L;
  };
  let N = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return N === !1 && (N = i.getProgramParameter(E, que)), N;
  }, this.destroy = function() {
    r.releaseStatesOfProgram(this), i.deleteProgram(E), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = Yue++, this.cacheKey = e, this.usedTimes = 1, this.program = E, this.vertexShader = P, this.fragmentShader = D, this;
}
let pde = 0;
class mde {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, r = e.fragmentShader, i = this._getShaderStage(t), a = this._getShaderStage(r), o = this._getShaderCacheForMaterial(e);
    return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(a) === !1 && (o.add(a), a.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && (r = /* @__PURE__ */ new Set(), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && (r = new gde(e), t.set(e, r)), r;
  }
}
class gde {
  constructor(e) {
    this.id = pde++, this.code = e, this.usedTimes = 0;
  }
}
function vde(n, e, t, r, i, a, o) {
  const s = new wh(), u = new mde(), d = /* @__PURE__ */ new Set(), f = [], p = i.logarithmicDepthBuffer, g = i.vertexTextures;
  let v = i.precision;
  const b = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function E(L) {
    return d.add(L), L === 0 ? "uv" : `uv${L}`;
  }
  function S(L, N, H, j, G) {
    const X = j.fog, ae = G.geometry, Z = L.isMeshStandardMaterial ? j.environment : null, K = (L.isMeshStandardMaterial ? t : e).get(L.envMap || Z), B = K && K.mapping === _g ? K.image.height : null, Q = b[L.type];
    L.precision !== null && (v = i.getMaxPrecision(L.precision), v !== L.precision && console.warn("THREE.WebGLProgram.getParameters:", L.precision, "not supported, using", v, "instead."));
    const V = ae.morphAttributes.position || ae.morphAttributes.normal || ae.morphAttributes.color, q = V !== void 0 ? V.length : 0;
    let ne = 0;
    ae.morphAttributes.position !== void 0 && (ne = 1), ae.morphAttributes.normal !== void 0 && (ne = 2), ae.morphAttributes.color !== void 0 && (ne = 3);
    let ce, ie, oe, he;
    if (Q) {
      const lt = xl[Q];
      ce = lt.vertexShader, ie = lt.fragmentShader;
    } else
      ce = L.vertexShader, ie = L.fragmentShader, u.update(L), oe = u.getVertexShaderID(L), he = u.getFragmentShaderID(L);
    const le = n.getRenderTarget(), ve = G.isInstancedMesh === !0, Ne = G.isBatchedMesh === !0, xe = !!L.map, Me = !!L.matcap, $ = !!K, Te = !!L.aoMap, se = !!L.lightMap, Ie = !!L.bumpMap, be = !!L.normalMap, et = !!L.displacementMap, Xe = !!L.emissiveMap, $e = !!L.metalnessMap, te = !!L.roughnessMap, Y = L.anisotropy > 0, Se = L.clearcoat > 0, Oe = L.dispersion > 0, Pe = L.iridescence > 0, Ve = L.sheen > 0, Ze = L.transmission > 0, nt = Y && !!L.anisotropyMap, ht = Se && !!L.clearcoatMap, pt = Se && !!L.clearcoatNormalMap, Be = Se && !!L.clearcoatRoughnessMap, ye = Pe && !!L.iridescenceMap, Ue = Pe && !!L.iridescenceThicknessMap, Ye = Ve && !!L.sheenColorMap, tt = Ve && !!L.sheenRoughnessMap, st = !!L.specularMap, Tt = !!L.specularColorMap, Rt = !!L.specularIntensityMap, ue = Ze && !!L.transmissionMap, De = Ze && !!L.thicknessMap, Ge = !!L.gradientMap, We = !!L.alphaMap, He = L.alphaTest > 0, ut = !!L.alphaHash, vt = !!L.extensions;
    let _t = lc;
    L.toneMapped && (le === null || le.isXRRenderTarget === !0) && (_t = n.toneMapping);
    const Wt = {
      shaderID: Q,
      shaderType: L.type,
      shaderName: L.name,
      vertexShader: ce,
      fragmentShader: ie,
      defines: L.defines,
      customVertexShaderID: oe,
      customFragmentShaderID: he,
      isRawShaderMaterial: L.isRawShaderMaterial === !0,
      glslVersion: L.glslVersion,
      precision: v,
      batching: Ne,
      batchingColor: Ne && G._colorsTexture !== null,
      instancing: ve,
      instancingColor: ve && G.instanceColor !== null,
      instancingMorph: ve && G.morphTexture !== null,
      supportsVertexTextures: g,
      outputColorSpace: le === null ? n.outputColorSpace : le.isXRRenderTarget === !0 ? le.texture.colorSpace : xu,
      alphaToCoverage: !!L.alphaToCoverage,
      map: xe,
      matcap: Me,
      envMap: $,
      envMapMode: $ && K.mapping,
      envMapCubeUVHeight: B,
      aoMap: Te,
      lightMap: se,
      bumpMap: Ie,
      normalMap: be,
      displacementMap: g && et,
      emissiveMap: Xe,
      normalMapObjectSpace: be && L.normalMapType === mk,
      normalMapTangentSpace: be && L.normalMapType === Xd,
      metalnessMap: $e,
      roughnessMap: te,
      anisotropy: Y,
      anisotropyMap: nt,
      clearcoat: Se,
      clearcoatMap: ht,
      clearcoatNormalMap: pt,
      clearcoatRoughnessMap: Be,
      dispersion: Oe,
      iridescence: Pe,
      iridescenceMap: ye,
      iridescenceThicknessMap: Ue,
      sheen: Ve,
      sheenColorMap: Ye,
      sheenRoughnessMap: tt,
      specularMap: st,
      specularColorMap: Tt,
      specularIntensityMap: Rt,
      transmission: Ze,
      transmissionMap: ue,
      thicknessMap: De,
      gradientMap: Ge,
      opaque: L.transparent === !1 && L.blending === xh && L.alphaToCoverage === !1,
      alphaMap: We,
      alphaTest: He,
      alphaHash: ut,
      combine: L.combine,
      //
      mapUv: xe && E(L.map.channel),
      aoMapUv: Te && E(L.aoMap.channel),
      lightMapUv: se && E(L.lightMap.channel),
      bumpMapUv: Ie && E(L.bumpMap.channel),
      normalMapUv: be && E(L.normalMap.channel),
      displacementMapUv: et && E(L.displacementMap.channel),
      emissiveMapUv: Xe && E(L.emissiveMap.channel),
      metalnessMapUv: $e && E(L.metalnessMap.channel),
      roughnessMapUv: te && E(L.roughnessMap.channel),
      anisotropyMapUv: nt && E(L.anisotropyMap.channel),
      clearcoatMapUv: ht && E(L.clearcoatMap.channel),
      clearcoatNormalMapUv: pt && E(L.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Be && E(L.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ye && E(L.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ue && E(L.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ye && E(L.sheenColorMap.channel),
      sheenRoughnessMapUv: tt && E(L.sheenRoughnessMap.channel),
      specularMapUv: st && E(L.specularMap.channel),
      specularColorMapUv: Tt && E(L.specularColorMap.channel),
      specularIntensityMapUv: Rt && E(L.specularIntensityMap.channel),
      transmissionMapUv: ue && E(L.transmissionMap.channel),
      thicknessMapUv: De && E(L.thicknessMap.channel),
      alphaMapUv: We && E(L.alphaMap.channel),
      //
      vertexTangents: !!ae.attributes.tangent && (be || Y),
      vertexColors: L.vertexColors,
      vertexAlphas: L.vertexColors === !0 && !!ae.attributes.color && ae.attributes.color.itemSize === 4,
      pointsUvs: G.isPoints === !0 && !!ae.attributes.uv && (xe || We),
      fog: !!X,
      useFog: L.fog === !0,
      fogExp2: !!X && X.isFogExp2,
      flatShading: L.flatShading === !0,
      sizeAttenuation: L.sizeAttenuation === !0,
      logarithmicDepthBuffer: p,
      skinning: G.isSkinnedMesh === !0,
      morphTargets: ae.morphAttributes.position !== void 0,
      morphNormals: ae.morphAttributes.normal !== void 0,
      morphColors: ae.morphAttributes.color !== void 0,
      morphTargetsCount: q,
      morphTextureStride: ne,
      numDirLights: N.directional.length,
      numPointLights: N.point.length,
      numSpotLights: N.spot.length,
      numSpotLightMaps: N.spotLightMap.length,
      numRectAreaLights: N.rectArea.length,
      numHemiLights: N.hemi.length,
      numDirLightShadows: N.directionalShadowMap.length,
      numPointLightShadows: N.pointShadowMap.length,
      numSpotLightShadows: N.spotShadowMap.length,
      numSpotLightShadowsWithMaps: N.numSpotLightShadowsWithMaps,
      numLightProbes: N.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: L.dithering,
      shadowMapEnabled: n.shadowMap.enabled && H.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: _t,
      decodeVideoTexture: xe && L.map.isVideoTexture === !0 && Cr.getTransfer(L.map.colorSpace) === ei,
      premultipliedAlpha: L.premultipliedAlpha,
      doubleSided: L.side === ic,
      flipSided: L.side === ho,
      useDepthPacking: L.depthPacking >= 0,
      depthPacking: L.depthPacking || 0,
      index0AttributeName: L.index0AttributeName,
      extensionClipCullDistance: vt && L.extensions.clipCullDistance === !0 && r.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (vt && L.extensions.multiDraw === !0 || Ne) && r.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: L.customProgramCacheKey()
    };
    return Wt.vertexUv1s = d.has(1), Wt.vertexUv2s = d.has(2), Wt.vertexUv3s = d.has(3), d.clear(), Wt;
  }
  function _(L) {
    const N = [];
    if (L.shaderID ? N.push(L.shaderID) : (N.push(L.customVertexShaderID), N.push(L.customFragmentShaderID)), L.defines !== void 0)
      for (const H in L.defines)
        N.push(H), N.push(L.defines[H]);
    return L.isRawShaderMaterial === !1 && (w(N, L), C(N, L), N.push(n.outputColorSpace)), N.push(L.customProgramCacheKey), N.join();
  }
  function w(L, N) {
    L.push(N.precision), L.push(N.outputColorSpace), L.push(N.envMapMode), L.push(N.envMapCubeUVHeight), L.push(N.mapUv), L.push(N.alphaMapUv), L.push(N.lightMapUv), L.push(N.aoMapUv), L.push(N.bumpMapUv), L.push(N.normalMapUv), L.push(N.displacementMapUv), L.push(N.emissiveMapUv), L.push(N.metalnessMapUv), L.push(N.roughnessMapUv), L.push(N.anisotropyMapUv), L.push(N.clearcoatMapUv), L.push(N.clearcoatNormalMapUv), L.push(N.clearcoatRoughnessMapUv), L.push(N.iridescenceMapUv), L.push(N.iridescenceThicknessMapUv), L.push(N.sheenColorMapUv), L.push(N.sheenRoughnessMapUv), L.push(N.specularMapUv), L.push(N.specularColorMapUv), L.push(N.specularIntensityMapUv), L.push(N.transmissionMapUv), L.push(N.thicknessMapUv), L.push(N.combine), L.push(N.fogExp2), L.push(N.sizeAttenuation), L.push(N.morphTargetsCount), L.push(N.morphAttributeCount), L.push(N.numDirLights), L.push(N.numPointLights), L.push(N.numSpotLights), L.push(N.numSpotLightMaps), L.push(N.numHemiLights), L.push(N.numRectAreaLights), L.push(N.numDirLightShadows), L.push(N.numPointLightShadows), L.push(N.numSpotLightShadows), L.push(N.numSpotLightShadowsWithMaps), L.push(N.numLightProbes), L.push(N.shadowMapType), L.push(N.toneMapping), L.push(N.numClippingPlanes), L.push(N.numClipIntersection), L.push(N.depthPacking);
  }
  function C(L, N) {
    s.disableAll(), N.supportsVertexTextures && s.enable(0), N.instancing && s.enable(1), N.instancingColor && s.enable(2), N.instancingMorph && s.enable(3), N.matcap && s.enable(4), N.envMap && s.enable(5), N.normalMapObjectSpace && s.enable(6), N.normalMapTangentSpace && s.enable(7), N.clearcoat && s.enable(8), N.iridescence && s.enable(9), N.alphaTest && s.enable(10), N.vertexColors && s.enable(11), N.vertexAlphas && s.enable(12), N.vertexUv1s && s.enable(13), N.vertexUv2s && s.enable(14), N.vertexUv3s && s.enable(15), N.vertexTangents && s.enable(16), N.anisotropy && s.enable(17), N.alphaHash && s.enable(18), N.batching && s.enable(19), N.dispersion && s.enable(20), N.batchingColor && s.enable(21), L.push(s.mask), s.disableAll(), N.fog && s.enable(0), N.useFog && s.enable(1), N.flatShading && s.enable(2), N.logarithmicDepthBuffer && s.enable(3), N.skinning && s.enable(4), N.morphTargets && s.enable(5), N.morphNormals && s.enable(6), N.morphColors && s.enable(7), N.premultipliedAlpha && s.enable(8), N.shadowMapEnabled && s.enable(9), N.doubleSided && s.enable(10), N.flipSided && s.enable(11), N.useDepthPacking && s.enable(12), N.dithering && s.enable(13), N.transmission && s.enable(14), N.sheen && s.enable(15), N.opaque && s.enable(16), N.pointsUvs && s.enable(17), N.decodeVideoTexture && s.enable(18), N.alphaToCoverage && s.enable(19), L.push(s.mask);
  }
  function R(L) {
    const N = b[L.type];
    let H;
    if (N) {
      const j = xl[N];
      H = Ok.clone(j.uniforms);
    } else
      H = L.uniforms;
    return H;
  }
  function P(L, N) {
    let H;
    for (let j = 0, G = f.length; j < G; j++) {
      const X = f[j];
      if (X.cacheKey === N) {
        H = X, ++H.usedTimes;
        break;
      }
    }
    return H === void 0 && (H = new hde(n, N, L, a), f.push(H)), H;
  }
  function D(L) {
    if (--L.usedTimes === 0) {
      const N = f.indexOf(L);
      f[N] = f[f.length - 1], f.pop(), L.destroy();
    }
  }
  function I(L) {
    u.remove(L);
  }
  function U() {
    u.dispose();
  }
  return {
    getParameters: S,
    getProgramCacheKey: _,
    getUniforms: R,
    acquireProgram: P,
    releaseProgram: D,
    releaseShaderCache: I,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: f,
    dispose: U
  };
}
function yde() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(a) {
    let o = n.get(a);
    return o === void 0 && (o = {}, n.set(a, o)), o;
  }
  function t(a) {
    n.delete(a);
  }
  function r(a, o, s) {
    n.get(a)[o] = s;
  }
  function i() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: r,
    dispose: i
  };
}
function bde(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id;
}
function tF(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id;
}
function nF() {
  const n = [];
  let e = 0;
  const t = [], r = [], i = [];
  function a() {
    e = 0, t.length = 0, r.length = 0, i.length = 0;
  }
  function o(p, g, v, b, E, S) {
    let _ = n[e];
    return _ === void 0 ? (_ = {
      id: p.id,
      object: p,
      geometry: g,
      material: v,
      groupOrder: b,
      renderOrder: p.renderOrder,
      z: E,
      group: S
    }, n[e] = _) : (_.id = p.id, _.object = p, _.geometry = g, _.material = v, _.groupOrder = b, _.renderOrder = p.renderOrder, _.z = E, _.group = S), e++, _;
  }
  function s(p, g, v, b, E, S) {
    const _ = o(p, g, v, b, E, S);
    v.transmission > 0 ? r.push(_) : v.transparent === !0 ? i.push(_) : t.push(_);
  }
  function u(p, g, v, b, E, S) {
    const _ = o(p, g, v, b, E, S);
    v.transmission > 0 ? r.unshift(_) : v.transparent === !0 ? i.unshift(_) : t.unshift(_);
  }
  function d(p, g) {
    t.length > 1 && t.sort(p || bde), r.length > 1 && r.sort(g || tF), i.length > 1 && i.sort(g || tF);
  }
  function f() {
    for (let p = e, g = n.length; p < g; p++) {
      const v = n[p];
      if (v.id === null) break;
      v.id = null, v.object = null, v.geometry = null, v.material = null, v.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: a,
    push: s,
    unshift: u,
    finish: f,
    sort: d
  };
}
function Sde() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(r, i) {
    const a = n.get(r);
    let o;
    return a === void 0 ? (o = new nF(), n.set(r, [o])) : i >= a.length ? (o = new nF(), a.push(o)) : o = a[i], o;
  }
  function t() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function _de() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new de(),
            color: new an()
          };
          break;
        case "SpotLight":
          t = {
            position: new de(),
            direction: new de(),
            color: new an(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new de(),
            color: new an(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new de(),
            skyColor: new an(),
            groundColor: new an()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new an(),
            position: new de(),
            halfWidth: new de(),
            halfHeight: new de()
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
function xde() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new St()
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new St()
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new St(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
let Ede = 0;
function Cde(n, e) {
  return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
}
function wde(n) {
  const e = new _de(), t = xde(), r = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let d = 0; d < 9; d++) r.probe.push(new de());
  const i = new de(), a = new wn(), o = new wn();
  function s(d) {
    let f = 0, p = 0, g = 0;
    for (let L = 0; L < 9; L++) r.probe[L].set(0, 0, 0);
    let v = 0, b = 0, E = 0, S = 0, _ = 0, w = 0, C = 0, R = 0, P = 0, D = 0, I = 0;
    d.sort(Cde);
    for (let L = 0, N = d.length; L < N; L++) {
      const H = d[L], j = H.color, G = H.intensity, X = H.distance, ae = H.shadow && H.shadow.map ? H.shadow.map.texture : null;
      if (H.isAmbientLight)
        f += j.r * G, p += j.g * G, g += j.b * G;
      else if (H.isLightProbe) {
        for (let Z = 0; Z < 9; Z++)
          r.probe[Z].addScaledVector(H.sh.coefficients[Z], G);
        I++;
      } else if (H.isDirectionalLight) {
        const Z = e.get(H);
        if (Z.color.copy(H.color).multiplyScalar(H.intensity), H.castShadow) {
          const K = H.shadow, B = t.get(H);
          B.shadowIntensity = K.intensity, B.shadowBias = K.bias, B.shadowNormalBias = K.normalBias, B.shadowRadius = K.radius, B.shadowMapSize = K.mapSize, r.directionalShadow[v] = B, r.directionalShadowMap[v] = ae, r.directionalShadowMatrix[v] = H.shadow.matrix, w++;
        }
        r.directional[v] = Z, v++;
      } else if (H.isSpotLight) {
        const Z = e.get(H);
        Z.position.setFromMatrixPosition(H.matrixWorld), Z.color.copy(j).multiplyScalar(G), Z.distance = X, Z.coneCos = Math.cos(H.angle), Z.penumbraCos = Math.cos(H.angle * (1 - H.penumbra)), Z.decay = H.decay, r.spot[E] = Z;
        const K = H.shadow;
        if (H.map && (r.spotLightMap[P] = H.map, P++, K.updateMatrices(H), H.castShadow && D++), r.spotLightMatrix[E] = K.matrix, H.castShadow) {
          const B = t.get(H);
          B.shadowIntensity = K.intensity, B.shadowBias = K.bias, B.shadowNormalBias = K.normalBias, B.shadowRadius = K.radius, B.shadowMapSize = K.mapSize, r.spotShadow[E] = B, r.spotShadowMap[E] = ae, R++;
        }
        E++;
      } else if (H.isRectAreaLight) {
        const Z = e.get(H);
        Z.color.copy(j).multiplyScalar(G), Z.halfWidth.set(H.width * 0.5, 0, 0), Z.halfHeight.set(0, H.height * 0.5, 0), r.rectArea[S] = Z, S++;
      } else if (H.isPointLight) {
        const Z = e.get(H);
        if (Z.color.copy(H.color).multiplyScalar(H.intensity), Z.distance = H.distance, Z.decay = H.decay, H.castShadow) {
          const K = H.shadow, B = t.get(H);
          B.shadowIntensity = K.intensity, B.shadowBias = K.bias, B.shadowNormalBias = K.normalBias, B.shadowRadius = K.radius, B.shadowMapSize = K.mapSize, B.shadowCameraNear = K.camera.near, B.shadowCameraFar = K.camera.far, r.pointShadow[b] = B, r.pointShadowMap[b] = ae, r.pointShadowMatrix[b] = H.shadow.matrix, C++;
        }
        r.point[b] = Z, b++;
      } else if (H.isHemisphereLight) {
        const Z = e.get(H);
        Z.skyColor.copy(H.color).multiplyScalar(G), Z.groundColor.copy(H.groundColor).multiplyScalar(G), r.hemi[_] = Z, _++;
      }
    }
    S > 0 && (n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Yt.LTC_FLOAT_1, r.rectAreaLTC2 = Yt.LTC_FLOAT_2) : (r.rectAreaLTC1 = Yt.LTC_HALF_1, r.rectAreaLTC2 = Yt.LTC_HALF_2)), r.ambient[0] = f, r.ambient[1] = p, r.ambient[2] = g;
    const U = r.hash;
    (U.directionalLength !== v || U.pointLength !== b || U.spotLength !== E || U.rectAreaLength !== S || U.hemiLength !== _ || U.numDirectionalShadows !== w || U.numPointShadows !== C || U.numSpotShadows !== R || U.numSpotMaps !== P || U.numLightProbes !== I) && (r.directional.length = v, r.spot.length = E, r.rectArea.length = S, r.point.length = b, r.hemi.length = _, r.directionalShadow.length = w, r.directionalShadowMap.length = w, r.pointShadow.length = C, r.pointShadowMap.length = C, r.spotShadow.length = R, r.spotShadowMap.length = R, r.directionalShadowMatrix.length = w, r.pointShadowMatrix.length = C, r.spotLightMatrix.length = R + P - D, r.spotLightMap.length = P, r.numSpotLightShadowsWithMaps = D, r.numLightProbes = I, U.directionalLength = v, U.pointLength = b, U.spotLength = E, U.rectAreaLength = S, U.hemiLength = _, U.numDirectionalShadows = w, U.numPointShadows = C, U.numSpotShadows = R, U.numSpotMaps = P, U.numLightProbes = I, r.version = Ede++);
  }
  function u(d, f) {
    let p = 0, g = 0, v = 0, b = 0, E = 0;
    const S = f.matrixWorldInverse;
    for (let _ = 0, w = d.length; _ < w; _++) {
      const C = d[_];
      if (C.isDirectionalLight) {
        const R = r.directional[p];
        R.direction.setFromMatrixPosition(C.matrixWorld), i.setFromMatrixPosition(C.target.matrixWorld), R.direction.sub(i), R.direction.transformDirection(S), p++;
      } else if (C.isSpotLight) {
        const R = r.spot[v];
        R.position.setFromMatrixPosition(C.matrixWorld), R.position.applyMatrix4(S), R.direction.setFromMatrixPosition(C.matrixWorld), i.setFromMatrixPosition(C.target.matrixWorld), R.direction.sub(i), R.direction.transformDirection(S), v++;
      } else if (C.isRectAreaLight) {
        const R = r.rectArea[b];
        R.position.setFromMatrixPosition(C.matrixWorld), R.position.applyMatrix4(S), o.identity(), a.copy(C.matrixWorld), a.premultiply(S), o.extractRotation(a), R.halfWidth.set(C.width * 0.5, 0, 0), R.halfHeight.set(0, C.height * 0.5, 0), R.halfWidth.applyMatrix4(o), R.halfHeight.applyMatrix4(o), b++;
      } else if (C.isPointLight) {
        const R = r.point[g];
        R.position.setFromMatrixPosition(C.matrixWorld), R.position.applyMatrix4(S), g++;
      } else if (C.isHemisphereLight) {
        const R = r.hemi[E];
        R.direction.setFromMatrixPosition(C.matrixWorld), R.direction.transformDirection(S), E++;
      }
    }
  }
  return {
    setup: s,
    setupView: u,
    state: r
  };
}
function rF(n) {
  const e = new wde(n), t = [], r = [];
  function i(f) {
    d.camera = f, t.length = 0, r.length = 0;
  }
  function a(f) {
    t.push(f);
  }
  function o(f) {
    r.push(f);
  }
  function s() {
    e.setup(t);
  }
  function u(f) {
    e.setupView(t, f);
  }
  const d = {
    lightsArray: t,
    shadowsArray: r,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: i,
    state: d,
    setupLights: s,
    setupLightsView: u,
    pushLight: a,
    pushShadow: o
  };
}
function Mde(n) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(i, a = 0) {
    const o = e.get(i);
    let s;
    return o === void 0 ? (s = new rF(n), e.set(i, [s])) : a >= o.length ? (s = new rF(n), o.push(s)) : s = o[a], s;
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: r
  };
}
class JO extends Da {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = hk, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class eP extends Da {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const Tde = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Rde = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Ade(n, e, t) {
  let r = new N0();
  const i = new St(), a = new St(), o = new wr(), s = new JO({ depthPacking: pk }), u = new eP(), d = {}, f = t.maxTextureSize, p = { [mu]: ho, [ho]: mu, [ic]: ic }, g = new Rl({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new St() },
      radius: { value: 4 }
    },
    vertexShader: Tde,
    fragmentShader: Rde
  }), v = g.clone();
  v.defines.HORIZONTAL_PASS = 1;
  const b = new Xn();
  b.setAttribute(
    "position",
    new jr(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const E = new Zi(b, g), S = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = UE;
  let _ = this.type;
  this.render = function(D, I, U) {
    if (S.enabled === !1 || S.autoUpdate === !1 && S.needsUpdate === !1 || D.length === 0) return;
    const L = n.getRenderTarget(), N = n.getActiveCubeFace(), H = n.getActiveMipmapLevel(), j = n.state;
    j.setBlending(cu), j.buffers.color.setClear(1, 1, 1, 1), j.buffers.depth.setTest(!0), j.setScissorTest(!1);
    const G = _ !== bl && this.type === bl, X = _ === bl && this.type !== bl;
    for (let ae = 0, Z = D.length; ae < Z; ae++) {
      const K = D[ae], B = K.shadow;
      if (B === void 0) {
        console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
        continue;
      }
      if (B.autoUpdate === !1 && B.needsUpdate === !1) continue;
      i.copy(B.mapSize);
      const Q = B.getFrameExtents();
      if (i.multiply(Q), a.copy(B.mapSize), (i.x > f || i.y > f) && (i.x > f && (a.x = Math.floor(f / Q.x), i.x = a.x * Q.x, B.mapSize.x = a.x), i.y > f && (a.y = Math.floor(f / Q.y), i.y = a.y * Q.y, B.mapSize.y = a.y)), B.map === null || G === !0 || X === !0) {
        const q = this.type !== bl ? { minFilter: ba, magFilter: ba } : {};
        B.map !== null && B.map.dispose(), B.map = new Tl(i.x, i.y, q), B.map.texture.name = K.name + ".shadowMap", B.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(B.map), n.clear();
      const V = B.getViewportCount();
      for (let q = 0; q < V; q++) {
        const ne = B.getViewport(q);
        o.set(
          a.x * ne.x,
          a.y * ne.y,
          a.x * ne.z,
          a.y * ne.w
        ), j.viewport(o), B.updateMatrices(K, q), r = B.getFrustum(), R(I, U, B.camera, K, this.type);
      }
      B.isPointLightShadow !== !0 && this.type === bl && w(B, U), B.needsUpdate = !1;
    }
    _ = this.type, S.needsUpdate = !1, n.setRenderTarget(L, N, H);
  };
  function w(D, I) {
    const U = e.update(E);
    g.defines.VSM_SAMPLES !== D.blurSamples && (g.defines.VSM_SAMPLES = D.blurSamples, v.defines.VSM_SAMPLES = D.blurSamples, g.needsUpdate = !0, v.needsUpdate = !0), D.mapPass === null && (D.mapPass = new Tl(i.x, i.y)), g.uniforms.shadow_pass.value = D.map.texture, g.uniforms.resolution.value = D.mapSize, g.uniforms.radius.value = D.radius, n.setRenderTarget(D.mapPass), n.clear(), n.renderBufferDirect(I, null, U, g, E, null), v.uniforms.shadow_pass.value = D.mapPass.texture, v.uniforms.resolution.value = D.mapSize, v.uniforms.radius.value = D.radius, n.setRenderTarget(D.map), n.clear(), n.renderBufferDirect(I, null, U, v, E, null);
  }
  function C(D, I, U, L) {
    let N = null;
    const H = U.isPointLight === !0 ? D.customDistanceMaterial : D.customDepthMaterial;
    if (H !== void 0)
      N = H;
    else if (N = U.isPointLight === !0 ? u : s, n.localClippingEnabled && I.clipShadows === !0 && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0 || I.map && I.alphaTest > 0) {
      const j = N.uuid, G = I.uuid;
      let X = d[j];
      X === void 0 && (X = {}, d[j] = X);
      let ae = X[G];
      ae === void 0 && (ae = N.clone(), X[G] = ae, I.addEventListener("dispose", P)), N = ae;
    }
    if (N.visible = I.visible, N.wireframe = I.wireframe, L === bl ? N.side = I.shadowSide !== null ? I.shadowSide : I.side : N.side = I.shadowSide !== null ? I.shadowSide : p[I.side], N.alphaMap = I.alphaMap, N.alphaTest = I.alphaTest, N.map = I.map, N.clipShadows = I.clipShadows, N.clippingPlanes = I.clippingPlanes, N.clipIntersection = I.clipIntersection, N.displacementMap = I.displacementMap, N.displacementScale = I.displacementScale, N.displacementBias = I.displacementBias, N.wireframeLinewidth = I.wireframeLinewidth, N.linewidth = I.linewidth, U.isPointLight === !0 && N.isMeshDistanceMaterial === !0) {
      const j = n.properties.get(N);
      j.light = U;
    }
    return N;
  }
  function R(D, I, U, L, N) {
    if (D.visible === !1) return;
    if (D.layers.test(I.layers) && (D.isMesh || D.isLine || D.isPoints) && (D.castShadow || D.receiveShadow && N === bl) && (!D.frustumCulled || r.intersectsObject(D))) {
      D.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, D.matrixWorld);
      const G = e.update(D), X = D.material;
      if (Array.isArray(X)) {
        const ae = G.groups;
        for (let Z = 0, K = ae.length; Z < K; Z++) {
          const B = ae[Z], Q = X[B.materialIndex];
          if (Q && Q.visible) {
            const V = C(D, Q, L, N);
            D.onBeforeShadow(n, D, I, U, G, V, B), n.renderBufferDirect(U, null, G, V, D, B), D.onAfterShadow(n, D, I, U, G, V, B);
          }
        }
      } else if (X.visible) {
        const ae = C(D, X, L, N);
        D.onBeforeShadow(n, D, I, U, G, ae, null), n.renderBufferDirect(U, null, G, ae, D, null), D.onAfterShadow(n, D, I, U, G, ae, null);
      }
    }
    const j = D.children;
    for (let G = 0, X = j.length; G < X; G++)
      R(j[G], I, U, L, N);
  }
  function P(D) {
    D.target.removeEventListener("dispose", P);
    for (const U in d) {
      const L = d[U], N = D.target.uuid;
      N in L && (L[N].dispose(), delete L[N]);
    }
  }
}
function Ode(n) {
  function e() {
    let ue = !1;
    const De = new wr();
    let Ge = null;
    const We = new wr(0, 0, 0, 0);
    return {
      setMask: function(He) {
        Ge !== He && !ue && (n.colorMask(He, He, He, He), Ge = He);
      },
      setLocked: function(He) {
        ue = He;
      },
      setClear: function(He, ut, vt, _t, Wt) {
        Wt === !0 && (He *= _t, ut *= _t, vt *= _t), De.set(He, ut, vt, _t), We.equals(De) === !1 && (n.clearColor(He, ut, vt, _t), We.copy(De));
      },
      reset: function() {
        ue = !1, Ge = null, We.set(-1, 0, 0, 0);
      }
    };
  }
  function t() {
    let ue = !1, De = null, Ge = null, We = null;
    return {
      setTest: function(He) {
        He ? he(n.DEPTH_TEST) : le(n.DEPTH_TEST);
      },
      setMask: function(He) {
        De !== He && !ue && (n.depthMask(He), De = He);
      },
      setFunc: function(He) {
        if (Ge !== He) {
          switch (He) {
            case q4:
              n.depthFunc(n.NEVER);
              break;
            case Y4:
              n.depthFunc(n.ALWAYS);
              break;
            case K4:
              n.depthFunc(n.LESS);
              break;
            case Zy:
              n.depthFunc(n.LEQUAL);
              break;
            case Z4:
              n.depthFunc(n.EQUAL);
              break;
            case Q4:
              n.depthFunc(n.GEQUAL);
              break;
            case J4:
              n.depthFunc(n.GREATER);
              break;
            case ek:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Ge = He;
        }
      },
      setLocked: function(He) {
        ue = He;
      },
      setClear: function(He) {
        We !== He && (n.clearDepth(He), We = He);
      },
      reset: function() {
        ue = !1, De = null, Ge = null, We = null;
      }
    };
  }
  function r() {
    let ue = !1, De = null, Ge = null, We = null, He = null, ut = null, vt = null, _t = null, Wt = null;
    return {
      setTest: function(lt) {
        ue || (lt ? he(n.STENCIL_TEST) : le(n.STENCIL_TEST));
      },
      setMask: function(lt) {
        De !== lt && !ue && (n.stencilMask(lt), De = lt);
      },
      setFunc: function(lt, Ct, un) {
        (Ge !== lt || We !== Ct || He !== un) && (n.stencilFunc(lt, Ct, un), Ge = lt, We = Ct, He = un);
      },
      setOp: function(lt, Ct, un) {
        (ut !== lt || vt !== Ct || _t !== un) && (n.stencilOp(lt, Ct, un), ut = lt, vt = Ct, _t = un);
      },
      setLocked: function(lt) {
        ue = lt;
      },
      setClear: function(lt) {
        Wt !== lt && (n.clearStencil(lt), Wt = lt);
      },
      reset: function() {
        ue = !1, De = null, Ge = null, We = null, He = null, ut = null, vt = null, _t = null, Wt = null;
      }
    };
  }
  const i = new e(), a = new t(), o = new r(), s = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let d = {}, f = {}, p = /* @__PURE__ */ new WeakMap(), g = [], v = null, b = !1, E = null, S = null, _ = null, w = null, C = null, R = null, P = null, D = new an(0, 0, 0), I = 0, U = !1, L = null, N = null, H = null, j = null, G = null;
  const X = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let ae = !1, Z = 0;
  const K = n.getParameter(n.VERSION);
  K.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec(K)[1]), ae = Z >= 1) : K.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec(K)[1]), ae = Z >= 2);
  let B = null, Q = {};
  const V = n.getParameter(n.SCISSOR_BOX), q = n.getParameter(n.VIEWPORT), ne = new wr().fromArray(V), ce = new wr().fromArray(q);
  function ie(ue, De, Ge, We) {
    const He = new Uint8Array(4), ut = n.createTexture();
    n.bindTexture(ue, ut), n.texParameteri(ue, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(ue, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let vt = 0; vt < Ge; vt++)
      ue === n.TEXTURE_3D || ue === n.TEXTURE_2D_ARRAY ? n.texImage3D(De, 0, n.RGBA, 1, 1, We, 0, n.RGBA, n.UNSIGNED_BYTE, He) : n.texImage2D(De + vt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, He);
    return ut;
  }
  const oe = {};
  oe[n.TEXTURE_2D] = ie(n.TEXTURE_2D, n.TEXTURE_2D, 1), oe[n.TEXTURE_CUBE_MAP] = ie(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), oe[n.TEXTURE_2D_ARRAY] = ie(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), oe[n.TEXTURE_3D] = ie(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), he(n.DEPTH_TEST), a.setFunc(Zy), Ie(!1), be(JR), he(n.CULL_FACE), Te(cu);
  function he(ue) {
    d[ue] !== !0 && (n.enable(ue), d[ue] = !0);
  }
  function le(ue) {
    d[ue] !== !1 && (n.disable(ue), d[ue] = !1);
  }
  function ve(ue, De) {
    return f[ue] !== De ? (n.bindFramebuffer(ue, De), f[ue] = De, ue === n.DRAW_FRAMEBUFFER && (f[n.FRAMEBUFFER] = De), ue === n.FRAMEBUFFER && (f[n.DRAW_FRAMEBUFFER] = De), !0) : !1;
  }
  function Ne(ue, De) {
    let Ge = g, We = !1;
    if (ue) {
      Ge = p.get(De), Ge === void 0 && (Ge = [], p.set(De, Ge));
      const He = ue.textures;
      if (Ge.length !== He.length || Ge[0] !== n.COLOR_ATTACHMENT0) {
        for (let ut = 0, vt = He.length; ut < vt; ut++)
          Ge[ut] = n.COLOR_ATTACHMENT0 + ut;
        Ge.length = He.length, We = !0;
      }
    } else
      Ge[0] !== n.BACK && (Ge[0] = n.BACK, We = !0);
    We && n.drawBuffers(Ge);
  }
  function xe(ue) {
    return v !== ue ? (n.useProgram(ue), v = ue, !0) : !1;
  }
  const Me = {
    [Ud]: n.FUNC_ADD,
    [P4]: n.FUNC_SUBTRACT,
    [D4]: n.FUNC_REVERSE_SUBTRACT
  };
  Me[I4] = n.MIN, Me[N4] = n.MAX;
  const $ = {
    [L4]: n.ZERO,
    [F4]: n.ONE,
    [U4]: n.SRC_COLOR,
    [wx]: n.SRC_ALPHA,
    [$4]: n.SRC_ALPHA_SATURATE,
    [V4]: n.DST_COLOR,
    [B4]: n.DST_ALPHA,
    [z4]: n.ONE_MINUS_SRC_COLOR,
    [Mx]: n.ONE_MINUS_SRC_ALPHA,
    [k4]: n.ONE_MINUS_DST_COLOR,
    [H4]: n.ONE_MINUS_DST_ALPHA,
    [W4]: n.CONSTANT_COLOR,
    [j4]: n.ONE_MINUS_CONSTANT_COLOR,
    [G4]: n.CONSTANT_ALPHA,
    [X4]: n.ONE_MINUS_CONSTANT_ALPHA
  };
  function Te(ue, De, Ge, We, He, ut, vt, _t, Wt, lt) {
    if (ue === cu) {
      b === !0 && (le(n.BLEND), b = !1);
      return;
    }
    if (b === !1 && (he(n.BLEND), b = !0), ue !== O4) {
      if (ue !== E || lt !== U) {
        if ((S !== Ud || C !== Ud) && (n.blendEquation(n.FUNC_ADD), S = Ud, C = Ud), lt)
          switch (ue) {
            case xh:
              n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case eA:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case tA:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case nA:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ue);
              break;
          }
        else
          switch (ue) {
            case xh:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case eA:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case tA:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case nA:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ue);
              break;
          }
        _ = null, w = null, R = null, P = null, D.set(0, 0, 0), I = 0, E = ue, U = lt;
      }
      return;
    }
    He = He || De, ut = ut || Ge, vt = vt || We, (De !== S || He !== C) && (n.blendEquationSeparate(Me[De], Me[He]), S = De, C = He), (Ge !== _ || We !== w || ut !== R || vt !== P) && (n.blendFuncSeparate($[Ge], $[We], $[ut], $[vt]), _ = Ge, w = We, R = ut, P = vt), (_t.equals(D) === !1 || Wt !== I) && (n.blendColor(_t.r, _t.g, _t.b, Wt), D.copy(_t), I = Wt), E = ue, U = !1;
  }
  function se(ue, De) {
    ue.side === ic ? le(n.CULL_FACE) : he(n.CULL_FACE);
    let Ge = ue.side === ho;
    De && (Ge = !Ge), Ie(Ge), ue.blending === xh && ue.transparent === !1 ? Te(cu) : Te(ue.blending, ue.blendEquation, ue.blendSrc, ue.blendDst, ue.blendEquationAlpha, ue.blendSrcAlpha, ue.blendDstAlpha, ue.blendColor, ue.blendAlpha, ue.premultipliedAlpha), a.setFunc(ue.depthFunc), a.setTest(ue.depthTest), a.setMask(ue.depthWrite), i.setMask(ue.colorWrite);
    const We = ue.stencilWrite;
    o.setTest(We), We && (o.setMask(ue.stencilWriteMask), o.setFunc(ue.stencilFunc, ue.stencilRef, ue.stencilFuncMask), o.setOp(ue.stencilFail, ue.stencilZFail, ue.stencilZPass)), Xe(ue.polygonOffset, ue.polygonOffsetFactor, ue.polygonOffsetUnits), ue.alphaToCoverage === !0 ? he(n.SAMPLE_ALPHA_TO_COVERAGE) : le(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ie(ue) {
    L !== ue && (ue ? n.frontFace(n.CW) : n.frontFace(n.CCW), L = ue);
  }
  function be(ue) {
    ue !== T4 ? (he(n.CULL_FACE), ue !== N && (ue === JR ? n.cullFace(n.BACK) : ue === R4 ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : le(n.CULL_FACE), N = ue;
  }
  function et(ue) {
    ue !== H && (ae && n.lineWidth(ue), H = ue);
  }
  function Xe(ue, De, Ge) {
    ue ? (he(n.POLYGON_OFFSET_FILL), (j !== De || G !== Ge) && (n.polygonOffset(De, Ge), j = De, G = Ge)) : le(n.POLYGON_OFFSET_FILL);
  }
  function $e(ue) {
    ue ? he(n.SCISSOR_TEST) : le(n.SCISSOR_TEST);
  }
  function te(ue) {
    ue === void 0 && (ue = n.TEXTURE0 + X - 1), B !== ue && (n.activeTexture(ue), B = ue);
  }
  function Y(ue, De, Ge) {
    Ge === void 0 && (B === null ? Ge = n.TEXTURE0 + X - 1 : Ge = B);
    let We = Q[Ge];
    We === void 0 && (We = { type: void 0, texture: void 0 }, Q[Ge] = We), (We.type !== ue || We.texture !== De) && (B !== Ge && (n.activeTexture(Ge), B = Ge), n.bindTexture(ue, De || oe[ue]), We.type = ue, We.texture = De);
  }
  function Se() {
    const ue = Q[B];
    ue !== void 0 && ue.type !== void 0 && (n.bindTexture(ue.type, null), ue.type = void 0, ue.texture = void 0);
  }
  function Oe() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function Pe() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function Ve() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function Ze() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function nt() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function ht() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function pt() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function Be() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function ye() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function Ue() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (ue) {
      console.error("THREE.WebGLState:", ue);
    }
  }
  function Ye(ue) {
    ne.equals(ue) === !1 && (n.scissor(ue.x, ue.y, ue.z, ue.w), ne.copy(ue));
  }
  function tt(ue) {
    ce.equals(ue) === !1 && (n.viewport(ue.x, ue.y, ue.z, ue.w), ce.copy(ue));
  }
  function st(ue, De) {
    let Ge = u.get(De);
    Ge === void 0 && (Ge = /* @__PURE__ */ new WeakMap(), u.set(De, Ge));
    let We = Ge.get(ue);
    We === void 0 && (We = n.getUniformBlockIndex(De, ue.name), Ge.set(ue, We));
  }
  function Tt(ue, De) {
    const We = u.get(De).get(ue);
    s.get(De) !== We && (n.uniformBlockBinding(De, We, ue.__bindingPointIndex), s.set(De, We));
  }
  function Rt() {
    n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), d = {}, B = null, Q = {}, f = {}, p = /* @__PURE__ */ new WeakMap(), g = [], v = null, b = !1, E = null, S = null, _ = null, w = null, C = null, R = null, P = null, D = new an(0, 0, 0), I = 0, U = !1, L = null, N = null, H = null, j = null, G = null, ne.set(0, 0, n.canvas.width, n.canvas.height), ce.set(0, 0, n.canvas.width, n.canvas.height), i.reset(), a.reset(), o.reset();
  }
  return {
    buffers: {
      color: i,
      depth: a,
      stencil: o
    },
    enable: he,
    disable: le,
    bindFramebuffer: ve,
    drawBuffers: Ne,
    useProgram: xe,
    setBlending: Te,
    setMaterial: se,
    setFlipSided: Ie,
    setCullFace: be,
    setLineWidth: et,
    setPolygonOffset: Xe,
    setScissorTest: $e,
    activeTexture: te,
    bindTexture: Y,
    unbindTexture: Se,
    compressedTexImage2D: Oe,
    compressedTexImage3D: Pe,
    texImage2D: ye,
    texImage3D: Ue,
    updateUBOMapping: st,
    uniformBlockBinding: Tt,
    texStorage2D: pt,
    texStorage3D: Be,
    texSubImage2D: Ve,
    texSubImage3D: Ze,
    compressedTexSubImage2D: nt,
    compressedTexSubImage3D: ht,
    scissor: Ye,
    viewport: tt,
    reset: Rt
  };
}
function Pde(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return t > e ? (n.repeat.x = 1, n.repeat.y = t / e, n.offset.x = 0, n.offset.y = (1 - n.repeat.y) / 2) : (n.repeat.x = e / t, n.repeat.y = 1, n.offset.x = (1 - n.repeat.x) / 2, n.offset.y = 0), n;
}
function Dde(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return t > e ? (n.repeat.x = e / t, n.repeat.y = 1, n.offset.x = (1 - n.repeat.x) / 2, n.offset.y = 0) : (n.repeat.x = 1, n.repeat.y = t / e, n.offset.x = 0, n.offset.y = (1 - n.repeat.y) / 2), n;
}
function Ide(n) {
  return n.repeat.x = 1, n.repeat.y = 1, n.offset.x = 0, n.offset.y = 0, n;
}
function lA(n, e, t, r) {
  const i = Nde(r);
  switch (t) {
    case zO:
      return n * e;
    case HO:
      return n * e;
    case VO:
      return n * e * 2;
    case kE:
      return n * e / i.components * i.byteLength;
    case O0:
      return n * e / i.components * i.byteLength;
    case kO:
      return n * e * 2 / i.components * i.byteLength;
    case $E:
      return n * e * 2 / i.components * i.byteLength;
    case BO:
      return n * e * 3 / i.components * i.byteLength;
    case Xa:
      return n * e * 4 / i.components * i.byteLength;
    case WE:
      return n * e * 4 / i.components * i.byteLength;
    case Oy:
    case Py:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Dy:
    case Iy:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Rx:
    case Ox:
      return Math.max(n, 16) * Math.max(e, 8) / 4;
    case Tx:
    case Ax:
      return Math.max(n, 8) * Math.max(e, 8) / 2;
    case Px:
    case Dx:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Ix:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Nx:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Lx:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Fx:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Ux:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case zx:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Bx:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Hx:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Vx:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case kx:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case $x:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Wx:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case jx:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Gx:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Xx:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Ny:
    case qx:
    case Yx:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case $O:
    case Kx:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case Zx:
    case Qx:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${t} format.`
  );
}
function Nde(n) {
  switch (n) {
    case Ml:
    case LO:
      return { byteLength: 1, components: 1 };
    case lg:
    case FO:
    case xg:
      return { byteLength: 2, components: 1 };
    case HE:
    case VE:
      return { byteLength: 2, components: 4 };
    case vu:
    case BE:
    case Ho:
      return { byteLength: 4, components: 1 };
    case UO:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
const Lde = {
  contain: Pde,
  cover: Dde,
  fill: Ide,
  getByteLength: lA
};
function Fde(n, e, t, r, i, a, o) {
  const s = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, u = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), d = new St(), f = /* @__PURE__ */ new WeakMap();
  let p;
  const g = /* @__PURE__ */ new WeakMap();
  let v = !1;
  try {
    v = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function b(te, Y) {
    return v ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(te, Y)
    ) : c0("canvas");
  }
  function E(te, Y, Se) {
    let Oe = 1;
    const Pe = $e(te);
    if ((Pe.width > Se || Pe.height > Se) && (Oe = Se / Math.max(Pe.width, Pe.height)), Oe < 1)
      if (typeof HTMLImageElement < "u" && te instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && te instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && te instanceof ImageBitmap || typeof VideoFrame < "u" && te instanceof VideoFrame) {
        const Ve = Math.floor(Oe * Pe.width), Ze = Math.floor(Oe * Pe.height);
        p === void 0 && (p = b(Ve, Ze));
        const nt = Y ? b(Ve, Ze) : p;
        return nt.width = Ve, nt.height = Ze, nt.getContext("2d").drawImage(te, 0, 0, Ve, Ze), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Pe.width + "x" + Pe.height + ") to (" + Ve + "x" + Ze + ")."), nt;
      } else
        return "data" in te && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Pe.width + "x" + Pe.height + ")."), te;
    return te;
  }
  function S(te) {
    return te.generateMipmaps && te.minFilter !== ba && te.minFilter !== Ki;
  }
  function _(te) {
    n.generateMipmap(te);
  }
  function w(te, Y, Se, Oe, Pe = !1) {
    if (te !== null) {
      if (n[te] !== void 0) return n[te];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + te + "'");
    }
    let Ve = Y;
    if (Y === n.RED && (Se === n.FLOAT && (Ve = n.R32F), Se === n.HALF_FLOAT && (Ve = n.R16F), Se === n.UNSIGNED_BYTE && (Ve = n.R8)), Y === n.RED_INTEGER && (Se === n.UNSIGNED_BYTE && (Ve = n.R8UI), Se === n.UNSIGNED_SHORT && (Ve = n.R16UI), Se === n.UNSIGNED_INT && (Ve = n.R32UI), Se === n.BYTE && (Ve = n.R8I), Se === n.SHORT && (Ve = n.R16I), Se === n.INT && (Ve = n.R32I)), Y === n.RG && (Se === n.FLOAT && (Ve = n.RG32F), Se === n.HALF_FLOAT && (Ve = n.RG16F), Se === n.UNSIGNED_BYTE && (Ve = n.RG8)), Y === n.RG_INTEGER && (Se === n.UNSIGNED_BYTE && (Ve = n.RG8UI), Se === n.UNSIGNED_SHORT && (Ve = n.RG16UI), Se === n.UNSIGNED_INT && (Ve = n.RG32UI), Se === n.BYTE && (Ve = n.RG8I), Se === n.SHORT && (Ve = n.RG16I), Se === n.INT && (Ve = n.RG32I)), Y === n.RGB && Se === n.UNSIGNED_INT_5_9_9_9_REV && (Ve = n.RGB9_E5), Y === n.RGBA) {
      const Ze = Pe ? i0 : Cr.getTransfer(Oe);
      Se === n.FLOAT && (Ve = n.RGBA32F), Se === n.HALF_FLOAT && (Ve = n.RGBA16F), Se === n.UNSIGNED_BYTE && (Ve = Ze === ei ? n.SRGB8_ALPHA8 : n.RGBA8), Se === n.UNSIGNED_SHORT_4_4_4_4 && (Ve = n.RGBA4), Se === n.UNSIGNED_SHORT_5_5_5_1 && (Ve = n.RGB5_A1);
    }
    return (Ve === n.R16F || Ve === n.R32F || Ve === n.RG16F || Ve === n.RG32F || Ve === n.RGBA16F || Ve === n.RGBA32F) && e.get("EXT_color_buffer_float"), Ve;
  }
  function C(te, Y) {
    let Se;
    return te ? Y === null || Y === vu || Y === Nh ? Se = n.DEPTH24_STENCIL8 : Y === Ho ? Se = n.DEPTH32F_STENCIL8 : Y === lg && (Se = n.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : Y === null || Y === vu || Y === Nh ? Se = n.DEPTH_COMPONENT24 : Y === Ho ? Se = n.DEPTH_COMPONENT32F : Y === lg && (Se = n.DEPTH_COMPONENT16), Se;
  }
  function R(te, Y) {
    return S(te) === !0 || te.isFramebufferTexture && te.minFilter !== ba && te.minFilter !== Ki ? Math.log2(Math.max(Y.width, Y.height)) + 1 : te.mipmaps !== void 0 && te.mipmaps.length > 0 ? te.mipmaps.length : te.isCompressedTexture && Array.isArray(te.image) ? Y.mipmaps.length : 1;
  }
  function P(te) {
    const Y = te.target;
    Y.removeEventListener("dispose", P), I(Y), Y.isVideoTexture && f.delete(Y);
  }
  function D(te) {
    const Y = te.target;
    Y.removeEventListener("dispose", D), L(Y);
  }
  function I(te) {
    const Y = r.get(te);
    if (Y.__webglInit === void 0) return;
    const Se = te.source, Oe = g.get(Se);
    if (Oe) {
      const Pe = Oe[Y.__cacheKey];
      Pe.usedTimes--, Pe.usedTimes === 0 && U(te), Object.keys(Oe).length === 0 && g.delete(Se);
    }
    r.remove(te);
  }
  function U(te) {
    const Y = r.get(te);
    n.deleteTexture(Y.__webglTexture);
    const Se = te.source, Oe = g.get(Se);
    delete Oe[Y.__cacheKey], o.memory.textures--;
  }
  function L(te) {
    const Y = r.get(te);
    if (te.depthTexture && te.depthTexture.dispose(), te.isWebGLCubeRenderTarget)
      for (let Oe = 0; Oe < 6; Oe++) {
        if (Array.isArray(Y.__webglFramebuffer[Oe]))
          for (let Pe = 0; Pe < Y.__webglFramebuffer[Oe].length; Pe++) n.deleteFramebuffer(Y.__webglFramebuffer[Oe][Pe]);
        else
          n.deleteFramebuffer(Y.__webglFramebuffer[Oe]);
        Y.__webglDepthbuffer && n.deleteRenderbuffer(Y.__webglDepthbuffer[Oe]);
      }
    else {
      if (Array.isArray(Y.__webglFramebuffer))
        for (let Oe = 0; Oe < Y.__webglFramebuffer.length; Oe++) n.deleteFramebuffer(Y.__webglFramebuffer[Oe]);
      else
        n.deleteFramebuffer(Y.__webglFramebuffer);
      if (Y.__webglDepthbuffer && n.deleteRenderbuffer(Y.__webglDepthbuffer), Y.__webglMultisampledFramebuffer && n.deleteFramebuffer(Y.__webglMultisampledFramebuffer), Y.__webglColorRenderbuffer)
        for (let Oe = 0; Oe < Y.__webglColorRenderbuffer.length; Oe++)
          Y.__webglColorRenderbuffer[Oe] && n.deleteRenderbuffer(Y.__webglColorRenderbuffer[Oe]);
      Y.__webglDepthRenderbuffer && n.deleteRenderbuffer(Y.__webglDepthRenderbuffer);
    }
    const Se = te.textures;
    for (let Oe = 0, Pe = Se.length; Oe < Pe; Oe++) {
      const Ve = r.get(Se[Oe]);
      Ve.__webglTexture && (n.deleteTexture(Ve.__webglTexture), o.memory.textures--), r.remove(Se[Oe]);
    }
    r.remove(te);
  }
  let N = 0;
  function H() {
    N = 0;
  }
  function j() {
    const te = N;
    return te >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + te + " texture units while this GPU supports only " + i.maxTextures), N += 1, te;
  }
  function G(te) {
    const Y = [];
    return Y.push(te.wrapS), Y.push(te.wrapT), Y.push(te.wrapR || 0), Y.push(te.magFilter), Y.push(te.minFilter), Y.push(te.anisotropy), Y.push(te.internalFormat), Y.push(te.format), Y.push(te.type), Y.push(te.generateMipmaps), Y.push(te.premultiplyAlpha), Y.push(te.flipY), Y.push(te.unpackAlignment), Y.push(te.colorSpace), Y.join();
  }
  function X(te, Y) {
    const Se = r.get(te);
    if (te.isVideoTexture && et(te), te.isRenderTargetTexture === !1 && te.version > 0 && Se.__version !== te.version) {
      const Oe = te.image;
      if (Oe === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Oe.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ce(Se, te, Y);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, Se.__webglTexture, n.TEXTURE0 + Y);
  }
  function ae(te, Y) {
    const Se = r.get(te);
    if (te.version > 0 && Se.__version !== te.version) {
      ce(Se, te, Y);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, Se.__webglTexture, n.TEXTURE0 + Y);
  }
  function Z(te, Y) {
    const Se = r.get(te);
    if (te.version > 0 && Se.__version !== te.version) {
      ce(Se, te, Y);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, Se.__webglTexture, n.TEXTURE0 + Y);
  }
  function K(te, Y) {
    const Se = r.get(te);
    if (te.version > 0 && Se.__version !== te.version) {
      ie(Se, te, Y);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, Se.__webglTexture, n.TEXTURE0 + Y);
  }
  const B = {
    [e0]: n.REPEAT,
    [Xs]: n.CLAMP_TO_EDGE,
    [t0]: n.MIRRORED_REPEAT
  }, Q = {
    [ba]: n.NEAREST,
    [NO]: n.NEAREST_MIPMAP_NEAREST,
    [km]: n.NEAREST_MIPMAP_LINEAR,
    [Ki]: n.LINEAR,
    [Ay]: n.LINEAR_MIPMAP_NEAREST,
    [oc]: n.LINEAR_MIPMAP_LINEAR
  }, V = {
    [gk]: n.NEVER,
    [xk]: n.ALWAYS,
    [vk]: n.LESS,
    [jO]: n.LEQUAL,
    [yk]: n.EQUAL,
    [_k]: n.GEQUAL,
    [bk]: n.GREATER,
    [Sk]: n.NOTEQUAL
  };
  function q(te, Y) {
    if (Y.type === Ho && e.has("OES_texture_float_linear") === !1 && (Y.magFilter === Ki || Y.magFilter === Ay || Y.magFilter === km || Y.magFilter === oc || Y.minFilter === Ki || Y.minFilter === Ay || Y.minFilter === km || Y.minFilter === oc) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), n.texParameteri(te, n.TEXTURE_WRAP_S, B[Y.wrapS]), n.texParameteri(te, n.TEXTURE_WRAP_T, B[Y.wrapT]), (te === n.TEXTURE_3D || te === n.TEXTURE_2D_ARRAY) && n.texParameteri(te, n.TEXTURE_WRAP_R, B[Y.wrapR]), n.texParameteri(te, n.TEXTURE_MAG_FILTER, Q[Y.magFilter]), n.texParameteri(te, n.TEXTURE_MIN_FILTER, Q[Y.minFilter]), Y.compareFunction && (n.texParameteri(te, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(te, n.TEXTURE_COMPARE_FUNC, V[Y.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (Y.magFilter === ba || Y.minFilter !== km && Y.minFilter !== oc || Y.type === Ho && e.has("OES_texture_float_linear") === !1) return;
      if (Y.anisotropy > 1 || r.get(Y).__currentAnisotropy) {
        const Se = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(te, Se.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(Y.anisotropy, i.getMaxAnisotropy())), r.get(Y).__currentAnisotropy = Y.anisotropy;
      }
    }
  }
  function ne(te, Y) {
    let Se = !1;
    te.__webglInit === void 0 && (te.__webglInit = !0, Y.addEventListener("dispose", P));
    const Oe = Y.source;
    let Pe = g.get(Oe);
    Pe === void 0 && (Pe = {}, g.set(Oe, Pe));
    const Ve = G(Y);
    if (Ve !== te.__cacheKey) {
      Pe[Ve] === void 0 && (Pe[Ve] = {
        texture: n.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, Se = !0), Pe[Ve].usedTimes++;
      const Ze = Pe[te.__cacheKey];
      Ze !== void 0 && (Pe[te.__cacheKey].usedTimes--, Ze.usedTimes === 0 && U(Y)), te.__cacheKey = Ve, te.__webglTexture = Pe[Ve].texture;
    }
    return Se;
  }
  function ce(te, Y, Se) {
    let Oe = n.TEXTURE_2D;
    (Y.isDataArrayTexture || Y.isCompressedArrayTexture) && (Oe = n.TEXTURE_2D_ARRAY), Y.isData3DTexture && (Oe = n.TEXTURE_3D);
    const Pe = ne(te, Y), Ve = Y.source;
    t.bindTexture(Oe, te.__webglTexture, n.TEXTURE0 + Se);
    const Ze = r.get(Ve);
    if (Ve.version !== Ze.__version || Pe === !0) {
      t.activeTexture(n.TEXTURE0 + Se);
      const nt = Cr.getPrimaries(Cr.workingColorSpace), ht = Y.colorSpace === ru ? null : Cr.getPrimaries(Y.colorSpace), pt = Y.colorSpace === ru || nt === ht ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, Y.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, Y.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, pt);
      let Be = E(Y.image, !1, i.maxTextureSize);
      Be = Xe(Y, Be);
      const ye = a.convert(Y.format, Y.colorSpace), Ue = a.convert(Y.type);
      let Ye = w(Y.internalFormat, ye, Ue, Y.colorSpace, Y.isVideoTexture);
      q(Oe, Y);
      let tt;
      const st = Y.mipmaps, Tt = Y.isVideoTexture !== !0, Rt = Ze.__version === void 0 || Pe === !0, ue = Ve.dataReady, De = R(Y, Be);
      if (Y.isDepthTexture)
        Ye = C(Y.format === Lh, Y.type), Rt && (Tt ? t.texStorage2D(n.TEXTURE_2D, 1, Ye, Be.width, Be.height) : t.texImage2D(n.TEXTURE_2D, 0, Ye, Be.width, Be.height, 0, ye, Ue, null));
      else if (Y.isDataTexture)
        if (st.length > 0) {
          Tt && Rt && t.texStorage2D(n.TEXTURE_2D, De, Ye, st[0].width, st[0].height);
          for (let Ge = 0, We = st.length; Ge < We; Ge++)
            tt = st[Ge], Tt ? ue && t.texSubImage2D(n.TEXTURE_2D, Ge, 0, 0, tt.width, tt.height, ye, Ue, tt.data) : t.texImage2D(n.TEXTURE_2D, Ge, Ye, tt.width, tt.height, 0, ye, Ue, tt.data);
          Y.generateMipmaps = !1;
        } else
          Tt ? (Rt && t.texStorage2D(n.TEXTURE_2D, De, Ye, Be.width, Be.height), ue && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Be.width, Be.height, ye, Ue, Be.data)) : t.texImage2D(n.TEXTURE_2D, 0, Ye, Be.width, Be.height, 0, ye, Ue, Be.data);
      else if (Y.isCompressedTexture)
        if (Y.isCompressedArrayTexture) {
          Tt && Rt && t.texStorage3D(n.TEXTURE_2D_ARRAY, De, Ye, st[0].width, st[0].height, Be.depth);
          for (let Ge = 0, We = st.length; Ge < We; Ge++)
            if (tt = st[Ge], Y.format !== Xa)
              if (ye !== null)
                if (Tt) {
                  if (ue)
                    if (Y.layerUpdates.size > 0) {
                      const He = lA(tt.width, tt.height, Y.format, Y.type);
                      for (const ut of Y.layerUpdates) {
                        const vt = tt.data.subarray(
                          ut * He / tt.data.BYTES_PER_ELEMENT,
                          (ut + 1) * He / tt.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Ge, 0, 0, ut, tt.width, tt.height, 1, ye, vt, 0, 0);
                      }
                      Y.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Ge, 0, 0, 0, tt.width, tt.height, Be.depth, ye, tt.data, 0, 0);
                } else
                  t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Ge, Ye, tt.width, tt.height, Be.depth, 0, tt.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              Tt ? ue && t.texSubImage3D(n.TEXTURE_2D_ARRAY, Ge, 0, 0, 0, tt.width, tt.height, Be.depth, ye, Ue, tt.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, Ge, Ye, tt.width, tt.height, Be.depth, 0, ye, Ue, tt.data);
        } else {
          Tt && Rt && t.texStorage2D(n.TEXTURE_2D, De, Ye, st[0].width, st[0].height);
          for (let Ge = 0, We = st.length; Ge < We; Ge++)
            tt = st[Ge], Y.format !== Xa ? ye !== null ? Tt ? ue && t.compressedTexSubImage2D(n.TEXTURE_2D, Ge, 0, 0, tt.width, tt.height, ye, tt.data) : t.compressedTexImage2D(n.TEXTURE_2D, Ge, Ye, tt.width, tt.height, 0, tt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Tt ? ue && t.texSubImage2D(n.TEXTURE_2D, Ge, 0, 0, tt.width, tt.height, ye, Ue, tt.data) : t.texImage2D(n.TEXTURE_2D, Ge, Ye, tt.width, tt.height, 0, ye, Ue, tt.data);
        }
      else if (Y.isDataArrayTexture)
        if (Tt) {
          if (Rt && t.texStorage3D(n.TEXTURE_2D_ARRAY, De, Ye, Be.width, Be.height, Be.depth), ue)
            if (Y.layerUpdates.size > 0) {
              const Ge = lA(Be.width, Be.height, Y.format, Y.type);
              for (const We of Y.layerUpdates) {
                const He = Be.data.subarray(
                  We * Ge / Be.data.BYTES_PER_ELEMENT,
                  (We + 1) * Ge / Be.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, We, Be.width, Be.height, 1, ye, Ue, He);
              }
              Y.clearLayerUpdates();
            } else
              t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Be.width, Be.height, Be.depth, ye, Ue, Be.data);
        } else
          t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Ye, Be.width, Be.height, Be.depth, 0, ye, Ue, Be.data);
      else if (Y.isData3DTexture)
        Tt ? (Rt && t.texStorage3D(n.TEXTURE_3D, De, Ye, Be.width, Be.height, Be.depth), ue && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Be.width, Be.height, Be.depth, ye, Ue, Be.data)) : t.texImage3D(n.TEXTURE_3D, 0, Ye, Be.width, Be.height, Be.depth, 0, ye, Ue, Be.data);
      else if (Y.isFramebufferTexture) {
        if (Rt)
          if (Tt)
            t.texStorage2D(n.TEXTURE_2D, De, Ye, Be.width, Be.height);
          else {
            let Ge = Be.width, We = Be.height;
            for (let He = 0; He < De; He++)
              t.texImage2D(n.TEXTURE_2D, He, Ye, Ge, We, 0, ye, Ue, null), Ge >>= 1, We >>= 1;
          }
      } else if (st.length > 0) {
        if (Tt && Rt) {
          const Ge = $e(st[0]);
          t.texStorage2D(n.TEXTURE_2D, De, Ye, Ge.width, Ge.height);
        }
        for (let Ge = 0, We = st.length; Ge < We; Ge++)
          tt = st[Ge], Tt ? ue && t.texSubImage2D(n.TEXTURE_2D, Ge, 0, 0, ye, Ue, tt) : t.texImage2D(n.TEXTURE_2D, Ge, Ye, ye, Ue, tt);
        Y.generateMipmaps = !1;
      } else if (Tt) {
        if (Rt) {
          const Ge = $e(Be);
          t.texStorage2D(n.TEXTURE_2D, De, Ye, Ge.width, Ge.height);
        }
        ue && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, ye, Ue, Be);
      } else
        t.texImage2D(n.TEXTURE_2D, 0, Ye, ye, Ue, Be);
      S(Y) && _(Oe), Ze.__version = Ve.version, Y.onUpdate && Y.onUpdate(Y);
    }
    te.__version = Y.version;
  }
  function ie(te, Y, Se) {
    if (Y.image.length !== 6) return;
    const Oe = ne(te, Y), Pe = Y.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, te.__webglTexture, n.TEXTURE0 + Se);
    const Ve = r.get(Pe);
    if (Pe.version !== Ve.__version || Oe === !0) {
      t.activeTexture(n.TEXTURE0 + Se);
      const Ze = Cr.getPrimaries(Cr.workingColorSpace), nt = Y.colorSpace === ru ? null : Cr.getPrimaries(Y.colorSpace), ht = Y.colorSpace === ru || Ze === nt ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, Y.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, Y.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ht);
      const pt = Y.isCompressedTexture || Y.image[0].isCompressedTexture, Be = Y.image[0] && Y.image[0].isDataTexture, ye = [];
      for (let We = 0; We < 6; We++)
        !pt && !Be ? ye[We] = E(Y.image[We], !0, i.maxCubemapSize) : ye[We] = Be ? Y.image[We].image : Y.image[We], ye[We] = Xe(Y, ye[We]);
      const Ue = ye[0], Ye = a.convert(Y.format, Y.colorSpace), tt = a.convert(Y.type), st = w(Y.internalFormat, Ye, tt, Y.colorSpace), Tt = Y.isVideoTexture !== !0, Rt = Ve.__version === void 0 || Oe === !0, ue = Pe.dataReady;
      let De = R(Y, Ue);
      q(n.TEXTURE_CUBE_MAP, Y);
      let Ge;
      if (pt) {
        Tt && Rt && t.texStorage2D(n.TEXTURE_CUBE_MAP, De, st, Ue.width, Ue.height);
        for (let We = 0; We < 6; We++) {
          Ge = ye[We].mipmaps;
          for (let He = 0; He < Ge.length; He++) {
            const ut = Ge[He];
            Y.format !== Xa ? Ye !== null ? Tt ? ue && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, He, 0, 0, ut.width, ut.height, Ye, ut.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, He, st, ut.width, ut.height, 0, ut.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Tt ? ue && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, He, 0, 0, ut.width, ut.height, Ye, tt, ut.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, He, st, ut.width, ut.height, 0, Ye, tt, ut.data);
          }
        }
      } else {
        if (Ge = Y.mipmaps, Tt && Rt) {
          Ge.length > 0 && De++;
          const We = $e(ye[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, De, st, We.width, We.height);
        }
        for (let We = 0; We < 6; We++)
          if (Be) {
            Tt ? ue && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, 0, 0, 0, ye[We].width, ye[We].height, Ye, tt, ye[We].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, 0, st, ye[We].width, ye[We].height, 0, Ye, tt, ye[We].data);
            for (let He = 0; He < Ge.length; He++) {
              const vt = Ge[He].image[We].image;
              Tt ? ue && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, He + 1, 0, 0, vt.width, vt.height, Ye, tt, vt.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, He + 1, st, vt.width, vt.height, 0, Ye, tt, vt.data);
            }
          } else {
            Tt ? ue && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, 0, 0, 0, Ye, tt, ye[We]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, 0, st, Ye, tt, ye[We]);
            for (let He = 0; He < Ge.length; He++) {
              const ut = Ge[He];
              Tt ? ue && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, He + 1, 0, 0, Ye, tt, ut.image[We]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + We, He + 1, st, Ye, tt, ut.image[We]);
            }
          }
      }
      S(Y) && _(n.TEXTURE_CUBE_MAP), Ve.__version = Pe.version, Y.onUpdate && Y.onUpdate(Y);
    }
    te.__version = Y.version;
  }
  function oe(te, Y, Se, Oe, Pe, Ve) {
    const Ze = a.convert(Se.format, Se.colorSpace), nt = a.convert(Se.type), ht = w(Se.internalFormat, Ze, nt, Se.colorSpace);
    if (!r.get(Y).__hasExternalTextures) {
      const Be = Math.max(1, Y.width >> Ve), ye = Math.max(1, Y.height >> Ve);
      Pe === n.TEXTURE_3D || Pe === n.TEXTURE_2D_ARRAY ? t.texImage3D(Pe, Ve, ht, Be, ye, Y.depth, 0, Ze, nt, null) : t.texImage2D(Pe, Ve, ht, Be, ye, 0, Ze, nt, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, te), be(Y) ? s.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, Oe, Pe, r.get(Se).__webglTexture, 0, Ie(Y)) : (Pe === n.TEXTURE_2D || Pe >= n.TEXTURE_CUBE_MAP_POSITIVE_X && Pe <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, Oe, Pe, r.get(Se).__webglTexture, Ve), t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function he(te, Y, Se) {
    if (n.bindRenderbuffer(n.RENDERBUFFER, te), Y.depthBuffer) {
      const Oe = Y.depthTexture, Pe = Oe && Oe.isDepthTexture ? Oe.type : null, Ve = C(Y.stencilBuffer, Pe), Ze = Y.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, nt = Ie(Y);
      be(Y) ? s.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, nt, Ve, Y.width, Y.height) : Se ? n.renderbufferStorageMultisample(n.RENDERBUFFER, nt, Ve, Y.width, Y.height) : n.renderbufferStorage(n.RENDERBUFFER, Ve, Y.width, Y.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, Ze, n.RENDERBUFFER, te);
    } else {
      const Oe = Y.textures;
      for (let Pe = 0; Pe < Oe.length; Pe++) {
        const Ve = Oe[Pe], Ze = a.convert(Ve.format, Ve.colorSpace), nt = a.convert(Ve.type), ht = w(Ve.internalFormat, Ze, nt, Ve.colorSpace), pt = Ie(Y);
        Se && be(Y) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, pt, ht, Y.width, Y.height) : be(Y) ? s.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, pt, ht, Y.width, Y.height) : n.renderbufferStorage(n.RENDERBUFFER, ht, Y.width, Y.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function le(te, Y) {
    if (Y && Y.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(n.FRAMEBUFFER, te), !(Y.depthTexture && Y.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!r.get(Y.depthTexture).__webglTexture || Y.depthTexture.image.width !== Y.width || Y.depthTexture.image.height !== Y.height) && (Y.depthTexture.image.width = Y.width, Y.depthTexture.image.height = Y.height, Y.depthTexture.needsUpdate = !0), X(Y.depthTexture, 0);
    const Oe = r.get(Y.depthTexture).__webglTexture, Pe = Ie(Y);
    if (Y.depthTexture.format === Eh)
      be(Y) ? s.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Oe, 0, Pe) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Oe, 0);
    else if (Y.depthTexture.format === Lh)
      be(Y) ? s.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Oe, 0, Pe) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Oe, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function ve(te) {
    const Y = r.get(te), Se = te.isWebGLCubeRenderTarget === !0;
    if (te.depthTexture && !Y.__autoAllocateDepthBuffer) {
      if (Se) throw new Error("target.depthTexture not supported in Cube render targets");
      le(Y.__webglFramebuffer, te);
    } else if (Se) {
      Y.__webglDepthbuffer = [];
      for (let Oe = 0; Oe < 6; Oe++)
        t.bindFramebuffer(n.FRAMEBUFFER, Y.__webglFramebuffer[Oe]), Y.__webglDepthbuffer[Oe] = n.createRenderbuffer(), he(Y.__webglDepthbuffer[Oe], te, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, Y.__webglFramebuffer), Y.__webglDepthbuffer = n.createRenderbuffer(), he(Y.__webglDepthbuffer, te, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ne(te, Y, Se) {
    const Oe = r.get(te);
    Y !== void 0 && oe(Oe.__webglFramebuffer, te, te.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), Se !== void 0 && ve(te);
  }
  function xe(te) {
    const Y = te.texture, Se = r.get(te), Oe = r.get(Y);
    te.addEventListener("dispose", D);
    const Pe = te.textures, Ve = te.isWebGLCubeRenderTarget === !0, Ze = Pe.length > 1;
    if (Ze || (Oe.__webglTexture === void 0 && (Oe.__webglTexture = n.createTexture()), Oe.__version = Y.version, o.memory.textures++), Ve) {
      Se.__webglFramebuffer = [];
      for (let nt = 0; nt < 6; nt++)
        if (Y.mipmaps && Y.mipmaps.length > 0) {
          Se.__webglFramebuffer[nt] = [];
          for (let ht = 0; ht < Y.mipmaps.length; ht++)
            Se.__webglFramebuffer[nt][ht] = n.createFramebuffer();
        } else
          Se.__webglFramebuffer[nt] = n.createFramebuffer();
    } else {
      if (Y.mipmaps && Y.mipmaps.length > 0) {
        Se.__webglFramebuffer = [];
        for (let nt = 0; nt < Y.mipmaps.length; nt++)
          Se.__webglFramebuffer[nt] = n.createFramebuffer();
      } else
        Se.__webglFramebuffer = n.createFramebuffer();
      if (Ze)
        for (let nt = 0, ht = Pe.length; nt < ht; nt++) {
          const pt = r.get(Pe[nt]);
          pt.__webglTexture === void 0 && (pt.__webglTexture = n.createTexture(), o.memory.textures++);
        }
      if (te.samples > 0 && be(te) === !1) {
        Se.__webglMultisampledFramebuffer = n.createFramebuffer(), Se.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, Se.__webglMultisampledFramebuffer);
        for (let nt = 0; nt < Pe.length; nt++) {
          const ht = Pe[nt];
          Se.__webglColorRenderbuffer[nt] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, Se.__webglColorRenderbuffer[nt]);
          const pt = a.convert(ht.format, ht.colorSpace), Be = a.convert(ht.type), ye = w(ht.internalFormat, pt, Be, ht.colorSpace, te.isXRRenderTarget === !0), Ue = Ie(te);
          n.renderbufferStorageMultisample(n.RENDERBUFFER, Ue, ye, te.width, te.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + nt, n.RENDERBUFFER, Se.__webglColorRenderbuffer[nt]);
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null), te.depthBuffer && (Se.__webglDepthRenderbuffer = n.createRenderbuffer(), he(Se.__webglDepthRenderbuffer, te, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (Ve) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, Oe.__webglTexture), q(n.TEXTURE_CUBE_MAP, Y);
      for (let nt = 0; nt < 6; nt++)
        if (Y.mipmaps && Y.mipmaps.length > 0)
          for (let ht = 0; ht < Y.mipmaps.length; ht++)
            oe(Se.__webglFramebuffer[nt][ht], te, Y, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + nt, ht);
        else
          oe(Se.__webglFramebuffer[nt], te, Y, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + nt, 0);
      S(Y) && _(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Ze) {
      for (let nt = 0, ht = Pe.length; nt < ht; nt++) {
        const pt = Pe[nt], Be = r.get(pt);
        t.bindTexture(n.TEXTURE_2D, Be.__webglTexture), q(n.TEXTURE_2D, pt), oe(Se.__webglFramebuffer, te, pt, n.COLOR_ATTACHMENT0 + nt, n.TEXTURE_2D, 0), S(pt) && _(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let nt = n.TEXTURE_2D;
      if ((te.isWebGL3DRenderTarget || te.isWebGLArrayRenderTarget) && (nt = te.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), t.bindTexture(nt, Oe.__webglTexture), q(nt, Y), Y.mipmaps && Y.mipmaps.length > 0)
        for (let ht = 0; ht < Y.mipmaps.length; ht++)
          oe(Se.__webglFramebuffer[ht], te, Y, n.COLOR_ATTACHMENT0, nt, ht);
      else
        oe(Se.__webglFramebuffer, te, Y, n.COLOR_ATTACHMENT0, nt, 0);
      S(Y) && _(nt), t.unbindTexture();
    }
    te.depthBuffer && ve(te);
  }
  function Me(te) {
    const Y = te.textures;
    for (let Se = 0, Oe = Y.length; Se < Oe; Se++) {
      const Pe = Y[Se];
      if (S(Pe)) {
        const Ve = te.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D, Ze = r.get(Pe).__webglTexture;
        t.bindTexture(Ve, Ze), _(Ve), t.unbindTexture();
      }
    }
  }
  const $ = [], Te = [];
  function se(te) {
    if (te.samples > 0) {
      if (be(te) === !1) {
        const Y = te.textures, Se = te.width, Oe = te.height;
        let Pe = n.COLOR_BUFFER_BIT;
        const Ve = te.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, Ze = r.get(te), nt = Y.length > 1;
        if (nt)
          for (let ht = 0; ht < Y.length; ht++)
            t.bindFramebuffer(n.FRAMEBUFFER, Ze.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ht, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, Ze.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ht, n.TEXTURE_2D, null, 0);
        t.bindFramebuffer(n.READ_FRAMEBUFFER, Ze.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ze.__webglFramebuffer);
        for (let ht = 0; ht < Y.length; ht++) {
          if (te.resolveDepthBuffer && (te.depthBuffer && (Pe |= n.DEPTH_BUFFER_BIT), te.stencilBuffer && te.resolveStencilBuffer && (Pe |= n.STENCIL_BUFFER_BIT)), nt) {
            n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Ze.__webglColorRenderbuffer[ht]);
            const pt = r.get(Y[ht]).__webglTexture;
            n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, pt, 0);
          }
          n.blitFramebuffer(0, 0, Se, Oe, 0, 0, Se, Oe, Pe, n.NEAREST), u === !0 && ($.length = 0, Te.length = 0, $.push(n.COLOR_ATTACHMENT0 + ht), te.depthBuffer && te.resolveDepthBuffer === !1 && ($.push(Ve), Te.push(Ve), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, Te)), n.invalidateFramebuffer(n.READ_FRAMEBUFFER, $));
        }
        if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), nt)
          for (let ht = 0; ht < Y.length; ht++) {
            t.bindFramebuffer(n.FRAMEBUFFER, Ze.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ht, n.RENDERBUFFER, Ze.__webglColorRenderbuffer[ht]);
            const pt = r.get(Y[ht]).__webglTexture;
            t.bindFramebuffer(n.FRAMEBUFFER, Ze.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ht, n.TEXTURE_2D, pt, 0);
          }
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ze.__webglMultisampledFramebuffer);
      } else if (te.depthBuffer && te.resolveDepthBuffer === !1 && u) {
        const Y = te.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Y]);
      }
    }
  }
  function Ie(te) {
    return Math.min(i.maxSamples, te.samples);
  }
  function be(te) {
    const Y = r.get(te);
    return te.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && Y.__useRenderToTexture !== !1;
  }
  function et(te) {
    const Y = o.render.frame;
    f.get(te) !== Y && (f.set(te, Y), te.update());
  }
  function Xe(te, Y) {
    const Se = te.colorSpace, Oe = te.format, Pe = te.type;
    return te.isCompressedTexture === !0 || te.isVideoTexture === !0 || Se !== xu && Se !== ru && (Cr.getTransfer(Se) === ei ? (Oe !== Xa || Pe !== Ml) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", Se)), Y;
  }
  function $e(te) {
    return typeof HTMLImageElement < "u" && te instanceof HTMLImageElement ? (d.width = te.naturalWidth || te.width, d.height = te.naturalHeight || te.height) : typeof VideoFrame < "u" && te instanceof VideoFrame ? (d.width = te.displayWidth, d.height = te.displayHeight) : (d.width = te.width, d.height = te.height), d;
  }
  this.allocateTextureUnit = j, this.resetTextureUnits = H, this.setTexture2D = X, this.setTexture2DArray = ae, this.setTexture3D = Z, this.setTextureCube = K, this.rebindTextures = Ne, this.setupRenderTarget = xe, this.updateRenderTargetMipmap = Me, this.updateMultisampleRenderTarget = se, this.setupDepthRenderbuffer = ve, this.setupFrameBufferTexture = oe, this.useMultisampledRTT = be;
}
function zk(n, e) {
  function t(r, i = ru) {
    let a;
    const o = Cr.getTransfer(i);
    if (r === Ml) return n.UNSIGNED_BYTE;
    if (r === HE) return n.UNSIGNED_SHORT_4_4_4_4;
    if (r === VE) return n.UNSIGNED_SHORT_5_5_5_1;
    if (r === UO) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (r === LO) return n.BYTE;
    if (r === FO) return n.SHORT;
    if (r === lg) return n.UNSIGNED_SHORT;
    if (r === BE) return n.INT;
    if (r === vu) return n.UNSIGNED_INT;
    if (r === Ho) return n.FLOAT;
    if (r === xg) return n.HALF_FLOAT;
    if (r === zO) return n.ALPHA;
    if (r === BO) return n.RGB;
    if (r === Xa) return n.RGBA;
    if (r === HO) return n.LUMINANCE;
    if (r === VO) return n.LUMINANCE_ALPHA;
    if (r === Eh) return n.DEPTH_COMPONENT;
    if (r === Lh) return n.DEPTH_STENCIL;
    if (r === kE) return n.RED;
    if (r === O0) return n.RED_INTEGER;
    if (r === kO) return n.RG;
    if (r === $E) return n.RG_INTEGER;
    if (r === WE) return n.RGBA_INTEGER;
    if (r === Oy || r === Py || r === Dy || r === Iy)
      if (o === ei)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (r === Oy) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === Py) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === Dy) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === Iy) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (r === Oy) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === Py) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === Dy) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === Iy) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (r === Tx || r === Rx || r === Ax || r === Ox)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (r === Tx) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === Rx) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === Ax) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === Ox) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (r === Px || r === Dx || r === Ix)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (r === Px || r === Dx) return o === ei ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (r === Ix) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (r === Nx || r === Lx || r === Fx || r === Ux || r === zx || r === Bx || r === Hx || r === Vx || r === kx || r === $x || r === Wx || r === jx || r === Gx || r === Xx)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (r === Nx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === Lx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === Fx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === Ux) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === zx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === Bx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === Hx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === Vx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === kx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === $x) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === Wx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === jx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === Gx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === Xx) return o === ei ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (r === Ny || r === qx || r === Yx)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (r === Ny) return o === ei ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === qx) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === Yx) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (r === $O || r === Kx || r === Zx || r === Qx)
      if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
        if (r === Ny) return a.COMPRESSED_RED_RGTC1_EXT;
        if (r === Kx) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === Zx) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === Qx) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return r === Nh ? n.UNSIGNED_INT_24_8 : n[r] !== void 0 ? n[r] : null;
  }
  return { convert: t };
}
class Bk extends sa {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class jm extends pr {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const Ude = { type: "move" };
class GM {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new jm(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new jm(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new de(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new de()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new jm(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new de(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new de()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const r of e.hand.values())
          this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, r) {
    let i = null, a = null, o = null;
    const s = this._targetRay, u = this._grip, d = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (d && e.hand) {
        o = !0;
        for (const E of e.hand.values()) {
          const S = t.getJointPose(E, r), _ = this._getHandJoint(d, E);
          S !== null && (_.matrix.fromArray(S.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.matrixWorldNeedsUpdate = !0, _.jointRadius = S.radius), _.visible = S !== null;
        }
        const f = d.joints["index-finger-tip"], p = d.joints["thumb-tip"], g = f.position.distanceTo(p.position), v = 0.02, b = 5e-3;
        d.inputState.pinching && g > v + b ? (d.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !d.inputState.pinching && g <= v - b && (d.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        u !== null && e.gripSpace && (a = t.getPose(e.gripSpace, r), a !== null && (u.matrix.fromArray(a.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(a.linearVelocity)) : u.hasLinearVelocity = !1, a.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(a.angularVelocity)) : u.hasAngularVelocity = !1));
      s !== null && (i = t.getPose(e.targetRaySpace, r), i === null && a !== null && (i = a), i !== null && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(Ude)));
    }
    return s !== null && (s.visible = i !== null), u !== null && (u.visible = a !== null), d !== null && (d.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new jm();
      r.matrixAutoUpdate = !1, r.visible = !1, e.joints[t.jointName] = r, e.add(r);
    }
    return e.joints[t.jointName];
  }
}
const zde = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, Bde = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class Hde {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, r) {
    if (this.texture === null) {
      const i = new Ei(), a = e.properties.get(i);
      a.__webglTexture = t.texture, (t.depthNear != r.depthNear || t.depthFar != r.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, r = new Rl({
        vertexShader: zde,
        fragmentShader: Bde,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: t.z },
          depthHeight: { value: t.w }
        }
      });
      this.mesh = new Zi(new Cg(20, 20), r);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class Vde extends Eu {
  constructor(e, t) {
    super();
    const r = this;
    let i = null, a = 1, o = null, s = "local-floor", u = 1, d = null, f = null, p = null, g = null, v = null, b = null;
    const E = new Hde(), S = t.getContextAttributes();
    let _ = null, w = null;
    const C = [], R = [], P = new St();
    let D = null;
    const I = new sa();
    I.layers.enable(1), I.viewport = new wr();
    const U = new sa();
    U.layers.enable(2), U.viewport = new wr();
    const L = [I, U], N = new Bk();
    N.layers.enable(1), N.layers.enable(2);
    let H = null, j = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(ie) {
      let oe = C[ie];
      return oe === void 0 && (oe = new GM(), C[ie] = oe), oe.getTargetRaySpace();
    }, this.getControllerGrip = function(ie) {
      let oe = C[ie];
      return oe === void 0 && (oe = new GM(), C[ie] = oe), oe.getGripSpace();
    }, this.getHand = function(ie) {
      let oe = C[ie];
      return oe === void 0 && (oe = new GM(), C[ie] = oe), oe.getHandSpace();
    };
    function G(ie) {
      const oe = R.indexOf(ie.inputSource);
      if (oe === -1)
        return;
      const he = C[oe];
      he !== void 0 && (he.update(ie.inputSource, ie.frame, d || o), he.dispatchEvent({ type: ie.type, data: ie.inputSource }));
    }
    function X() {
      i.removeEventListener("select", G), i.removeEventListener("selectstart", G), i.removeEventListener("selectend", G), i.removeEventListener("squeeze", G), i.removeEventListener("squeezestart", G), i.removeEventListener("squeezeend", G), i.removeEventListener("end", X), i.removeEventListener("inputsourceschange", ae);
      for (let ie = 0; ie < C.length; ie++) {
        const oe = R[ie];
        oe !== null && (R[ie] = null, C[ie].disconnect(oe));
      }
      H = null, j = null, E.reset(), e.setRenderTarget(_), v = null, g = null, p = null, i = null, w = null, ce.stop(), r.isPresenting = !1, e.setPixelRatio(D), e.setSize(P.width, P.height, !1), r.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(ie) {
      a = ie, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(ie) {
      s = ie, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return d || o;
    }, this.setReferenceSpace = function(ie) {
      d = ie;
    }, this.getBaseLayer = function() {
      return g !== null ? g : v;
    }, this.getBinding = function() {
      return p;
    }, this.getFrame = function() {
      return b;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(ie) {
      if (i = ie, i !== null) {
        if (_ = e.getRenderTarget(), i.addEventListener("select", G), i.addEventListener("selectstart", G), i.addEventListener("selectend", G), i.addEventListener("squeeze", G), i.addEventListener("squeezestart", G), i.addEventListener("squeezeend", G), i.addEventListener("end", X), i.addEventListener("inputsourceschange", ae), S.xrCompatible !== !0 && await t.makeXRCompatible(), D = e.getPixelRatio(), e.getSize(P), i.renderState.layers === void 0) {
          const oe = {
            antialias: S.antialias,
            alpha: !0,
            depth: S.depth,
            stencil: S.stencil,
            framebufferScaleFactor: a
          };
          v = new XRWebGLLayer(i, t, oe), i.updateRenderState({ baseLayer: v }), e.setPixelRatio(1), e.setSize(v.framebufferWidth, v.framebufferHeight, !1), w = new Tl(
            v.framebufferWidth,
            v.framebufferHeight,
            {
              format: Xa,
              type: Ml,
              colorSpace: e.outputColorSpace,
              stencilBuffer: S.stencil
            }
          );
        } else {
          let oe = null, he = null, le = null;
          S.depth && (le = S.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, oe = S.stencil ? Lh : Eh, he = S.stencil ? Nh : vu);
          const ve = {
            colorFormat: t.RGBA8,
            depthFormat: le,
            scaleFactor: a
          };
          p = new XRWebGLBinding(i, t), g = p.createProjectionLayer(ve), i.updateRenderState({ layers: [g] }), e.setPixelRatio(1), e.setSize(g.textureWidth, g.textureHeight, !1), w = new Tl(
            g.textureWidth,
            g.textureHeight,
            {
              format: Xa,
              type: Ml,
              depthTexture: new QO(g.textureWidth, g.textureHeight, he, void 0, void 0, void 0, void 0, void 0, void 0, oe),
              stencilBuffer: S.stencil,
              colorSpace: e.outputColorSpace,
              samples: S.antialias ? 4 : 0,
              resolveDepthBuffer: g.ignoreDepthValues === !1
            }
          );
        }
        w.isXRRenderTarget = !0, this.setFoveation(u), d = null, o = await i.requestReferenceSpace(s), ce.setContext(i), ce.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return E.getDepthTexture();
    };
    function ae(ie) {
      for (let oe = 0; oe < ie.removed.length; oe++) {
        const he = ie.removed[oe], le = R.indexOf(he);
        le >= 0 && (R[le] = null, C[le].disconnect(he));
      }
      for (let oe = 0; oe < ie.added.length; oe++) {
        const he = ie.added[oe];
        let le = R.indexOf(he);
        if (le === -1) {
          for (let Ne = 0; Ne < C.length; Ne++)
            if (Ne >= R.length) {
              R.push(he), le = Ne;
              break;
            } else if (R[Ne] === null) {
              R[Ne] = he, le = Ne;
              break;
            }
          if (le === -1) break;
        }
        const ve = C[le];
        ve && ve.connect(he);
      }
    }
    const Z = new de(), K = new de();
    function B(ie, oe, he) {
      Z.setFromMatrixPosition(oe.matrixWorld), K.setFromMatrixPosition(he.matrixWorld);
      const le = Z.distanceTo(K), ve = oe.projectionMatrix.elements, Ne = he.projectionMatrix.elements, xe = ve[14] / (ve[10] - 1), Me = ve[14] / (ve[10] + 1), $ = (ve[9] + 1) / ve[5], Te = (ve[9] - 1) / ve[5], se = (ve[8] - 1) / ve[0], Ie = (Ne[8] + 1) / Ne[0], be = xe * se, et = xe * Ie, Xe = le / (-se + Ie), $e = Xe * -se;
      oe.matrixWorld.decompose(ie.position, ie.quaternion, ie.scale), ie.translateX($e), ie.translateZ(Xe), ie.matrixWorld.compose(ie.position, ie.quaternion, ie.scale), ie.matrixWorldInverse.copy(ie.matrixWorld).invert();
      const te = xe + Xe, Y = Me + Xe, Se = be - $e, Oe = et + (le - $e), Pe = $ * Me / Y * te, Ve = Te * Me / Y * te;
      ie.projectionMatrix.makePerspective(Se, Oe, Pe, Ve, te, Y), ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert();
    }
    function Q(ie, oe) {
      oe === null ? ie.matrixWorld.copy(ie.matrix) : ie.matrixWorld.multiplyMatrices(oe.matrixWorld, ie.matrix), ie.matrixWorldInverse.copy(ie.matrixWorld).invert();
    }
    this.updateCamera = function(ie) {
      if (i === null) return;
      E.texture !== null && (ie.near = E.depthNear, ie.far = E.depthFar), N.near = U.near = I.near = ie.near, N.far = U.far = I.far = ie.far, (H !== N.near || j !== N.far) && (i.updateRenderState({
        depthNear: N.near,
        depthFar: N.far
      }), H = N.near, j = N.far, I.near = H, I.far = j, U.near = H, U.far = j, I.updateProjectionMatrix(), U.updateProjectionMatrix(), ie.updateProjectionMatrix());
      const oe = ie.parent, he = N.cameras;
      Q(N, oe);
      for (let le = 0; le < he.length; le++)
        Q(he[le], oe);
      he.length === 2 ? B(N, I, U) : N.projectionMatrix.copy(I.projectionMatrix), V(ie, N, oe);
    };
    function V(ie, oe, he) {
      he === null ? ie.matrix.copy(oe.matrixWorld) : (ie.matrix.copy(he.matrixWorld), ie.matrix.invert(), ie.matrix.multiply(oe.matrixWorld)), ie.matrix.decompose(ie.position, ie.quaternion, ie.scale), ie.updateMatrixWorld(!0), ie.projectionMatrix.copy(oe.projectionMatrix), ie.projectionMatrixInverse.copy(oe.projectionMatrixInverse), ie.isPerspectiveCamera && (ie.fov = cg * 2 * Math.atan(1 / ie.projectionMatrix.elements[5]), ie.zoom = 1);
    }
    this.getCamera = function() {
      return N;
    }, this.getFoveation = function() {
      if (!(g === null && v === null))
        return u;
    }, this.setFoveation = function(ie) {
      u = ie, g !== null && (g.fixedFoveation = ie), v !== null && v.fixedFoveation !== void 0 && (v.fixedFoveation = ie);
    }, this.hasDepthSensing = function() {
      return E.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return E.getMesh(N);
    };
    let q = null;
    function ne(ie, oe) {
      if (f = oe.getViewerPose(d || o), b = oe, f !== null) {
        const he = f.views;
        v !== null && (e.setRenderTargetFramebuffer(w, v.framebuffer), e.setRenderTarget(w));
        let le = !1;
        he.length !== N.cameras.length && (N.cameras.length = 0, le = !0);
        for (let Ne = 0; Ne < he.length; Ne++) {
          const xe = he[Ne];
          let Me = null;
          if (v !== null)
            Me = v.getViewport(xe);
          else {
            const Te = p.getViewSubImage(g, xe);
            Me = Te.viewport, Ne === 0 && (e.setRenderTargetTextures(
              w,
              Te.colorTexture,
              g.ignoreDepthValues ? void 0 : Te.depthStencilTexture
            ), e.setRenderTarget(w));
          }
          let $ = L[Ne];
          $ === void 0 && ($ = new sa(), $.layers.enable(Ne), $.viewport = new wr(), L[Ne] = $), $.matrix.fromArray(xe.transform.matrix), $.matrix.decompose($.position, $.quaternion, $.scale), $.projectionMatrix.fromArray(xe.projectionMatrix), $.projectionMatrixInverse.copy($.projectionMatrix).invert(), $.viewport.set(Me.x, Me.y, Me.width, Me.height), Ne === 0 && (N.matrix.copy($.matrix), N.matrix.decompose(N.position, N.quaternion, N.scale)), le === !0 && N.cameras.push($);
        }
        const ve = i.enabledFeatures;
        if (ve && ve.includes("depth-sensing")) {
          const Ne = p.getDepthInformation(he[0]);
          Ne && Ne.isValid && Ne.texture && E.init(e, Ne, i.renderState);
        }
      }
      for (let he = 0; he < C.length; he++) {
        const le = R[he], ve = C[he];
        le !== null && ve !== void 0 && ve.update(le, oe, d || o);
      }
      q && q(ie, oe), oe.detectedPlanes && r.dispatchEvent({ type: "planesdetected", data: oe }), b = null;
    }
    const ce = new Ik();
    ce.setAnimationLoop(ne), this.setAnimationLoop = function(ie) {
      q = ie;
    }, this.dispose = function() {
    };
  }
}
const Wf = /* @__PURE__ */ new gs(), kde = /* @__PURE__ */ new wn();
function $de(n, e) {
  function t(S, _) {
    S.matrixAutoUpdate === !0 && S.updateMatrix(), _.value.copy(S.matrix);
  }
  function r(S, _) {
    _.color.getRGB(S.fogColor.value, Ak(n)), _.isFog ? (S.fogNear.value = _.near, S.fogFar.value = _.far) : _.isFogExp2 && (S.fogDensity.value = _.density);
  }
  function i(S, _, w, C, R) {
    _.isMeshBasicMaterial || _.isMeshLambertMaterial ? a(S, _) : _.isMeshToonMaterial ? (a(S, _), p(S, _)) : _.isMeshPhongMaterial ? (a(S, _), f(S, _)) : _.isMeshStandardMaterial ? (a(S, _), g(S, _), _.isMeshPhysicalMaterial && v(S, _, R)) : _.isMeshMatcapMaterial ? (a(S, _), b(S, _)) : _.isMeshDepthMaterial ? a(S, _) : _.isMeshDistanceMaterial ? (a(S, _), E(S, _)) : _.isMeshNormalMaterial ? a(S, _) : _.isLineBasicMaterial ? (o(S, _), _.isLineDashedMaterial && s(S, _)) : _.isPointsMaterial ? u(S, _, w, C) : _.isSpriteMaterial ? d(S, _) : _.isShadowMaterial ? (S.color.value.copy(_.color), S.opacity.value = _.opacity) : _.isShaderMaterial && (_.uniformsNeedUpdate = !1);
  }
  function a(S, _) {
    S.opacity.value = _.opacity, _.color && S.diffuse.value.copy(_.color), _.emissive && S.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity), _.map && (S.map.value = _.map, t(_.map, S.mapTransform)), _.alphaMap && (S.alphaMap.value = _.alphaMap, t(_.alphaMap, S.alphaMapTransform)), _.bumpMap && (S.bumpMap.value = _.bumpMap, t(_.bumpMap, S.bumpMapTransform), S.bumpScale.value = _.bumpScale, _.side === ho && (S.bumpScale.value *= -1)), _.normalMap && (S.normalMap.value = _.normalMap, t(_.normalMap, S.normalMapTransform), S.normalScale.value.copy(_.normalScale), _.side === ho && S.normalScale.value.negate()), _.displacementMap && (S.displacementMap.value = _.displacementMap, t(_.displacementMap, S.displacementMapTransform), S.displacementScale.value = _.displacementScale, S.displacementBias.value = _.displacementBias), _.emissiveMap && (S.emissiveMap.value = _.emissiveMap, t(_.emissiveMap, S.emissiveMapTransform)), _.specularMap && (S.specularMap.value = _.specularMap, t(_.specularMap, S.specularMapTransform)), _.alphaTest > 0 && (S.alphaTest.value = _.alphaTest);
    const w = e.get(_), C = w.envMap, R = w.envMapRotation;
    C && (S.envMap.value = C, Wf.copy(R), Wf.x *= -1, Wf.y *= -1, Wf.z *= -1, C.isCubeTexture && C.isRenderTargetTexture === !1 && (Wf.y *= -1, Wf.z *= -1), S.envMapRotation.value.setFromMatrix4(kde.makeRotationFromEuler(Wf)), S.flipEnvMap.value = C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1, S.reflectivity.value = _.reflectivity, S.ior.value = _.ior, S.refractionRatio.value = _.refractionRatio), _.lightMap && (S.lightMap.value = _.lightMap, S.lightMapIntensity.value = _.lightMapIntensity, t(_.lightMap, S.lightMapTransform)), _.aoMap && (S.aoMap.value = _.aoMap, S.aoMapIntensity.value = _.aoMapIntensity, t(_.aoMap, S.aoMapTransform));
  }
  function o(S, _) {
    S.diffuse.value.copy(_.color), S.opacity.value = _.opacity, _.map && (S.map.value = _.map, t(_.map, S.mapTransform));
  }
  function s(S, _) {
    S.dashSize.value = _.dashSize, S.totalSize.value = _.dashSize + _.gapSize, S.scale.value = _.scale;
  }
  function u(S, _, w, C) {
    S.diffuse.value.copy(_.color), S.opacity.value = _.opacity, S.size.value = _.size * w, S.scale.value = C * 0.5, _.map && (S.map.value = _.map, t(_.map, S.uvTransform)), _.alphaMap && (S.alphaMap.value = _.alphaMap, t(_.alphaMap, S.alphaMapTransform)), _.alphaTest > 0 && (S.alphaTest.value = _.alphaTest);
  }
  function d(S, _) {
    S.diffuse.value.copy(_.color), S.opacity.value = _.opacity, S.rotation.value = _.rotation, _.map && (S.map.value = _.map, t(_.map, S.mapTransform)), _.alphaMap && (S.alphaMap.value = _.alphaMap, t(_.alphaMap, S.alphaMapTransform)), _.alphaTest > 0 && (S.alphaTest.value = _.alphaTest);
  }
  function f(S, _) {
    S.specular.value.copy(_.specular), S.shininess.value = Math.max(_.shininess, 1e-4);
  }
  function p(S, _) {
    _.gradientMap && (S.gradientMap.value = _.gradientMap);
  }
  function g(S, _) {
    S.metalness.value = _.metalness, _.metalnessMap && (S.metalnessMap.value = _.metalnessMap, t(_.metalnessMap, S.metalnessMapTransform)), S.roughness.value = _.roughness, _.roughnessMap && (S.roughnessMap.value = _.roughnessMap, t(_.roughnessMap, S.roughnessMapTransform)), _.envMap && (S.envMapIntensity.value = _.envMapIntensity);
  }
  function v(S, _, w) {
    S.ior.value = _.ior, _.sheen > 0 && (S.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen), S.sheenRoughness.value = _.sheenRoughness, _.sheenColorMap && (S.sheenColorMap.value = _.sheenColorMap, t(_.sheenColorMap, S.sheenColorMapTransform)), _.sheenRoughnessMap && (S.sheenRoughnessMap.value = _.sheenRoughnessMap, t(_.sheenRoughnessMap, S.sheenRoughnessMapTransform))), _.clearcoat > 0 && (S.clearcoat.value = _.clearcoat, S.clearcoatRoughness.value = _.clearcoatRoughness, _.clearcoatMap && (S.clearcoatMap.value = _.clearcoatMap, t(_.clearcoatMap, S.clearcoatMapTransform)), _.clearcoatRoughnessMap && (S.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap, t(_.clearcoatRoughnessMap, S.clearcoatRoughnessMapTransform)), _.clearcoatNormalMap && (S.clearcoatNormalMap.value = _.clearcoatNormalMap, t(_.clearcoatNormalMap, S.clearcoatNormalMapTransform), S.clearcoatNormalScale.value.copy(_.clearcoatNormalScale), _.side === ho && S.clearcoatNormalScale.value.negate())), _.dispersion > 0 && (S.dispersion.value = _.dispersion), _.iridescence > 0 && (S.iridescence.value = _.iridescence, S.iridescenceIOR.value = _.iridescenceIOR, S.iridescenceThicknessMinimum.value = _.iridescenceThicknessRange[0], S.iridescenceThicknessMaximum.value = _.iridescenceThicknessRange[1], _.iridescenceMap && (S.iridescenceMap.value = _.iridescenceMap, t(_.iridescenceMap, S.iridescenceMapTransform)), _.iridescenceThicknessMap && (S.iridescenceThicknessMap.value = _.iridescenceThicknessMap, t(_.iridescenceThicknessMap, S.iridescenceThicknessMapTransform))), _.transmission > 0 && (S.transmission.value = _.transmission, S.transmissionSamplerMap.value = w.texture, S.transmissionSamplerSize.value.set(w.width, w.height), _.transmissionMap && (S.transmissionMap.value = _.transmissionMap, t(_.transmissionMap, S.transmissionMapTransform)), S.thickness.value = _.thickness, _.thicknessMap && (S.thicknessMap.value = _.thicknessMap, t(_.thicknessMap, S.thicknessMapTransform)), S.attenuationDistance.value = _.attenuationDistance, S.attenuationColor.value.copy(_.attenuationColor)), _.anisotropy > 0 && (S.anisotropyVector.value.set(_.anisotropy * Math.cos(_.anisotropyRotation), _.anisotropy * Math.sin(_.anisotropyRotation)), _.anisotropyMap && (S.anisotropyMap.value = _.anisotropyMap, t(_.anisotropyMap, S.anisotropyMapTransform))), S.specularIntensity.value = _.specularIntensity, S.specularColor.value.copy(_.specularColor), _.specularColorMap && (S.specularColorMap.value = _.specularColorMap, t(_.specularColorMap, S.specularColorMapTransform)), _.specularIntensityMap && (S.specularIntensityMap.value = _.specularIntensityMap, t(_.specularIntensityMap, S.specularIntensityMapTransform));
  }
  function b(S, _) {
    _.matcap && (S.matcap.value = _.matcap);
  }
  function E(S, _) {
    const w = e.get(_).light;
    S.referencePosition.value.setFromMatrixPosition(w.matrixWorld), S.nearDistance.value = w.shadow.camera.near, S.farDistance.value = w.shadow.camera.far;
  }
  return {
    refreshFogUniforms: r,
    refreshMaterialUniforms: i
  };
}
function Wde(n, e, t, r) {
  let i = {}, a = {}, o = [];
  const s = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function u(w, C) {
    const R = C.program;
    r.uniformBlockBinding(w, R);
  }
  function d(w, C) {
    let R = i[w.id];
    R === void 0 && (b(w), R = f(w), i[w.id] = R, w.addEventListener("dispose", S));
    const P = C.program;
    r.updateUBOMapping(w, P);
    const D = e.render.frame;
    a[w.id] !== D && (g(w), a[w.id] = D);
  }
  function f(w) {
    const C = p();
    w.__bindingPointIndex = C;
    const R = n.createBuffer(), P = w.__size, D = w.usage;
    return n.bindBuffer(n.UNIFORM_BUFFER, R), n.bufferData(n.UNIFORM_BUFFER, P, D), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, C, R), R;
  }
  function p() {
    for (let w = 0; w < s; w++)
      if (o.indexOf(w) === -1)
        return o.push(w), w;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function g(w) {
    const C = i[w.id], R = w.uniforms, P = w.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, C);
    for (let D = 0, I = R.length; D < I; D++) {
      const U = Array.isArray(R[D]) ? R[D] : [R[D]];
      for (let L = 0, N = U.length; L < N; L++) {
        const H = U[L];
        if (v(H, D, L, P) === !0) {
          const j = H.__offset, G = Array.isArray(H.value) ? H.value : [H.value];
          let X = 0;
          for (let ae = 0; ae < G.length; ae++) {
            const Z = G[ae], K = E(Z);
            typeof Z == "number" || typeof Z == "boolean" ? (H.__data[0] = Z, n.bufferSubData(n.UNIFORM_BUFFER, j + X, H.__data)) : Z.isMatrix3 ? (H.__data[0] = Z.elements[0], H.__data[1] = Z.elements[1], H.__data[2] = Z.elements[2], H.__data[3] = 0, H.__data[4] = Z.elements[3], H.__data[5] = Z.elements[4], H.__data[6] = Z.elements[5], H.__data[7] = 0, H.__data[8] = Z.elements[6], H.__data[9] = Z.elements[7], H.__data[10] = Z.elements[8], H.__data[11] = 0) : (Z.toArray(H.__data, X), X += K.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          n.bufferSubData(n.UNIFORM_BUFFER, j, H.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function v(w, C, R, P) {
    const D = w.value, I = C + "_" + R;
    if (P[I] === void 0)
      return typeof D == "number" || typeof D == "boolean" ? P[I] = D : P[I] = D.clone(), !0;
    {
      const U = P[I];
      if (typeof D == "number" || typeof D == "boolean") {
        if (U !== D)
          return P[I] = D, !0;
      } else if (U.equals(D) === !1)
        return U.copy(D), !0;
    }
    return !1;
  }
  function b(w) {
    const C = w.uniforms;
    let R = 0;
    const P = 16;
    for (let I = 0, U = C.length; I < U; I++) {
      const L = Array.isArray(C[I]) ? C[I] : [C[I]];
      for (let N = 0, H = L.length; N < H; N++) {
        const j = L[N], G = Array.isArray(j.value) ? j.value : [j.value];
        for (let X = 0, ae = G.length; X < ae; X++) {
          const Z = G[X], K = E(Z), B = R % P;
          B !== 0 && P - B < K.boundary && (R += P - B), j.__data = new Float32Array(K.storage / Float32Array.BYTES_PER_ELEMENT), j.__offset = R, R += K.storage;
        }
      }
    }
    const D = R % P;
    return D > 0 && (R += P - D), w.__size = R, w.__cache = {}, this;
  }
  function E(w) {
    const C = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof w == "number" || typeof w == "boolean" ? (C.boundary = 4, C.storage = 4) : w.isVector2 ? (C.boundary = 8, C.storage = 8) : w.isVector3 || w.isColor ? (C.boundary = 16, C.storage = 12) : w.isVector4 ? (C.boundary = 16, C.storage = 16) : w.isMatrix3 ? (C.boundary = 48, C.storage = 48) : w.isMatrix4 ? (C.boundary = 64, C.storage = 64) : w.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w), C;
  }
  function S(w) {
    const C = w.target;
    C.removeEventListener("dispose", S);
    const R = o.indexOf(C.__bindingPointIndex);
    o.splice(R, 1), n.deleteBuffer(i[C.id]), delete i[C.id], delete a[C.id];
  }
  function _() {
    for (const w in i)
      n.deleteBuffer(i[w]);
    o = [], i = {}, a = {};
  }
  return {
    bind: u,
    update: d,
    dispose: _
  };
}
class Hk {
  constructor(e = {}) {
    const {
      canvas: t = wk(),
      context: r = null,
      depth: i = !0,
      stencil: a = !1,
      alpha: o = !1,
      antialias: s = !1,
      premultipliedAlpha: u = !0,
      preserveDrawingBuffer: d = !1,
      powerPreference: f = "default",
      failIfMajorPerformanceCaveat: p = !1
    } = e;
    this.isWebGLRenderer = !0;
    let g;
    if (r !== null) {
      if (typeof WebGLRenderingContext < "u" && r instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      g = r.getContextAttributes().alpha;
    } else
      g = o;
    const v = new Uint32Array(4), b = new Int32Array(4);
    let E = null, S = null;
    const _ = [], w = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = js, this.toneMapping = lc, this.toneMappingExposure = 1;
    const C = this;
    let R = !1, P = 0, D = 0, I = null, U = -1, L = null;
    const N = new wr(), H = new wr();
    let j = null;
    const G = new an(0);
    let X = 0, ae = t.width, Z = t.height, K = 1, B = null, Q = null;
    const V = new wr(0, 0, ae, Z), q = new wr(0, 0, ae, Z);
    let ne = !1;
    const ce = new N0();
    let ie = !1, oe = !1;
    const he = new wn(), le = new de(), ve = new wr(), Ne = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let xe = !1;
    function Me() {
      return I === null ? K : 1;
    }
    let $ = r;
    function Te(ee, _e) {
      return t.getContext(ee, _e);
    }
    try {
      const ee = {
        alpha: !0,
        depth: i,
        stencil: a,
        antialias: s,
        premultipliedAlpha: u,
        preserveDrawingBuffer: d,
        powerPreference: f,
        failIfMajorPerformanceCaveat: p
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${FE}`), t.addEventListener("webglcontextlost", Ge, !1), t.addEventListener("webglcontextrestored", We, !1), t.addEventListener("webglcontextcreationerror", He, !1), $ === null) {
        const _e = "webgl2";
        if ($ = Te(_e, ee), $ === null)
          throw Te(_e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (ee) {
      throw console.error("THREE.WebGLRenderer: " + ee.message), ee;
    }
    let se, Ie, be, et, Xe, $e, te, Y, Se, Oe, Pe, Ve, Ze, nt, ht, pt, Be, ye, Ue, Ye, tt, st, Tt, Rt;
    function ue() {
      se = new Qce($), se.init(), st = new zk($, se), Ie = new Gce($, se, e, st), be = new Ode($), et = new tue($), Xe = new yde(), $e = new Fde($, se, be, Xe, Ie, st, et), te = new qce(C), Y = new Zce(C), Se = new lse($), Tt = new Wce($, Se), Oe = new Jce($, Se, et, Tt), Pe = new rue($, Oe, Se, et), Ue = new nue($, Ie, $e), pt = new Xce(Xe), Ve = new vde(C, te, Y, se, Ie, Tt, pt), Ze = new $de(C, Xe), nt = new Sde(), ht = new Mde(se), ye = new $ce(C, te, Y, be, Pe, g, u), Be = new Ade(C, Pe, Ie), Rt = new Wde($, et, Ie, be), Ye = new jce($, se, et), tt = new eue($, se, et), et.programs = Ve.programs, C.capabilities = Ie, C.extensions = se, C.properties = Xe, C.renderLists = nt, C.shadowMap = Be, C.state = be, C.info = et;
    }
    ue();
    const De = new Vde(C, $);
    this.xr = De, this.getContext = function() {
      return $;
    }, this.getContextAttributes = function() {
      return $.getContextAttributes();
    }, this.forceContextLoss = function() {
      const ee = se.get("WEBGL_lose_context");
      ee && ee.loseContext();
    }, this.forceContextRestore = function() {
      const ee = se.get("WEBGL_lose_context");
      ee && ee.restoreContext();
    }, this.getPixelRatio = function() {
      return K;
    }, this.setPixelRatio = function(ee) {
      ee !== void 0 && (K = ee, this.setSize(ae, Z, !1));
    }, this.getSize = function(ee) {
      return ee.set(ae, Z);
    }, this.setSize = function(ee, _e, Ae = !0) {
      if (De.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      ae = ee, Z = _e, t.width = Math.floor(ee * K), t.height = Math.floor(_e * K), Ae === !0 && (t.style.width = ee + "px", t.style.height = _e + "px"), this.setViewport(0, 0, ee, _e);
    }, this.getDrawingBufferSize = function(ee) {
      return ee.set(ae * K, Z * K).floor();
    }, this.setDrawingBufferSize = function(ee, _e, Ae) {
      ae = ee, Z = _e, K = Ae, t.width = Math.floor(ee * Ae), t.height = Math.floor(_e * Ae), this.setViewport(0, 0, ee, _e);
    }, this.getCurrentViewport = function(ee) {
      return ee.copy(N);
    }, this.getViewport = function(ee) {
      return ee.copy(V);
    }, this.setViewport = function(ee, _e, Ae, Ce) {
      ee.isVector4 ? V.set(ee.x, ee.y, ee.z, ee.w) : V.set(ee, _e, Ae, Ce), be.viewport(N.copy(V).multiplyScalar(K).round());
    }, this.getScissor = function(ee) {
      return ee.copy(q);
    }, this.setScissor = function(ee, _e, Ae, Ce) {
      ee.isVector4 ? q.set(ee.x, ee.y, ee.z, ee.w) : q.set(ee, _e, Ae, Ce), be.scissor(H.copy(q).multiplyScalar(K).round());
    }, this.getScissorTest = function() {
      return ne;
    }, this.setScissorTest = function(ee) {
      be.setScissorTest(ne = ee);
    }, this.setOpaqueSort = function(ee) {
      B = ee;
    }, this.setTransparentSort = function(ee) {
      Q = ee;
    }, this.getClearColor = function(ee) {
      return ee.copy(ye.getClearColor());
    }, this.setClearColor = function() {
      ye.setClearColor.apply(ye, arguments);
    }, this.getClearAlpha = function() {
      return ye.getClearAlpha();
    }, this.setClearAlpha = function() {
      ye.setClearAlpha.apply(ye, arguments);
    }, this.clear = function(ee = !0, _e = !0, Ae = !0) {
      let Ce = 0;
      if (ee) {
        let pe = !1;
        if (I !== null) {
          const je = I.texture.format;
          pe = je === WE || je === $E || je === O0;
        }
        if (pe) {
          const je = I.texture.type, bt = je === Ml || je === vu || je === lg || je === Nh || je === HE || je === VE, It = ye.getClearColor(), Lt = ye.getClearAlpha(), Ht = It.r, on = It.g, sn = It.b;
          bt ? (v[0] = Ht, v[1] = on, v[2] = sn, v[3] = Lt, $.clearBufferuiv($.COLOR, 0, v)) : (b[0] = Ht, b[1] = on, b[2] = sn, b[3] = Lt, $.clearBufferiv($.COLOR, 0, b));
        } else
          Ce |= $.COLOR_BUFFER_BIT;
      }
      _e && (Ce |= $.DEPTH_BUFFER_BIT), Ae && (Ce |= $.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), $.clear(Ce);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Ge, !1), t.removeEventListener("webglcontextrestored", We, !1), t.removeEventListener("webglcontextcreationerror", He, !1), nt.dispose(), ht.dispose(), Xe.dispose(), te.dispose(), Y.dispose(), Pe.dispose(), Tt.dispose(), Rt.dispose(), Ve.dispose(), De.dispose(), De.removeEventListener("sessionstart", un), De.removeEventListener("sessionend", Nn), xt.stop();
    };
    function Ge(ee) {
      ee.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), R = !0;
    }
    function We() {
      console.log("THREE.WebGLRenderer: Context Restored."), R = !1;
      const ee = et.autoReset, _e = Be.enabled, Ae = Be.autoUpdate, Ce = Be.needsUpdate, pe = Be.type;
      ue(), et.autoReset = ee, Be.enabled = _e, Be.autoUpdate = Ae, Be.needsUpdate = Ce, Be.type = pe;
    }
    function He(ee) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ee.statusMessage);
    }
    function ut(ee) {
      const _e = ee.target;
      _e.removeEventListener("dispose", ut), vt(_e);
    }
    function vt(ee) {
      _t(ee), Xe.remove(ee);
    }
    function _t(ee) {
      const _e = Xe.get(ee).programs;
      _e !== void 0 && (_e.forEach(function(Ae) {
        Ve.releaseProgram(Ae);
      }), ee.isShaderMaterial && Ve.releaseShaderCache(ee));
    }
    this.renderBufferDirect = function(ee, _e, Ae, Ce, pe, je) {
      _e === null && (_e = Ne);
      const bt = pe.isMesh && pe.matrixWorld.determinant() < 0, It = yt(ee, _e, Ae, Ce, pe);
      be.setMaterial(Ce, bt);
      let Lt = Ae.index, Ht = 1;
      if (Ce.wireframe === !0) {
        if (Lt = Oe.getWireframeAttribute(Ae), Lt === void 0) return;
        Ht = 2;
      }
      const on = Ae.drawRange, sn = Ae.attributes.position;
      let Rn = on.start * Ht, Vn = (on.start + on.count) * Ht;
      je !== null && (Rn = Math.max(Rn, je.start * Ht), Vn = Math.min(Vn, (je.start + je.count) * Ht)), Lt !== null ? (Rn = Math.max(Rn, 0), Vn = Math.min(Vn, Lt.count)) : sn != null && (Rn = Math.max(Rn, 0), Vn = Math.min(Vn, sn.count));
      const Kn = Vn - Rn;
      if (Kn < 0 || Kn === 1 / 0) return;
      Tt.setup(pe, Ce, It, Ae, Lt);
      let Zn, Jt = Ye;
      if (Lt !== null && (Zn = Se.get(Lt), Jt = tt, Jt.setIndex(Zn)), pe.isMesh)
        Ce.wireframe === !0 ? (be.setLineWidth(Ce.wireframeLinewidth * Me()), Jt.setMode($.LINES)) : Jt.setMode($.TRIANGLES);
      else if (pe.isLine) {
        let Nt = Ce.linewidth;
        Nt === void 0 && (Nt = 1), be.setLineWidth(Nt * Me()), pe.isLineSegments ? Jt.setMode($.LINES) : pe.isLineLoop ? Jt.setMode($.LINE_LOOP) : Jt.setMode($.LINE_STRIP);
      } else pe.isPoints ? Jt.setMode($.POINTS) : pe.isSprite && Jt.setMode($.TRIANGLES);
      if (pe.isBatchedMesh)
        if (pe._multiDrawInstances !== null)
          Jt.renderMultiDrawInstances(pe._multiDrawStarts, pe._multiDrawCounts, pe._multiDrawCount, pe._multiDrawInstances);
        else if (se.get("WEBGL_multi_draw"))
          Jt.renderMultiDraw(pe._multiDrawStarts, pe._multiDrawCounts, pe._multiDrawCount);
        else {
          const Nt = pe._multiDrawStarts, rr = pe._multiDrawCounts, hn = pe._multiDrawCount, Tn = Lt ? Se.get(Lt).bytesPerElement : 1, Xr = Xe.get(Ce).currentProgram.getUniforms();
          for (let ur = 0; ur < hn; ur++)
            Xr.setValue($, "_gl_DrawID", ur), Jt.render(Nt[ur] / Tn, rr[ur]);
        }
      else if (pe.isInstancedMesh)
        Jt.renderInstances(Rn, Kn, pe.count);
      else if (Ae.isInstancedBufferGeometry) {
        const Nt = Ae._maxInstanceCount !== void 0 ? Ae._maxInstanceCount : 1 / 0, rr = Math.min(Ae.instanceCount, Nt);
        Jt.renderInstances(Rn, Kn, rr);
      } else
        Jt.render(Rn, Kn);
    };
    function Wt(ee, _e, Ae) {
      ee.transparent === !0 && ee.side === ic && ee.forceSinglePass === !1 ? (ee.side = ho, ee.needsUpdate = !0, cr(ee, _e, Ae), ee.side = mu, ee.needsUpdate = !0, cr(ee, _e, Ae), ee.side = ic) : cr(ee, _e, Ae);
    }
    this.compile = function(ee, _e, Ae = null) {
      Ae === null && (Ae = ee), S = ht.get(Ae), S.init(_e), w.push(S), Ae.traverseVisible(function(pe) {
        pe.isLight && pe.layers.test(_e.layers) && (S.pushLight(pe), pe.castShadow && S.pushShadow(pe));
      }), ee !== Ae && ee.traverseVisible(function(pe) {
        pe.isLight && pe.layers.test(_e.layers) && (S.pushLight(pe), pe.castShadow && S.pushShadow(pe));
      }), S.setupLights();
      const Ce = /* @__PURE__ */ new Set();
      return ee.traverse(function(pe) {
        const je = pe.material;
        if (je)
          if (Array.isArray(je))
            for (let bt = 0; bt < je.length; bt++) {
              const It = je[bt];
              Wt(It, Ae, pe), Ce.add(It);
            }
          else
            Wt(je, Ae, pe), Ce.add(je);
      }), w.pop(), S = null, Ce;
    }, this.compileAsync = function(ee, _e, Ae = null) {
      const Ce = this.compile(ee, _e, Ae);
      return new Promise((pe) => {
        function je() {
          if (Ce.forEach(function(bt) {
            Xe.get(bt).currentProgram.isReady() && Ce.delete(bt);
          }), Ce.size === 0) {
            pe(ee);
            return;
          }
          setTimeout(je, 10);
        }
        se.get("KHR_parallel_shader_compile") !== null ? je() : setTimeout(je, 10);
      });
    };
    let lt = null;
    function Ct(ee) {
      lt && lt(ee);
    }
    function un() {
      xt.stop();
    }
    function Nn() {
      xt.start();
    }
    const xt = new Ik();
    xt.setAnimationLoop(Ct), typeof self < "u" && xt.setContext(self), this.setAnimationLoop = function(ee) {
      lt = ee, De.setAnimationLoop(ee), ee === null ? xt.stop() : xt.start();
    }, De.addEventListener("sessionstart", un), De.addEventListener("sessionend", Nn), this.render = function(ee, _e) {
      if (_e !== void 0 && _e.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (R === !0) return;
      if (ee.matrixWorldAutoUpdate === !0 && ee.updateMatrixWorld(), _e.parent === null && _e.matrixWorldAutoUpdate === !0 && _e.updateMatrixWorld(), De.enabled === !0 && De.isPresenting === !0 && (De.cameraAutoUpdate === !0 && De.updateCamera(_e), _e = De.getCamera()), ee.isScene === !0 && ee.onBeforeRender(C, ee, _e, I), S = ht.get(ee, w.length), S.init(_e), w.push(S), he.multiplyMatrices(_e.projectionMatrix, _e.matrixWorldInverse), ce.setFromProjectionMatrix(he), oe = this.localClippingEnabled, ie = pt.init(this.clippingPlanes, oe), E = nt.get(ee, _.length), E.init(), _.push(E), De.enabled === !0 && De.isPresenting === !0) {
        const je = C.xr.getDepthSensingMesh();
        je !== null && Pt(je, _e, -1 / 0, C.sortObjects);
      }
      Pt(ee, _e, 0, C.sortObjects), E.finish(), C.sortObjects === !0 && E.sort(B, Q), xe = De.enabled === !1 || De.isPresenting === !1 || De.hasDepthSensing() === !1, xe && ye.addToRenderList(E, ee), this.info.render.frame++, ie === !0 && pt.beginShadows();
      const Ae = S.state.shadowsArray;
      Be.render(Ae, ee, _e), ie === !0 && pt.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const Ce = E.opaque, pe = E.transmissive;
      if (S.setupLights(), _e.isArrayCamera) {
        const je = _e.cameras;
        if (pe.length > 0)
          for (let bt = 0, It = je.length; bt < It; bt++) {
            const Lt = je[bt];
            Qt(Ce, pe, ee, Lt);
          }
        xe && ye.render(ee);
        for (let bt = 0, It = je.length; bt < It; bt++) {
          const Lt = je[bt];
          Bt(E, ee, Lt, Lt.viewport);
        }
      } else
        pe.length > 0 && Qt(Ce, pe, ee, _e), xe && ye.render(ee), Bt(E, ee, _e);
      I !== null && ($e.updateMultisampleRenderTarget(I), $e.updateRenderTargetMipmap(I)), ee.isScene === !0 && ee.onAfterRender(C, ee, _e), Tt.resetDefaultState(), U = -1, L = null, w.pop(), w.length > 0 ? (S = w[w.length - 1], ie === !0 && pt.setGlobalState(C.clippingPlanes, S.state.camera)) : S = null, _.pop(), _.length > 0 ? E = _[_.length - 1] : E = null;
    };
    function Pt(ee, _e, Ae, Ce) {
      if (ee.visible === !1) return;
      if (ee.layers.test(_e.layers)) {
        if (ee.isGroup)
          Ae = ee.renderOrder;
        else if (ee.isLOD)
          ee.autoUpdate === !0 && ee.update(_e);
        else if (ee.isLight)
          S.pushLight(ee), ee.castShadow && S.pushShadow(ee);
        else if (ee.isSprite) {
          if (!ee.frustumCulled || ce.intersectsSprite(ee)) {
            Ce && ve.setFromMatrixPosition(ee.matrixWorld).applyMatrix4(he);
            const bt = Pe.update(ee), It = ee.material;
            It.visible && E.push(ee, bt, It, Ae, ve.z, null);
          }
        } else if ((ee.isMesh || ee.isLine || ee.isPoints) && (!ee.frustumCulled || ce.intersectsObject(ee))) {
          const bt = Pe.update(ee), It = ee.material;
          if (Ce && (ee.boundingSphere !== void 0 ? (ee.boundingSphere === null && ee.computeBoundingSphere(), ve.copy(ee.boundingSphere.center)) : (bt.boundingSphere === null && bt.computeBoundingSphere(), ve.copy(bt.boundingSphere.center)), ve.applyMatrix4(ee.matrixWorld).applyMatrix4(he)), Array.isArray(It)) {
            const Lt = bt.groups;
            for (let Ht = 0, on = Lt.length; Ht < on; Ht++) {
              const sn = Lt[Ht], Rn = It[sn.materialIndex];
              Rn && Rn.visible && E.push(ee, bt, Rn, Ae, ve.z, sn);
            }
          } else It.visible && E.push(ee, bt, It, Ae, ve.z, null);
        }
      }
      const je = ee.children;
      for (let bt = 0, It = je.length; bt < It; bt++)
        Pt(je[bt], _e, Ae, Ce);
    }
    function Bt(ee, _e, Ae, Ce) {
      const pe = ee.opaque, je = ee.transmissive, bt = ee.transparent;
      S.setupLightsView(Ae), ie === !0 && pt.setGlobalState(C.clippingPlanes, Ae), Ce && be.viewport(N.copy(Ce)), pe.length > 0 && vn(pe, _e, Ae), je.length > 0 && vn(je, _e, Ae), bt.length > 0 && vn(bt, _e, Ae), be.buffers.depth.setTest(!0), be.buffers.depth.setMask(!0), be.buffers.color.setMask(!0), be.setPolygonOffset(!1);
    }
    function Qt(ee, _e, Ae, Ce) {
      if ((Ae.isScene === !0 ? Ae.overrideMaterial : null) !== null)
        return;
      S.state.transmissionRenderTarget[Ce.id] === void 0 && (S.state.transmissionRenderTarget[Ce.id] = new Tl(1, 1, {
        generateMipmaps: !0,
        type: se.has("EXT_color_buffer_half_float") || se.has("EXT_color_buffer_float") ? xg : Ml,
        minFilter: oc,
        samples: 4,
        stencilBuffer: a,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Cr.workingColorSpace
      }));
      const je = S.state.transmissionRenderTarget[Ce.id], bt = Ce.viewport || N;
      je.setSize(bt.z, bt.w);
      const It = C.getRenderTarget();
      C.setRenderTarget(je), C.getClearColor(G), X = C.getClearAlpha(), X < 1 && C.setClearColor(16777215, 0.5), xe ? ye.render(Ae) : C.clear();
      const Lt = C.toneMapping;
      C.toneMapping = lc;
      const Ht = Ce.viewport;
      if (Ce.viewport !== void 0 && (Ce.viewport = void 0), S.setupLightsView(Ce), ie === !0 && pt.setGlobalState(C.clippingPlanes, Ce), vn(ee, Ae, Ce), $e.updateMultisampleRenderTarget(je), $e.updateRenderTargetMipmap(je), se.has("WEBGL_multisampled_render_to_texture") === !1) {
        let on = !1;
        for (let sn = 0, Rn = _e.length; sn < Rn; sn++) {
          const Vn = _e[sn], Kn = Vn.object, Zn = Vn.geometry, Jt = Vn.material, Nt = Vn.group;
          if (Jt.side === ic && Kn.layers.test(Ce.layers)) {
            const rr = Jt.side;
            Jt.side = ho, Jt.needsUpdate = !0, Mn(Kn, Ae, Ce, Zn, Jt, Nt), Jt.side = rr, Jt.needsUpdate = !0, on = !0;
          }
        }
        on === !0 && ($e.updateMultisampleRenderTarget(je), $e.updateRenderTargetMipmap(je));
      }
      C.setRenderTarget(It), C.setClearColor(G, X), Ht !== void 0 && (Ce.viewport = Ht), C.toneMapping = Lt;
    }
    function vn(ee, _e, Ae) {
      const Ce = _e.isScene === !0 ? _e.overrideMaterial : null;
      for (let pe = 0, je = ee.length; pe < je; pe++) {
        const bt = ee[pe], It = bt.object, Lt = bt.geometry, Ht = Ce === null ? bt.material : Ce, on = bt.group;
        It.layers.test(Ae.layers) && Mn(It, _e, Ae, Lt, Ht, on);
      }
    }
    function Mn(ee, _e, Ae, Ce, pe, je) {
      ee.onBeforeRender(C, _e, Ae, Ce, pe, je), ee.modelViewMatrix.multiplyMatrices(Ae.matrixWorldInverse, ee.matrixWorld), ee.normalMatrix.getNormalMatrix(ee.modelViewMatrix), pe.transparent === !0 && pe.side === ic && pe.forceSinglePass === !1 ? (pe.side = ho, pe.needsUpdate = !0, C.renderBufferDirect(Ae, _e, Ce, pe, ee, je), pe.side = mu, pe.needsUpdate = !0, C.renderBufferDirect(Ae, _e, Ce, pe, ee, je), pe.side = ic) : C.renderBufferDirect(Ae, _e, Ce, pe, ee, je), ee.onAfterRender(C, _e, Ae, Ce, pe, je);
    }
    function cr(ee, _e, Ae) {
      _e.isScene !== !0 && (_e = Ne);
      const Ce = Xe.get(ee), pe = S.state.lights, je = S.state.shadowsArray, bt = pe.state.version, It = Ve.getParameters(ee, pe.state, je, _e, Ae), Lt = Ve.getProgramCacheKey(It);
      let Ht = Ce.programs;
      Ce.environment = ee.isMeshStandardMaterial ? _e.environment : null, Ce.fog = _e.fog, Ce.envMap = (ee.isMeshStandardMaterial ? Y : te).get(ee.envMap || Ce.environment), Ce.envMapRotation = Ce.environment !== null && ee.envMap === null ? _e.environmentRotation : ee.envMapRotation, Ht === void 0 && (ee.addEventListener("dispose", ut), Ht = /* @__PURE__ */ new Map(), Ce.programs = Ht);
      let on = Ht.get(Lt);
      if (on !== void 0) {
        if (Ce.currentProgram === on && Ce.lightsStateVersion === bt)
          return it(ee, It), on;
      } else
        It.uniforms = Ve.getUniforms(ee), ee.onBeforeCompile(It, C), on = Ve.acquireProgram(It, Lt), Ht.set(Lt, on), Ce.uniforms = It.uniforms;
      const sn = Ce.uniforms;
      return (!ee.isShaderMaterial && !ee.isRawShaderMaterial || ee.clipping === !0) && (sn.clippingPlanes = pt.uniform), it(ee, It), Ce.needsLights = Sn(ee), Ce.lightsStateVersion = bt, Ce.needsLights && (sn.ambientLightColor.value = pe.state.ambient, sn.lightProbe.value = pe.state.probe, sn.directionalLights.value = pe.state.directional, sn.directionalLightShadows.value = pe.state.directionalShadow, sn.spotLights.value = pe.state.spot, sn.spotLightShadows.value = pe.state.spotShadow, sn.rectAreaLights.value = pe.state.rectArea, sn.ltc_1.value = pe.state.rectAreaLTC1, sn.ltc_2.value = pe.state.rectAreaLTC2, sn.pointLights.value = pe.state.point, sn.pointLightShadows.value = pe.state.pointShadow, sn.hemisphereLights.value = pe.state.hemi, sn.directionalShadowMap.value = pe.state.directionalShadowMap, sn.directionalShadowMatrix.value = pe.state.directionalShadowMatrix, sn.spotShadowMap.value = pe.state.spotShadowMap, sn.spotLightMatrix.value = pe.state.spotLightMatrix, sn.spotLightMap.value = pe.state.spotLightMap, sn.pointShadowMap.value = pe.state.pointShadowMap, sn.pointShadowMatrix.value = pe.state.pointShadowMatrix), Ce.currentProgram = on, Ce.uniformsList = null, on;
    }
    function ge(ee) {
      if (ee.uniformsList === null) {
        const _e = ee.currentProgram.getUniforms();
        ee.uniformsList = ax.seqWithValue(_e.seq, ee.uniforms);
      }
      return ee.uniformsList;
    }
    function it(ee, _e) {
      const Ae = Xe.get(ee);
      Ae.outputColorSpace = _e.outputColorSpace, Ae.batching = _e.batching, Ae.batchingColor = _e.batchingColor, Ae.instancing = _e.instancing, Ae.instancingColor = _e.instancingColor, Ae.instancingMorph = _e.instancingMorph, Ae.skinning = _e.skinning, Ae.morphTargets = _e.morphTargets, Ae.morphNormals = _e.morphNormals, Ae.morphColors = _e.morphColors, Ae.morphTargetsCount = _e.morphTargetsCount, Ae.numClippingPlanes = _e.numClippingPlanes, Ae.numIntersection = _e.numClipIntersection, Ae.vertexAlphas = _e.vertexAlphas, Ae.vertexTangents = _e.vertexTangents, Ae.toneMapping = _e.toneMapping;
    }
    function yt(ee, _e, Ae, Ce, pe) {
      _e.isScene !== !0 && (_e = Ne), $e.resetTextureUnits();
      const je = _e.fog, bt = Ce.isMeshStandardMaterial ? _e.environment : null, It = I === null ? C.outputColorSpace : I.isXRRenderTarget === !0 ? I.texture.colorSpace : xu, Lt = (Ce.isMeshStandardMaterial ? Y : te).get(Ce.envMap || bt), Ht = Ce.vertexColors === !0 && !!Ae.attributes.color && Ae.attributes.color.itemSize === 4, on = !!Ae.attributes.tangent && (!!Ce.normalMap || Ce.anisotropy > 0), sn = !!Ae.morphAttributes.position, Rn = !!Ae.morphAttributes.normal, Vn = !!Ae.morphAttributes.color;
      let Kn = lc;
      Ce.toneMapped && (I === null || I.isXRRenderTarget === !0) && (Kn = C.toneMapping);
      const Zn = Ae.morphAttributes.position || Ae.morphAttributes.normal || Ae.morphAttributes.color, Jt = Zn !== void 0 ? Zn.length : 0, Nt = Xe.get(Ce), rr = S.state.lights;
      if (ie === !0 && (oe === !0 || ee !== L)) {
        const Pn = ee === L && Ce.id === U;
        pt.setState(Ce, ee, Pn);
      }
      let hn = !1;
      Ce.version === Nt.__version ? (Nt.needsLights && Nt.lightsStateVersion !== rr.state.version || Nt.outputColorSpace !== It || pe.isBatchedMesh && Nt.batching === !1 || !pe.isBatchedMesh && Nt.batching === !0 || pe.isBatchedMesh && Nt.batchingColor === !0 && pe.colorTexture === null || pe.isBatchedMesh && Nt.batchingColor === !1 && pe.colorTexture !== null || pe.isInstancedMesh && Nt.instancing === !1 || !pe.isInstancedMesh && Nt.instancing === !0 || pe.isSkinnedMesh && Nt.skinning === !1 || !pe.isSkinnedMesh && Nt.skinning === !0 || pe.isInstancedMesh && Nt.instancingColor === !0 && pe.instanceColor === null || pe.isInstancedMesh && Nt.instancingColor === !1 && pe.instanceColor !== null || pe.isInstancedMesh && Nt.instancingMorph === !0 && pe.morphTexture === null || pe.isInstancedMesh && Nt.instancingMorph === !1 && pe.morphTexture !== null || Nt.envMap !== Lt || Ce.fog === !0 && Nt.fog !== je || Nt.numClippingPlanes !== void 0 && (Nt.numClippingPlanes !== pt.numPlanes || Nt.numIntersection !== pt.numIntersection) || Nt.vertexAlphas !== Ht || Nt.vertexTangents !== on || Nt.morphTargets !== sn || Nt.morphNormals !== Rn || Nt.morphColors !== Vn || Nt.toneMapping !== Kn || Nt.morphTargetsCount !== Jt) && (hn = !0) : (hn = !0, Nt.__version = Ce.version);
      let Tn = Nt.currentProgram;
      hn === !0 && (Tn = cr(Ce, _e, pe));
      let Xr = !1, ur = !1, cn = !1;
      const en = Tn.getUniforms(), gr = Nt.uniforms;
      if (be.useProgram(Tn.program) && (Xr = !0, ur = !0, cn = !0), Ce.id !== U && (U = Ce.id, ur = !0), Xr || L !== ee) {
        en.setValue($, "projectionMatrix", ee.projectionMatrix), en.setValue($, "viewMatrix", ee.matrixWorldInverse);
        const Pn = en.map.cameraPosition;
        Pn !== void 0 && Pn.setValue($, le.setFromMatrixPosition(ee.matrixWorld)), Ie.logarithmicDepthBuffer && en.setValue(
          $,
          "logDepthBufFC",
          2 / (Math.log(ee.far + 1) / Math.LN2)
        ), (Ce.isMeshPhongMaterial || Ce.isMeshToonMaterial || Ce.isMeshLambertMaterial || Ce.isMeshBasicMaterial || Ce.isMeshStandardMaterial || Ce.isShaderMaterial) && en.setValue($, "isOrthographic", ee.isOrthographicCamera === !0), L !== ee && (L = ee, ur = !0, cn = !0);
      }
      if (pe.isSkinnedMesh) {
        en.setOptional($, pe, "bindMatrix"), en.setOptional($, pe, "bindMatrixInverse");
        const Pn = pe.skeleton;
        Pn && (Pn.boneTexture === null && Pn.computeBoneTexture(), en.setValue($, "boneTexture", Pn.boneTexture, $e));
      }
      pe.isBatchedMesh && (en.setOptional($, pe, "batchingTexture"), en.setValue($, "batchingTexture", pe._matricesTexture, $e), en.setOptional($, pe, "batchingIdTexture"), en.setValue($, "batchingIdTexture", pe._indirectTexture, $e), en.setOptional($, pe, "batchingColorTexture"), pe._colorsTexture !== null && en.setValue($, "batchingColorTexture", pe._colorsTexture, $e));
      const qr = Ae.morphAttributes;
      if ((qr.position !== void 0 || qr.normal !== void 0 || qr.color !== void 0) && Ue.update(pe, Ae, Tn), (ur || Nt.receiveShadow !== pe.receiveShadow) && (Nt.receiveShadow = pe.receiveShadow, en.setValue($, "receiveShadow", pe.receiveShadow)), Ce.isMeshGouraudMaterial && Ce.envMap !== null && (gr.envMap.value = Lt, gr.flipEnvMap.value = Lt.isCubeTexture && Lt.isRenderTargetTexture === !1 ? -1 : 1), Ce.isMeshStandardMaterial && Ce.envMap === null && _e.environment !== null && (gr.envMapIntensity.value = _e.environmentIntensity), ur && (en.setValue($, "toneMappingExposure", C.toneMappingExposure), Nt.needsLights && Kt(gr, cn), je && Ce.fog === !0 && Ze.refreshFogUniforms(gr, je), Ze.refreshMaterialUniforms(gr, Ce, K, Z, S.state.transmissionRenderTarget[ee.id]), ax.upload($, ge(Nt), gr, $e)), Ce.isShaderMaterial && Ce.uniformsNeedUpdate === !0 && (ax.upload($, ge(Nt), gr, $e), Ce.uniformsNeedUpdate = !1), Ce.isSpriteMaterial && en.setValue($, "center", pe.center), en.setValue($, "modelViewMatrix", pe.modelViewMatrix), en.setValue($, "normalMatrix", pe.normalMatrix), en.setValue($, "modelMatrix", pe.matrixWorld), Ce.isShaderMaterial || Ce.isRawShaderMaterial) {
        const Pn = Ce.uniformsGroups;
        for (let Fr = 0, Sr = Pn.length; Fr < Sr; Fr++) {
          const Oi = Pn[Fr];
          Rt.update(Oi, Tn), Rt.bind(Oi, Tn);
        }
      }
      return Tn;
    }
    function Kt(ee, _e) {
      ee.ambientLightColor.needsUpdate = _e, ee.lightProbe.needsUpdate = _e, ee.directionalLights.needsUpdate = _e, ee.directionalLightShadows.needsUpdate = _e, ee.pointLights.needsUpdate = _e, ee.pointLightShadows.needsUpdate = _e, ee.spotLights.needsUpdate = _e, ee.spotLightShadows.needsUpdate = _e, ee.rectAreaLights.needsUpdate = _e, ee.hemisphereLights.needsUpdate = _e;
    }
    function Sn(ee) {
      return ee.isMeshLambertMaterial || ee.isMeshToonMaterial || ee.isMeshPhongMaterial || ee.isMeshStandardMaterial || ee.isShadowMaterial || ee.isShaderMaterial && ee.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return P;
    }, this.getActiveMipmapLevel = function() {
      return D;
    }, this.getRenderTarget = function() {
      return I;
    }, this.setRenderTargetTextures = function(ee, _e, Ae) {
      Xe.get(ee.texture).__webglTexture = _e, Xe.get(ee.depthTexture).__webglTexture = Ae;
      const Ce = Xe.get(ee);
      Ce.__hasExternalTextures = !0, Ce.__autoAllocateDepthBuffer = Ae === void 0, Ce.__autoAllocateDepthBuffer || se.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Ce.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(ee, _e) {
      const Ae = Xe.get(ee);
      Ae.__webglFramebuffer = _e, Ae.__useDefaultFramebuffer = _e === void 0;
    }, this.setRenderTarget = function(ee, _e = 0, Ae = 0) {
      I = ee, P = _e, D = Ae;
      let Ce = !0, pe = null, je = !1, bt = !1;
      if (ee) {
        const Lt = Xe.get(ee);
        Lt.__useDefaultFramebuffer !== void 0 ? (be.bindFramebuffer($.FRAMEBUFFER, null), Ce = !1) : Lt.__webglFramebuffer === void 0 ? $e.setupRenderTarget(ee) : Lt.__hasExternalTextures && $e.rebindTextures(ee, Xe.get(ee.texture).__webglTexture, Xe.get(ee.depthTexture).__webglTexture);
        const Ht = ee.texture;
        (Ht.isData3DTexture || Ht.isDataArrayTexture || Ht.isCompressedArrayTexture) && (bt = !0);
        const on = Xe.get(ee).__webglFramebuffer;
        ee.isWebGLCubeRenderTarget ? (Array.isArray(on[_e]) ? pe = on[_e][Ae] : pe = on[_e], je = !0) : ee.samples > 0 && $e.useMultisampledRTT(ee) === !1 ? pe = Xe.get(ee).__webglMultisampledFramebuffer : Array.isArray(on) ? pe = on[Ae] : pe = on, N.copy(ee.viewport), H.copy(ee.scissor), j = ee.scissorTest;
      } else
        N.copy(V).multiplyScalar(K).floor(), H.copy(q).multiplyScalar(K).floor(), j = ne;
      if (be.bindFramebuffer($.FRAMEBUFFER, pe) && Ce && be.drawBuffers(ee, pe), be.viewport(N), be.scissor(H), be.setScissorTest(j), je) {
        const Lt = Xe.get(ee.texture);
        $.framebufferTexture2D($.FRAMEBUFFER, $.COLOR_ATTACHMENT0, $.TEXTURE_CUBE_MAP_POSITIVE_X + _e, Lt.__webglTexture, Ae);
      } else if (bt) {
        const Lt = Xe.get(ee.texture), Ht = _e || 0;
        $.framebufferTextureLayer($.FRAMEBUFFER, $.COLOR_ATTACHMENT0, Lt.__webglTexture, Ae || 0, Ht);
      }
      U = -1;
    }, this.readRenderTargetPixels = function(ee, _e, Ae, Ce, pe, je, bt) {
      if (!(ee && ee.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let It = Xe.get(ee).__webglFramebuffer;
      if (ee.isWebGLCubeRenderTarget && bt !== void 0 && (It = It[bt]), It) {
        be.bindFramebuffer($.FRAMEBUFFER, It);
        try {
          const Lt = ee.texture, Ht = Lt.format, on = Lt.type;
          if (!Ie.textureFormatReadable(Ht)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!Ie.textureTypeReadable(on)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          _e >= 0 && _e <= ee.width - Ce && Ae >= 0 && Ae <= ee.height - pe && $.readPixels(_e, Ae, Ce, pe, st.convert(Ht), st.convert(on), je);
        } finally {
          const Lt = I !== null ? Xe.get(I).__webglFramebuffer : null;
          be.bindFramebuffer($.FRAMEBUFFER, Lt);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(ee, _e, Ae, Ce, pe, je, bt) {
      if (!(ee && ee.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let It = Xe.get(ee).__webglFramebuffer;
      if (ee.isWebGLCubeRenderTarget && bt !== void 0 && (It = It[bt]), It) {
        be.bindFramebuffer($.FRAMEBUFFER, It);
        try {
          const Lt = ee.texture, Ht = Lt.format, on = Lt.type;
          if (!Ie.textureFormatReadable(Ht))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          if (!Ie.textureTypeReadable(on))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          if (_e >= 0 && _e <= ee.width - Ce && Ae >= 0 && Ae <= ee.height - pe) {
            const sn = $.createBuffer();
            $.bindBuffer($.PIXEL_PACK_BUFFER, sn), $.bufferData($.PIXEL_PACK_BUFFER, je.byteLength, $.STREAM_READ), $.readPixels(_e, Ae, Ce, pe, st.convert(Ht), st.convert(on), 0), $.flush();
            const Rn = $.fenceSync($.SYNC_GPU_COMMANDS_COMPLETE, 0);
            await Ioe($, Rn, 4);
            try {
              $.bindBuffer($.PIXEL_PACK_BUFFER, sn), $.getBufferSubData($.PIXEL_PACK_BUFFER, 0, je);
            } finally {
              $.deleteBuffer(sn), $.deleteSync(Rn);
            }
            return je;
          }
        } finally {
          const Lt = I !== null ? Xe.get(I).__webglFramebuffer : null;
          be.bindFramebuffer($.FRAMEBUFFER, Lt);
        }
      }
    }, this.copyFramebufferToTexture = function(ee, _e = null, Ae = 0) {
      ee.isTexture !== !0 && (console.warn("WebGLRenderer: copyFramebufferToTexture function signature has changed."), _e = arguments[0] || null, ee = arguments[1]);
      const Ce = Math.pow(2, -Ae), pe = Math.floor(ee.image.width * Ce), je = Math.floor(ee.image.height * Ce), bt = _e !== null ? _e.x : 0, It = _e !== null ? _e.y : 0;
      $e.setTexture2D(ee, 0), $.copyTexSubImage2D($.TEXTURE_2D, Ae, 0, 0, bt, It, pe, je), be.unbindTexture();
    }, this.copyTextureToTexture = function(ee, _e, Ae = null, Ce = null, pe = 0) {
      ee.isTexture !== !0 && (console.warn("WebGLRenderer: copyTextureToTexture function signature has changed."), Ce = arguments[0] || null, ee = arguments[1], _e = arguments[2], pe = arguments[3] || 0, Ae = null);
      let je, bt, It, Lt, Ht, on;
      Ae !== null ? (je = Ae.max.x - Ae.min.x, bt = Ae.max.y - Ae.min.y, It = Ae.min.x, Lt = Ae.min.y) : (je = ee.image.width, bt = ee.image.height, It = 0, Lt = 0), Ce !== null ? (Ht = Ce.x, on = Ce.y) : (Ht = 0, on = 0);
      const sn = st.convert(_e.format), Rn = st.convert(_e.type);
      $e.setTexture2D(_e, 0), $.pixelStorei($.UNPACK_FLIP_Y_WEBGL, _e.flipY), $.pixelStorei($.UNPACK_PREMULTIPLY_ALPHA_WEBGL, _e.premultiplyAlpha), $.pixelStorei($.UNPACK_ALIGNMENT, _e.unpackAlignment);
      const Vn = $.getParameter($.UNPACK_ROW_LENGTH), Kn = $.getParameter($.UNPACK_IMAGE_HEIGHT), Zn = $.getParameter($.UNPACK_SKIP_PIXELS), Jt = $.getParameter($.UNPACK_SKIP_ROWS), Nt = $.getParameter($.UNPACK_SKIP_IMAGES), rr = ee.isCompressedTexture ? ee.mipmaps[pe] : ee.image;
      $.pixelStorei($.UNPACK_ROW_LENGTH, rr.width), $.pixelStorei($.UNPACK_IMAGE_HEIGHT, rr.height), $.pixelStorei($.UNPACK_SKIP_PIXELS, It), $.pixelStorei($.UNPACK_SKIP_ROWS, Lt), ee.isDataTexture ? $.texSubImage2D($.TEXTURE_2D, pe, Ht, on, je, bt, sn, Rn, rr.data) : ee.isCompressedTexture ? $.compressedTexSubImage2D($.TEXTURE_2D, pe, Ht, on, rr.width, rr.height, sn, rr.data) : $.texSubImage2D($.TEXTURE_2D, pe, Ht, on, je, bt, sn, Rn, rr), $.pixelStorei($.UNPACK_ROW_LENGTH, Vn), $.pixelStorei($.UNPACK_IMAGE_HEIGHT, Kn), $.pixelStorei($.UNPACK_SKIP_PIXELS, Zn), $.pixelStorei($.UNPACK_SKIP_ROWS, Jt), $.pixelStorei($.UNPACK_SKIP_IMAGES, Nt), pe === 0 && _e.generateMipmaps && $.generateMipmap($.TEXTURE_2D), be.unbindTexture();
    }, this.copyTextureToTexture3D = function(ee, _e, Ae = null, Ce = null, pe = 0) {
      ee.isTexture !== !0 && (console.warn("WebGLRenderer: copyTextureToTexture3D function signature has changed."), Ae = arguments[0] || null, Ce = arguments[1] || null, ee = arguments[2], _e = arguments[3], pe = arguments[4] || 0);
      let je, bt, It, Lt, Ht, on, sn, Rn, Vn;
      const Kn = ee.isCompressedTexture ? ee.mipmaps[pe] : ee.image;
      Ae !== null ? (je = Ae.max.x - Ae.min.x, bt = Ae.max.y - Ae.min.y, It = Ae.max.z - Ae.min.z, Lt = Ae.min.x, Ht = Ae.min.y, on = Ae.min.z) : (je = Kn.width, bt = Kn.height, It = Kn.depth, Lt = 0, Ht = 0, on = 0), Ce !== null ? (sn = Ce.x, Rn = Ce.y, Vn = Ce.z) : (sn = 0, Rn = 0, Vn = 0);
      const Zn = st.convert(_e.format), Jt = st.convert(_e.type);
      let Nt;
      if (_e.isData3DTexture)
        $e.setTexture3D(_e, 0), Nt = $.TEXTURE_3D;
      else if (_e.isDataArrayTexture || _e.isCompressedArrayTexture)
        $e.setTexture2DArray(_e, 0), Nt = $.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      $.pixelStorei($.UNPACK_FLIP_Y_WEBGL, _e.flipY), $.pixelStorei($.UNPACK_PREMULTIPLY_ALPHA_WEBGL, _e.premultiplyAlpha), $.pixelStorei($.UNPACK_ALIGNMENT, _e.unpackAlignment);
      const rr = $.getParameter($.UNPACK_ROW_LENGTH), hn = $.getParameter($.UNPACK_IMAGE_HEIGHT), Tn = $.getParameter($.UNPACK_SKIP_PIXELS), Xr = $.getParameter($.UNPACK_SKIP_ROWS), ur = $.getParameter($.UNPACK_SKIP_IMAGES);
      $.pixelStorei($.UNPACK_ROW_LENGTH, Kn.width), $.pixelStorei($.UNPACK_IMAGE_HEIGHT, Kn.height), $.pixelStorei($.UNPACK_SKIP_PIXELS, Lt), $.pixelStorei($.UNPACK_SKIP_ROWS, Ht), $.pixelStorei($.UNPACK_SKIP_IMAGES, on), ee.isDataTexture || ee.isData3DTexture ? $.texSubImage3D(Nt, pe, sn, Rn, Vn, je, bt, It, Zn, Jt, Kn.data) : _e.isCompressedArrayTexture ? $.compressedTexSubImage3D(Nt, pe, sn, Rn, Vn, je, bt, It, Zn, Kn.data) : $.texSubImage3D(Nt, pe, sn, Rn, Vn, je, bt, It, Zn, Jt, Kn), $.pixelStorei($.UNPACK_ROW_LENGTH, rr), $.pixelStorei($.UNPACK_IMAGE_HEIGHT, hn), $.pixelStorei($.UNPACK_SKIP_PIXELS, Tn), $.pixelStorei($.UNPACK_SKIP_ROWS, Xr), $.pixelStorei($.UNPACK_SKIP_IMAGES, ur), pe === 0 && _e.generateMipmaps && $.generateMipmap(Nt), be.unbindTexture();
    }, this.initRenderTarget = function(ee) {
      Xe.get(ee).__webglFramebuffer === void 0 && $e.setupRenderTarget(ee);
    }, this.initTexture = function(ee) {
      ee.isCubeTexture ? $e.setTextureCube(ee, 0) : ee.isData3DTexture ? $e.setTexture3D(ee, 0) : ee.isDataArrayTexture || ee.isCompressedArrayTexture ? $e.setTexture2DArray(ee, 0) : $e.setTexture2D(ee, 0), be.unbindTexture();
    }, this.resetState = function() {
      P = 0, D = 0, I = null, be.reset(), Tt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return sc;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === GE ? "display-p3" : "srgb", t.unpackColorSpace = Cr.workingColorSpace === P0 ? "display-p3" : "srgb";
  }
}
class YE {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new an(e), this.density = t;
  }
  clone() {
    return new YE(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class KE {
  constructor(e, t = 1, r = 1e3) {
    this.isFog = !0, this.name = "", this.color = new an(e), this.near = t, this.far = r;
  }
  clone() {
    return new KE(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
let eE = class extends pr {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new gs(), this.environmentIntensity = 1, this.environmentRotation = new gs(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
};
class ZE {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = s0, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = ps();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return XO("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, r) {
    e *= this.stride, r *= t.stride;
    for (let i = 0, a = this.stride; i < a; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ps()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ps()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const so = /* @__PURE__ */ new de();
class Fh {
  constructor(e, t, r, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      so.fromBufferAttribute(this, t), so.applyMatrix4(e), this.setXYZ(t, so.x, so.y, so.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      so.fromBufferAttribute(this, t), so.applyNormalMatrix(e), this.setXYZ(t, so.x, so.y, so.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      so.fromBufferAttribute(this, t), so.transformDirection(e), this.setXYZ(t, so.x, so.y, so.z);
    return this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (r = uo(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return this.normalized && (r = Bn(r, this.array)), this.data.array[e * this.data.stride + this.offset + t] = r, this;
  }
  setX(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = Bn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = uo(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = uo(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = uo(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = uo(t, this.array)), t;
  }
  setXY(e, t, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array), i = Bn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, r, i, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Bn(t, this.array), r = Bn(r, this.array), i = Bn(i, this.array), a = Bn(a, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = a, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          t.push(this.data.array[i + a]);
      }
      return new jr(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Fh(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let a = 0; a < this.itemSize; a++)
          t.push(this.data.array[i + a]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class tP extends Da {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new an(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let Cm;
const Jv = /* @__PURE__ */ new de(), wm = /* @__PURE__ */ new de(), Mm = /* @__PURE__ */ new de(), Tm = /* @__PURE__ */ new St(), ey = /* @__PURE__ */ new St(), Vk = /* @__PURE__ */ new wn(), f_ = /* @__PURE__ */ new de(), ty = /* @__PURE__ */ new de(), h_ = /* @__PURE__ */ new de(), iF = /* @__PURE__ */ new St(), XM = /* @__PURE__ */ new St(), aF = /* @__PURE__ */ new St();
class kk extends pr {
  constructor(e = new tP()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", Cm === void 0) {
      Cm = new Xn();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), r = new ZE(t, 5);
      Cm.setIndex([0, 1, 2, 0, 2, 3]), Cm.setAttribute("position", new Fh(r, 3, 0, !1)), Cm.setAttribute("uv", new Fh(r, 2, 3, !1));
    }
    this.geometry = Cm, this.material = e, this.center = new St(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), wm.setFromMatrixScale(this.matrixWorld), Vk.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Mm.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && wm.multiplyScalar(-Mm.z);
    const r = this.material.rotation;
    let i, a;
    r !== 0 && (a = Math.cos(r), i = Math.sin(r));
    const o = this.center;
    p_(f_.set(-0.5, -0.5, 0), Mm, o, wm, i, a), p_(ty.set(0.5, -0.5, 0), Mm, o, wm, i, a), p_(h_.set(0.5, 0.5, 0), Mm, o, wm, i, a), iF.set(0, 0), XM.set(1, 0), aF.set(1, 1);
    let s = e.ray.intersectTriangle(f_, ty, h_, !1, Jv);
    if (s === null && (p_(ty.set(-0.5, 0.5, 0), Mm, o, wm, i, a), XM.set(0, 1), s = e.ray.intersectTriangle(f_, h_, ty, !1, Jv), s === null))
      return;
    const u = e.ray.origin.distanceTo(Jv);
    u < e.near || u > e.far || t.push({
      distance: u,
      point: Jv.clone(),
      uv: ds.getInterpolation(Jv, f_, ty, h_, iF, XM, aF, new St()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function p_(n, e, t, r, i, a) {
  Tm.subVectors(n, t).addScalar(0.5).multiply(r), i !== void 0 ? (ey.x = a * Tm.x - i * Tm.y, ey.y = i * Tm.x + a * Tm.y) : ey.copy(Tm), n.copy(e), n.x += ey.x, n.y += ey.y, n.applyMatrix4(Vk);
}
const m_ = /* @__PURE__ */ new de(), oF = /* @__PURE__ */ new de();
class $k extends pr {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const a = t[r];
      this.addLevel(a.object.clone(), a.distance, a.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let a;
    for (a = 0; a < i.length && !(t < i[a].distance); a++)
      ;
    return i.splice(a, 0, { distance: t, hysteresis: r, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i; r++) {
        let a = t[r].distance;
        if (t[r].object.visible && (a -= a * t[r].hysteresis), e < a)
          break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      m_.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(m_);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      m_.setFromMatrixPosition(e.matrixWorld), oF.setFromMatrixPosition(this.matrixWorld);
      const r = m_.distanceTo(oF) / e.zoom;
      t[0].object.visible = !0;
      let i, a;
      for (i = 1, a = t.length; i < a; i++) {
        let o = t[i].distance;
        if (t[i].object.visible && (o -= o * t[i].hysteresis), r >= o)
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < a; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const r = this.levels;
    for (let i = 0, a = r.length; i < a; i++) {
      const o = r[i];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis
      });
    }
    return t;
  }
}
const sF = /* @__PURE__ */ new de(), lF = /* @__PURE__ */ new wr(), cF = /* @__PURE__ */ new wr(), jde = /* @__PURE__ */ new de(), uF = /* @__PURE__ */ new wn(), g_ = /* @__PURE__ */ new de(), qM = /* @__PURE__ */ new Pa(), dF = /* @__PURE__ */ new wn(), YM = /* @__PURE__ */ new Eg();
class Wk extends Zi {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = rA, this.bindMatrix = new wn(), this.bindMatrixInverse = new wn(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new qa()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, g_), this.boundingBox.expandByPoint(g_);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Pa()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, g_), this.boundingSphere.expandByPoint(g_);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const r = this.material, i = this.matrixWorld;
    r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), qM.copy(this.boundingSphere), qM.applyMatrix4(i), e.ray.intersectsSphere(qM) !== !1 && (dF.copy(i).invert(), YM.copy(e.ray).applyMatrix4(dF), !(this.boundingBox !== null && YM.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, YM)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new wr(), t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const a = 1 / e.manhattanLength();
      a !== 1 / 0 ? e.multiplyScalar(a) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === rA ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === ck ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton, i = this.geometry;
    lF.fromBufferAttribute(i.attributes.skinIndex, e), cF.fromBufferAttribute(i.attributes.skinWeight, e), sF.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let a = 0; a < 4; a++) {
      const o = cF.getComponent(a);
      if (o !== 0) {
        const s = lF.getComponent(a);
        uF.multiplyMatrices(r.bones[s].matrixWorld, r.boneInverses[s]), t.addScaledVector(jde.copy(sF).applyMatrix4(uF), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class nP extends pr {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class cc extends Ei {
  constructor(e = null, t = 1, r = 1, i, a, o, s, u, d = ba, f = ba, p, g) {
    super(null, o, s, u, d, f, i, a, p, g), this.isDataTexture = !0, this.image = { data: e, width: t, height: r }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const fF = /* @__PURE__ */ new wn(), Gde = /* @__PURE__ */ new wn();
class QE {
  constructor(e = [], t = []) {
    this.uuid = ps(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new wn());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new wn();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, r = this.boneMatrices, i = this.boneTexture;
    for (let a = 0, o = e.length; a < o; a++) {
      const s = e[a] ? e[a].matrixWorld : Gde;
      fF.multiplyMatrices(s, t[a]), fF.toArray(r, a * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new QE(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new cc(t, e, e, Xa, Ho);
    return r.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = r, this;
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const a = e.bones[r];
      let o = t[a];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", a), o = new nP()), this.bones.push(o), this.boneInverses.push(new wn().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, r = this.boneInverses;
    for (let i = 0, a = t.length; i < a; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const s = r[i];
      e.boneInverses.push(s.toArray());
    }
    return e;
  }
}
class dg extends jr {
  constructor(e, t, r, i = 1) {
    super(e, t, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const Rm = /* @__PURE__ */ new wn(), hF = /* @__PURE__ */ new wn(), v_ = [], pF = /* @__PURE__ */ new qa(), Xde = /* @__PURE__ */ new wn(), ny = /* @__PURE__ */ new Zi(), ry = /* @__PURE__ */ new Pa();
class jk extends Zi {
  constructor(e, t, r) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new dg(new Float32Array(r * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = r, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < r; i++)
      this.setMatrixAt(i, Xde);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new qa()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Rm), pF.copy(e.boundingBox).applyMatrix4(Rm), this.boundingBox.union(pF);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Pa()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Rm), ry.copy(e.boundingSphere).applyMatrix4(Rm), this.boundingSphere.union(ry);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const r = t.morphTargetInfluences, i = this.morphTexture.source.data.data, a = r.length + 1, o = e * a + 1;
    for (let s = 0; s < r.length; s++)
      r[s] = i[o + s];
  }
  raycast(e, t) {
    const r = this.matrixWorld, i = this.count;
    if (ny.geometry = this.geometry, ny.material = this.material, ny.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), ry.copy(this.boundingSphere), ry.applyMatrix4(r), e.ray.intersectsSphere(ry) !== !1))
      for (let a = 0; a < i; a++) {
        this.getMatrixAt(a, Rm), hF.multiplyMatrices(r, Rm), ny.matrixWorld = hF, ny.raycast(e, v_);
        for (let o = 0, s = v_.length; o < s; o++) {
          const u = v_[o];
          u.instanceId = a, u.object = this, t.push(u);
        }
        v_.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new dg(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const r = t.morphTargetInfluences, i = r.length + 1;
    this.morphTexture === null && (this.morphTexture = new cc(new Float32Array(i * this.count), i, this.count, kE, Ho));
    const a = this.morphTexture.source.data.data;
    let o = 0;
    for (let d = 0; d < r.length; d++)
      o += r[d];
    const s = this.geometry.morphTargetsRelative ? 1 : 1 - o, u = i * e;
    a[u] = s, a.set(r, u + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
function qde(n, e) {
  return n.z - e.z;
}
function Yde(n, e) {
  return e.z - n.z;
}
class Kde {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t, r) {
    const i = this.pool, a = this.list;
    this.index >= i.length && i.push({
      start: -1,
      count: -1,
      z: -1,
      index: -1
    });
    const o = i[this.index];
    a.push(o), this.index++, o.start = e.start, o.count = e.count, o.z = t, o.index = r;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const Rd = /* @__PURE__ */ new wn(), KM = /* @__PURE__ */ new wn(), Zde = /* @__PURE__ */ new wn(), Qde = /* @__PURE__ */ new an(1, 1, 1), mF = /* @__PURE__ */ new wn(), ZM = /* @__PURE__ */ new N0(), y_ = /* @__PURE__ */ new qa(), jf = /* @__PURE__ */ new Pa(), iy = /* @__PURE__ */ new de(), gF = /* @__PURE__ */ new de(), Jde = /* @__PURE__ */ new de(), QM = /* @__PURE__ */ new Kde(), Ga = /* @__PURE__ */ new Zi(), b_ = [];
function efe(n, e, t = 0) {
  const r = e.itemSize;
  if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
    const i = n.count;
    for (let a = 0; a < i; a++)
      for (let o = 0; o < r; o++)
        e.setComponent(a + t, o, n.getComponent(a, o));
  } else
    e.array.set(n.array, t * r);
  e.needsUpdate = !0;
}
class Gk extends Zi {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  constructor(e, t, r = t * 2, i) {
    super(new Xn(), i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawInfo = [], this._drawRanges = [], this._reservedRanges = [], this._bounds = [], this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = r, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), r = new cc(t, e, e, Xa, Ho);
    this._matricesTexture = r;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e), r = new cc(t, e, e, O0, vu);
    this._indirectTexture = r;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxIndexCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1), r = new cc(t, e, e, Xa, Ho);
    r.colorSpace = Cr.workingColorSpace, this._colorsTexture = r;
  }
  _initializeGeometry(e) {
    const t = this.geometry, r = this._maxVertexCount, i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const a in e.attributes) {
        const o = e.getAttribute(a), { array: s, itemSize: u, normalized: d } = o, f = new s.constructor(r * u), p = new jr(f, u, d);
        t.setAttribute(a, p);
      }
      if (e.getIndex() !== null) {
        const a = r > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new jr(a, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const r in t.attributes) {
      if (!e.hasAttribute(r))
        throw new Error(`BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`);
      const i = e.getAttribute(r), a = t.getAttribute(r);
      if (i.itemSize !== a.itemSize || i.normalized !== a.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new qa());
    const e = this._geometryCount, t = this.boundingBox, r = this._drawInfo;
    t.makeEmpty();
    for (let i = 0; i < e; i++) {
      if (r[i].active === !1) continue;
      const a = r[i].geometryIndex;
      this.getMatrixAt(i, Rd), this.getBoundingBoxAt(a, y_).applyMatrix4(Rd), t.union(y_);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Pa());
    const e = this.boundingSphere, t = this._drawInfo;
    e.makeEmpty();
    for (let r = 0, i = t.length; r < i; r++) {
      if (t[r].active === !1) continue;
      const a = t[r].geometryIndex;
      this.getMatrixAt(r, Rd), this.getBoundingSphereAt(a, jf).applyMatrix4(Rd), e.union(jf);
    }
  }
  addInstance(e) {
    if (this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    this._drawInfo.push({
      visible: !0,
      active: !0,
      geometryIndex: e
    });
    const t = this._drawInfo.length - 1, r = this._matricesTexture, i = r.image.data;
    Zde.toArray(i, t * 16), r.needsUpdate = !0;
    const a = this._colorsTexture;
    return a && (Qde.toArray(a.image.data, t * 4), a.needsUpdate = !0), t;
  }
  addGeometry(e, t = -1, r = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._drawInfo.length >= this._maxInstanceCount)
      throw new Error("BatchedMesh: Maximum item count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1
    };
    let a = null;
    const o = this._reservedRanges, s = this._drawRanges, u = this._bounds;
    this._geometryCount !== 0 && (a = o[o.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, a === null ? i.vertexStart = 0 : i.vertexStart = a.vertexStart + a.vertexCount;
    const d = e.getIndex(), f = d !== null;
    if (f && (r === -1 ? i.indexCount = d.count : i.indexCount = r, a === null ? i.indexStart = 0 : i.indexStart = a.indexStart + a.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const p = this._geometryCount;
    return this._geometryCount++, o.push(i), s.push({
      start: f ? i.indexStart : i.vertexStart,
      count: -1
    }), u.push({
      boxInitialized: !1,
      box: new qa(),
      sphereInitialized: !1,
      sphere: new Pa()
    }), this.setGeometryAt(p, e), p;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const r = this.geometry, i = r.getIndex() !== null, a = r.getIndex(), o = t.getIndex(), s = this._reservedRanges[e];
    if (i && o.count > s.indexCount || t.attributes.position.count > s.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const u = s.vertexStart, d = s.vertexCount;
    for (const v in r.attributes) {
      const b = t.getAttribute(v), E = r.getAttribute(v);
      efe(b, E, u);
      const S = b.itemSize;
      for (let _ = b.count, w = d; _ < w; _++) {
        const C = u + _;
        for (let R = 0; R < S; R++)
          E.setComponent(C, R, 0);
      }
      E.needsUpdate = !0, E.addUpdateRange(u * S, d * S);
    }
    if (i) {
      const v = s.indexStart;
      for (let b = 0; b < o.count; b++)
        a.setX(v + b, u + o.getX(b));
      for (let b = o.count, E = s.indexCount; b < E; b++)
        a.setX(v + b, u);
      a.needsUpdate = !0, a.addUpdateRange(v, s.indexCount);
    }
    const f = this._bounds[e];
    t.boundingBox !== null ? (f.box.copy(t.boundingBox), f.boxInitialized = !0) : f.boxInitialized = !1, t.boundingSphere !== null ? (f.sphere.copy(t.boundingSphere), f.sphereInitialized = !0) : f.sphereInitialized = !1;
    const p = this._drawRanges[e], g = t.getAttribute("position");
    return p.count = i ? o.count : g.count, this._visibilityChanged = !0, e;
  }
  /*
  	deleteGeometry( geometryId ) {
  
  		// TODO: delete geometry and associated instances
  
  	}
  	*/
  /*
  	deleteInstance( instanceId ) {
  
  		// Note: User needs to call optimize() afterward to pack the data.
  
  		const drawInfo = this._drawInfo;
  		if ( instanceId >= drawInfo.length || drawInfo[ instanceId ].active === false ) {
  
  			return this;
  
  		}
  
  		drawInfo[ instanceId ].active = false;
  		this._visibilityChanged = true;
  
  		return this;
  
  	}
  	*/
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const r = this._bounds[e], i = r.box, a = this.geometry;
    if (r.boxInitialized === !1) {
      i.makeEmpty();
      const o = a.index, s = a.attributes.position, u = this._drawRanges[e];
      for (let d = u.start, f = u.start + u.count; d < f; d++) {
        let p = d;
        o && (p = o.getX(p)), i.expandByPoint(iy.fromBufferAttribute(s, p));
      }
      r.boxInitialized = !0;
    }
    return t.copy(i), t;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const r = this._bounds[e], i = r.sphere, a = this.geometry;
    if (r.sphereInitialized === !1) {
      i.makeEmpty(), this.getBoundingBoxAt(e, y_), y_.getCenter(i.center);
      const o = a.index, s = a.attributes.position, u = this._drawRanges[e];
      let d = 0;
      for (let f = u.start, p = u.start + u.count; f < p; f++) {
        let g = f;
        o && (g = o.getX(g)), iy.fromBufferAttribute(s, g), d = Math.max(d, i.center.distanceToSquared(iy));
      }
      i.radius = Math.sqrt(d), r.sphereInitialized = !0;
    }
    return t.copy(i), t;
  }
  setMatrixAt(e, t) {
    const r = this._drawInfo, i = this._matricesTexture, a = this._matricesTexture.image.data;
    return e >= r.length || r[e].active === !1 ? this : (t.toArray(a, e * 16), i.needsUpdate = !0, this);
  }
  getMatrixAt(e, t) {
    const r = this._drawInfo, i = this._matricesTexture.image.data;
    return e >= r.length || r[e].active === !1 ? null : t.fromArray(i, e * 16);
  }
  setColorAt(e, t) {
    this._colorsTexture === null && this._initColorsTexture();
    const r = this._colorsTexture, i = this._colorsTexture.image.data, a = this._drawInfo;
    return e >= a.length || a[e].active === !1 ? this : (t.toArray(i, e * 4), r.needsUpdate = !0, this);
  }
  getColorAt(e, t) {
    const r = this._colorsTexture.image.data, i = this._drawInfo;
    return e >= i.length || i[e].active === !1 ? null : t.fromArray(r, e * 4);
  }
  setVisibleAt(e, t) {
    const r = this._drawInfo;
    return e >= r.length || r[e].active === !1 || r[e].visible === t ? this : (r[e].visible = t, this._visibilityChanged = !0, this);
  }
  getVisibleAt(e) {
    const t = this._drawInfo;
    return e >= t.length || t[e].active === !1 ? !1 : t[e].visible;
  }
  raycast(e, t) {
    const r = this._drawInfo, i = this._drawRanges, a = this.matrixWorld, o = this.geometry;
    Ga.material = this.material, Ga.geometry.index = o.index, Ga.geometry.attributes = o.attributes, Ga.geometry.boundingBox === null && (Ga.geometry.boundingBox = new qa()), Ga.geometry.boundingSphere === null && (Ga.geometry.boundingSphere = new Pa());
    for (let s = 0, u = r.length; s < u; s++) {
      if (!r[s].visible || !r[s].active)
        continue;
      const d = r[s].geometryIndex, f = i[d];
      Ga.geometry.setDrawRange(f.start, f.count), this.getMatrixAt(s, Ga.matrixWorld).premultiply(a), this.getBoundingBoxAt(d, Ga.geometry.boundingBox), this.getBoundingSphereAt(d, Ga.geometry.boundingSphere), Ga.raycast(e, b_);
      for (let p = 0, g = b_.length; p < g; p++) {
        const v = b_[p];
        v.object = this, v.batchId = s, t.push(v);
      }
      b_.length = 0;
    }
    Ga.material = null, Ga.geometry.index = null, Ga.geometry.attributes = {}, Ga.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._drawInfo = e._drawInfo.map((t) => ({ ...t })), this._bounds = e._bounds.map((t) => ({
      boxInitialized: t.boxInitialized,
      box: t.box.clone(),
      sphereInitialized: t.sphereInitialized,
      sphere: t.sphere.clone()
    })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.slice()), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null), this;
  }
  onBeforeRender(e, t, r, i, a) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const o = i.getIndex(), s = o === null ? 1 : o.array.BYTES_PER_ELEMENT, u = this._drawInfo, d = this._multiDrawStarts, f = this._multiDrawCounts, p = this._drawRanges, g = this.perObjectFrustumCulled, v = this._indirectTexture, b = v.image.data;
    g && (mF.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse).multiply(this.matrixWorld), ZM.setFromProjectionMatrix(
      mF,
      e.coordinateSystem
    ));
    let E = 0;
    if (this.sortObjects) {
      KM.copy(this.matrixWorld).invert(), iy.setFromMatrixPosition(r.matrixWorld).applyMatrix4(KM), gF.set(0, 0, -1).transformDirection(r.matrixWorld).transformDirection(KM);
      for (let w = 0, C = u.length; w < C; w++)
        if (u[w].visible && u[w].active) {
          const R = u[w].geometryIndex;
          this.getMatrixAt(w, Rd), this.getBoundingSphereAt(R, jf).applyMatrix4(Rd);
          let P = !1;
          if (g && (P = !ZM.intersectsSphere(jf)), !P) {
            const D = Jde.subVectors(jf.center, iy).dot(gF);
            QM.push(p[R], D, w);
          }
        }
      const S = QM.list, _ = this.customSort;
      _ === null ? S.sort(a.transparent ? Yde : qde) : _.call(this, S, r);
      for (let w = 0, C = S.length; w < C; w++) {
        const R = S[w];
        d[E] = R.start * s, f[E] = R.count, b[E] = R.index, E++;
      }
      QM.reset();
    } else
      for (let S = 0, _ = u.length; S < _; S++)
        if (u[S].visible && u[S].active) {
          const w = u[S].geometryIndex;
          let C = !1;
          if (g && (this.getMatrixAt(S, Rd), this.getBoundingSphereAt(w, jf).applyMatrix4(Rd), C = !ZM.intersectsSphere(jf)), !C) {
            const R = p[w];
            d[E] = R.start * s, f[E] = R.count, b[E] = S, E++;
          }
        }
    v.needsUpdate = !0, this._multiDrawCount = E, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, r, i, a, o) {
    this.onBeforeRender(e, null, i, a, o);
  }
}
class vo extends Da {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new an(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const tE = /* @__PURE__ */ new de(), nE = /* @__PURE__ */ new de(), vF = /* @__PURE__ */ new wn(), ay = /* @__PURE__ */ new Eg(), S_ = /* @__PURE__ */ new Pa(), JM = /* @__PURE__ */ new de(), yF = /* @__PURE__ */ new de();
class $d extends pr {
  constructor(e = new Xn(), t = new vo()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [0];
      for (let i = 1, a = t.count; i < a; i++)
        tE.fromBufferAttribute(t, i - 1), nE.fromBufferAttribute(t, i), r[i] = r[i - 1], r[i] += tE.distanceTo(nE);
      e.setAttribute("lineDistance", new fn(r, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.matrixWorld, a = e.params.Line.threshold, o = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), S_.copy(r.boundingSphere), S_.applyMatrix4(i), S_.radius += a, e.ray.intersectsSphere(S_) === !1) return;
    vF.copy(i).invert(), ay.copy(e.ray).applyMatrix4(vF);
    const s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = s * s, d = this.isLineSegments ? 2 : 1, f = r.index, g = r.attributes.position;
    if (f !== null) {
      const v = Math.max(0, o.start), b = Math.min(f.count, o.start + o.count);
      for (let E = v, S = b - 1; E < S; E += d) {
        const _ = f.getX(E), w = f.getX(E + 1), C = __(this, e, ay, u, _, w);
        C && t.push(C);
      }
      if (this.isLineLoop) {
        const E = f.getX(b - 1), S = f.getX(v), _ = __(this, e, ay, u, E, S);
        _ && t.push(_);
      }
    } else {
      const v = Math.max(0, o.start), b = Math.min(g.count, o.start + o.count);
      for (let E = v, S = b - 1; E < S; E += d) {
        const _ = __(this, e, ay, u, E, E + 1);
        _ && t.push(_);
      }
      if (this.isLineLoop) {
        const E = __(this, e, ay, u, b - 1, v);
        E && t.push(E);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = a;
        }
      }
    }
  }
}
function __(n, e, t, r, i, a) {
  const o = n.geometry.attributes.position;
  if (tE.fromBufferAttribute(o, i), nE.fromBufferAttribute(o, a), t.distanceSqToSegment(tE, nE, JM, yF) > r) return;
  JM.applyMatrix4(n.matrixWorld);
  const u = e.ray.origin.distanceTo(JM);
  if (!(u < e.near || u > e.far))
    return {
      distance: u,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: yF.clone().applyMatrix4(n.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: n
    };
}
const bF = /* @__PURE__ */ new de(), SF = /* @__PURE__ */ new de();
class gc extends $d {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [];
      for (let i = 0, a = t.count; i < a; i += 2)
        bF.fromBufferAttribute(t, i), SF.fromBufferAttribute(t, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + bF.distanceTo(SF);
      e.setAttribute("lineDistance", new fn(r, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class Xk extends $d {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class rP extends Da {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new an(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const _F = /* @__PURE__ */ new wn(), cA = /* @__PURE__ */ new Eg(), x_ = /* @__PURE__ */ new Pa(), E_ = /* @__PURE__ */ new de();
class qk extends pr {
  constructor(e = new Xn(), t = new rP()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.matrixWorld, a = e.params.Points.threshold, o = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), x_.copy(r.boundingSphere), x_.applyMatrix4(i), x_.radius += a, e.ray.intersectsSphere(x_) === !1) return;
    _F.copy(i).invert(), cA.copy(e.ray).applyMatrix4(_F);
    const s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = s * s, d = r.index, p = r.attributes.position;
    if (d !== null) {
      const g = Math.max(0, o.start), v = Math.min(d.count, o.start + o.count);
      for (let b = g, E = v; b < E; b++) {
        const S = d.getX(b);
        E_.fromBufferAttribute(p, S), xF(E_, S, u, i, e, t, this);
      }
    } else {
      const g = Math.max(0, o.start), v = Math.min(p.count, o.start + o.count);
      for (let b = g, E = v; b < E; b++)
        E_.fromBufferAttribute(p, b), xF(E_, b, u, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = a;
        }
      }
    }
  }
}
function xF(n, e, t, r, i, a, o) {
  const s = cA.distanceSqToPoint(n);
  if (s < t) {
    const u = new de();
    cA.closestPointToPoint(n, u), u.applyMatrix4(r);
    const d = i.ray.origin.distanceTo(u);
    if (d < i.near || d > i.far) return;
    a.push({
      distance: d,
      distanceToRay: Math.sqrt(s),
      point: u,
      index: e,
      face: null,
      object: o
    });
  }
}
class tfe extends Ei {
  constructor(e, t, r, i, a, o, s, u, d) {
    super(e, t, r, i, a, o, s, u, d), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : Ki, this.magFilter = a !== void 0 ? a : Ki, this.generateMipmaps = !1;
    const f = this;
    function p() {
      f.needsUpdate = !0, e.requestVideoFrameCallback(p);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(p);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class nfe extends Ei {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = ba, this.minFilter = ba, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class JE extends Ei {
  constructor(e, t, r, i, a, o, s, u, d, f, p, g) {
    super(null, o, s, u, d, f, i, a, p, g), this.isCompressedTexture = !0, this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class rfe extends JE {
  constructor(e, t, r, i, a, o) {
    super(e, t, r, a, o), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = Xs, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class ife extends JE {
  constructor(e, t, r) {
    super(void 0, e[0].width, e[0].height, t, r, gu), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class afe extends Ei {
  constructor(e, t, r, i, a, o, s, u, d) {
    super(e, t, r, i, a, o, s, u, d), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Pl {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, i = this.getPoint(0), a = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      r = this.getPoint(o / e), a += r.distanceTo(i), t.push(a), i = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const a = r.length;
    let o;
    t ? o = t : o = e * r[a - 1];
    let s = 0, u = a - 1, d;
    for (; s <= u; )
      if (i = Math.floor(s + (u - s) / 2), d = r[i] - o, d < 0)
        s = i + 1;
      else if (d > 0)
        u = i - 1;
      else {
        u = i;
        break;
      }
    if (i = u, r[i] === o)
      return i / (a - 1);
    const f = r[i], g = r[i + 1] - f, v = (o - f) / g;
    return (i + v) / (a - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let i = e - 1e-4, a = e + 1e-4;
    i < 0 && (i = 0), a > 1 && (a = 1);
    const o = this.getPoint(i), s = this.getPoint(a), u = t || (o.isVector2 ? new St() : new de());
    return u.copy(s).sub(o).normalize(), u;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new de(), i = [], a = [], o = [], s = new de(), u = new wn();
    for (let v = 0; v <= e; v++) {
      const b = v / e;
      i[v] = this.getTangentAt(b, new de());
    }
    a[0] = new de(), o[0] = new de();
    let d = Number.MAX_VALUE;
    const f = Math.abs(i[0].x), p = Math.abs(i[0].y), g = Math.abs(i[0].z);
    f <= d && (d = f, r.set(1, 0, 0)), p <= d && (d = p, r.set(0, 1, 0)), g <= d && r.set(0, 0, 1), s.crossVectors(i[0], r).normalize(), a[0].crossVectors(i[0], s), o[0].crossVectors(i[0], a[0]);
    for (let v = 1; v <= e; v++) {
      if (a[v] = a[v - 1].clone(), o[v] = o[v - 1].clone(), s.crossVectors(i[v - 1], i[v]), s.length() > Number.EPSILON) {
        s.normalize();
        const b = Math.acos(Ti(i[v - 1].dot(i[v]), -1, 1));
        a[v].applyMatrix4(u.makeRotationAxis(s, b));
      }
      o[v].crossVectors(i[v], a[v]);
    }
    if (t === !0) {
      let v = Math.acos(Ti(a[0].dot(a[e]), -1, 1));
      v /= e, i[0].dot(s.crossVectors(a[0], a[e])) > 0 && (v = -v);
      for (let b = 1; b <= e; b++)
        a[b].applyMatrix4(u.makeRotationAxis(i[b], v * b)), o[b].crossVectors(i[b], a[b]);
    }
    return {
      tangents: i,
      normals: a,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class eC extends Pl {
  constructor(e = 0, t = 0, r = 1, i = 1, a = 0, o = Math.PI * 2, s = !1, u = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = i, this.aStartAngle = a, this.aEndAngle = o, this.aClockwise = s, this.aRotation = u;
  }
  getPoint(e, t = new St()) {
    const r = t, i = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += i;
    for (; a > i; ) a -= i;
    a < Number.EPSILON && (o ? a = 0 : a = i), this.aClockwise === !0 && !o && (a === i ? a = -i : a = a - i);
    const s = this.aStartAngle + e * a;
    let u = this.aX + this.xRadius * Math.cos(s), d = this.aY + this.yRadius * Math.sin(s);
    if (this.aRotation !== 0) {
      const f = Math.cos(this.aRotation), p = Math.sin(this.aRotation), g = u - this.aX, v = d - this.aY;
      u = g * f - v * p + this.aX, d = g * p + v * f + this.aY;
    }
    return r.set(u, d);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class Yk extends eC {
  constructor(e, t, r, i, a, o) {
    super(e, t, r, r, i, a, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function iP() {
  let n = 0, e = 0, t = 0, r = 0;
  function i(a, o, s, u) {
    n = a, e = s, t = -3 * a + 3 * o - 2 * s - u, r = 2 * a - 2 * o + s + u;
  }
  return {
    initCatmullRom: function(a, o, s, u, d) {
      i(o, s, d * (s - a), d * (u - o));
    },
    initNonuniformCatmullRom: function(a, o, s, u, d, f, p) {
      let g = (o - a) / d - (s - a) / (d + f) + (s - o) / f, v = (s - o) / f - (u - o) / (f + p) + (u - s) / p;
      g *= f, v *= f, i(o, s, g, v);
    },
    calc: function(a) {
      const o = a * a, s = o * a;
      return n + e * a + t * o + r * s;
    }
  };
}
const C_ = /* @__PURE__ */ new de(), eT = /* @__PURE__ */ new iP(), tT = /* @__PURE__ */ new iP(), nT = /* @__PURE__ */ new iP();
class Kk extends Pl {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = i;
  }
  getPoint(e, t = new de()) {
    const r = t, i = this.points, a = i.length, o = (a - (this.closed ? 0 : 1)) * e;
    let s = Math.floor(o), u = o - s;
    this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / a) + 1) * a : u === 0 && s === a - 1 && (s = a - 2, u = 1);
    let d, f;
    this.closed || s > 0 ? d = i[(s - 1) % a] : (C_.subVectors(i[0], i[1]).add(i[0]), d = C_);
    const p = i[s % a], g = i[(s + 1) % a];
    if (this.closed || s + 2 < a ? f = i[(s + 2) % a] : (C_.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]), f = C_), this.curveType === "centripetal" || this.curveType === "chordal") {
      const v = this.curveType === "chordal" ? 0.5 : 0.25;
      let b = Math.pow(d.distanceToSquared(p), v), E = Math.pow(p.distanceToSquared(g), v), S = Math.pow(g.distanceToSquared(f), v);
      E < 1e-4 && (E = 1), b < 1e-4 && (b = E), S < 1e-4 && (S = E), eT.initNonuniformCatmullRom(d.x, p.x, g.x, f.x, b, E, S), tT.initNonuniformCatmullRom(d.y, p.y, g.y, f.y, b, E, S), nT.initNonuniformCatmullRom(d.z, p.z, g.z, f.z, b, E, S);
    } else this.curveType === "catmullrom" && (eT.initCatmullRom(d.x, p.x, g.x, f.x, this.tension), tT.initCatmullRom(d.y, p.y, g.y, f.y, this.tension), nT.initCatmullRom(d.z, p.z, g.z, f.z, this.tension));
    return r.set(
      eT.calc(u),
      tT.calc(u),
      nT.calc(u)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new de().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function EF(n, e, t, r, i) {
  const a = (r - e) * 0.5, o = (i - t) * 0.5, s = n * n, u = n * s;
  return (2 * t - 2 * r + a + o) * u + (-3 * t + 3 * r - 2 * a - o) * s + a * n + t;
}
function ofe(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function sfe(n, e) {
  return 2 * (1 - n) * n * e;
}
function lfe(n, e) {
  return n * n * e;
}
function Fy(n, e, t, r) {
  return ofe(n, e) + sfe(n, t) + lfe(n, r);
}
function cfe(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function ufe(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function dfe(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function ffe(n, e) {
  return n * n * n * e;
}
function Uy(n, e, t, r, i) {
  return cfe(n, e) + ufe(n, t) + dfe(n, r) + ffe(n, i);
}
class aP extends Pl {
  constructor(e = new St(), t = new St(), r = new St(), i = new St()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i;
  }
  getPoint(e, t = new St()) {
    const r = t, i = this.v0, a = this.v1, o = this.v2, s = this.v3;
    return r.set(
      Uy(e, i.x, a.x, o.x, s.x),
      Uy(e, i.y, a.y, o.y, s.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Zk extends Pl {
  constructor(e = new de(), t = new de(), r = new de(), i = new de()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i;
  }
  getPoint(e, t = new de()) {
    const r = t, i = this.v0, a = this.v1, o = this.v2, s = this.v3;
    return r.set(
      Uy(e, i.x, a.x, o.x, s.x),
      Uy(e, i.y, a.y, o.y, s.y),
      Uy(e, i.z, a.z, o.z, s.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class oP extends Pl {
  constructor(e = new St(), t = new St()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new St()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new St()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Qk extends Pl {
  constructor(e = new de(), t = new de()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new de()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new de()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class sP extends Pl {
  constructor(e = new St(), t = new St(), r = new St()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new St()) {
    const r = t, i = this.v0, a = this.v1, o = this.v2;
    return r.set(
      Fy(e, i.x, a.x, o.x),
      Fy(e, i.y, a.y, o.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class lP extends Pl {
  constructor(e = new de(), t = new de(), r = new de()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new de()) {
    const r = t, i = this.v0, a = this.v1, o = this.v2;
    return r.set(
      Fy(e, i.x, a.x, o.x),
      Fy(e, i.y, a.y, o.y),
      Fy(e, i.z, a.z, o.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class cP extends Pl {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new St()) {
    const r = t, i = this.points, a = (i.length - 1) * e, o = Math.floor(a), s = a - o, u = i[o === 0 ? o : o - 1], d = i[o], f = i[o > i.length - 2 ? i.length - 1 : o + 1], p = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return r.set(
      EF(s, u.x, d.x, f.x, p.x),
      EF(s, u.y, d.y, f.y, p.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new St().fromArray(i));
    }
    return this;
  }
}
var rE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: Yk,
  CatmullRomCurve3: Kk,
  CubicBezierCurve: aP,
  CubicBezierCurve3: Zk,
  EllipseCurve: eC,
  LineCurve: oP,
  LineCurve3: Qk,
  QuadraticBezierCurve: sP,
  QuadraticBezierCurve3: lP,
  SplineCurve: cP
});
class Jk extends Pl {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new rE[r](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const r = e * this.getLength(), i = this.getCurveLengths();
    let a = 0;
    for (; a < i.length; ) {
      if (i[a] >= r) {
        const o = i[a] - r, s = this.curves[a], u = s.getLength(), d = u === 0 ? 0 : 1 - o / u;
        return s.getPointAt(d, t);
      }
      a++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, a = this.curves; i < a.length; i++) {
      const o = a[i], s = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, u = o.getPoints(s);
      for (let d = 0; d < u.length; d++) {
        const f = u[d];
        r && r.equals(f) || (t.push(f), r = f);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new rE[i.type]().fromJSON(i));
    }
    return this;
  }
}
class u0 extends Jk {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new St(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new oP(this.currentPoint.clone(), new St(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const a = new sP(
      this.currentPoint.clone(),
      new St(e, t),
      new St(r, i)
    );
    return this.curves.push(a), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, a, o) {
    const s = new aP(
      this.currentPoint.clone(),
      new St(e, t),
      new St(r, i),
      new St(a, o)
    );
    return this.curves.push(s), this.currentPoint.set(a, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new cP(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, a, o) {
    const s = this.currentPoint.x, u = this.currentPoint.y;
    return this.absarc(
      e + s,
      t + u,
      r,
      i,
      a,
      o
    ), this;
  }
  absarc(e, t, r, i, a, o) {
    return this.absellipse(e, t, r, r, i, a, o), this;
  }
  ellipse(e, t, r, i, a, o, s, u) {
    const d = this.currentPoint.x, f = this.currentPoint.y;
    return this.absellipse(e + d, t + f, r, i, a, o, s, u), this;
  }
  absellipse(e, t, r, i, a, o, s, u) {
    const d = new eC(e, t, r, i, a, o, s, u);
    if (this.curves.length > 0) {
      const p = d.getPoint(0);
      p.equals(this.currentPoint) || this.lineTo(p.x, p.y);
    }
    this.curves.push(d);
    const f = d.getPoint(1);
    return this.currentPoint.copy(f), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class F0 extends Xn {
  constructor(e = [new St(0, -0.5), new St(0.5, 0), new St(0, 0.5)], t = 12, r = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: i
    }, t = Math.floor(t), i = Ti(i, 0, Math.PI * 2);
    const a = [], o = [], s = [], u = [], d = [], f = 1 / t, p = new de(), g = new St(), v = new de(), b = new de(), E = new de();
    let S = 0, _ = 0;
    for (let w = 0; w <= e.length - 1; w++)
      switch (w) {
        case 0:
          S = e[w + 1].x - e[w].x, _ = e[w + 1].y - e[w].y, v.x = _ * 1, v.y = -S, v.z = _ * 0, E.copy(v), v.normalize(), u.push(v.x, v.y, v.z);
          break;
        case e.length - 1:
          u.push(E.x, E.y, E.z);
          break;
        default:
          S = e[w + 1].x - e[w].x, _ = e[w + 1].y - e[w].y, v.x = _ * 1, v.y = -S, v.z = _ * 0, b.copy(v), v.x += E.x, v.y += E.y, v.z += E.z, v.normalize(), u.push(v.x, v.y, v.z), E.copy(b);
      }
    for (let w = 0; w <= t; w++) {
      const C = r + w * f * i, R = Math.sin(C), P = Math.cos(C);
      for (let D = 0; D <= e.length - 1; D++) {
        p.x = e[D].x * R, p.y = e[D].y, p.z = e[D].x * P, o.push(p.x, p.y, p.z), g.x = w / t, g.y = D / (e.length - 1), s.push(g.x, g.y);
        const I = u[3 * D + 0] * R, U = u[3 * D + 1], L = u[3 * D + 0] * P;
        d.push(I, U, L);
      }
    }
    for (let w = 0; w < t; w++)
      for (let C = 0; C < e.length - 1; C++) {
        const R = C + w * e.length, P = R, D = R + e.length, I = R + e.length + 1, U = R + 1;
        a.push(P, D, U), a.push(I, U, D);
      }
    this.setIndex(a), this.setAttribute("position", new fn(o, 3)), this.setAttribute("uv", new fn(s, 2)), this.setAttribute("normal", new fn(d, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new F0(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class tC extends F0 {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const a = new u0();
    a.absarc(0, -t / 2, e, Math.PI * 1.5, 0), a.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(a.getPoints(r), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: r,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new tC(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class nC extends Xn {
  constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: i
    }, t = Math.max(3, t);
    const a = [], o = [], s = [], u = [], d = new de(), f = new St();
    o.push(0, 0, 0), s.push(0, 0, 1), u.push(0.5, 0.5);
    for (let p = 0, g = 3; p <= t; p++, g += 3) {
      const v = r + p / t * i;
      d.x = e * Math.cos(v), d.y = e * Math.sin(v), o.push(d.x, d.y, d.z), s.push(0, 0, 1), f.x = (o[g] / e + 1) / 2, f.y = (o[g + 1] / e + 1) / 2, u.push(f.x, f.y);
    }
    for (let p = 1; p <= t; p++)
      a.push(p, p + 1, 0);
    this.setIndex(a), this.setAttribute("position", new fn(o, 3)), this.setAttribute("normal", new fn(s, 3)), this.setAttribute("uv", new fn(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new nC(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Mg extends Xn {
  constructor(e = 1, t = 1, r = 1, i = 32, a = 1, o = !1, s = 0, u = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: i,
      heightSegments: a,
      openEnded: o,
      thetaStart: s,
      thetaLength: u
    };
    const d = this;
    i = Math.floor(i), a = Math.floor(a);
    const f = [], p = [], g = [], v = [];
    let b = 0;
    const E = [], S = r / 2;
    let _ = 0;
    w(), o === !1 && (e > 0 && C(!0), t > 0 && C(!1)), this.setIndex(f), this.setAttribute("position", new fn(p, 3)), this.setAttribute("normal", new fn(g, 3)), this.setAttribute("uv", new fn(v, 2));
    function w() {
      const R = new de(), P = new de();
      let D = 0;
      const I = (t - e) / r;
      for (let U = 0; U <= a; U++) {
        const L = [], N = U / a, H = N * (t - e) + e;
        for (let j = 0; j <= i; j++) {
          const G = j / i, X = G * u + s, ae = Math.sin(X), Z = Math.cos(X);
          P.x = H * ae, P.y = -N * r + S, P.z = H * Z, p.push(P.x, P.y, P.z), R.set(ae, I, Z).normalize(), g.push(R.x, R.y, R.z), v.push(G, 1 - N), L.push(b++);
        }
        E.push(L);
      }
      for (let U = 0; U < i; U++)
        for (let L = 0; L < a; L++) {
          const N = E[L][U], H = E[L + 1][U], j = E[L + 1][U + 1], G = E[L][U + 1];
          f.push(N, H, G), f.push(H, j, G), D += 6;
        }
      d.addGroup(_, D, 0), _ += D;
    }
    function C(R) {
      const P = b, D = new St(), I = new de();
      let U = 0;
      const L = R === !0 ? e : t, N = R === !0 ? 1 : -1;
      for (let j = 1; j <= i; j++)
        p.push(0, S * N, 0), g.push(0, N, 0), v.push(0.5, 0.5), b++;
      const H = b;
      for (let j = 0; j <= i; j++) {
        const X = j / i * u + s, ae = Math.cos(X), Z = Math.sin(X);
        I.x = L * Z, I.y = S * N, I.z = L * ae, p.push(I.x, I.y, I.z), g.push(0, N, 0), D.x = ae * 0.5 + 0.5, D.y = Z * 0.5 * N + 0.5, v.push(D.x, D.y), b++;
      }
      for (let j = 0; j < i; j++) {
        const G = P + j, X = H + j;
        R === !0 ? f.push(X, X + 1, G) : f.push(X + 1, X, G), U += 3;
      }
      d.addGroup(_, U, R === !0 ? 1 : 2), _ += U;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mg(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class rC extends Mg {
  constructor(e = 1, t = 1, r = 32, i = 1, a = !1, o = 0, s = Math.PI * 2) {
    super(0, e, t, r, i, a, o, s), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: i,
      openEnded: a,
      thetaStart: o,
      thetaLength: s
    };
  }
  static fromJSON(e) {
    return new rC(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Yd extends Xn {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: i
    };
    const a = [], o = [];
    s(i), d(r), f(), this.setAttribute("position", new fn(a, 3)), this.setAttribute("normal", new fn(a.slice(), 3)), this.setAttribute("uv", new fn(o, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function s(w) {
      const C = new de(), R = new de(), P = new de();
      for (let D = 0; D < t.length; D += 3)
        v(t[D + 0], C), v(t[D + 1], R), v(t[D + 2], P), u(C, R, P, w);
    }
    function u(w, C, R, P) {
      const D = P + 1, I = [];
      for (let U = 0; U <= D; U++) {
        I[U] = [];
        const L = w.clone().lerp(R, U / D), N = C.clone().lerp(R, U / D), H = D - U;
        for (let j = 0; j <= H; j++)
          j === 0 && U === D ? I[U][j] = L : I[U][j] = L.clone().lerp(N, j / H);
      }
      for (let U = 0; U < D; U++)
        for (let L = 0; L < 2 * (D - U) - 1; L++) {
          const N = Math.floor(L / 2);
          L % 2 === 0 ? (g(I[U][N + 1]), g(I[U + 1][N]), g(I[U][N])) : (g(I[U][N + 1]), g(I[U + 1][N + 1]), g(I[U + 1][N]));
        }
    }
    function d(w) {
      const C = new de();
      for (let R = 0; R < a.length; R += 3)
        C.x = a[R + 0], C.y = a[R + 1], C.z = a[R + 2], C.normalize().multiplyScalar(w), a[R + 0] = C.x, a[R + 1] = C.y, a[R + 2] = C.z;
    }
    function f() {
      const w = new de();
      for (let C = 0; C < a.length; C += 3) {
        w.x = a[C + 0], w.y = a[C + 1], w.z = a[C + 2];
        const R = S(w) / 2 / Math.PI + 0.5, P = _(w) / Math.PI + 0.5;
        o.push(R, 1 - P);
      }
      b(), p();
    }
    function p() {
      for (let w = 0; w < o.length; w += 6) {
        const C = o[w + 0], R = o[w + 2], P = o[w + 4], D = Math.max(C, R, P), I = Math.min(C, R, P);
        D > 0.9 && I < 0.1 && (C < 0.2 && (o[w + 0] += 1), R < 0.2 && (o[w + 2] += 1), P < 0.2 && (o[w + 4] += 1));
      }
    }
    function g(w) {
      a.push(w.x, w.y, w.z);
    }
    function v(w, C) {
      const R = w * 3;
      C.x = e[R + 0], C.y = e[R + 1], C.z = e[R + 2];
    }
    function b() {
      const w = new de(), C = new de(), R = new de(), P = new de(), D = new St(), I = new St(), U = new St();
      for (let L = 0, N = 0; L < a.length; L += 9, N += 6) {
        w.set(a[L + 0], a[L + 1], a[L + 2]), C.set(a[L + 3], a[L + 4], a[L + 5]), R.set(a[L + 6], a[L + 7], a[L + 8]), D.set(o[N + 0], o[N + 1]), I.set(o[N + 2], o[N + 3]), U.set(o[N + 4], o[N + 5]), P.copy(w).add(C).add(R).divideScalar(3);
        const H = S(P);
        E(D, N + 0, w, H), E(I, N + 2, C, H), E(U, N + 4, R, H);
      }
    }
    function E(w, C, R, P) {
      P < 0 && w.x === 1 && (o[C] = w.x - 1), R.x === 0 && R.z === 0 && (o[C] = P / 2 / Math.PI + 0.5);
    }
    function S(w) {
      return Math.atan2(w.z, -w.x);
    }
    function _(w) {
      return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Yd(e.vertices, e.indices, e.radius, e.details);
  }
}
class iC extends Yd {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, i = 1 / r, a = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -i,
      -r,
      0,
      -i,
      r,
      0,
      i,
      -r,
      0,
      i,
      r,
      // (1/, , 0)
      -i,
      -r,
      0,
      -i,
      r,
      0,
      i,
      -r,
      0,
      i,
      r,
      0,
      // (, 0, 1/)
      -r,
      0,
      -i,
      r,
      0,
      -i,
      -r,
      0,
      i,
      r,
      0,
      i
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(a, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new iC(e.radius, e.detail);
  }
}
const w_ = /* @__PURE__ */ new de(), M_ = /* @__PURE__ */ new de(), rT = /* @__PURE__ */ new de(), T_ = /* @__PURE__ */ new ds();
class e$ extends Xn {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), a = Math.cos(Ch * t), o = e.getIndex(), s = e.getAttribute("position"), u = o ? o.count : s.count, d = [0, 0, 0], f = ["a", "b", "c"], p = new Array(3), g = {}, v = [];
      for (let b = 0; b < u; b += 3) {
        o ? (d[0] = o.getX(b), d[1] = o.getX(b + 1), d[2] = o.getX(b + 2)) : (d[0] = b, d[1] = b + 1, d[2] = b + 2);
        const { a: E, b: S, c: _ } = T_;
        if (E.fromBufferAttribute(s, d[0]), S.fromBufferAttribute(s, d[1]), _.fromBufferAttribute(s, d[2]), T_.getNormal(rT), p[0] = `${Math.round(E.x * i)},${Math.round(E.y * i)},${Math.round(E.z * i)}`, p[1] = `${Math.round(S.x * i)},${Math.round(S.y * i)},${Math.round(S.z * i)}`, p[2] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(_.z * i)}`, !(p[0] === p[1] || p[1] === p[2] || p[2] === p[0]))
          for (let w = 0; w < 3; w++) {
            const C = (w + 1) % 3, R = p[w], P = p[C], D = T_[f[w]], I = T_[f[C]], U = `${R}_${P}`, L = `${P}_${R}`;
            L in g && g[L] ? (rT.dot(g[L].normal) <= a && (v.push(D.x, D.y, D.z), v.push(I.x, I.y, I.z)), g[L] = null) : U in g || (g[U] = {
              index0: d[w],
              index1: d[C],
              normal: rT.clone()
            });
          }
      }
      for (const b in g)
        if (g[b]) {
          const { index0: E, index1: S } = g[b];
          w_.fromBufferAttribute(s, E), M_.fromBufferAttribute(s, S), v.push(w_.x, w_.y, w_.z), v.push(M_.x, M_.y, M_.z);
        }
      this.setAttribute("position", new fn(v, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class uu extends u0 {
  constructor(e) {
    super(e), this.uuid = ps(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new u0().fromJSON(i));
    }
    return this;
  }
}
const hfe = {
  triangulate: function(n, e, t = 2) {
    const r = e && e.length, i = r ? e[0] * t : n.length;
    let a = t$(n, 0, i, t, !0);
    const o = [];
    if (!a || a.next === a.prev) return o;
    let s, u, d, f, p, g, v;
    if (r && (a = yfe(n, e, a, t)), n.length > 80 * t) {
      s = d = n[0], u = f = n[1];
      for (let b = t; b < i; b += t)
        p = n[b], g = n[b + 1], p < s && (s = p), g < u && (u = g), p > d && (d = p), g > f && (f = g);
      v = Math.max(d - s, f - u), v = v !== 0 ? 32767 / v : 0;
    }
    return d0(a, o, t, s, u, v, 0), o;
  }
};
function t$(n, e, t, r, i) {
  let a, o;
  if (i === Afe(n, e, t, r) > 0)
    for (a = e; a < t; a += r) o = CF(a, n[a], n[a + 1], o);
  else
    for (a = t - r; a >= e; a -= r) o = CF(a, n[a], n[a + 1], o);
  return o && aC(o, o.next) && (h0(o), o = o.next), o;
}
function Uh(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n, r;
  do
    if (r = !1, !t.steiner && (aC(t, t.next) || xi(t.prev, t, t.next) === 0)) {
      if (h0(t), t = e = t.prev, t === t.next) break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function d0(n, e, t, r, i, a, o) {
  if (!n) return;
  !o && a && Efe(n, r, i, a);
  let s = n, u, d;
  for (; n.prev !== n.next; ) {
    if (u = n.prev, d = n.next, a ? mfe(n, r, i, a) : pfe(n)) {
      e.push(u.i / t | 0), e.push(n.i / t | 0), e.push(d.i / t | 0), h0(n), n = d.next, s = d.next;
      continue;
    }
    if (n = d, n === s) {
      o ? o === 1 ? (n = gfe(Uh(n), e, t), d0(n, e, t, r, i, a, 2)) : o === 2 && vfe(n, e, t, r, i, a) : d0(Uh(n), e, t, r, i, a, 1);
      break;
    }
  }
}
function pfe(n) {
  const e = n.prev, t = n, r = n.next;
  if (xi(e, t, r) >= 0) return !1;
  const i = e.x, a = t.x, o = r.x, s = e.y, u = t.y, d = r.y, f = i < a ? i < o ? i : o : a < o ? a : o, p = s < u ? s < d ? s : d : u < d ? u : d, g = i > a ? i > o ? i : o : a > o ? a : o, v = s > u ? s > d ? s : d : u > d ? u : d;
  let b = r.next;
  for (; b !== e; ) {
    if (b.x >= f && b.x <= g && b.y >= p && b.y <= v && Gm(i, s, a, u, o, d, b.x, b.y) && xi(b.prev, b, b.next) >= 0) return !1;
    b = b.next;
  }
  return !0;
}
function mfe(n, e, t, r) {
  const i = n.prev, a = n, o = n.next;
  if (xi(i, a, o) >= 0) return !1;
  const s = i.x, u = a.x, d = o.x, f = i.y, p = a.y, g = o.y, v = s < u ? s < d ? s : d : u < d ? u : d, b = f < p ? f < g ? f : g : p < g ? p : g, E = s > u ? s > d ? s : d : u > d ? u : d, S = f > p ? f > g ? f : g : p > g ? p : g, _ = uA(v, b, e, t, r), w = uA(E, S, e, t, r);
  let C = n.prevZ, R = n.nextZ;
  for (; C && C.z >= _ && R && R.z <= w; ) {
    if (C.x >= v && C.x <= E && C.y >= b && C.y <= S && C !== i && C !== o && Gm(s, f, u, p, d, g, C.x, C.y) && xi(C.prev, C, C.next) >= 0 || (C = C.prevZ, R.x >= v && R.x <= E && R.y >= b && R.y <= S && R !== i && R !== o && Gm(s, f, u, p, d, g, R.x, R.y) && xi(R.prev, R, R.next) >= 0)) return !1;
    R = R.nextZ;
  }
  for (; C && C.z >= _; ) {
    if (C.x >= v && C.x <= E && C.y >= b && C.y <= S && C !== i && C !== o && Gm(s, f, u, p, d, g, C.x, C.y) && xi(C.prev, C, C.next) >= 0) return !1;
    C = C.prevZ;
  }
  for (; R && R.z <= w; ) {
    if (R.x >= v && R.x <= E && R.y >= b && R.y <= S && R !== i && R !== o && Gm(s, f, u, p, d, g, R.x, R.y) && xi(R.prev, R, R.next) >= 0) return !1;
    R = R.nextZ;
  }
  return !0;
}
function gfe(n, e, t) {
  let r = n;
  do {
    const i = r.prev, a = r.next.next;
    !aC(i, a) && n$(i, r, r.next, a) && f0(i, a) && f0(a, i) && (e.push(i.i / t | 0), e.push(r.i / t | 0), e.push(a.i / t | 0), h0(r), h0(r.next), r = n = a), r = r.next;
  } while (r !== n);
  return Uh(r);
}
function vfe(n, e, t, r, i, a) {
  let o = n;
  do {
    let s = o.next.next;
    for (; s !== o.prev; ) {
      if (o.i !== s.i && Mfe(o, s)) {
        let u = r$(o, s);
        o = Uh(o, o.next), u = Uh(u, u.next), d0(o, e, t, r, i, a, 0), d0(u, e, t, r, i, a, 0);
        return;
      }
      s = s.next;
    }
    o = o.next;
  } while (o !== n);
}
function yfe(n, e, t, r) {
  const i = [];
  let a, o, s, u, d;
  for (a = 0, o = e.length; a < o; a++)
    s = e[a] * r, u = a < o - 1 ? e[a + 1] * r : n.length, d = t$(n, s, u, r, !1), d === d.next && (d.steiner = !0), i.push(wfe(d));
  for (i.sort(bfe), a = 0; a < i.length; a++)
    t = Sfe(i[a], t);
  return t;
}
function bfe(n, e) {
  return n.x - e.x;
}
function Sfe(n, e) {
  const t = _fe(n, e);
  if (!t)
    return e;
  const r = r$(t, n);
  return Uh(r, r.next), Uh(t, t.next);
}
function _fe(n, e) {
  let t = e, r = -1 / 0, i;
  const a = n.x, o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const g = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (g <= a && g > r && (r = g, i = t.x < t.next.x ? t : t.next, g === a))
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const s = i, u = i.x, d = i.y;
  let f = 1 / 0, p;
  t = i;
  do
    a >= t.x && t.x >= u && a !== t.x && Gm(o < d ? a : r, o, u, d, o < d ? r : a, o, t.x, t.y) && (p = Math.abs(o - t.y) / (a - t.x), f0(t, n) && (p < f || p === f && (t.x > i.x || t.x === i.x && xfe(i, t))) && (i = t, f = p)), t = t.next;
  while (t !== s);
  return i;
}
function xfe(n, e) {
  return xi(n.prev, n, e.prev) < 0 && xi(e.next, n, n.next) < 0;
}
function Efe(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = uA(i.x, i.y, e, t, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== n);
  i.prevZ.nextZ = null, i.prevZ = null, Cfe(i);
}
function Cfe(n) {
  let e, t, r, i, a, o, s, u, d = 1;
  do {
    for (t = n, n = null, a = null, o = 0; t; ) {
      for (o++, r = t, s = 0, e = 0; e < d && (s++, r = r.nextZ, !!r); e++)
        ;
      for (u = d; s > 0 || u > 0 && r; )
        s !== 0 && (u === 0 || !r || t.z <= r.z) ? (i = t, t = t.nextZ, s--) : (i = r, r = r.nextZ, u--), a ? a.nextZ = i : n = i, i.prevZ = a, a = i;
      t = r;
    }
    a.nextZ = null, d *= 2;
  } while (o > 1);
  return n;
}
function uA(n, e, t, r, i) {
  return n = (n - t) * i | 0, e = (e - r) * i | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1;
}
function wfe(n) {
  let e = n, t = n;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== n);
  return t;
}
function Gm(n, e, t, r, i, a, o, s) {
  return (i - o) * (e - s) >= (n - o) * (a - s) && (n - o) * (r - s) >= (t - o) * (e - s) && (t - o) * (a - s) >= (i - o) * (r - s);
}
function Mfe(n, e) {
  return n.next.i !== e.i && n.prev.i !== e.i && !Tfe(n, e) && // dones't intersect other edges
  (f0(n, e) && f0(e, n) && Rfe(n, e) && // locally visible
  (xi(n.prev, n, e.prev) || xi(n, e.prev, e)) || // does not create opposite-facing sectors
  aC(n, e) && xi(n.prev, n, n.next) > 0 && xi(e.prev, e, e.next) > 0);
}
function xi(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function aC(n, e) {
  return n.x === e.x && n.y === e.y;
}
function n$(n, e, t, r) {
  const i = A_(xi(n, e, t)), a = A_(xi(n, e, r)), o = A_(xi(t, r, n)), s = A_(xi(t, r, e));
  return !!(i !== a && o !== s || i === 0 && R_(n, t, e) || a === 0 && R_(n, r, e) || o === 0 && R_(t, n, r) || s === 0 && R_(t, e, r));
}
function R_(n, e, t) {
  return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
}
function A_(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function Tfe(n, e) {
  let t = n;
  do {
    if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && n$(t, t.next, n, e)) return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function f0(n, e) {
  return xi(n.prev, n, n.next) < 0 ? xi(n, e, n.next) >= 0 && xi(n, n.prev, e) >= 0 : xi(n, e, n.prev) < 0 || xi(n, n.next, e) < 0;
}
function Rfe(n, e) {
  let t = n, r = !1;
  const i = (n.x + e.x) / 2, a = (n.y + e.y) / 2;
  do
    t.y > a != t.next.y > a && t.next.y !== t.y && i < (t.next.x - t.x) * (a - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== n);
  return r;
}
function r$(n, e) {
  const t = new dA(n.i, n.x, n.y), r = new dA(e.i, e.x, e.y), i = n.next, a = e.prev;
  return n.next = e, e.prev = n, t.next = i, i.prev = t, r.next = t, t.prev = r, a.next = r, r.prev = a, r;
}
function CF(n, e, t, r) {
  const i = new dA(n, e, t);
  return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i;
}
function h0(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function dA(n, e, t) {
  this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function Afe(n, e, t, r) {
  let i = 0;
  for (let a = e, o = t - r; a < t; a += r)
    i += (n[o] - n[a]) * (n[a + 1] + n[o + 1]), o = a;
  return i;
}
class uc {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, a = 0; a < t; i = a++)
      r += e[i].x * e[a].y - e[a].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return uc.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], i = [], a = [];
    wF(e), MF(r, e);
    let o = e.length;
    t.forEach(wF);
    for (let u = 0; u < t.length; u++)
      i.push(o), o += t[u].length, MF(r, t[u]);
    const s = hfe.triangulate(r, i);
    for (let u = 0; u < s.length; u += 3)
      a.push(s.slice(u, u + 3));
    return a;
  }
}
function wF(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function MF(n, e) {
  for (let t = 0; t < e.length; t++)
    n.push(e[t].x), n.push(e[t].y);
}
class Tg extends Xn {
  constructor(e = new uu([new St(0.5, 0.5), new St(-0.5, 0.5), new St(-0.5, -0.5), new St(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, i = [], a = [];
    for (let s = 0, u = e.length; s < u; s++) {
      const d = e[s];
      o(d);
    }
    this.setAttribute("position", new fn(i, 3)), this.setAttribute("uv", new fn(a, 2)), this.computeVertexNormals();
    function o(s) {
      const u = [], d = t.curveSegments !== void 0 ? t.curveSegments : 12, f = t.steps !== void 0 ? t.steps : 1, p = t.depth !== void 0 ? t.depth : 1;
      let g = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, v = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, b = t.bevelSize !== void 0 ? t.bevelSize : v - 0.1, E = t.bevelOffset !== void 0 ? t.bevelOffset : 0, S = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const _ = t.extrudePath, w = t.UVGenerator !== void 0 ? t.UVGenerator : Ofe;
      let C, R = !1, P, D, I, U;
      _ && (C = _.getSpacedPoints(f), R = !0, g = !1, P = _.computeFrenetFrames(f, !1), D = new de(), I = new de(), U = new de()), g || (S = 0, v = 0, b = 0, E = 0);
      const L = s.extractPoints(d);
      let N = L.shape;
      const H = L.holes;
      if (!uc.isClockWise(N)) {
        N = N.reverse();
        for (let $ = 0, Te = H.length; $ < Te; $++) {
          const se = H[$];
          uc.isClockWise(se) && (H[$] = se.reverse());
        }
      }
      const G = uc.triangulateShape(N, H), X = N;
      for (let $ = 0, Te = H.length; $ < Te; $++) {
        const se = H[$];
        N = N.concat(se);
      }
      function ae($, Te, se) {
        return Te || console.error("THREE.ExtrudeGeometry: vec does not exist"), $.clone().addScaledVector(Te, se);
      }
      const Z = N.length, K = G.length;
      function B($, Te, se) {
        let Ie, be, et;
        const Xe = $.x - Te.x, $e = $.y - Te.y, te = se.x - $.x, Y = se.y - $.y, Se = Xe * Xe + $e * $e, Oe = Xe * Y - $e * te;
        if (Math.abs(Oe) > Number.EPSILON) {
          const Pe = Math.sqrt(Se), Ve = Math.sqrt(te * te + Y * Y), Ze = Te.x - $e / Pe, nt = Te.y + Xe / Pe, ht = se.x - Y / Ve, pt = se.y + te / Ve, Be = ((ht - Ze) * Y - (pt - nt) * te) / (Xe * Y - $e * te);
          Ie = Ze + Xe * Be - $.x, be = nt + $e * Be - $.y;
          const ye = Ie * Ie + be * be;
          if (ye <= 2)
            return new St(Ie, be);
          et = Math.sqrt(ye / 2);
        } else {
          let Pe = !1;
          Xe > Number.EPSILON ? te > Number.EPSILON && (Pe = !0) : Xe < -Number.EPSILON ? te < -Number.EPSILON && (Pe = !0) : Math.sign($e) === Math.sign(Y) && (Pe = !0), Pe ? (Ie = -$e, be = Xe, et = Math.sqrt(Se)) : (Ie = Xe, be = $e, et = Math.sqrt(Se / 2));
        }
        return new St(Ie / et, be / et);
      }
      const Q = [];
      for (let $ = 0, Te = X.length, se = Te - 1, Ie = $ + 1; $ < Te; $++, se++, Ie++)
        se === Te && (se = 0), Ie === Te && (Ie = 0), Q[$] = B(X[$], X[se], X[Ie]);
      const V = [];
      let q, ne = Q.concat();
      for (let $ = 0, Te = H.length; $ < Te; $++) {
        const se = H[$];
        q = [];
        for (let Ie = 0, be = se.length, et = be - 1, Xe = Ie + 1; Ie < be; Ie++, et++, Xe++)
          et === be && (et = 0), Xe === be && (Xe = 0), q[Ie] = B(se[Ie], se[et], se[Xe]);
        V.push(q), ne = ne.concat(q);
      }
      for (let $ = 0; $ < S; $++) {
        const Te = $ / S, se = v * Math.cos(Te * Math.PI / 2), Ie = b * Math.sin(Te * Math.PI / 2) + E;
        for (let be = 0, et = X.length; be < et; be++) {
          const Xe = ae(X[be], Q[be], Ie);
          le(Xe.x, Xe.y, -se);
        }
        for (let be = 0, et = H.length; be < et; be++) {
          const Xe = H[be];
          q = V[be];
          for (let $e = 0, te = Xe.length; $e < te; $e++) {
            const Y = ae(Xe[$e], q[$e], Ie);
            le(Y.x, Y.y, -se);
          }
        }
      }
      const ce = b + E;
      for (let $ = 0; $ < Z; $++) {
        const Te = g ? ae(N[$], ne[$], ce) : N[$];
        R ? (I.copy(P.normals[0]).multiplyScalar(Te.x), D.copy(P.binormals[0]).multiplyScalar(Te.y), U.copy(C[0]).add(I).add(D), le(U.x, U.y, U.z)) : le(Te.x, Te.y, 0);
      }
      for (let $ = 1; $ <= f; $++)
        for (let Te = 0; Te < Z; Te++) {
          const se = g ? ae(N[Te], ne[Te], ce) : N[Te];
          R ? (I.copy(P.normals[$]).multiplyScalar(se.x), D.copy(P.binormals[$]).multiplyScalar(se.y), U.copy(C[$]).add(I).add(D), le(U.x, U.y, U.z)) : le(se.x, se.y, p / f * $);
        }
      for (let $ = S - 1; $ >= 0; $--) {
        const Te = $ / S, se = v * Math.cos(Te * Math.PI / 2), Ie = b * Math.sin(Te * Math.PI / 2) + E;
        for (let be = 0, et = X.length; be < et; be++) {
          const Xe = ae(X[be], Q[be], Ie);
          le(Xe.x, Xe.y, p + se);
        }
        for (let be = 0, et = H.length; be < et; be++) {
          const Xe = H[be];
          q = V[be];
          for (let $e = 0, te = Xe.length; $e < te; $e++) {
            const Y = ae(Xe[$e], q[$e], Ie);
            R ? le(Y.x, Y.y + C[f - 1].y, C[f - 1].x + se) : le(Y.x, Y.y, p + se);
          }
        }
      }
      ie(), oe();
      function ie() {
        const $ = i.length / 3;
        if (g) {
          let Te = 0, se = Z * Te;
          for (let Ie = 0; Ie < K; Ie++) {
            const be = G[Ie];
            ve(be[2] + se, be[1] + se, be[0] + se);
          }
          Te = f + S * 2, se = Z * Te;
          for (let Ie = 0; Ie < K; Ie++) {
            const be = G[Ie];
            ve(be[0] + se, be[1] + se, be[2] + se);
          }
        } else {
          for (let Te = 0; Te < K; Te++) {
            const se = G[Te];
            ve(se[2], se[1], se[0]);
          }
          for (let Te = 0; Te < K; Te++) {
            const se = G[Te];
            ve(se[0] + Z * f, se[1] + Z * f, se[2] + Z * f);
          }
        }
        r.addGroup($, i.length / 3 - $, 0);
      }
      function oe() {
        const $ = i.length / 3;
        let Te = 0;
        he(X, Te), Te += X.length;
        for (let se = 0, Ie = H.length; se < Ie; se++) {
          const be = H[se];
          he(be, Te), Te += be.length;
        }
        r.addGroup($, i.length / 3 - $, 1);
      }
      function he($, Te) {
        let se = $.length;
        for (; --se >= 0; ) {
          const Ie = se;
          let be = se - 1;
          be < 0 && (be = $.length - 1);
          for (let et = 0, Xe = f + S * 2; et < Xe; et++) {
            const $e = Z * et, te = Z * (et + 1), Y = Te + Ie + $e, Se = Te + be + $e, Oe = Te + be + te, Pe = Te + Ie + te;
            Ne(Y, Se, Oe, Pe);
          }
        }
      }
      function le($, Te, se) {
        u.push($), u.push(Te), u.push(se);
      }
      function ve($, Te, se) {
        xe($), xe(Te), xe(se);
        const Ie = i.length / 3, be = w.generateTopUV(r, i, Ie - 3, Ie - 2, Ie - 1);
        Me(be[0]), Me(be[1]), Me(be[2]);
      }
      function Ne($, Te, se, Ie) {
        xe($), xe(Te), xe(Ie), xe(Te), xe(se), xe(Ie);
        const be = i.length / 3, et = w.generateSideWallUV(r, i, be - 6, be - 3, be - 2, be - 1);
        Me(et[0]), Me(et[1]), Me(et[3]), Me(et[1]), Me(et[2]), Me(et[3]);
      }
      function xe($) {
        i.push(u[$ * 3 + 0]), i.push(u[$ * 3 + 1]), i.push(u[$ * 3 + 2]);
      }
      function Me($) {
        a.push($.x), a.push($.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return Pfe(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let a = 0, o = e.shapes.length; a < o; a++) {
      const s = t[e.shapes[a]];
      r.push(s);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new rE[i.type]().fromJSON(i)), new Tg(r, e.options);
  }
}
const Ofe = {
  generateTopUV: function(n, e, t, r, i) {
    const a = e[t * 3], o = e[t * 3 + 1], s = e[r * 3], u = e[r * 3 + 1], d = e[i * 3], f = e[i * 3 + 1];
    return [
      new St(a, o),
      new St(s, u),
      new St(d, f)
    ];
  },
  generateSideWallUV: function(n, e, t, r, i, a) {
    const o = e[t * 3], s = e[t * 3 + 1], u = e[t * 3 + 2], d = e[r * 3], f = e[r * 3 + 1], p = e[r * 3 + 2], g = e[i * 3], v = e[i * 3 + 1], b = e[i * 3 + 2], E = e[a * 3], S = e[a * 3 + 1], _ = e[a * 3 + 2];
    return Math.abs(s - f) < Math.abs(o - d) ? [
      new St(o, 1 - u),
      new St(d, 1 - p),
      new St(g, 1 - b),
      new St(E, 1 - _)
    ] : [
      new St(s, 1 - u),
      new St(f, 1 - p),
      new St(v, 1 - b),
      new St(S, 1 - _)
    ];
  }
};
function Pfe(n, e, t) {
  if (t.shapes = [], Array.isArray(n))
    for (let r = 0, i = n.length; r < i; r++) {
      const a = n[r];
      t.shapes.push(a.uuid);
    }
  else
    t.shapes.push(n.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class oC extends Yd {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], a = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, a, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new oC(e.radius, e.detail);
  }
}
class U0 extends Yd {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new U0(e.radius, e.detail);
  }
}
class sC extends Xn {
  constructor(e = 0.5, t = 1, r = 32, i = 1, a = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: i,
      thetaStart: a,
      thetaLength: o
    }, r = Math.max(3, r), i = Math.max(1, i);
    const s = [], u = [], d = [], f = [];
    let p = e;
    const g = (t - e) / i, v = new de(), b = new St();
    for (let E = 0; E <= i; E++) {
      for (let S = 0; S <= r; S++) {
        const _ = a + S / r * o;
        v.x = p * Math.cos(_), v.y = p * Math.sin(_), u.push(v.x, v.y, v.z), d.push(0, 0, 1), b.x = (v.x / t + 1) / 2, b.y = (v.y / t + 1) / 2, f.push(b.x, b.y);
      }
      p += g;
    }
    for (let E = 0; E < i; E++) {
      const S = E * (r + 1);
      for (let _ = 0; _ < r; _++) {
        const w = _ + S, C = w, R = w + r + 1, P = w + r + 2, D = w + 1;
        s.push(C, R, D), s.push(R, P, D);
      }
    }
    this.setIndex(s), this.setAttribute("position", new fn(u, 3)), this.setAttribute("normal", new fn(d, 3)), this.setAttribute("uv", new fn(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new sC(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class lC extends Xn {
  constructor(e = new uu([new St(0, 0.5), new St(-0.5, -0.5), new St(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], i = [], a = [], o = [];
    let s = 0, u = 0;
    if (Array.isArray(e) === !1)
      d(e);
    else
      for (let f = 0; f < e.length; f++)
        d(e[f]), this.addGroup(s, u, f), s += u, u = 0;
    this.setIndex(r), this.setAttribute("position", new fn(i, 3)), this.setAttribute("normal", new fn(a, 3)), this.setAttribute("uv", new fn(o, 2));
    function d(f) {
      const p = i.length / 3, g = f.extractPoints(t);
      let v = g.shape;
      const b = g.holes;
      uc.isClockWise(v) === !1 && (v = v.reverse());
      for (let S = 0, _ = b.length; S < _; S++) {
        const w = b[S];
        uc.isClockWise(w) === !0 && (b[S] = w.reverse());
      }
      const E = uc.triangulateShape(v, b);
      for (let S = 0, _ = b.length; S < _; S++) {
        const w = b[S];
        v = v.concat(w);
      }
      for (let S = 0, _ = v.length; S < _; S++) {
        const w = v[S];
        i.push(w.x, w.y, 0), a.push(0, 0, 1), o.push(w.x, w.y);
      }
      for (let S = 0, _ = E.length; S < _; S++) {
        const w = E[S], C = w[0] + p, R = w[1] + p, P = w[2] + p;
        r.push(C, R, P), u += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return Dfe(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, a = e.shapes.length; i < a; i++) {
      const o = t[e.shapes[i]];
      r.push(o);
    }
    return new lC(r, e.curveSegments);
  }
}
function Dfe(n, e) {
  if (e.shapes = [], Array.isArray(n))
    for (let t = 0, r = n.length; t < r; t++) {
      const i = n[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(n.uuid);
  return e;
}
class z0 extends Xn {
  constructor(e = 1, t = 32, r = 16, i = 0, a = Math.PI * 2, o = 0, s = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: i,
      phiLength: a,
      thetaStart: o,
      thetaLength: s
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const u = Math.min(o + s, Math.PI);
    let d = 0;
    const f = [], p = new de(), g = new de(), v = [], b = [], E = [], S = [];
    for (let _ = 0; _ <= r; _++) {
      const w = [], C = _ / r;
      let R = 0;
      _ === 0 && o === 0 ? R = 0.5 / t : _ === r && u === Math.PI && (R = -0.5 / t);
      for (let P = 0; P <= t; P++) {
        const D = P / t;
        p.x = -e * Math.cos(i + D * a) * Math.sin(o + C * s), p.y = e * Math.cos(o + C * s), p.z = e * Math.sin(i + D * a) * Math.sin(o + C * s), b.push(p.x, p.y, p.z), g.copy(p).normalize(), E.push(g.x, g.y, g.z), S.push(D + R, 1 - C), w.push(d++);
      }
      f.push(w);
    }
    for (let _ = 0; _ < r; _++)
      for (let w = 0; w < t; w++) {
        const C = f[_][w + 1], R = f[_][w], P = f[_ + 1][w], D = f[_ + 1][w + 1];
        (_ !== 0 || o > 0) && v.push(C, R, D), (_ !== r - 1 || u < Math.PI) && v.push(R, P, D);
      }
    this.setIndex(v), this.setAttribute("position", new fn(b, 3)), this.setAttribute("normal", new fn(E, 3)), this.setAttribute("uv", new fn(S, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new z0(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class cC extends Yd {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new cC(e.radius, e.detail);
  }
}
class uC extends Xn {
  constructor(e = 1, t = 0.4, r = 12, i = 48, a = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: i,
      arc: a
    }, r = Math.floor(r), i = Math.floor(i);
    const o = [], s = [], u = [], d = [], f = new de(), p = new de(), g = new de();
    for (let v = 0; v <= r; v++)
      for (let b = 0; b <= i; b++) {
        const E = b / i * a, S = v / r * Math.PI * 2;
        p.x = (e + t * Math.cos(S)) * Math.cos(E), p.y = (e + t * Math.cos(S)) * Math.sin(E), p.z = t * Math.sin(S), s.push(p.x, p.y, p.z), f.x = e * Math.cos(E), f.y = e * Math.sin(E), g.subVectors(p, f).normalize(), u.push(g.x, g.y, g.z), d.push(b / i), d.push(v / r);
      }
    for (let v = 1; v <= r; v++)
      for (let b = 1; b <= i; b++) {
        const E = (i + 1) * v + b - 1, S = (i + 1) * (v - 1) + b - 1, _ = (i + 1) * (v - 1) + b, w = (i + 1) * v + b;
        o.push(E, S, w), o.push(S, _, w);
      }
    this.setIndex(o), this.setAttribute("position", new fn(s, 3)), this.setAttribute("normal", new fn(u, 3)), this.setAttribute("uv", new fn(d, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new uC(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class dC extends Xn {
  constructor(e = 1, t = 0.4, r = 64, i = 8, a = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: i,
      p: a,
      q: o
    }, r = Math.floor(r), i = Math.floor(i);
    const s = [], u = [], d = [], f = [], p = new de(), g = new de(), v = new de(), b = new de(), E = new de(), S = new de(), _ = new de();
    for (let C = 0; C <= r; ++C) {
      const R = C / r * a * Math.PI * 2;
      w(R, a, o, e, v), w(R + 0.01, a, o, e, b), S.subVectors(b, v), _.addVectors(b, v), E.crossVectors(S, _), _.crossVectors(E, S), E.normalize(), _.normalize();
      for (let P = 0; P <= i; ++P) {
        const D = P / i * Math.PI * 2, I = -t * Math.cos(D), U = t * Math.sin(D);
        p.x = v.x + (I * _.x + U * E.x), p.y = v.y + (I * _.y + U * E.y), p.z = v.z + (I * _.z + U * E.z), u.push(p.x, p.y, p.z), g.subVectors(p, v).normalize(), d.push(g.x, g.y, g.z), f.push(C / r), f.push(P / i);
      }
    }
    for (let C = 1; C <= r; C++)
      for (let R = 1; R <= i; R++) {
        const P = (i + 1) * (C - 1) + (R - 1), D = (i + 1) * C + (R - 1), I = (i + 1) * C + R, U = (i + 1) * (C - 1) + R;
        s.push(P, D, U), s.push(D, I, U);
      }
    this.setIndex(s), this.setAttribute("position", new fn(u, 3)), this.setAttribute("normal", new fn(d, 3)), this.setAttribute("uv", new fn(f, 2));
    function w(C, R, P, D, I) {
      const U = Math.cos(C), L = Math.sin(C), N = P / R * C, H = Math.cos(N);
      I.x = D * (2 + H) * 0.5 * U, I.y = D * (2 + H) * L * 0.5, I.z = D * Math.sin(N) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new dC(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class fC extends Xn {
  constructor(e = new lP(new de(-1, -1, 0), new de(-1, 1, 0), new de(1, 1, 0)), t = 64, r = 1, i = 8, a = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: i,
      closed: a
    };
    const o = e.computeFrenetFrames(t, a);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const s = new de(), u = new de(), d = new St();
    let f = new de();
    const p = [], g = [], v = [], b = [];
    E(), this.setIndex(b), this.setAttribute("position", new fn(p, 3)), this.setAttribute("normal", new fn(g, 3)), this.setAttribute("uv", new fn(v, 2));
    function E() {
      for (let C = 0; C < t; C++)
        S(C);
      S(a === !1 ? t : 0), w(), _();
    }
    function S(C) {
      f = e.getPointAt(C / t, f);
      const R = o.normals[C], P = o.binormals[C];
      for (let D = 0; D <= i; D++) {
        const I = D / i * Math.PI * 2, U = Math.sin(I), L = -Math.cos(I);
        u.x = L * R.x + U * P.x, u.y = L * R.y + U * P.y, u.z = L * R.z + U * P.z, u.normalize(), g.push(u.x, u.y, u.z), s.x = f.x + r * u.x, s.y = f.y + r * u.y, s.z = f.z + r * u.z, p.push(s.x, s.y, s.z);
      }
    }
    function _() {
      for (let C = 1; C <= t; C++)
        for (let R = 1; R <= i; R++) {
          const P = (i + 1) * (C - 1) + (R - 1), D = (i + 1) * C + (R - 1), I = (i + 1) * C + R, U = (i + 1) * (C - 1) + R;
          b.push(P, D, U), b.push(D, I, U);
        }
    }
    function w() {
      for (let C = 0; C <= t; C++)
        for (let R = 0; R <= i; R++)
          d.x = C / t, d.y = R / i, v.push(d.x, d.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new fC(
      new rE[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class i$ extends Xn {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), i = new de(), a = new de();
      if (e.index !== null) {
        const o = e.attributes.position, s = e.index;
        let u = e.groups;
        u.length === 0 && (u = [{ start: 0, count: s.count, materialIndex: 0 }]);
        for (let d = 0, f = u.length; d < f; ++d) {
          const p = u[d], g = p.start, v = p.count;
          for (let b = g, E = g + v; b < E; b += 3)
            for (let S = 0; S < 3; S++) {
              const _ = s.getX(b + S), w = s.getX(b + (S + 1) % 3);
              i.fromBufferAttribute(o, _), a.fromBufferAttribute(o, w), TF(i, a, r) === !0 && (t.push(i.x, i.y, i.z), t.push(a.x, a.y, a.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let s = 0, u = o.count / 3; s < u; s++)
          for (let d = 0; d < 3; d++) {
            const f = 3 * s + d, p = 3 * s + (d + 1) % 3;
            i.fromBufferAttribute(o, f), a.fromBufferAttribute(o, p), TF(i, a, r) === !0 && (t.push(i.x, i.y, i.z), t.push(a.x, a.y, a.z));
          }
      }
      this.setAttribute("position", new fn(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function TF(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var RF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Cu,
  CapsuleGeometry: tC,
  CircleGeometry: nC,
  ConeGeometry: rC,
  CylinderGeometry: Mg,
  DodecahedronGeometry: iC,
  EdgesGeometry: e$,
  ExtrudeGeometry: Tg,
  IcosahedronGeometry: oC,
  LatheGeometry: F0,
  OctahedronGeometry: U0,
  PlaneGeometry: Cg,
  PolyhedronGeometry: Yd,
  RingGeometry: sC,
  ShapeGeometry: lC,
  SphereGeometry: z0,
  TetrahedronGeometry: cC,
  TorusGeometry: uC,
  TorusKnotGeometry: dC,
  TubeGeometry: fC,
  WireframeGeometry: i$
});
class a$ extends Da {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new an(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class o$ extends Rl {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class uP extends Da {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new an(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new an(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xd, this.normalScale = new St(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new gs(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class s$ extends uP {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new St(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Ti(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new an(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new an(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new an(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class l$ extends Da {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new an(16777215), this.specular = new an(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new an(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xd, this.normalScale = new St(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new gs(), this.combine = A0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class c$ extends Da {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new an(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new an(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xd, this.normalScale = new St(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class u$ extends Da {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xd, this.normalScale = new St(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class d$ extends Da {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new an(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new an(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xd, this.normalScale = new St(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new gs(), this.combine = A0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class f$ extends Da {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new an(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xd, this.normalScale = new St(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class h$ extends vo {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function ph(n, e, t) {
  return !n || // let 'undefined' and 'null' pass
  !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n);
}
function p$(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function m$(n) {
  function e(i, a) {
    return n[i] - n[a];
  }
  const t = n.length, r = new Array(t);
  for (let i = 0; i !== t; ++i) r[i] = i;
  return r.sort(e), r;
}
function fA(n, e, t) {
  const r = n.length, i = new n.constructor(r);
  for (let a = 0, o = 0; o !== r; ++a) {
    const s = t[a] * e;
    for (let u = 0; u !== e; ++u)
      i[o++] = n[s + u];
  }
  return i;
}
function dP(n, e, t, r) {
  let i = 1, a = n[0];
  for (; a !== void 0 && a[r] === void 0; )
    a = n[i++];
  if (a === void 0) return;
  let o = a[r];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        o = a[r], o !== void 0 && (e.push(a.time), t.push.apply(t, o)), a = n[i++];
      while (a !== void 0);
    else if (o.toArray !== void 0)
      do
        o = a[r], o !== void 0 && (e.push(a.time), o.toArray(t, t.length)), a = n[i++];
      while (a !== void 0);
    else
      do
        o = a[r], o !== void 0 && (e.push(a.time), t.push(o)), a = n[i++];
      while (a !== void 0);
}
function Ife(n, e, t, r, i = 30) {
  const a = n.clone();
  a.name = e;
  const o = [];
  for (let u = 0; u < a.tracks.length; ++u) {
    const d = a.tracks[u], f = d.getValueSize(), p = [], g = [];
    for (let v = 0; v < d.times.length; ++v) {
      const b = d.times[v] * i;
      if (!(b < t || b >= r)) {
        p.push(d.times[v]);
        for (let E = 0; E < f; ++E)
          g.push(d.values[v * f + E]);
      }
    }
    p.length !== 0 && (d.times = ph(p, d.times.constructor), d.values = ph(g, d.values.constructor), o.push(d));
  }
  a.tracks = o;
  let s = 1 / 0;
  for (let u = 0; u < a.tracks.length; ++u)
    s > a.tracks[u].times[0] && (s = a.tracks[u].times[0]);
  for (let u = 0; u < a.tracks.length; ++u)
    a.tracks[u].shift(-1 * s);
  return a.resetDuration(), a;
}
function Nfe(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length, a = e / r;
  for (let o = 0; o < i; ++o) {
    const s = t.tracks[o], u = s.ValueTypeName;
    if (u === "bool" || u === "string") continue;
    const d = n.tracks.find(function(_) {
      return _.name === s.name && _.ValueTypeName === u;
    });
    if (d === void 0) continue;
    let f = 0;
    const p = s.getValueSize();
    s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = p / 3);
    let g = 0;
    const v = d.getValueSize();
    d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (g = v / 3);
    const b = s.times.length - 1;
    let E;
    if (a <= s.times[0]) {
      const _ = f, w = p - f;
      E = s.values.slice(_, w);
    } else if (a >= s.times[b]) {
      const _ = b * p + f, w = _ + p - f;
      E = s.values.slice(_, w);
    } else {
      const _ = s.createInterpolant(), w = f, C = p - f;
      _.evaluate(a), E = _.resultBuffer.slice(w, C);
    }
    u === "quaternion" && new po().fromArray(E).normalize().conjugate().toArray(E);
    const S = d.times.length;
    for (let _ = 0; _ < S; ++_) {
      const w = _ * v + g;
      if (u === "quaternion")
        po.multiplyQuaternionsFlat(
          d.values,
          w,
          E,
          0,
          d.values,
          w
        );
      else {
        const C = v - g * 2;
        for (let R = 0; R < C; ++R)
          d.values[w + R] -= E[R];
      }
    }
  }
  return n.blendMode = WO, n;
}
const Lfe = {
  convertArray: ph,
  isTypedArray: p$,
  getKeyframeOrder: m$,
  sortedArray: fA,
  flattenJSON: dP,
  subclip: Ife,
  makeClipAdditive: Nfe
};
class B0 {
  constructor(e, t, r, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex, i = t[r], a = t[r - 1];
    e: {
      t: {
        let o;
        n: {
          r: if (!(e < i)) {
            for (let s = r + 2; ; ) {
              if (i === void 0) {
                if (e < a) break r;
                return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
              }
              if (r === s) break;
              if (a = i, i = t[++r], e < i)
                break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= a)) {
            const s = t[1];
            e < s && (r = 2, a = s);
            for (let u = r - 2; ; ) {
              if (a === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (r === u) break;
              if (i = a, a = t[--r - 1], e >= a)
                break t;
            }
            o = r, r = 0;
            break n;
          }
          break e;
        }
        for (; r < o; ) {
          const s = r + o >>> 1;
          e < t[s] ? o = s : r = s + 1;
        }
        if (i = t[r], a = t[r - 1], a === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
      }
      this._cachedIndex = r, this.intervalChanged_(r, a, i);
    }
    return this.interpolate_(r, a, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, a = e * i;
    for (let o = 0; o !== i; ++o)
      t[o] = r[a + o];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class g$ extends B0 {
  constructor(e, t, r, i) {
    super(e, t, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: dh,
      endingEnd: dh
    };
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let a = e - 2, o = e + 1, s = i[a], u = i[o];
    if (s === void 0)
      switch (this.getSettings_().endingStart) {
        case fh:
          a = e, s = 2 * t - r;
          break;
        case r0:
          a = i.length - 2, s = t + i[a] - i[a + 1];
          break;
        default:
          a = e, s = r;
      }
    if (u === void 0)
      switch (this.getSettings_().endingEnd) {
        case fh:
          o = e, u = 2 * r - t;
          break;
        case r0:
          o = 1, u = r + i[1] - i[0];
          break;
        default:
          o = e - 1, u = t;
      }
    const d = (r - t) * 0.5, f = this.valueSize;
    this._weightPrev = d / (t - s), this._weightNext = d / (u - r), this._offsetPrev = a * f, this._offsetNext = o * f;
  }
  interpolate_(e, t, r, i) {
    const a = this.resultBuffer, o = this.sampleValues, s = this.valueSize, u = e * s, d = u - s, f = this._offsetPrev, p = this._offsetNext, g = this._weightPrev, v = this._weightNext, b = (r - t) / (i - t), E = b * b, S = E * b, _ = -g * S + 2 * g * E - g * b, w = (1 + g) * S + (-1.5 - 2 * g) * E + (-0.5 + g) * b + 1, C = (-1 - v) * S + (1.5 + v) * E + 0.5 * b, R = v * S - v * E;
    for (let P = 0; P !== s; ++P)
      a[P] = _ * o[f + P] + w * o[d + P] + C * o[u + P] + R * o[p + P];
    return a;
  }
}
class fP extends B0 {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const a = this.resultBuffer, o = this.sampleValues, s = this.valueSize, u = e * s, d = u - s, f = (r - t) / (i - t), p = 1 - f;
    for (let g = 0; g !== s; ++g)
      a[g] = o[d + g] * p + o[u + g] * f;
    return a;
  }
}
class v$ extends B0 {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Dl {
  constructor(e, t, r, i) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = ph(t, this.TimeBufferType), this.values = ph(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON)
      r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: ph(e.times, Array),
        values: ph(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return r.type = e.ValueTypeName, r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new v$(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new fP(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new g$(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case n0:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Jx:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case ix:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return n0;
      case this.InterpolantFactoryMethodLinear:
        return Jx;
      case this.InterpolantFactoryMethodSmooth:
        return ix;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r)
        t[r] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r)
        t[r] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const r = this.times, i = r.length;
    let a = 0, o = i - 1;
    for (; a !== i && r[a] < e; )
      ++a;
    for (; o !== -1 && r[o] > t; )
      --o;
    if (++o, a !== 0 || o !== i) {
      a >= o && (o = Math.max(o, 1), a = o - 1);
      const s = this.getValueSize();
      this.times = r.slice(a, o), this.values = this.values.slice(a * s, o * s);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const r = this.times, i = this.values, a = r.length;
    a === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let o = null;
    for (let s = 0; s !== a; s++) {
      const u = r[s];
      if (typeof u == "number" && isNaN(u)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, u), e = !1;
        break;
      }
      if (o !== null && o > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, s, u, o), e = !1;
        break;
      }
      o = u;
    }
    if (i !== void 0 && p$(i))
      for (let s = 0, u = i.length; s !== u; ++s) {
        const d = i[s];
        if (isNaN(d)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, d), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), r = this.getValueSize(), i = this.getInterpolation() === ix, a = e.length - 1;
    let o = 1;
    for (let s = 1; s < a; ++s) {
      let u = !1;
      const d = e[s], f = e[s + 1];
      if (d !== f && (s !== 1 || d !== e[0]))
        if (i)
          u = !0;
        else {
          const p = s * r, g = p - r, v = p + r;
          for (let b = 0; b !== r; ++b) {
            const E = t[p + b];
            if (E !== t[g + b] || E !== t[v + b]) {
              u = !0;
              break;
            }
          }
        }
      if (u) {
        if (s !== o) {
          e[o] = e[s];
          const p = s * r, g = o * r;
          for (let v = 0; v !== r; ++v)
            t[g + v] = t[p + v];
        }
        ++o;
      }
    }
    if (a > 0) {
      e[o] = e[a];
      for (let s = a * r, u = o * r, d = 0; d !== r; ++d)
        t[u + d] = t[s + d];
      ++o;
    }
    return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * r)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), r = this.constructor, i = new r(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
Dl.prototype.TimeBufferType = Float32Array;
Dl.prototype.ValueBufferType = Float32Array;
Dl.prototype.DefaultInterpolation = Jx;
class Wh extends Dl {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, r) {
    super(e, t, r);
  }
}
Wh.prototype.ValueTypeName = "bool";
Wh.prototype.ValueBufferType = Array;
Wh.prototype.DefaultInterpolation = n0;
Wh.prototype.InterpolantFactoryMethodLinear = void 0;
Wh.prototype.InterpolantFactoryMethodSmooth = void 0;
class hP extends Dl {
}
hP.prototype.ValueTypeName = "color";
class p0 extends Dl {
}
p0.prototype.ValueTypeName = "number";
class y$ extends B0 {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const a = this.resultBuffer, o = this.sampleValues, s = this.valueSize, u = (r - t) / (i - t);
    let d = e * s;
    for (let f = d + s; d !== f; d += 4)
      po.slerpFlat(a, 0, o, d - s, o, d, u);
    return a;
  }
}
class H0 extends Dl {
  InterpolantFactoryMethodLinear(e) {
    return new y$(this.times, this.values, this.getValueSize(), e);
  }
}
H0.prototype.ValueTypeName = "quaternion";
H0.prototype.InterpolantFactoryMethodSmooth = void 0;
class jh extends Dl {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(e, t, r) {
    super(e, t, r);
  }
}
jh.prototype.ValueTypeName = "string";
jh.prototype.ValueBufferType = Array;
jh.prototype.DefaultInterpolation = n0;
jh.prototype.InterpolantFactoryMethodLinear = void 0;
jh.prototype.InterpolantFactoryMethodSmooth = void 0;
class m0 extends Dl {
}
m0.prototype.ValueTypeName = "vector";
class g0 {
  constructor(e = "", t = -1, r = [], i = jE) {
    this.name = e, this.tracks = r, this.duration = t, this.blendMode = i, this.uuid = ps(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], r = e.tracks, i = 1 / (e.fps || 1);
    for (let o = 0, s = r.length; o !== s; ++o)
      t.push(Ufe(r[o]).scale(i));
    const a = new this(e.name, e.duration, t, e.blendMode);
    return a.uuid = e.uuid, a;
  }
  static toJSON(e) {
    const t = [], r = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let a = 0, o = r.length; a !== o; ++a)
      t.push(Dl.toJSON(r[a]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const a = t.length, o = [];
    for (let s = 0; s < a; s++) {
      let u = [], d = [];
      u.push(
        (s + a - 1) % a,
        s,
        (s + 1) % a
      ), d.push(0, 1, 0);
      const f = m$(u);
      u = fA(u, 1, f), d = fA(d, 1, f), !i && u[0] === 0 && (u.push(a), d.push(d[0])), o.push(
        new p0(
          ".morphTargetInfluences[" + t[s].name + "]",
          u,
          d
        ).scale(1 / r)
      );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < r.length; i++)
      if (r[i].name === t)
        return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {}, a = /^([\w-]*?)([\d]+)$/;
    for (let s = 0, u = e.length; s < u; s++) {
      const d = e[s], f = d.name.match(a);
      if (f && f.length > 1) {
        const p = f[1];
        let g = i[p];
        g || (i[p] = g = []), g.push(d);
      }
    }
    const o = [];
    for (const s in i)
      o.push(this.CreateFromMorphTargetSequence(s, i[s], t, r));
    return o;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const r = function(p, g, v, b, E) {
      if (v.length !== 0) {
        const S = [], _ = [];
        dP(v, S, _, b), S.length !== 0 && E.push(new p(g, S, _));
      }
    }, i = [], a = e.name || "default", o = e.fps || 30, s = e.blendMode;
    let u = e.length || -1;
    const d = e.hierarchy || [];
    for (let p = 0; p < d.length; p++) {
      const g = d[p].keys;
      if (!(!g || g.length === 0))
        if (g[0].morphTargets) {
          const v = {};
          let b;
          for (b = 0; b < g.length; b++)
            if (g[b].morphTargets)
              for (let E = 0; E < g[b].morphTargets.length; E++)
                v[g[b].morphTargets[E]] = -1;
          for (const E in v) {
            const S = [], _ = [];
            for (let w = 0; w !== g[b].morphTargets.length; ++w) {
              const C = g[b];
              S.push(C.time), _.push(C.morphTarget === E ? 1 : 0);
            }
            i.push(new p0(".morphTargetInfluence[" + E + "]", S, _));
          }
          u = v.length * o;
        } else {
          const v = ".bones[" + t[p].name + "]";
          r(
            m0,
            v + ".position",
            g,
            "pos",
            i
          ), r(
            H0,
            v + ".quaternion",
            g,
            "rot",
            i
          ), r(
            m0,
            v + ".scale",
            g,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(a, u, i, s);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const a = this.tracks[r];
      t = Math.max(t, a.times[a.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function Ffe(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return p0;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return m0;
    case "color":
      return hP;
    case "quaternion":
      return H0;
    case "bool":
    case "boolean":
      return Wh;
    case "string":
      return jh;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function Ufe(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = Ffe(n.type);
  if (n.times === void 0) {
    const t = [], r = [];
    dP(n.keys, t, r, "value"), n.times = t, n.values = r;
  }
  return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
}
const su = {
  enabled: !1,
  files: {},
  add: function(n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function(n) {
    if (this.enabled !== !1)
      return this.files[n];
  },
  remove: function(n) {
    delete this.files[n];
  },
  clear: function() {
    this.files = {};
  }
};
class pP {
  constructor(e, t, r) {
    const i = this;
    let a = !1, o = 0, s = 0, u;
    const d = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function(f) {
      s++, a === !1 && i.onStart !== void 0 && i.onStart(f, o, s), a = !0;
    }, this.itemEnd = function(f) {
      o++, i.onProgress !== void 0 && i.onProgress(f, o, s), o === s && (a = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(f) {
      i.onError !== void 0 && i.onError(f);
    }, this.resolveURL = function(f) {
      return u ? u(f) : f;
    }, this.setURLModifier = function(f) {
      return u = f, this;
    }, this.addHandler = function(f, p) {
      return d.push(f, p), this;
    }, this.removeHandler = function(f) {
      const p = d.indexOf(f);
      return p !== -1 && d.splice(p, 2), this;
    }, this.getHandler = function(f) {
      for (let p = 0, g = d.length; p < g; p += 2) {
        const v = d[p], b = d[p + 1];
        if (v.global && (v.lastIndex = 0), v.test(f))
          return b;
      }
      return null;
    };
  }
}
const b$ = /* @__PURE__ */ new pP();
class Wo {
  constructor(e) {
    this.manager = e !== void 0 ? e : b$, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const r = this;
    return new Promise(function(i, a) {
      r.load(e, i, t, a);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Wo.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Jc = {};
class zfe extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class yu extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = su.get(e);
    if (a !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(a), this.manager.itemEnd(e);
      }, 0), a;
    if (Jc[e] !== void 0) {
      Jc[e].push({
        onLoad: t,
        onProgress: r,
        onError: i
      });
      return;
    }
    Jc[e] = [], Jc[e].push({
      onLoad: t,
      onProgress: r,
      onError: i
    });
    const o = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), s = this.mimeType, u = this.responseType;
    fetch(o).then((d) => {
      if (d.status === 200 || d.status === 0) {
        if (d.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || d.body === void 0 || d.body.getReader === void 0)
          return d;
        const f = Jc[e], p = d.body.getReader(), g = d.headers.get("X-File-Size") || d.headers.get("Content-Length"), v = g ? parseInt(g) : 0, b = v !== 0;
        let E = 0;
        const S = new ReadableStream({
          start(_) {
            w();
            function w() {
              p.read().then(({ done: C, value: R }) => {
                if (C)
                  _.close();
                else {
                  E += R.byteLength;
                  const P = new ProgressEvent("progress", { lengthComputable: b, loaded: E, total: v });
                  for (let D = 0, I = f.length; D < I; D++) {
                    const U = f[D];
                    U.onProgress && U.onProgress(P);
                  }
                  _.enqueue(R), w();
                }
              }, (C) => {
                _.error(C);
              });
            }
          }
        });
        return new Response(S);
      } else
        throw new zfe(`fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`, d);
    }).then((d) => {
      switch (u) {
        case "arraybuffer":
          return d.arrayBuffer();
        case "blob":
          return d.blob();
        case "document":
          return d.text().then((f) => new DOMParser().parseFromString(f, s));
        case "json":
          return d.json();
        default:
          if (s === void 0)
            return d.text();
          {
            const p = /charset="?([^;"\s]*)"?/i.exec(s), g = p && p[1] ? p[1].toLowerCase() : void 0, v = new TextDecoder(g);
            return d.arrayBuffer().then((b) => v.decode(b));
          }
      }
    }).then((d) => {
      su.add(e, d);
      const f = Jc[e];
      delete Jc[e];
      for (let p = 0, g = f.length; p < g; p++) {
        const v = f[p];
        v.onLoad && v.onLoad(d);
      }
    }).catch((d) => {
      const f = Jc[e];
      if (f === void 0)
        throw this.manager.itemError(e), d;
      delete Jc[e];
      for (let p = 0, g = f.length; p < g; p++) {
        const v = f[p];
        v.onError && v.onError(d);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class Bfe extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = this, o = new yu(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(s) {
      try {
        t(a.parse(JSON.parse(s)));
      } catch (u) {
        i ? i(u) : console.error(u), a.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = g0.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class Hfe extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = this, o = [], s = new JE(), u = new yu(this.manager);
    u.setPath(this.path), u.setResponseType("arraybuffer"), u.setRequestHeader(this.requestHeader), u.setWithCredentials(a.withCredentials);
    let d = 0;
    function f(p) {
      u.load(e[p], function(g) {
        const v = a.parse(g, !0);
        o[p] = {
          width: v.width,
          height: v.height,
          format: v.format,
          mipmaps: v.mipmaps
        }, d += 1, d === 6 && (v.mipmapCount === 1 && (s.minFilter = Ki), s.image = o, s.format = v.format, s.needsUpdate = !0, t && t(s));
      }, r, i);
    }
    if (Array.isArray(e))
      for (let p = 0, g = e.length; p < g; ++p)
        f(p);
    else
      u.load(e, function(p) {
        const g = a.parse(p, !0);
        if (g.isCubemap) {
          const v = g.mipmaps.length / g.mipmapCount;
          for (let b = 0; b < v; b++) {
            o[b] = { mipmaps: [] };
            for (let E = 0; E < g.mipmapCount; E++)
              o[b].mipmaps.push(g.mipmaps[b * g.mipmapCount + E]), o[b].format = g.format, o[b].width = g.width, o[b].height = g.height;
          }
          s.image = o;
        } else
          s.image.width = g.width, s.image.height = g.height, s.mipmaps = g.mipmaps;
        g.mipmapCount === 1 && (s.minFilter = Ki), s.format = g.format, s.needsUpdate = !0, t && t(s);
      }, r, i);
    return s;
  }
}
class v0 extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = this, o = su.get(e);
    if (o !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        t && t(o), a.manager.itemEnd(e);
      }, 0), o;
    const s = c0("img");
    function u() {
      f(), su.add(e, this), t && t(this), a.manager.itemEnd(e);
    }
    function d(p) {
      f(), i && i(p), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function f() {
      s.removeEventListener("load", u, !1), s.removeEventListener("error", d, !1);
    }
    return s.addEventListener("load", u, !1), s.addEventListener("error", d, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (s.crossOrigin = this.crossOrigin), a.manager.itemStart(e), s.src = e, s;
  }
}
class Vfe extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = new I0();
    a.colorSpace = js;
    const o = new v0(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let s = 0;
    function u(d) {
      o.load(e[d], function(f) {
        a.images[d] = f, s++, s === 6 && (a.needsUpdate = !0, t && t(a));
      }, void 0, i);
    }
    for (let d = 0; d < e.length; ++d)
      u(d);
    return a;
  }
}
class kfe extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = this, o = new cc(), s = new yu(this.manager);
    return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(a.withCredentials), s.load(e, function(u) {
      let d;
      try {
        d = a.parse(u);
      } catch (f) {
        if (i !== void 0)
          i(f);
        else {
          console.error(f);
          return;
        }
      }
      d.image !== void 0 ? o.image = d.image : d.data !== void 0 && (o.image.width = d.width, o.image.height = d.height, o.image.data = d.data), o.wrapS = d.wrapS !== void 0 ? d.wrapS : Xs, o.wrapT = d.wrapT !== void 0 ? d.wrapT : Xs, o.magFilter = d.magFilter !== void 0 ? d.magFilter : Ki, o.minFilter = d.minFilter !== void 0 ? d.minFilter : Ki, o.anisotropy = d.anisotropy !== void 0 ? d.anisotropy : 1, d.colorSpace !== void 0 && (o.colorSpace = d.colorSpace), d.flipY !== void 0 && (o.flipY = d.flipY), d.format !== void 0 && (o.format = d.format), d.type !== void 0 && (o.type = d.type), d.mipmaps !== void 0 && (o.mipmaps = d.mipmaps, o.minFilter = oc), d.mipmapCount === 1 && (o.minFilter = Ki), d.generateMipmaps !== void 0 && (o.generateMipmaps = d.generateMipmaps), o.needsUpdate = !0, t && t(o, d);
    }, r, i), o;
  }
}
class $fe extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = new Ei(), o = new v0(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(s) {
      a.image = s, a.needsUpdate = !0, t !== void 0 && t(a);
    }, r, i), a;
  }
}
class Kd extends pr {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new an(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
  }
}
class S$ extends Kd {
  constructor(e, t, r) {
    super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(pr.DEFAULT_UP), this.updateMatrix(), this.groundColor = new an(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const iT = /* @__PURE__ */ new wn(), AF = /* @__PURE__ */ new de(), OF = /* @__PURE__ */ new de();
class mP {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new St(512, 512), this.map = null, this.mapPass = null, this.matrix = new wn(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new N0(), this._frameExtents = new St(1, 1), this._viewportCount = 1, this._viewports = [
      new wr(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, r = this.matrix;
    AF.setFromMatrixPosition(e.matrixWorld), t.position.copy(AF), OF.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(OF), t.updateMatrixWorld(), iT.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(iT), r.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), r.multiply(iT);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class Wfe extends mP {
  constructor() {
    super(new sa(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, r = cg * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, a = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || a !== t.far) && (t.fov = r, t.aspect = i, t.far = a, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class _$ extends Kd {
  constructor(e, t, r = 0, i = Math.PI / 3, a = 0, o = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(pr.DEFAULT_UP), this.updateMatrix(), this.target = new pr(), this.distance = r, this.angle = i, this.penumbra = a, this.decay = o, this.map = null, this.shadow = new Wfe();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const PF = /* @__PURE__ */ new wn(), oy = /* @__PURE__ */ new de(), aT = /* @__PURE__ */ new de();
class jfe extends mP {
  constructor() {
    super(new sa(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new St(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new wr(2, 1, 1, 1),
      // negative X
      new wr(0, 1, 1, 1),
      // positive Z
      new wr(3, 1, 1, 1),
      // negative Z
      new wr(1, 1, 1, 1),
      // positive Y
      new wr(3, 0, 1, 1),
      // negative Y
      new wr(1, 0, 1, 1)
    ], this._cubeDirections = [
      new de(1, 0, 0),
      new de(-1, 0, 0),
      new de(0, 0, 1),
      new de(0, 0, -1),
      new de(0, 1, 0),
      new de(0, -1, 0)
    ], this._cubeUps = [
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 0, 1),
      new de(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const r = this.camera, i = this.matrix, a = e.distance || r.far;
    a !== r.far && (r.far = a, r.updateProjectionMatrix()), oy.setFromMatrixPosition(e.matrixWorld), r.position.copy(oy), aT.copy(r.position), aT.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(aT), r.updateMatrixWorld(), i.makeTranslation(-oy.x, -oy.y, -oy.z), PF.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(PF);
  }
}
class x$ extends Kd {
  constructor(e, t, r = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new jfe();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class Gfe extends mP {
  constructor() {
    super(new L0(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class E$ extends Kd {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(pr.DEFAULT_UP), this.updateMatrix(), this.target = new pr(), this.shadow = new Gfe();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class C$ extends Kd {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class w$ extends Kd {
  constructor(e, t, r = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class M$ {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new de());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const r = e.x, i = e.y, a = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * i), t.addScaledVector(o[2], 0.488603 * a), t.addScaledVector(o[3], 0.488603 * r), t.addScaledVector(o[4], 1.092548 * (r * i)), t.addScaledVector(o[5], 1.092548 * (i * a)), t.addScaledVector(o[6], 0.315392 * (3 * a * a - 1)), t.addScaledVector(o[7], 1.092548 * (r * a)), t.addScaledVector(o[8], 0.546274 * (r * r - i * i)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const r = e.x, i = e.y, a = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * i), t.addScaledVector(o[2], 2 * 0.511664 * a), t.addScaledVector(o[3], 2 * 0.511664 * r), t.addScaledVector(o[4], 2 * 0.429043 * r * i), t.addScaledVector(o[5], 2 * 0.429043 * i * a), t.addScaledVector(o[6], 0.743125 * a * a - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * r * a), t.addScaledVector(o[8], 0.429043 * (r * r - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++)
      r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++)
      r[i].toArray(e, t + i * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const r = e.x, i = e.y, a = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * a, t[3] = 0.488603 * r, t[4] = 1.092548 * r * i, t[5] = 1.092548 * i * a, t[6] = 0.315392 * (3 * a * a - 1), t[7] = 1.092548 * r * a, t[8] = 0.546274 * (r * r - i * i);
  }
}
class T$ extends Kd {
  constructor(e = new M$(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class hC extends Wo {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, i) {
    const a = this, o = new yu(a.manager);
    o.setPath(a.path), o.setRequestHeader(a.requestHeader), o.setWithCredentials(a.withCredentials), o.load(e, function(s) {
      try {
        t(a.parse(JSON.parse(s)));
      } catch (u) {
        i ? i(u) : console.error(u), a.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = this.textures;
    function r(a) {
      return t[a] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", a), t[a];
    }
    const i = hC.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new an().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const a in e.uniforms) {
        const o = e.uniforms[a];
        switch (i.uniforms[a] = {}, o.type) {
          case "t":
            i.uniforms[a].value = r(o.value);
            break;
          case "c":
            i.uniforms[a].value = new an().setHex(o.value);
            break;
          case "v2":
            i.uniforms[a].value = new St().fromArray(o.value);
            break;
          case "v3":
            i.uniforms[a].value = new de().fromArray(o.value);
            break;
          case "v4":
            i.uniforms[a].value = new wr().fromArray(o.value);
            break;
          case "m3":
            i.uniforms[a].value = new zn().fromArray(o.value);
            break;
          case "m4":
            i.uniforms[a].value = new wn().fromArray(o.value);
            break;
          default:
            i.uniforms[a].value = o.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const a in e.extensions)
        i.extensions[a] = e.extensions[a];
    if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let a = e.normalScale;
      Array.isArray(a) === !1 && (a = [a, a]), i.normalScale = new St().fromArray(a);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new St().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: a$,
      SpriteMaterial: tP,
      RawShaderMaterial: o$,
      ShaderMaterial: Rl,
      PointsMaterial: rP,
      MeshPhysicalMaterial: s$,
      MeshStandardMaterial: uP,
      MeshPhongMaterial: l$,
      MeshToonMaterial: c$,
      MeshNormalMaterial: u$,
      MeshLambertMaterial: d$,
      MeshDepthMaterial: JO,
      MeshDistanceMaterial: eP,
      MeshBasicMaterial: qd,
      MeshMatcapMaterial: f$,
      LineDashedMaterial: h$,
      LineBasicMaterial: vo,
      Material: Da
    };
    return new t[e]();
  }
}
class hA {
  static decodeText(e) {
    if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++)
      t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class R$ extends Xn {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class A$ extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = this, o = new yu(a.manager);
    o.setPath(a.path), o.setRequestHeader(a.requestHeader), o.setWithCredentials(a.withCredentials), o.load(e, function(s) {
      try {
        t(a.parse(JSON.parse(s)));
      } catch (u) {
        i ? i(u) : console.error(u), a.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = {}, r = {};
    function i(v, b) {
      if (t[b] !== void 0) return t[b];
      const S = v.interleavedBuffers[b], _ = a(v, S.buffer), w = $m(S.type, _), C = new ZE(w, S.stride);
      return C.uuid = S.uuid, t[b] = C, C;
    }
    function a(v, b) {
      if (r[b] !== void 0) return r[b];
      const S = v.arrayBuffers[b], _ = new Uint32Array(S).buffer;
      return r[b] = _, _;
    }
    const o = e.isInstancedBufferGeometry ? new R$() : new Xn(), s = e.data.index;
    if (s !== void 0) {
      const v = $m(s.type, s.array);
      o.setIndex(new jr(v, 1));
    }
    const u = e.data.attributes;
    for (const v in u) {
      const b = u[v];
      let E;
      if (b.isInterleavedBufferAttribute) {
        const S = i(e.data, b.data);
        E = new Fh(S, b.itemSize, b.offset, b.normalized);
      } else {
        const S = $m(b.type, b.array), _ = b.isInstancedBufferAttribute ? dg : jr;
        E = new _(S, b.itemSize, b.normalized);
      }
      b.name !== void 0 && (E.name = b.name), b.usage !== void 0 && E.setUsage(b.usage), o.setAttribute(v, E);
    }
    const d = e.data.morphAttributes;
    if (d)
      for (const v in d) {
        const b = d[v], E = [];
        for (let S = 0, _ = b.length; S < _; S++) {
          const w = b[S];
          let C;
          if (w.isInterleavedBufferAttribute) {
            const R = i(e.data, w.data);
            C = new Fh(R, w.itemSize, w.offset, w.normalized);
          } else {
            const R = $m(w.type, w.array);
            C = new jr(R, w.itemSize, w.normalized);
          }
          w.name !== void 0 && (C.name = w.name), E.push(C);
        }
        o.morphAttributes[v] = E;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const p = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (p !== void 0)
      for (let v = 0, b = p.length; v !== b; ++v) {
        const E = p[v];
        o.addGroup(E.start, E.count, E.materialIndex);
      }
    const g = e.data.boundingSphere;
    if (g !== void 0) {
      const v = new de();
      g.center !== void 0 && v.fromArray(g.center), o.boundingSphere = new Pa(v, g.radius);
    }
    return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
  }
}
class Xfe extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = this, o = this.path === "" ? hA.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const s = new yu(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function(u) {
      let d = null;
      try {
        d = JSON.parse(u);
      } catch (p) {
        i !== void 0 && i(p), console.error("THREE:ObjectLoader: Can't parse " + e + ".", p.message);
        return;
      }
      const f = d.metadata;
      if (f === void 0 || f.type === void 0 || f.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      a.parse(d, t);
    }, r, i);
  }
  async loadAsync(e, t) {
    const r = this, i = this.path === "" ? hA.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const a = new yu(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials);
    const o = await a.loadAsync(e, t), s = JSON.parse(o), u = s.metadata;
    if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(s);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), a = this.parseGeometries(e.geometries, i), o = this.parseImages(e.images, function() {
      t !== void 0 && t(d);
    }), s = this.parseTextures(e.textures, o), u = this.parseMaterials(e.materials, s), d = this.parseObject(e.object, a, u, s, r), f = this.parseSkeletons(e.skeletons, d);
    if (this.bindSkeletons(d, f), this.bindLightTargets(d), t !== void 0) {
      let p = !1;
      for (const g in o)
        if (o[g].data instanceof HTMLImageElement) {
          p = !0;
          break;
        }
      p === !1 && t(d);
    }
    return d;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), a = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, a), s = this.parseMaterials(e.materials, o), u = this.parseObject(e.object, i, s, o, t), d = this.parseSkeletons(e.skeletons, u);
    return this.bindSkeletons(u, d), this.bindLightTargets(u), u;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const a = new uu().fromJSON(e[r]);
        t[a.uuid] = a;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {}, i = {};
    if (t.traverse(function(a) {
      a.isBone && (i[a.uuid] = a);
    }), e !== void 0)
      for (let a = 0, o = e.length; a < o; a++) {
        const s = new QE().fromJSON(e[a], i);
        r[s.uuid] = s;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new A$();
      for (let a = 0, o = e.length; a < o; a++) {
        let s;
        const u = e[a];
        switch (u.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            s = i.parse(u);
            break;
          default:
            u.type in RF ? s = RF[u.type].fromJSON(u, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${u.type}"`);
        }
        s.uuid = u.uuid, u.name !== void 0 && (s.name = u.name), u.userData !== void 0 && (s.userData = u.userData), r[u.uuid] = s;
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {}, i = {};
    if (e !== void 0) {
      const a = new hC();
      a.setTextures(t);
      for (let o = 0, s = e.length; o < s; o++) {
        const u = e[o];
        r[u.uuid] === void 0 && (r[u.uuid] = a.parse(u)), i[u.uuid] = r[u.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r], a = g0.parse(i);
        t[a.uuid] = a;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this, i = {};
    let a;
    function o(u) {
      return r.manager.itemStart(u), a.load(u, function() {
        r.manager.itemEnd(u);
      }, void 0, function() {
        r.manager.itemError(u), r.manager.itemEnd(u);
      });
    }
    function s(u) {
      if (typeof u == "string") {
        const d = u, f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : r.resourcePath + d;
        return o(f);
      } else
        return u.data ? {
          data: $m(u.type, u.data),
          width: u.width,
          height: u.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const u = new pP(t);
      a = new v0(u), a.setCrossOrigin(this.crossOrigin);
      for (let d = 0, f = e.length; d < f; d++) {
        const p = e[d], g = p.url;
        if (Array.isArray(g)) {
          const v = [];
          for (let b = 0, E = g.length; b < E; b++) {
            const S = g[b], _ = s(S);
            _ !== null && (_ instanceof HTMLImageElement ? v.push(_) : v.push(new cc(_.data, _.width, _.height)));
          }
          i[p.uuid] = new hh(v);
        } else {
          const v = s(p.url);
          i[p.uuid] = new hh(v);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, r = {};
    let i;
    async function a(o) {
      if (typeof o == "string") {
        const s = o, u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s) ? s : t.resourcePath + s;
        return await i.loadAsync(u);
      } else
        return o.data ? {
          data: $m(o.type, o.data),
          width: o.width,
          height: o.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new v0(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let o = 0, s = e.length; o < s; o++) {
        const u = e[o], d = u.url;
        if (Array.isArray(d)) {
          const f = [];
          for (let p = 0, g = d.length; p < g; p++) {
            const v = d[p], b = await a(v);
            b !== null && (b instanceof HTMLImageElement ? f.push(b) : f.push(new cc(b.data, b.width, b.height)));
          }
          r[u.uuid] = new hh(f);
        } else {
          const f = await a(u.url);
          r[u.uuid] = new hh(f);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(a, o) {
      return typeof a == "number" ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), o[a]);
    }
    const i = {};
    if (e !== void 0)
      for (let a = 0, o = e.length; a < o; a++) {
        const s = e[a];
        s.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), t[s.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", s.image);
        const u = t[s.image], d = u.data;
        let f;
        Array.isArray(d) ? (f = new I0(), d.length === 6 && (f.needsUpdate = !0)) : (d && d.data ? f = new cc() : f = new Ei(), d && (f.needsUpdate = !0)), f.source = u, f.uuid = s.uuid, s.name !== void 0 && (f.name = s.name), s.mapping !== void 0 && (f.mapping = r(s.mapping, qfe)), s.channel !== void 0 && (f.channel = s.channel), s.offset !== void 0 && f.offset.fromArray(s.offset), s.repeat !== void 0 && f.repeat.fromArray(s.repeat), s.center !== void 0 && f.center.fromArray(s.center), s.rotation !== void 0 && (f.rotation = s.rotation), s.wrap !== void 0 && (f.wrapS = r(s.wrap[0], DF), f.wrapT = r(s.wrap[1], DF)), s.format !== void 0 && (f.format = s.format), s.internalFormat !== void 0 && (f.internalFormat = s.internalFormat), s.type !== void 0 && (f.type = s.type), s.colorSpace !== void 0 && (f.colorSpace = s.colorSpace), s.minFilter !== void 0 && (f.minFilter = r(s.minFilter, IF)), s.magFilter !== void 0 && (f.magFilter = r(s.magFilter, IF)), s.anisotropy !== void 0 && (f.anisotropy = s.anisotropy), s.flipY !== void 0 && (f.flipY = s.flipY), s.generateMipmaps !== void 0 && (f.generateMipmaps = s.generateMipmaps), s.premultiplyAlpha !== void 0 && (f.premultiplyAlpha = s.premultiplyAlpha), s.unpackAlignment !== void 0 && (f.unpackAlignment = s.unpackAlignment), s.compareFunction !== void 0 && (f.compareFunction = s.compareFunction), s.userData !== void 0 && (f.userData = s.userData), i[s.uuid] = f;
      }
    return i;
  }
  parseObject(e, t, r, i, a) {
    let o;
    function s(g) {
      return t[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", g), t[g];
    }
    function u(g) {
      if (g !== void 0) {
        if (Array.isArray(g)) {
          const v = [];
          for (let b = 0, E = g.length; b < E; b++) {
            const S = g[b];
            r[S] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", S), v.push(r[S]);
          }
          return v;
        }
        return r[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g), r[g];
      }
    }
    function d(g) {
      return i[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", g), i[g];
    }
    let f, p;
    switch (e.type) {
      case "Scene":
        o = new eE(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new an(e.background) : o.background = d(e.background)), e.environment !== void 0 && (o.environment = d(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new KE(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new YE(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        o = new sa(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        o = new L0(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new C$(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new E$(e.color, e.intensity), o.target = e.target || "";
        break;
      case "PointLight":
        o = new x$(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new w$(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new _$(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), o.target = e.target || "";
        break;
      case "HemisphereLight":
        o = new S$(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new T$().fromJSON(e);
        break;
      case "SkinnedMesh":
        f = s(e.geometry), p = u(e.material), o = new Wk(f, p), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        f = s(e.geometry), p = u(e.material), o = new Zi(f, p);
        break;
      case "InstancedMesh":
        f = s(e.geometry), p = u(e.material);
        const g = e.count, v = e.instanceMatrix, b = e.instanceColor;
        o = new jk(f, p, g), o.instanceMatrix = new dg(new Float32Array(v.array), 16), b !== void 0 && (o.instanceColor = new dg(new Float32Array(b.array), b.itemSize));
        break;
      case "BatchedMesh":
        f = s(e.geometry), p = u(e.material), o = new Gk(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, p), o.geometry = f, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((E) => {
          const S = new qa();
          S.min.fromArray(E.boxMin), S.max.fromArray(E.boxMax);
          const _ = new Pa();
          return _.radius = E.sphereRadius, _.center.fromArray(E.sphereCenter), {
            boxInitialized: E.boxInitialized,
            box: S,
            sphereInitialized: E.sphereInitialized,
            sphere: _
          };
        }), o._maxInstanceCount = e.maxInstanceCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = d(e.matricesTexture.uuid), e.colorsTexture !== void 0 && (o._colorsTexture = d(e.colorsTexture.uuid));
        break;
      case "LOD":
        o = new $k();
        break;
      case "Line":
        o = new $d(s(e.geometry), u(e.material));
        break;
      case "LineLoop":
        o = new Xk(s(e.geometry), u(e.material));
        break;
      case "LineSegments":
        o = new gc(s(e.geometry), u(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new qk(s(e.geometry), u(e.material));
        break;
      case "Sprite":
        o = new kk(u(e.material));
        break;
      case "Group":
        o = new jm();
        break;
      case "Bone":
        o = new nP();
        break;
      default:
        o = new pr();
    }
    if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (o.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
      const g = e.children;
      for (let v = 0; v < g.length; v++)
        o.add(this.parseObject(g[v], t, r, i, a));
    }
    if (e.animations !== void 0) {
      const g = e.animations;
      for (let v = 0; v < g.length; v++) {
        const b = g[v];
        o.animations.push(a[b]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const g = e.levels;
      for (let v = 0; v < g.length; v++) {
        const b = g[v], E = o.getObjectByProperty("uuid", b.object);
        E !== void 0 && o.addLevel(E, b.distance, b.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(r) {
      if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
        const i = t[r.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix);
      }
    });
  }
  bindLightTargets(e) {
    e.traverse(function(t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const r = t.target, i = e.getObjectByProperty("uuid", r);
        i !== void 0 ? t.target = i : t.target = new pr();
      }
    });
  }
}
const qfe = {
  UVMapping: zE,
  CubeReflectionMapping: gu,
  CubeRefractionMapping: kd,
  EquirectangularReflectionMapping: Qy,
  EquirectangularRefractionMapping: Jy,
  CubeUVReflectionMapping: _g
}, DF = {
  RepeatWrapping: e0,
  ClampToEdgeWrapping: Xs,
  MirroredRepeatWrapping: t0
}, IF = {
  NearestFilter: ba,
  NearestMipmapNearestFilter: NO,
  NearestMipmapLinearFilter: km,
  LinearFilter: Ki,
  LinearMipmapNearestFilter: Ay,
  LinearMipmapLinearFilter: oc
};
class Yfe extends Wo {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = this, o = su.get(e);
    if (o !== void 0) {
      if (a.manager.itemStart(e), o.then) {
        o.then((d) => {
          t && t(d), a.manager.itemEnd(e);
        }).catch((d) => {
          i && i(d);
        });
        return;
      }
      return setTimeout(function() {
        t && t(o), a.manager.itemEnd(e);
      }, 0), o;
    }
    const s = {};
    s.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", s.headers = this.requestHeader;
    const u = fetch(e, s).then(function(d) {
      return d.blob();
    }).then(function(d) {
      return createImageBitmap(d, Object.assign(a.options, { colorSpaceConversion: "none" }));
    }).then(function(d) {
      return su.add(e, d), t && t(d), a.manager.itemEnd(e), d;
    }).catch(function(d) {
      i && i(d), su.remove(e), a.manager.itemError(e), a.manager.itemEnd(e);
    });
    su.add(e, u), a.manager.itemStart(e);
  }
}
let O_;
class gP {
  static getContext() {
    return O_ === void 0 && (O_ = new (window.AudioContext || window.webkitAudioContext)()), O_;
  }
  static setContext(e) {
    O_ = e;
  }
}
class Kfe extends Wo {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const a = this, o = new yu(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(u) {
      try {
        const d = u.slice(0);
        gP.getContext().decodeAudioData(d, function(p) {
          t(p);
        }).catch(s);
      } catch (d) {
        s(d);
      }
    }, r, i);
    function s(u) {
      i ? i(u) : console.error(u), a.manager.itemError(e);
    }
  }
}
const NF = /* @__PURE__ */ new wn(), LF = /* @__PURE__ */ new wn(), Gf = /* @__PURE__ */ new wn();
class Zfe {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new sa(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new sa(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Gf.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, a = i * t.near / t.focus, o = t.near * Math.tan(Ch * t.fov * 0.5) / t.zoom;
      let s, u;
      LF.elements[12] = -i, NF.elements[12] = i, s = -o * t.aspect + a, u = o * t.aspect + a, Gf.elements[0] = 2 * t.near / (u - s), Gf.elements[8] = (u + s) / (u - s), this.cameraL.projectionMatrix.copy(Gf), s = -o * t.aspect - a, u = o * t.aspect - a, Gf.elements[0] = 2 * t.near / (u - s), Gf.elements[8] = (u + s) / (u - s), this.cameraR.projectionMatrix.copy(Gf);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(LF), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(NF);
  }
}
class vP {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = FF(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = FF();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function FF() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Xf = /* @__PURE__ */ new de(), UF = /* @__PURE__ */ new po(), Qfe = /* @__PURE__ */ new de(), qf = /* @__PURE__ */ new de();
class Jfe extends pr {
  constructor() {
    super(), this.type = "AudioListener", this.context = gP.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new vP();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, r = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Xf, UF, Qfe), qf.set(0, 0, -1).applyQuaternion(UF), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Xf.x, i), t.positionY.linearRampToValueAtTime(Xf.y, i), t.positionZ.linearRampToValueAtTime(Xf.z, i), t.forwardX.linearRampToValueAtTime(qf.x, i), t.forwardY.linearRampToValueAtTime(qf.y, i), t.forwardZ.linearRampToValueAtTime(qf.z, i), t.upX.linearRampToValueAtTime(r.x, i), t.upY.linearRampToValueAtTime(r.y, i), t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(Xf.x, Xf.y, Xf.z), t.setOrientation(qf.x, qf.y, qf.z, r.x, r.y, r.z);
  }
}
class O$ extends pr {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const Yf = /* @__PURE__ */ new de(), zF = /* @__PURE__ */ new po(), ehe = /* @__PURE__ */ new de(), Kf = /* @__PURE__ */ new de();
class the extends O$ {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, r) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(Yf, zF, ehe), Kf.set(0, 0, 1).applyQuaternion(zF);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Yf.x, r), t.positionY.linearRampToValueAtTime(Yf.y, r), t.positionZ.linearRampToValueAtTime(Yf.z, r), t.orientationX.linearRampToValueAtTime(Kf.x, r), t.orientationY.linearRampToValueAtTime(Kf.y, r), t.orientationZ.linearRampToValueAtTime(Kf.z, r);
    } else
      t.setPosition(Yf.x, Yf.y, Yf.z), t.setOrientation(Kf.x, Kf.y, Kf.z);
  }
}
class nhe {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++)
      e += t[r];
    return e / t.length;
  }
}
class P$ {
  constructor(e, t, r) {
    this.binding = e, this.valueSize = r;
    let i, a, o;
    switch (t) {
      case "quaternion":
        i = this._slerp, a = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, a = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
        break;
      default:
        i = this._lerp, a = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = a, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const r = this.buffer, i = this.valueSize, a = e * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let s = 0; s !== i; ++s)
        r[a + s] = r[s];
      o = t;
    } else {
      o += t;
      const s = t / o;
      this._mixBufferRegion(r, a, 0, s, i);
    }
    this.cumulativeWeight = o;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, r = this.valueSize, i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, r), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, r = this.buffer, i = e * t + t, a = this.cumulativeWeight, o = this.cumulativeWeightAdditive, s = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, a < 1) {
      const u = t * this._origIndex;
      this._mixBufferRegion(
        r,
        i,
        u,
        1 - a,
        t
      );
    }
    o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let u = t, d = t + t; u !== d; ++u)
      if (r[u] !== r[u + t]) {
        s.setValue(r, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, r = this.valueSize, i = r * this._origIndex;
    e.getValue(t, i);
    for (let a = r, o = i; a !== o; ++a)
      t[a] = t[i + a % r];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let r = e; r < t; r++)
      this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  // mix functions
  _select(e, t, r, i, a) {
    if (i >= 0.5)
      for (let o = 0; o !== a; ++o)
        e[t + o] = e[r + o];
  }
  _slerp(e, t, r, i) {
    po.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, a) {
    const o = this._workIndex * a;
    po.multiplyQuaternionsFlat(e, o, e, t, e, r), po.slerpFlat(e, t, e, t, e, o, i);
  }
  _lerp(e, t, r, i, a) {
    const o = 1 - i;
    for (let s = 0; s !== a; ++s) {
      const u = t + s;
      e[u] = e[u] * o + e[r + s] * i;
    }
  }
  _lerpAdditive(e, t, r, i, a) {
    for (let o = 0; o !== a; ++o) {
      const s = t + o;
      e[s] = e[s] + e[r + o] * i;
    }
  }
}
const yP = "\\[\\]\\.:\\/", rhe = new RegExp("[" + yP + "]", "g"), bP = "[^" + yP + "]", ihe = "[^" + yP.replace("\\.", "") + "]", ahe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", bP), ohe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", ihe), she = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", bP), lhe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", bP), che = new RegExp(
  "^" + ahe + ohe + she + lhe + "$"
), uhe = ["material", "materials", "bones", "map"];
class dhe {
  constructor(e, t, r) {
    const i = r || hr.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_, i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, a = r.length; i !== a; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class hr {
  constructor(e, t, r) {
    this.path = t, this.parsedPath = r || hr.parseTrackName(t), this.node = hr.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup ? new hr.Composite(e, t, r) : new hr(e, t, r);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(rhe, "");
  }
  static parseTrackName(e) {
    const t = che.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const a = r.nodeName.substring(i + 1);
      uhe.indexOf(a) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = a);
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return r;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0)
        return r;
    }
    if (e.children) {
      const r = function(a) {
        for (let o = 0; o < a.length; o++) {
          const s = a[o];
          if (s.name === t || s.uuid === t)
            return s;
          const u = r(s.children);
          if (u) return u;
        }
        return null;
      }, i = r(e.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, a = r.length; i !== a; ++i)
      e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, a = r.length; i !== a; ++i)
      r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, a = r.length; i !== a; ++i)
      r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, a = r.length; i !== a; ++i)
      r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, r = t.objectName, i = t.propertyName;
    let a = t.propertyIndex;
    if (e || (e = hr.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (r) {
      let d = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let f = 0; f < e.length; f++)
            if (e[f].name === d) {
              d = f;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[r];
      }
      if (d !== void 0) {
        if (e[d] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[d];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const d = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + d + "." + i + " but it wasn't found.", e);
      return;
    }
    let s = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? s = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (s = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (a !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[a] !== void 0 && (a = e.morphTargetDictionary[a]);
      }
      u = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = a;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (u = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][s];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
hr.Composite = dhe;
hr.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
hr.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
hr.prototype.GetterByBindingType = [
  hr.prototype._getValue_direct,
  hr.prototype._getValue_array,
  hr.prototype._getValue_arrayElement,
  hr.prototype._getValue_toArray
];
hr.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    hr.prototype._setValue_direct,
    hr.prototype._setValue_direct_setNeedsUpdate,
    hr.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    hr.prototype._setValue_array,
    hr.prototype._setValue_array_setNeedsUpdate,
    hr.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    hr.prototype._setValue_arrayElement,
    hr.prototype._setValue_arrayElement_setNeedsUpdate,
    hr.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    hr.prototype._setValue_fromArray,
    hr.prototype._setValue_fromArray_setNeedsUpdate,
    hr.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class fhe {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = ps(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, r = this._paths, i = this._parsedPaths, a = this._bindings, o = a.length;
    let s, u = e.length, d = this.nCachedObjects_;
    for (let f = 0, p = arguments.length; f !== p; ++f) {
      const g = arguments[f], v = g.uuid;
      let b = t[v];
      if (b === void 0) {
        b = u++, t[v] = b, e.push(g);
        for (let E = 0, S = o; E !== S; ++E)
          a[E].push(new hr(g, r[E], i[E]));
      } else if (b < d) {
        s = e[b];
        const E = --d, S = e[E];
        t[S.uuid] = b, e[b] = S, t[v] = E, e[E] = g;
        for (let _ = 0, w = o; _ !== w; ++_) {
          const C = a[_], R = C[E];
          let P = C[b];
          C[b] = R, P === void 0 && (P = new hr(g, r[_], i[_])), C[E] = P;
        }
      } else e[b] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = d;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length;
    let a = this.nCachedObjects_;
    for (let o = 0, s = arguments.length; o !== s; ++o) {
      const u = arguments[o], d = u.uuid, f = t[d];
      if (f !== void 0 && f >= a) {
        const p = a++, g = e[p];
        t[g.uuid] = f, e[f] = g, t[d] = p, e[p] = u;
        for (let v = 0, b = i; v !== b; ++v) {
          const E = r[v], S = E[p], _ = E[f];
          E[f] = S, E[p] = _;
        }
      }
    }
    this.nCachedObjects_ = a;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length;
    let a = this.nCachedObjects_, o = e.length;
    for (let s = 0, u = arguments.length; s !== u; ++s) {
      const d = arguments[s], f = d.uuid, p = t[f];
      if (p !== void 0)
        if (delete t[f], p < a) {
          const g = --a, v = e[g], b = --o, E = e[b];
          t[v.uuid] = p, e[p] = v, t[E.uuid] = g, e[g] = E, e.pop();
          for (let S = 0, _ = i; S !== _; ++S) {
            const w = r[S], C = w[g], R = w[b];
            w[p] = C, w[g] = R, w.pop();
          }
        } else {
          const g = --o, v = e[g];
          g > 0 && (t[v.uuid] = p), e[p] = v, e.pop();
          for (let b = 0, E = i; b !== E; ++b) {
            const S = r[b];
            S[p] = S[g], S.pop();
          }
        }
    }
    this.nCachedObjects_ = a;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const a = this._bindings;
    if (i !== void 0) return a[i];
    const o = this._paths, s = this._parsedPaths, u = this._objects, d = u.length, f = this.nCachedObjects_, p = new Array(d);
    i = a.length, r[e] = i, o.push(e), s.push(t), a.push(p);
    for (let g = f, v = u.length; g !== v; ++g) {
      const b = u[g];
      p[g] = new hr(b, e, t);
    }
    return p;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, r = t[e];
    if (r !== void 0) {
      const i = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length - 1, u = o[s], d = e[s];
      t[d] = r, o[r] = u, o.pop(), a[r] = a[s], a.pop(), i[r] = i[s], i.pop();
    }
  }
}
class D$ {
  constructor(e, t, r = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = i;
    const a = t.tracks, o = a.length, s = new Array(o), u = {
      endingStart: dh,
      endingEnd: dh
    };
    for (let d = 0; d !== o; ++d) {
      const f = a[d].createInterpolant(null);
      s[d] = f, f.settings = u;
    }
    this._interpolantSettings = u, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = dk, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if (e.fadeOut(t), this.fadeIn(t), r) {
      const i = this._clip.duration, a = e._clip.duration, o = a / i, s = i / a;
      e.warp(1, o, t), this.warp(s, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer, a = i.time, o = this.timeScale;
    let s = this._timeScaleInterpolant;
    s === null && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s);
    const u = s.parameterPositions, d = s.sampleValues;
    return u[0] = a, u[1] = a + r, d[0] = e / o, d[1] = t / o, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const a = this._startTime;
    if (a !== null) {
      const u = (e - a) * r;
      u < 0 || r === 0 ? t = 0 : (this._startTime = null, t = r * u);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), s = this._updateWeight(e);
    if (s > 0) {
      const u = this._interpolants, d = this._propertyBindings;
      switch (this.blendMode) {
        case WO:
          for (let f = 0, p = u.length; f !== p; ++f)
            u[f].evaluate(o), d[f].accumulateAdditive(s);
          break;
        case jE:
        default:
          for (let f = 0, p = u.length; f !== p; ++f)
            u[f].evaluate(o), d[f].accumulate(i, s);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        t *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        t *= i, e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, r = this.loop;
    let i = this.time + e, a = this._loopCount;
    const o = r === fk;
    if (e === 0)
      return a === -1 ? i : o && (a & 1) === 1 ? t - i : i;
    if (r === uk) {
      a === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (a === -1 && (e >= 0 ? (a = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), i >= t || i < 0) {
        const s = Math.floor(i / t);
        i -= t * s, a += Math.abs(s);
        const u = this.repetitions - a;
        if (u <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (u === 1) {
            const d = e < 0;
            this._setEndings(d, !d, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = a, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: s
          });
        }
      } else
        this.time = i;
      if (o && (a & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r ? (i.endingStart = fh, i.endingEnd = fh) : (e ? i.endingStart = this.zeroSlopeAtStart ? fh : dh : i.endingStart = r0, t ? i.endingEnd = this.zeroSlopeAtEnd ? fh : dh : i.endingEnd = r0);
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer, a = i.time;
    let o = this._weightInterpolant;
    o === null && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
    const s = o.parameterPositions, u = o.sampleValues;
    return s[0] = a, u[0] = t, s[1] = a + e, u[1] = r, this;
  }
}
const hhe = new Float32Array(1);
class phe extends Eu {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root, i = e._clip.tracks, a = i.length, o = e._propertyBindings, s = e._interpolants, u = r.uuid, d = this._bindingsByRootAndName;
    let f = d[u];
    f === void 0 && (f = {}, d[u] = f);
    for (let p = 0; p !== a; ++p) {
      const g = i[p], v = g.name;
      let b = f[v];
      if (b !== void 0)
        ++b.referenceCount, o[p] = b;
      else {
        if (b = o[p], b !== void 0) {
          b._cacheIndex === null && (++b.referenceCount, this._addInactiveBinding(b, u, v));
          continue;
        }
        const E = t && t._propertyBindings[p].binding.parsedPath;
        b = new P$(
          hr.create(r, v, E),
          g.ValueTypeName,
          g.getValueSize()
        ), ++b.referenceCount, this._addInactiveBinding(b, u, v), o[p] = b;
      }
      s[p].resultBuffer = b.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid, i = e._clip.uuid, a = this._actionsByClip[i];
        this._bindAction(
          e,
          a && a.knownActions[0]
        ), this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const a = t[r];
        a.useCount++ === 0 && (this._lendBinding(a), a.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const a = t[r];
        --a.useCount === 0 && (a.restoreOriginalState(), this._takeBackBinding(a));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions, a = this._actionsByClip;
    let o = a[t];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, a[t] = o;
    else {
      const s = o.knownActions;
      e._byClipCacheIndex = s.length, s.push(e);
    }
    e._cacheIndex = i.length, i.push(e), o.actionByRoot[r] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, r = t[t.length - 1], i = e._cacheIndex;
    r._cacheIndex = i, t[i] = r, t.pop(), e._cacheIndex = null;
    const a = e._clip.uuid, o = this._actionsByClip, s = o[a], u = s.knownActions, d = u[u.length - 1], f = e._byClipCacheIndex;
    d._byClipCacheIndex = f, u[f] = d, u.pop(), e._byClipCacheIndex = null;
    const p = s.actionByRoot, g = (e._localRoot || this._root).uuid;
    delete p[g], u.length === 0 && delete o[a], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const a = t[r];
      --a.referenceCount === 0 && this._removeInactiveBinding(a);
    }
  }
  _lendAction(e) {
    const t = this._actions, r = e._cacheIndex, i = this._nActiveActions++, a = t[i];
    e._cacheIndex = i, t[i] = e, a._cacheIndex = r, t[r] = a;
  }
  _takeBackAction(e) {
    const t = this._actions, r = e._cacheIndex, i = --this._nActiveActions, a = t[i];
    e._cacheIndex = i, t[i] = e, a._cacheIndex = r, t[r] = a;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName, a = this._bindings;
    let o = i[t];
    o === void 0 && (o = {}, i[t] = o), o[r] = e, e._cacheIndex = a.length, a.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, r = e.binding, i = r.rootNode.uuid, a = r.path, o = this._bindingsByRootAndName, s = o[i], u = t[t.length - 1], d = e._cacheIndex;
    u._cacheIndex = d, t[d] = u, t.pop(), delete s[a], Object.keys(s).length === 0 && delete o[i];
  }
  _lendBinding(e) {
    const t = this._bindings, r = e._cacheIndex, i = this._nActiveBindings++, a = t[i];
    e._cacheIndex = i, t[i] = e, a._cacheIndex = r, t[r] = a;
  }
  _takeBackBinding(e) {
    const t = this._bindings, r = e._cacheIndex, i = --this._nActiveBindings, a = t[i];
    e._cacheIndex = i, t[i] = e, a._cacheIndex = r, t[r] = a;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let r = e[t];
    return r === void 0 && (r = new fP(
      new Float32Array(2),
      new Float32Array(2),
      1,
      hhe
    ), r.__cacheIndex = t, e[t] = r), r;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, r = e.__cacheIndex, i = --this._nActiveControlInterpolants, a = t[i];
    e.__cacheIndex = i, t[i] = e, a.__cacheIndex = r, t[r] = a;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, r) {
    const i = t || this._root, a = i.uuid;
    let o = typeof e == "string" ? g0.findByName(i, e) : e;
    const s = o !== null ? o.uuid : e, u = this._actionsByClip[s];
    let d = null;
    if (r === void 0 && (o !== null ? r = o.blendMode : r = jE), u !== void 0) {
      const p = u.actionByRoot[a];
      if (p !== void 0 && p.blendMode === r)
        return p;
      d = u.knownActions[0], o === null && (o = d._clip);
    }
    if (o === null) return null;
    const f = new D$(this, o, t, r);
    return this._bindAction(f, d), this._addInactiveAction(f, s, a), f;
  }
  // get an existing action
  existingAction(e, t) {
    const r = t || this._root, i = r.uuid, a = typeof e == "string" ? g0.findByName(r, e) : e, o = a ? a.uuid : e, s = this._actionsByClip[o];
    return s !== void 0 && s.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r)
      e[r].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, r = this._nActiveActions, i = this.time += e, a = Math.sign(e), o = this._accuIndex ^= 1;
    for (let d = 0; d !== r; ++d)
      t[d]._update(i, e, a, o);
    const s = this._bindings, u = this._nActiveBindings;
    for (let d = 0; d !== u; ++d)
      s[d].apply(o);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, r = e.uuid, i = this._actionsByClip, a = i[r];
    if (a !== void 0) {
      const o = a.knownActions;
      for (let s = 0, u = o.length; s !== u; ++s) {
        const d = o[s];
        this._deactivateAction(d);
        const f = d._cacheIndex, p = t[t.length - 1];
        d._cacheIndex = null, d._byClipCacheIndex = null, p._cacheIndex = f, t[f] = p, t.pop(), this._removeInactiveBindingsForAction(d);
      }
      delete i[r];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, r = this._actionsByClip;
    for (const o in r) {
      const s = r[o].actionByRoot, u = s[t];
      u !== void 0 && (this._deactivateAction(u), this._removeInactiveAction(u));
    }
    const i = this._bindingsByRootAndName, a = i[t];
    if (a !== void 0)
      for (const o in a) {
        const s = a[o];
        s.restoreOriginalState(), this._removeInactiveBinding(s);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class SP {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new SP(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let mhe = 0;
class ghe extends Eu {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: mhe++ }), this.name = "", this.usage = s0, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const a = Array.isArray(t[r]) ? t[r] : [t[r]];
      for (let o = 0; o < a.length; o++)
        this.uniforms.push(a[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class vhe extends ZE {
  constructor(e, t, r = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class yhe {
  constructor(e, t, r, i, a) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = i, this.count = a, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
const BF = /* @__PURE__ */ new wn();
class _P {
  constructor(e, t, r = 0, i = 1 / 0) {
    this.ray = new Eg(e, t), this.near = r, this.far = i, this.camera = null, this.layers = new wh(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return BF.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(BF), this;
  }
  intersectObject(e, t = !0, r = []) {
    return pA(e, this, r, t), r.sort(HF), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, a = e.length; i < a; i++)
      pA(e[i], this, r, t);
    return r.sort(HF), r;
  }
}
function HF(n, e) {
  return n.distance - e.distance;
}
function pA(n, e, t, r) {
  let i = !0;
  if (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (i = !1), i === !0 && r === !0) {
    const a = n.children;
    for (let o = 0, s = a.length; o < s; o++)
      pA(a[o], e, t, !0);
  }
}
class I$ {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(Ti(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class bhe {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const VF = /* @__PURE__ */ new St();
class She {
  constructor(e = new St(1 / 0, 1 / 0), t = new St(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = VF.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, VF).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const kF = /* @__PURE__ */ new de(), P_ = /* @__PURE__ */ new de();
class _he {
  constructor(e = new de(), t = new de()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    kF.subVectors(e, this.start), P_.subVectors(this.end, this.start);
    const r = P_.dot(P_);
    let a = P_.dot(kF) / r;
    return t && (a = Ti(a, 0, 1)), a;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $F = /* @__PURE__ */ new de();
class xhe extends pr {
  constructor(e, t) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const r = new Xn(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let o = 0, s = 1, u = 32; o < u; o++, s++) {
      const d = o / u * Math.PI * 2, f = s / u * Math.PI * 2;
      i.push(
        Math.cos(d),
        Math.sin(d),
        1,
        Math.cos(f),
        Math.sin(f),
        1
      );
    }
    r.setAttribute("position", new fn(i, 3));
    const a = new vo({ fog: !1, toneMapped: !1 });
    this.cone = new gc(r, a), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), $F.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt($F), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const Ad = /* @__PURE__ */ new de(), D_ = /* @__PURE__ */ new wn(), oT = /* @__PURE__ */ new wn();
class Ehe extends gc {
  constructor(e) {
    const t = N$(e), r = new Xn(), i = [], a = [], o = new an(0, 0, 1), s = new an(0, 1, 0);
    for (let d = 0; d < t.length; d++) {
      const f = t[d];
      f.parent && f.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), a.push(o.r, o.g, o.b), a.push(s.r, s.g, s.b));
    }
    r.setAttribute("position", new fn(i, 3)), r.setAttribute("color", new fn(a, 3));
    const u = new vo({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(r, u), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, r = this.geometry, i = r.getAttribute("position");
    oT.copy(this.root.matrixWorld).invert();
    for (let a = 0, o = 0; a < t.length; a++) {
      const s = t[a];
      s.parent && s.parent.isBone && (D_.multiplyMatrices(oT, s.matrixWorld), Ad.setFromMatrixPosition(D_), i.setXYZ(o, Ad.x, Ad.y, Ad.z), D_.multiplyMatrices(oT, s.parent.matrixWorld), Ad.setFromMatrixPosition(D_), i.setXYZ(o + 1, Ad.x, Ad.y, Ad.z), o += 2);
    }
    r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function N$(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, N$(n.children[t]));
  return e;
}
class Che extends Zi {
  constructor(e, t, r) {
    const i = new z0(t, 4, 2), a = new qd({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, a), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const whe = /* @__PURE__ */ new de(), WF = /* @__PURE__ */ new an(), jF = /* @__PURE__ */ new an();
class Mhe extends pr {
  constructor(e, t, r) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper";
    const i = new U0(t);
    i.rotateY(Math.PI * 0.5), this.material = new qd({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const a = i.getAttribute("position"), o = new Float32Array(a.count * 3);
    i.setAttribute("color", new jr(o, 3)), this.add(new Zi(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      WF.copy(this.light.color), jF.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const a = r < i / 2 ? WF : jF;
        t.setXYZ(r, a.r, a.g, a.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(whe.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class The extends gc {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    r = new an(r), i = new an(i);
    const a = t / 2, o = e / t, s = e / 2, u = [], d = [];
    for (let g = 0, v = 0, b = -s; g <= t; g++, b += o) {
      u.push(-s, 0, b, s, 0, b), u.push(b, 0, -s, b, 0, s);
      const E = g === a ? r : i;
      E.toArray(d, v), v += 3, E.toArray(d, v), v += 3, E.toArray(d, v), v += 3, E.toArray(d, v), v += 3;
    }
    const f = new Xn();
    f.setAttribute("position", new fn(u, 3)), f.setAttribute("color", new fn(d, 3));
    const p = new vo({ vertexColors: !0, toneMapped: !1 });
    super(f, p), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Rhe extends gc {
  constructor(e = 10, t = 16, r = 8, i = 64, a = 4473924, o = 8947848) {
    a = new an(a), o = new an(o);
    const s = [], u = [];
    if (t > 1)
      for (let p = 0; p < t; p++) {
        const g = p / t * (Math.PI * 2), v = Math.sin(g) * e, b = Math.cos(g) * e;
        s.push(0, 0, 0), s.push(v, 0, b);
        const E = p & 1 ? a : o;
        u.push(E.r, E.g, E.b), u.push(E.r, E.g, E.b);
      }
    for (let p = 0; p < r; p++) {
      const g = p & 1 ? a : o, v = e - e / r * p;
      for (let b = 0; b < i; b++) {
        let E = b / i * (Math.PI * 2), S = Math.sin(E) * v, _ = Math.cos(E) * v;
        s.push(S, 0, _), u.push(g.r, g.g, g.b), E = (b + 1) / i * (Math.PI * 2), S = Math.sin(E) * v, _ = Math.cos(E) * v, s.push(S, 0, _), u.push(g.r, g.g, g.b);
      }
    }
    const d = new Xn();
    d.setAttribute("position", new fn(s, 3)), d.setAttribute("color", new fn(u, 3));
    const f = new vo({ vertexColors: !0, toneMapped: !1 });
    super(d, f), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const GF = /* @__PURE__ */ new de(), I_ = /* @__PURE__ */ new de(), XF = /* @__PURE__ */ new de();
class Ahe extends pr {
  constructor(e, t, r) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let i = new Xn();
    i.setAttribute("position", new fn([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const a = new vo({ fog: !1, toneMapped: !1 });
    this.lightPlane = new $d(i, a), this.add(this.lightPlane), i = new Xn(), i.setAttribute("position", new fn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new $d(i, a), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), GF.setFromMatrixPosition(this.light.matrixWorld), I_.setFromMatrixPosition(this.light.target.matrixWorld), XF.subVectors(I_, GF), this.lightPlane.lookAt(I_), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(I_), this.targetLine.scale.z = XF.length();
  }
}
const N_ = /* @__PURE__ */ new de(), Mi = /* @__PURE__ */ new D0();
class Ohe extends gc {
  constructor(e) {
    const t = new Xn(), r = new vo({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], a = [], o = {};
    s("n1", "n2"), s("n2", "n4"), s("n4", "n3"), s("n3", "n1"), s("f1", "f2"), s("f2", "f4"), s("f4", "f3"), s("f3", "f1"), s("n1", "f1"), s("n2", "f2"), s("n3", "f3"), s("n4", "f4"), s("p", "n1"), s("p", "n2"), s("p", "n3"), s("p", "n4"), s("u1", "u2"), s("u2", "u3"), s("u3", "u1"), s("c", "t"), s("p", "c"), s("cn1", "cn2"), s("cn3", "cn4"), s("cf1", "cf2"), s("cf3", "cf4");
    function s(b, E) {
      u(b), u(E);
    }
    function u(b) {
      i.push(0, 0, 0), a.push(0, 0, 0), o[b] === void 0 && (o[b] = []), o[b].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new fn(i, 3)), t.setAttribute("color", new fn(a, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
    const d = new an(16755200), f = new an(16711680), p = new an(43775), g = new an(16777215), v = new an(3355443);
    this.setColors(d, f, p, g, v);
  }
  setColors(e, t, r, i, a) {
    const s = this.geometry.getAttribute("color");
    s.setXYZ(0, e.r, e.g, e.b), s.setXYZ(1, e.r, e.g, e.b), s.setXYZ(2, e.r, e.g, e.b), s.setXYZ(3, e.r, e.g, e.b), s.setXYZ(4, e.r, e.g, e.b), s.setXYZ(5, e.r, e.g, e.b), s.setXYZ(6, e.r, e.g, e.b), s.setXYZ(7, e.r, e.g, e.b), s.setXYZ(8, e.r, e.g, e.b), s.setXYZ(9, e.r, e.g, e.b), s.setXYZ(10, e.r, e.g, e.b), s.setXYZ(11, e.r, e.g, e.b), s.setXYZ(12, e.r, e.g, e.b), s.setXYZ(13, e.r, e.g, e.b), s.setXYZ(14, e.r, e.g, e.b), s.setXYZ(15, e.r, e.g, e.b), s.setXYZ(16, e.r, e.g, e.b), s.setXYZ(17, e.r, e.g, e.b), s.setXYZ(18, e.r, e.g, e.b), s.setXYZ(19, e.r, e.g, e.b), s.setXYZ(20, e.r, e.g, e.b), s.setXYZ(21, e.r, e.g, e.b), s.setXYZ(22, e.r, e.g, e.b), s.setXYZ(23, e.r, e.g, e.b), s.setXYZ(24, t.r, t.g, t.b), s.setXYZ(25, t.r, t.g, t.b), s.setXYZ(26, t.r, t.g, t.b), s.setXYZ(27, t.r, t.g, t.b), s.setXYZ(28, t.r, t.g, t.b), s.setXYZ(29, t.r, t.g, t.b), s.setXYZ(30, t.r, t.g, t.b), s.setXYZ(31, t.r, t.g, t.b), s.setXYZ(32, r.r, r.g, r.b), s.setXYZ(33, r.r, r.g, r.b), s.setXYZ(34, r.r, r.g, r.b), s.setXYZ(35, r.r, r.g, r.b), s.setXYZ(36, r.r, r.g, r.b), s.setXYZ(37, r.r, r.g, r.b), s.setXYZ(38, i.r, i.g, i.b), s.setXYZ(39, i.r, i.g, i.b), s.setXYZ(40, a.r, a.g, a.b), s.setXYZ(41, a.r, a.g, a.b), s.setXYZ(42, a.r, a.g, a.b), s.setXYZ(43, a.r, a.g, a.b), s.setXYZ(44, a.r, a.g, a.b), s.setXYZ(45, a.r, a.g, a.b), s.setXYZ(46, a.r, a.g, a.b), s.setXYZ(47, a.r, a.g, a.b), s.setXYZ(48, a.r, a.g, a.b), s.setXYZ(49, a.r, a.g, a.b), s.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, r = 1, i = 1;
    Mi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Bi("c", t, e, Mi, 0, 0, -1), Bi("t", t, e, Mi, 0, 0, 1), Bi("n1", t, e, Mi, -r, -i, -1), Bi("n2", t, e, Mi, r, -i, -1), Bi("n3", t, e, Mi, -r, i, -1), Bi("n4", t, e, Mi, r, i, -1), Bi("f1", t, e, Mi, -r, -i, 1), Bi("f2", t, e, Mi, r, -i, 1), Bi("f3", t, e, Mi, -r, i, 1), Bi("f4", t, e, Mi, r, i, 1), Bi("u1", t, e, Mi, r * 0.7, i * 1.1, -1), Bi("u2", t, e, Mi, -r * 0.7, i * 1.1, -1), Bi("u3", t, e, Mi, 0, i * 2, -1), Bi("cf1", t, e, Mi, -r, 0, 1), Bi("cf2", t, e, Mi, r, 0, 1), Bi("cf3", t, e, Mi, 0, -i, 1), Bi("cf4", t, e, Mi, 0, i, 1), Bi("cn1", t, e, Mi, -r, 0, -1), Bi("cn2", t, e, Mi, r, 0, -1), Bi("cn3", t, e, Mi, 0, -i, -1), Bi("cn4", t, e, Mi, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Bi(n, e, t, r, i, a, o) {
  N_.set(i, a, o).unproject(r);
  const s = e[n];
  if (s !== void 0) {
    const u = t.getAttribute("position");
    for (let d = 0, f = s.length; d < f; d++)
      u.setXYZ(s[d], N_.x, N_.y, N_.z);
  }
}
const L_ = /* @__PURE__ */ new qa();
class Phe extends gc {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), a = new Xn();
    a.setIndex(new jr(r, 1)), a.setAttribute("position", new jr(i, 3)), super(a, new vo({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && L_.setFromObject(this.object), L_.isEmpty()) return;
    const t = L_.min, r = L_.max, i = this.geometry.attributes.position, a = i.array;
    a[0] = r.x, a[1] = r.y, a[2] = r.z, a[3] = t.x, a[4] = r.y, a[5] = r.z, a[6] = t.x, a[7] = t.y, a[8] = r.z, a[9] = r.x, a[10] = t.y, a[11] = r.z, a[12] = r.x, a[13] = r.y, a[14] = t.z, a[15] = t.x, a[16] = r.y, a[17] = t.z, a[18] = t.x, a[19] = t.y, a[20] = t.z, a[21] = r.x, a[22] = t.y, a[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Dhe extends gc {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], a = new Xn();
    a.setIndex(new jr(r, 1)), a.setAttribute("position", new fn(i, 3)), super(a, new vo({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Ihe extends $d {
  constructor(e, t = 1, r = 16776960) {
    const i = r, a = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new Xn();
    o.setAttribute("position", new fn(a, 3)), o.computeBoundingSphere(), super(o, new vo({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const s = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], u = new Xn();
    u.setAttribute("position", new fn(s, 3)), u.computeBoundingSphere(), this.add(new Zi(u, new qd({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const qF = /* @__PURE__ */ new de();
let F_, sT;
class Nhe extends pr {
  // dir is assumed to be normalized
  constructor(e = new de(0, 0, 1), t = new de(0, 0, 0), r = 1, i = 16776960, a = r * 0.2, o = a * 0.2) {
    super(), this.type = "ArrowHelper", F_ === void 0 && (F_ = new Xn(), F_.setAttribute("position", new fn([0, 0, 0, 0, 1, 0], 3)), sT = new Mg(0, 0.5, 1, 5, 1), sT.translate(0, -0.5, 0)), this.position.copy(t), this.line = new $d(F_, new vo({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Zi(sT, new qd({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, a, o);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      qF.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(qF, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class Lhe extends gc {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], r = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new Xn();
    i.setAttribute("position", new fn(t, 3)), i.setAttribute("color", new fn(r, 3));
    const a = new vo({ vertexColors: !0, toneMapped: !1 });
    super(i, a), this.type = "AxesHelper";
  }
  setColors(e, t, r) {
    const i = new an(), a = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(a, 0), i.toArray(a, 3), i.set(t), i.toArray(a, 6), i.toArray(a, 9), i.set(r), i.toArray(a, 12), i.toArray(a, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Fhe {
  constructor() {
    this.type = "ShapePath", this.color = new an(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new u0(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, a, o) {
    return this.currentPath.bezierCurveTo(e, t, r, i, a, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(_) {
      const w = [];
      for (let C = 0, R = _.length; C < R; C++) {
        const P = _[C], D = new uu();
        D.curves = P.curves, w.push(D);
      }
      return w;
    }
    function r(_, w) {
      const C = w.length;
      let R = !1;
      for (let P = C - 1, D = 0; D < C; P = D++) {
        let I = w[P], U = w[D], L = U.x - I.x, N = U.y - I.y;
        if (Math.abs(N) > Number.EPSILON) {
          if (N < 0 && (I = w[D], L = -L, U = w[P], N = -N), _.y < I.y || _.y > U.y) continue;
          if (_.y === I.y) {
            if (_.x === I.x) return !0;
          } else {
            const H = N * (_.x - I.x) - L * (_.y - I.y);
            if (H === 0) return !0;
            if (H < 0) continue;
            R = !R;
          }
        } else {
          if (_.y !== I.y) continue;
          if (U.x <= _.x && _.x <= I.x || I.x <= _.x && _.x <= U.x) return !0;
        }
      }
      return R;
    }
    const i = uc.isClockWise, a = this.subPaths;
    if (a.length === 0) return [];
    let o, s, u;
    const d = [];
    if (a.length === 1)
      return s = a[0], u = new uu(), u.curves = s.curves, d.push(u), d;
    let f = !i(a[0].getPoints());
    f = e ? !f : f;
    const p = [], g = [];
    let v = [], b = 0, E;
    g[b] = void 0, v[b] = [];
    for (let _ = 0, w = a.length; _ < w; _++)
      s = a[_], E = s.getPoints(), o = i(E), o = e ? !o : o, o ? (!f && g[b] && b++, g[b] = { s: new uu(), p: E }, g[b].s.curves = s.curves, f && b++, v[b] = []) : v[b].push({ h: s, p: E[0] });
    if (!g[0]) return t(a);
    if (g.length > 1) {
      let _ = !1, w = 0;
      for (let C = 0, R = g.length; C < R; C++)
        p[C] = [];
      for (let C = 0, R = g.length; C < R; C++) {
        const P = v[C];
        for (let D = 0; D < P.length; D++) {
          const I = P[D];
          let U = !0;
          for (let L = 0; L < g.length; L++)
            r(I.p, g[L].p) && (C !== L && w++, U ? (U = !1, p[L].push(I)) : _ = !0);
          U && p[C].push(I);
        }
      }
      w > 0 && _ === !1 && (v = p);
    }
    let S;
    for (let _ = 0, w = g.length; _ < w; _++) {
      u = g[_].s, d.push(u), S = v[_];
      for (let C = 0, R = S.length; C < R; C++)
        u.holes.push(S[C].h);
    }
    return d;
  }
}
class Uhe extends Tl {
  // @deprecated, r162
  constructor(e = 1, t = 1, r = 1, i = {}) {
    console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, { ...i, count: r }), this.isWebGLMultipleRenderTargets = !0;
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: FE
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = FE);
const zhe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: IO,
  AddEquation: Ud,
  AddOperation: nk,
  AdditiveAnimationBlendMode: WO,
  AdditiveBlending: eA,
  AgXToneMapping: sk,
  AlphaFormat: zO,
  AlwaysCompare: xk,
  AlwaysDepth: Y4,
  AlwaysStencilFunc: iA,
  AmbientLight: C$,
  AnimationAction: D$,
  AnimationClip: g0,
  AnimationLoader: Bfe,
  AnimationMixer: phe,
  AnimationObjectGroup: fhe,
  AnimationUtils: Lfe,
  ArcCurve: Yk,
  ArrayCamera: Bk,
  ArrowHelper: Nhe,
  AttachedBindMode: rA,
  Audio: O$,
  AudioAnalyser: nhe,
  AudioContext: gP,
  AudioListener: Jfe,
  AudioLoader: Kfe,
  AxesHelper: Lhe,
  BackSide: ho,
  BasicDepthPacking: hk,
  BasicShadowMap: A4,
  BatchedMesh: Gk,
  Bone: nP,
  BooleanKeyframeTrack: Wh,
  Box2: She,
  Box3: qa,
  Box3Helper: Dhe,
  BoxGeometry: Cu,
  BoxHelper: Phe,
  BufferAttribute: jr,
  BufferGeometry: Xn,
  BufferGeometryLoader: A$,
  ByteType: LO,
  Cache: su,
  Camera: D0,
  CameraHelper: Ohe,
  CanvasTexture: afe,
  CapsuleGeometry: tC,
  CatmullRomCurve3: Kk,
  CineonToneMapping: ak,
  CircleGeometry: nC,
  ClampToEdgeWrapping: Xs,
  Clock: vP,
  Color: an,
  ColorKeyframeTrack: hP,
  ColorManagement: Cr,
  CompressedArrayTexture: rfe,
  CompressedCubeTexture: ife,
  CompressedTexture: JE,
  CompressedTextureLoader: Hfe,
  ConeGeometry: rC,
  ConstantAlphaFactor: G4,
  ConstantColorFactor: W4,
  CubeCamera: Pk,
  CubeReflectionMapping: gu,
  CubeRefractionMapping: kd,
  CubeTexture: I0,
  CubeTextureLoader: Vfe,
  CubeUVReflectionMapping: _g,
  CubicBezierCurve: aP,
  CubicBezierCurve3: Zk,
  CubicInterpolant: g$,
  CullFaceBack: JR,
  CullFaceFront: R4,
  CullFaceFrontBack: zae,
  CullFaceNone: T4,
  Curve: Pl,
  CurvePath: Jk,
  CustomBlending: O4,
  CustomToneMapping: ok,
  CylinderGeometry: Mg,
  Cylindrical: bhe,
  Data3DTexture: qO,
  DataArrayTexture: XE,
  DataTexture: cc,
  DataTextureLoader: kfe,
  DataUtils: qoe,
  DecrementStencilOp: Kae,
  DecrementWrapStencilOp: Qae,
  DefaultLoadingManager: b$,
  DepthFormat: Eh,
  DepthStencilFormat: Lh,
  DepthTexture: QO,
  DetachedBindMode: ck,
  DirectionalLight: E$,
  DirectionalLightHelper: Ahe,
  DiscreteInterpolant: v$,
  DisplayP3ColorSpace: GE,
  DodecahedronGeometry: iC,
  DoubleSide: ic,
  DstAlphaFactor: B4,
  DstColorFactor: V4,
  DynamicCopyUsage: hoe,
  DynamicDrawUsage: soe,
  DynamicReadUsage: uoe,
  EdgesGeometry: e$,
  EllipseCurve: eC,
  EqualCompare: yk,
  EqualDepth: Z4,
  EqualStencilFunc: noe,
  EquirectangularReflectionMapping: Qy,
  EquirectangularRefractionMapping: Jy,
  Euler: gs,
  EventDispatcher: Eu,
  ExtrudeGeometry: Tg,
  FileLoader: yu,
  Float16BufferAttribute: ese,
  Float32BufferAttribute: fn,
  FloatType: Ho,
  Fog: KE,
  FogExp2: YE,
  FramebufferTexture: nfe,
  FrontSide: mu,
  Frustum: N0,
  GLBufferAttribute: yhe,
  GLSL1: moe,
  GLSL3: aA,
  GreaterCompare: bk,
  GreaterDepth: J4,
  GreaterEqualCompare: _k,
  GreaterEqualDepth: Q4,
  GreaterEqualStencilFunc: ooe,
  GreaterStencilFunc: ioe,
  GridHelper: The,
  Group: jm,
  HalfFloatType: xg,
  HemisphereLight: S$,
  HemisphereLightHelper: Mhe,
  IcosahedronGeometry: oC,
  ImageBitmapLoader: Yfe,
  ImageLoader: v0,
  ImageUtils: Mk,
  IncrementStencilOp: Yae,
  IncrementWrapStencilOp: Zae,
  InstancedBufferAttribute: dg,
  InstancedBufferGeometry: R$,
  InstancedInterleavedBuffer: vhe,
  InstancedMesh: jk,
  Int16BufferAttribute: Qoe,
  Int32BufferAttribute: Joe,
  Int8BufferAttribute: Yoe,
  IntType: BE,
  InterleavedBuffer: ZE,
  InterleavedBufferAttribute: Fh,
  Interpolant: B0,
  InterpolateDiscrete: n0,
  InterpolateLinear: Jx,
  InterpolateSmooth: ix,
  InvertStencilOp: Jae,
  KeepStencilOp: th,
  KeyframeTrack: Dl,
  LOD: $k,
  LatheGeometry: F0,
  Layers: wh,
  LessCompare: vk,
  LessDepth: K4,
  LessEqualCompare: jO,
  LessEqualDepth: Zy,
  LessEqualStencilFunc: roe,
  LessStencilFunc: toe,
  Light: Kd,
  LightProbe: T$,
  Line: $d,
  Line3: _he,
  LineBasicMaterial: vo,
  LineCurve: oP,
  LineCurve3: Qk,
  LineDashedMaterial: h$,
  LineLoop: Xk,
  LineSegments: gc,
  LinearDisplayP3ColorSpace: P0,
  LinearFilter: Ki,
  LinearInterpolant: fP,
  LinearMipMapLinearFilter: kae,
  LinearMipMapNearestFilter: Vae,
  LinearMipmapLinearFilter: oc,
  LinearMipmapNearestFilter: Ay,
  LinearSRGBColorSpace: xu,
  LinearToneMapping: rk,
  LinearTransfer: i0,
  Loader: Wo,
  LoaderUtils: hA,
  LoadingManager: pP,
  LoopOnce: uk,
  LoopPingPong: fk,
  LoopRepeat: dk,
  LuminanceAlphaFormat: VO,
  LuminanceFormat: HO,
  MOUSE: Fae,
  Material: Da,
  MaterialLoader: hC,
  MathUtils: Ek,
  Matrix3: zn,
  Matrix4: wn,
  MaxEquation: N4,
  Mesh: Zi,
  MeshBasicMaterial: qd,
  MeshDepthMaterial: JO,
  MeshDistanceMaterial: eP,
  MeshLambertMaterial: d$,
  MeshMatcapMaterial: f$,
  MeshNormalMaterial: u$,
  MeshPhongMaterial: l$,
  MeshPhysicalMaterial: s$,
  MeshStandardMaterial: uP,
  MeshToonMaterial: c$,
  MinEquation: I4,
  MirroredRepeatWrapping: t0,
  MixOperation: tk,
  MultiplyBlending: nA,
  MultiplyOperation: A0,
  NearestFilter: ba,
  NearestMipMapLinearFilter: Hae,
  NearestMipMapNearestFilter: Bae,
  NearestMipmapLinearFilter: km,
  NearestMipmapNearestFilter: NO,
  NeutralToneMapping: lk,
  NeverCompare: gk,
  NeverDepth: q4,
  NeverStencilFunc: eoe,
  NoBlending: cu,
  NoColorSpace: ru,
  NoToneMapping: lc,
  NormalAnimationBlendMode: jE,
  NormalBlending: xh,
  NotEqualCompare: Sk,
  NotEqualDepth: ek,
  NotEqualStencilFunc: aoe,
  NumberKeyframeTrack: p0,
  Object3D: pr,
  ObjectLoader: Xfe,
  ObjectSpaceNormalMap: mk,
  OctahedronGeometry: U0,
  OneFactor: F4,
  OneMinusConstantAlphaFactor: X4,
  OneMinusConstantColorFactor: j4,
  OneMinusDstAlphaFactor: H4,
  OneMinusDstColorFactor: k4,
  OneMinusSrcAlphaFactor: Mx,
  OneMinusSrcColorFactor: z4,
  OrthographicCamera: L0,
  P3Primaries: o0,
  PCFShadowMap: UE,
  PCFSoftShadowMap: Ry,
  PMREMGenerator: oA,
  Path: u0,
  PerspectiveCamera: sa,
  Plane: Ld,
  PlaneGeometry: Cg,
  PlaneHelper: Ihe,
  PointLight: x$,
  PointLightHelper: Che,
  Points: qk,
  PointsMaterial: rP,
  PolarGridHelper: Rhe,
  PolyhedronGeometry: Yd,
  PositionalAudio: the,
  PropertyBinding: hr,
  PropertyMixer: P$,
  QuadraticBezierCurve: sP,
  QuadraticBezierCurve3: lP,
  Quaternion: po,
  QuaternionKeyframeTrack: H0,
  QuaternionLinearInterpolant: y$,
  RED_GREEN_RGTC2_Format: Zx,
  RED_RGTC1_Format: $O,
  REVISION: FE,
  RGBADepthPacking: pk,
  RGBAFormat: Xa,
  RGBAIntegerFormat: WE,
  RGBA_ASTC_10x10_Format: jx,
  RGBA_ASTC_10x5_Format: kx,
  RGBA_ASTC_10x6_Format: $x,
  RGBA_ASTC_10x8_Format: Wx,
  RGBA_ASTC_12x10_Format: Gx,
  RGBA_ASTC_12x12_Format: Xx,
  RGBA_ASTC_4x4_Format: Nx,
  RGBA_ASTC_5x4_Format: Lx,
  RGBA_ASTC_5x5_Format: Fx,
  RGBA_ASTC_6x5_Format: Ux,
  RGBA_ASTC_6x6_Format: zx,
  RGBA_ASTC_8x5_Format: Bx,
  RGBA_ASTC_8x6_Format: Hx,
  RGBA_ASTC_8x8_Format: Vx,
  RGBA_BPTC_Format: Ny,
  RGBA_ETC2_EAC_Format: Ix,
  RGBA_PVRTC_2BPPV1_Format: Ox,
  RGBA_PVRTC_4BPPV1_Format: Ax,
  RGBA_S3TC_DXT1_Format: Py,
  RGBA_S3TC_DXT3_Format: Dy,
  RGBA_S3TC_DXT5_Format: Iy,
  RGBFormat: BO,
  RGBIntegerFormat: $ae,
  RGB_BPTC_SIGNED_Format: qx,
  RGB_BPTC_UNSIGNED_Format: Yx,
  RGB_ETC1_Format: Px,
  RGB_ETC2_Format: Dx,
  RGB_PVRTC_2BPPV1_Format: Rx,
  RGB_PVRTC_4BPPV1_Format: Tx,
  RGB_S3TC_DXT1_Format: Oy,
  RGFormat: kO,
  RGIntegerFormat: $E,
  RawShaderMaterial: o$,
  Ray: Eg,
  Raycaster: _P,
  Rec709Primaries: a0,
  RectAreaLight: w$,
  RedFormat: kE,
  RedIntegerFormat: O0,
  ReinhardToneMapping: ik,
  RenderTarget: Tk,
  RepeatWrapping: e0,
  ReplaceStencilOp: qae,
  ReverseSubtractEquation: D4,
  RingGeometry: sC,
  SIGNED_RED_GREEN_RGTC2_Format: Qx,
  SIGNED_RED_RGTC1_Format: Kx,
  SRGBColorSpace: js,
  SRGBTransfer: ei,
  Scene: eE,
  ShaderChunk: Gn,
  ShaderLib: xl,
  ShaderMaterial: Rl,
  ShadowMaterial: a$,
  Shape: uu,
  ShapeGeometry: lC,
  ShapePath: Fhe,
  ShapeUtils: uc,
  ShortType: FO,
  Skeleton: QE,
  SkeletonHelper: Ehe,
  SkinnedMesh: Wk,
  Source: hh,
  Sphere: Pa,
  SphereGeometry: z0,
  Spherical: I$,
  SphericalHarmonics3: M$,
  SplineCurve: cP,
  SpotLight: _$,
  SpotLightHelper: xhe,
  Sprite: kk,
  SpriteMaterial: tP,
  SrcAlphaFactor: wx,
  SrcAlphaSaturateFactor: $4,
  SrcColorFactor: U4,
  StaticCopyUsage: foe,
  StaticDrawUsage: s0,
  StaticReadUsage: coe,
  StereoCamera: Zfe,
  StreamCopyUsage: poe,
  StreamDrawUsage: loe,
  StreamReadUsage: doe,
  StringKeyframeTrack: jh,
  SubtractEquation: P4,
  SubtractiveBlending: tA,
  TOUCH: Uae,
  TangentSpaceNormalMap: Xd,
  TetrahedronGeometry: cC,
  Texture: Ei,
  TextureLoader: $fe,
  TextureUtils: Lde,
  TorusGeometry: uC,
  TorusKnotGeometry: dC,
  Triangle: ds,
  TriangleFanDrawMode: Gae,
  TriangleStripDrawMode: jae,
  TrianglesDrawMode: Wae,
  TubeGeometry: fC,
  UVMapping: zE,
  Uint16BufferAttribute: YO,
  Uint32BufferAttribute: KO,
  Uint8BufferAttribute: Koe,
  Uint8ClampedBufferAttribute: Zoe,
  Uniform: SP,
  UniformsGroup: ghe,
  UniformsLib: Yt,
  UniformsUtils: Ok,
  UnsignedByteType: Ml,
  UnsignedInt248Type: Nh,
  UnsignedInt5999Type: UO,
  UnsignedIntType: vu,
  UnsignedShort4444Type: HE,
  UnsignedShort5551Type: VE,
  UnsignedShortType: lg,
  VSMShadowMap: bl,
  Vector2: St,
  Vector3: de,
  Vector4: wr,
  VectorKeyframeTrack: m0,
  VideoTexture: tfe,
  WebGL3DRenderTarget: zoe,
  WebGLArrayRenderTarget: Uoe,
  WebGLCoordinateSystem: sc,
  WebGLCubeRenderTarget: Dk,
  WebGLMultipleRenderTargets: Uhe,
  WebGLRenderTarget: Tl,
  WebGLRenderer: Hk,
  WebGLUtils: zk,
  WebGPUCoordinateSystem: l0,
  WireframeGeometry: i$,
  WrapAroundEnding: r0,
  ZeroCurvatureEnding: dh,
  ZeroFactor: L4,
  ZeroSlopeEnding: fh,
  ZeroStencilOp: Xae,
  createCanvasElement: wk
}, Symbol.toStringTag, { value: "Module" }));
var mA = { exports: {} }, Od = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YF;
function Bhe() {
  return YF || (YF = 1, Od.ConcurrentRoot = 1, Od.ContinuousEventPriority = 4, Od.DefaultEventPriority = 16, Od.DiscreteEventPriority = 1, Od.IdleEventPriority = 536870912, Od.LegacyRoot = 0), Od;
}
var Pd = {}, KF;
function Hhe() {
  return KF || (KF = 1, Ee.env.NODE_ENV !== "production" && function() {
    var n = (
      /*                        */
      1
    ), e = (
      /*            */
      4
    ), t = (
      /*                    */
      16
    ), r = (
      /*                       */
      536870912
    ), i = n, a = e, o = t, s = r, u = 0, d = 1;
    Pd.ConcurrentRoot = d, Pd.ContinuousEventPriority = a, Pd.DefaultEventPriority = o, Pd.DiscreteEventPriority = i, Pd.IdleEventPriority = s, Pd.LegacyRoot = u;
  }()), Pd;
}
Ee.env.NODE_ENV === "production" ? mA.exports = Bhe() : mA.exports = Hhe();
var Xm = mA.exports;
function Vhe(n) {
  let e;
  const t = /* @__PURE__ */ new Set(), r = (d, f) => {
    const p = typeof d == "function" ? d(e) : d;
    if (p !== e) {
      const g = e;
      e = f ? p : Object.assign({}, e, p), t.forEach((v) => v(e, g));
    }
  }, i = () => e, a = (d, f = i, p = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let g = f(e);
    function v() {
      const b = f(e);
      if (!p(g, b)) {
        const E = g;
        d(g = b, E);
      }
    }
    return t.add(v), () => t.delete(v);
  }, u = { setState: r, getState: i, subscribe: (d, f, p) => f || p ? a(d, f, p) : (t.add(d), () => t.delete(d)), destroy: () => t.clear() };
  return e = n(r, i, u), u;
}
const khe = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), ZF = khe ? In : xA;
function $he(n) {
  const e = typeof n == "function" ? Vhe(n) : n, t = (r = e.getState, i = Object.is) => {
    const [, a] = V8((S) => S + 1, 0), o = e.getState(), s = kt(o), u = kt(r), d = kt(i), f = kt(!1), p = kt();
    p.current === void 0 && (p.current = r(o));
    let g, v = !1;
    (s.current !== o || u.current !== r || d.current !== i || f.current) && (g = r(o), v = !i(p.current, g)), ZF(() => {
      v && (p.current = g), s.current = o, u.current = r, d.current = i, f.current = !1;
    });
    const b = kt(o);
    ZF(() => {
      const S = () => {
        try {
          const w = e.getState(), C = u.current(w);
          d.current(p.current, C) || (s.current = w, p.current = C, a());
        } catch {
          f.current = !0, a();
        }
      }, _ = e.subscribe(S);
      return e.getState() !== b.current && S(), _;
    }, []);
    const E = v ? g : p.current;
    return PT(E), E;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const r = [t, e];
    return {
      next() {
        const i = r.length <= 0;
        return { value: r.shift(), done: i };
      }
    };
  }, t;
}
var gA = { exports: {} }, U_ = { exports: {} }, lT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QF;
function Whe() {
  return QF || (QF = 1, function(n) {
    function e(B, Q) {
      var V = B.length;
      B.push(Q);
      e: for (; 0 < V; ) {
        var q = V - 1 >>> 1, ne = B[q];
        if (0 < i(ne, Q)) B[q] = Q, B[V] = ne, V = q;
        else break e;
      }
    }
    function t(B) {
      return B.length === 0 ? null : B[0];
    }
    function r(B) {
      if (B.length === 0) return null;
      var Q = B[0], V = B.pop();
      if (V !== Q) {
        B[0] = V;
        e: for (var q = 0, ne = B.length, ce = ne >>> 1; q < ce; ) {
          var ie = 2 * (q + 1) - 1, oe = B[ie], he = ie + 1, le = B[he];
          if (0 > i(oe, V)) he < ne && 0 > i(le, oe) ? (B[q] = le, B[he] = V, q = he) : (B[q] = oe, B[ie] = V, q = ie);
          else if (he < ne && 0 > i(le, V)) B[q] = le, B[he] = V, q = he;
          else break e;
        }
      }
      return Q;
    }
    function i(B, Q) {
      var V = B.sortIndex - Q.sortIndex;
      return V !== 0 ? V : B.id - Q.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var a = performance;
      n.unstable_now = function() {
        return a.now();
      };
    } else {
      var o = Date, s = o.now();
      n.unstable_now = function() {
        return o.now() - s;
      };
    }
    var u = [], d = [], f = 1, p = null, g = 3, v = !1, b = !1, E = !1, S = typeof setTimeout == "function" ? setTimeout : null, _ = typeof clearTimeout == "function" ? clearTimeout : null, w = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function C(B) {
      for (var Q = t(d); Q !== null; ) {
        if (Q.callback === null) r(d);
        else if (Q.startTime <= B) r(d), Q.sortIndex = Q.expirationTime, e(u, Q);
        else break;
        Q = t(d);
      }
    }
    function R(B) {
      if (E = !1, C(B), !b) if (t(u) !== null) b = !0, Z(P);
      else {
        var Q = t(d);
        Q !== null && K(R, Q.startTime - B);
      }
    }
    function P(B, Q) {
      b = !1, E && (E = !1, _(U), U = -1), v = !0;
      var V = g;
      try {
        for (C(Q), p = t(u); p !== null && (!(p.expirationTime > Q) || B && !H()); ) {
          var q = p.callback;
          if (typeof q == "function") {
            p.callback = null, g = p.priorityLevel;
            var ne = q(p.expirationTime <= Q);
            Q = n.unstable_now(), typeof ne == "function" ? p.callback = ne : p === t(u) && r(u), C(Q);
          } else r(u);
          p = t(u);
        }
        if (p !== null) var ce = !0;
        else {
          var ie = t(d);
          ie !== null && K(R, ie.startTime - Q), ce = !1;
        }
        return ce;
      } finally {
        p = null, g = V, v = !1;
      }
    }
    var D = !1, I = null, U = -1, L = 5, N = -1;
    function H() {
      return !(n.unstable_now() - N < L);
    }
    function j() {
      if (I !== null) {
        var B = n.unstable_now();
        N = B;
        var Q = !0;
        try {
          Q = I(!0, B);
        } finally {
          Q ? G() : (D = !1, I = null);
        }
      } else D = !1;
    }
    var G;
    if (typeof w == "function") G = function() {
      w(j);
    };
    else if (typeof MessageChannel < "u") {
      var X = new MessageChannel(), ae = X.port2;
      X.port1.onmessage = j, G = function() {
        ae.postMessage(null);
      };
    } else G = function() {
      S(j, 0);
    };
    function Z(B) {
      I = B, D || (D = !0, G());
    }
    function K(B, Q) {
      U = S(function() {
        B(n.unstable_now());
      }, Q);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(B) {
      B.callback = null;
    }, n.unstable_continueExecution = function() {
      b || v || (b = !0, Z(P));
    }, n.unstable_forceFrameRate = function(B) {
      0 > B || 125 < B ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : L = 0 < B ? Math.floor(1e3 / B) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return g;
    }, n.unstable_getFirstCallbackNode = function() {
      return t(u);
    }, n.unstable_next = function(B) {
      switch (g) {
        case 1:
        case 2:
        case 3:
          var Q = 3;
          break;
        default:
          Q = g;
      }
      var V = g;
      g = Q;
      try {
        return B();
      } finally {
        g = V;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(B, Q) {
      switch (B) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          B = 3;
      }
      var V = g;
      g = B;
      try {
        return Q();
      } finally {
        g = V;
      }
    }, n.unstable_scheduleCallback = function(B, Q, V) {
      var q = n.unstable_now();
      switch (typeof V == "object" && V !== null ? (V = V.delay, V = typeof V == "number" && 0 < V ? q + V : q) : V = q, B) {
        case 1:
          var ne = -1;
          break;
        case 2:
          ne = 250;
          break;
        case 5:
          ne = 1073741823;
          break;
        case 4:
          ne = 1e4;
          break;
        default:
          ne = 5e3;
      }
      return ne = V + ne, B = { id: f++, callback: Q, priorityLevel: B, startTime: V, expirationTime: ne, sortIndex: -1 }, V > q ? (B.sortIndex = V, e(d, B), t(u) === null && B === t(d) && (E ? (_(U), U = -1) : E = !0, K(R, V - q))) : (B.sortIndex = ne, e(u, B), b || v || (b = !0, Z(P))), B;
    }, n.unstable_shouldYield = H, n.unstable_wrapCallback = function(B) {
      var Q = g;
      return function() {
        var V = g;
        g = Q;
        try {
          return B.apply(this, arguments);
        } finally {
          g = V;
        }
      };
    };
  }(lT)), lT;
}
var cT = {}, JF;
function jhe() {
  return JF || (JF = 1, function(n) {
    Ee.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function i(ye, Ue) {
        var Ye = ye.length;
        ye.push(Ue), s(ye, Ue, Ye);
      }
      function a(ye) {
        return ye.length === 0 ? null : ye[0];
      }
      function o(ye) {
        if (ye.length === 0)
          return null;
        var Ue = ye[0], Ye = ye.pop();
        return Ye !== Ue && (ye[0] = Ye, u(ye, Ye, 0)), Ue;
      }
      function s(ye, Ue, Ye) {
        for (var tt = Ye; tt > 0; ) {
          var st = tt - 1 >>> 1, Tt = ye[st];
          if (d(Tt, Ue) > 0)
            ye[st] = Ue, ye[tt] = Tt, tt = st;
          else
            return;
        }
      }
      function u(ye, Ue, Ye) {
        for (var tt = Ye, st = ye.length, Tt = st >>> 1; tt < Tt; ) {
          var Rt = (tt + 1) * 2 - 1, ue = ye[Rt], De = Rt + 1, Ge = ye[De];
          if (d(ue, Ue) < 0)
            De < st && d(Ge, ue) < 0 ? (ye[tt] = Ge, ye[De] = Ue, tt = De) : (ye[tt] = ue, ye[Rt] = Ue, tt = Rt);
          else if (De < st && d(Ge, Ue) < 0)
            ye[tt] = Ge, ye[De] = Ue, tt = De;
          else
            return;
        }
      }
      function d(ye, Ue) {
        var Ye = ye.sortIndex - Ue.sortIndex;
        return Ye !== 0 ? Ye : ye.id - Ue.id;
      }
      var f = 1, p = 2, g = 3, v = 4, b = 5;
      function E(ye, Ue) {
      }
      var S = typeof performance == "object" && typeof performance.now == "function";
      if (S) {
        var _ = performance;
        n.unstable_now = function() {
          return _.now();
        };
      } else {
        var w = Date, C = w.now();
        n.unstable_now = function() {
          return w.now() - C;
        };
      }
      var R = 1073741823, P = -1, D = 250, I = 5e3, U = 1e4, L = R, N = [], H = [], j = 1, G = null, X = g, ae = !1, Z = !1, K = !1, B = typeof setTimeout == "function" ? setTimeout : null, Q = typeof clearTimeout == "function" ? clearTimeout : null, V = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function q(ye) {
        for (var Ue = a(H); Ue !== null; ) {
          if (Ue.callback === null)
            o(H);
          else if (Ue.startTime <= ye)
            o(H), Ue.sortIndex = Ue.expirationTime, i(N, Ue);
          else
            return;
          Ue = a(H);
        }
      }
      function ne(ye) {
        if (K = !1, q(ye), !Z)
          if (a(N) !== null)
            Z = !0, Ze(ce);
          else {
            var Ue = a(H);
            Ue !== null && nt(ne, Ue.startTime - ye);
          }
      }
      function ce(ye, Ue) {
        Z = !1, K && (K = !1, ht()), ae = !0;
        var Ye = X;
        try {
          var tt;
          if (!t) return ie(ye, Ue);
        } finally {
          G = null, X = Ye, ae = !1;
        }
      }
      function ie(ye, Ue) {
        var Ye = Ue;
        for (q(Ye), G = a(N); G !== null && !e && !(G.expirationTime > Ye && (!ye || $e())); ) {
          var tt = G.callback;
          if (typeof tt == "function") {
            G.callback = null, X = G.priorityLevel;
            var st = G.expirationTime <= Ye, Tt = tt(st);
            Ye = n.unstable_now(), typeof Tt == "function" ? G.callback = Tt : G === a(N) && o(N), q(Ye);
          } else
            o(N);
          G = a(N);
        }
        if (G !== null)
          return !0;
        var Rt = a(H);
        return Rt !== null && nt(ne, Rt.startTime - Ye), !1;
      }
      function oe(ye, Ue) {
        switch (ye) {
          case f:
          case p:
          case g:
          case v:
          case b:
            break;
          default:
            ye = g;
        }
        var Ye = X;
        X = ye;
        try {
          return Ue();
        } finally {
          X = Ye;
        }
      }
      function he(ye) {
        var Ue;
        switch (X) {
          case f:
          case p:
          case g:
            Ue = g;
            break;
          default:
            Ue = X;
            break;
        }
        var Ye = X;
        X = Ue;
        try {
          return ye();
        } finally {
          X = Ye;
        }
      }
      function le(ye) {
        var Ue = X;
        return function() {
          var Ye = X;
          X = Ue;
          try {
            return ye.apply(this, arguments);
          } finally {
            X = Ye;
          }
        };
      }
      function ve(ye, Ue, Ye) {
        var tt = n.unstable_now(), st;
        if (typeof Ye == "object" && Ye !== null) {
          var Tt = Ye.delay;
          typeof Tt == "number" && Tt > 0 ? st = tt + Tt : st = tt;
        } else
          st = tt;
        var Rt;
        switch (ye) {
          case f:
            Rt = P;
            break;
          case p:
            Rt = D;
            break;
          case b:
            Rt = L;
            break;
          case v:
            Rt = U;
            break;
          case g:
          default:
            Rt = I;
            break;
        }
        var ue = st + Rt, De = {
          id: j++,
          callback: Ue,
          priorityLevel: ye,
          startTime: st,
          expirationTime: ue,
          sortIndex: -1
        };
        return st > tt ? (De.sortIndex = st, i(H, De), a(N) === null && De === a(H) && (K ? ht() : K = !0, nt(ne, st - tt))) : (De.sortIndex = ue, i(N, De), !Z && !ae && (Z = !0, Ze(ce))), De;
      }
      function Ne() {
      }
      function xe() {
        !Z && !ae && (Z = !0, Ze(ce));
      }
      function Me() {
        return a(N);
      }
      function $(ye) {
        ye.callback = null;
      }
      function Te() {
        return X;
      }
      var se = !1, Ie = null, be = -1, et = r, Xe = -1;
      function $e() {
        var ye = n.unstable_now() - Xe;
        return !(ye < et);
      }
      function te() {
      }
      function Y(ye) {
        if (ye < 0 || ye > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ye > 0 ? et = Math.floor(1e3 / ye) : et = r;
      }
      var Se = function() {
        if (Ie !== null) {
          var ye = n.unstable_now();
          Xe = ye;
          var Ue = !0, Ye = !0;
          try {
            Ye = Ie(Ue, ye);
          } finally {
            Ye ? Oe() : (se = !1, Ie = null);
          }
        } else
          se = !1;
      }, Oe;
      if (typeof V == "function")
        Oe = function() {
          V(Se);
        };
      else if (typeof MessageChannel < "u") {
        var Pe = new MessageChannel(), Ve = Pe.port2;
        Pe.port1.onmessage = Se, Oe = function() {
          Ve.postMessage(null);
        };
      } else
        Oe = function() {
          B(Se, 0);
        };
      function Ze(ye) {
        Ie = ye, se || (se = !0, Oe());
      }
      function nt(ye, Ue) {
        be = B(function() {
          ye(n.unstable_now());
        }, Ue);
      }
      function ht() {
        Q(be), be = -1;
      }
      var pt = te, Be = null;
      n.unstable_IdlePriority = b, n.unstable_ImmediatePriority = f, n.unstable_LowPriority = v, n.unstable_NormalPriority = g, n.unstable_Profiling = Be, n.unstable_UserBlockingPriority = p, n.unstable_cancelCallback = $, n.unstable_continueExecution = xe, n.unstable_forceFrameRate = Y, n.unstable_getCurrentPriorityLevel = Te, n.unstable_getFirstCallbackNode = Me, n.unstable_next = he, n.unstable_pauseExecution = Ne, n.unstable_requestPaint = pt, n.unstable_runWithPriority = oe, n.unstable_scheduleCallback = ve, n.unstable_shouldYield = $e, n.unstable_wrapCallback = le, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(cT)), cT;
}
var eU;
function L$() {
  return eU || (eU = 1, Ee.env.NODE_ENV === "production" ? U_.exports = Whe() : U_.exports = jhe()), U_.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uT, tU;
function Ghe() {
  return tU || (tU = 1, uT = function(e) {
    var t = {}, r = Fe, i = L$(), a = Object.assign;
    function o(h) {
      for (var m = "https://reactjs.org/docs/error-decoder.html?invariant=" + h, M = 1; M < arguments.length; M++) m += "&args[]=" + encodeURIComponent(arguments[M]);
      return "Minified React error #" + h + "; visit " + m + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, u = Symbol.for("react.element"), d = Symbol.for("react.portal"), f = Symbol.for("react.fragment"), p = Symbol.for("react.strict_mode"), g = Symbol.for("react.profiler"), v = Symbol.for("react.provider"), b = Symbol.for("react.context"), E = Symbol.for("react.forward_ref"), S = Symbol.for("react.suspense"), _ = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), C = Symbol.for("react.lazy"), R = Symbol.for("react.offscreen"), P = Symbol.iterator;
    function D(h) {
      return h === null || typeof h != "object" ? null : (h = P && h[P] || h["@@iterator"], typeof h == "function" ? h : null);
    }
    function I(h) {
      if (h == null) return null;
      if (typeof h == "function") return h.displayName || h.name || null;
      if (typeof h == "string") return h;
      switch (h) {
        case f:
          return "Fragment";
        case d:
          return "Portal";
        case g:
          return "Profiler";
        case p:
          return "StrictMode";
        case S:
          return "Suspense";
        case _:
          return "SuspenseList";
      }
      if (typeof h == "object") switch (h.$$typeof) {
        case b:
          return (h.displayName || "Context") + ".Consumer";
        case v:
          return (h._context.displayName || "Context") + ".Provider";
        case E:
          var m = h.render;
          return h = h.displayName, h || (h = m.displayName || m.name || "", h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"), h;
        case w:
          return m = h.displayName || null, m !== null ? m : I(h.type) || "Memo";
        case C:
          m = h._payload, h = h._init;
          try {
            return I(h(m));
          } catch {
          }
      }
      return null;
    }
    function U(h) {
      var m = h.type;
      switch (h.tag) {
        case 24:
          return "Cache";
        case 9:
          return (m.displayName || "Context") + ".Consumer";
        case 10:
          return (m._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return h = m.render, h = h.displayName || h.name || "", m.displayName || (h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return m;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return I(m);
        case 8:
          return m === p ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof m == "function") return m.displayName || m.name || null;
          if (typeof m == "string") return m;
      }
      return null;
    }
    function L(h) {
      var m = h, M = h;
      if (h.alternate) for (; m.return; ) m = m.return;
      else {
        h = m;
        do
          m = h, m.flags & 4098 && (M = m.return), h = m.return;
        while (h);
      }
      return m.tag === 3 ? M : null;
    }
    function N(h) {
      if (L(h) !== h) throw Error(o(188));
    }
    function H(h) {
      var m = h.alternate;
      if (!m) {
        if (m = L(h), m === null) throw Error(o(188));
        return m !== h ? null : h;
      }
      for (var M = h, A = m; ; ) {
        var z = M.return;
        if (z === null) break;
        var W = z.alternate;
        if (W === null) {
          if (A = z.return, A !== null) {
            M = A;
            continue;
          }
          break;
        }
        if (z.child === W.child) {
          for (W = z.child; W; ) {
            if (W === M) return N(z), h;
            if (W === A) return N(z), m;
            W = W.sibling;
          }
          throw Error(o(188));
        }
        if (M.return !== A.return) M = z, A = W;
        else {
          for (var fe = !1, Le = z.child; Le; ) {
            if (Le === M) {
              fe = !0, M = z, A = W;
              break;
            }
            if (Le === A) {
              fe = !0, A = z, M = W;
              break;
            }
            Le = Le.sibling;
          }
          if (!fe) {
            for (Le = W.child; Le; ) {
              if (Le === M) {
                fe = !0, M = W, A = z;
                break;
              }
              if (Le === A) {
                fe = !0, A = W, M = z;
                break;
              }
              Le = Le.sibling;
            }
            if (!fe) throw Error(o(189));
          }
        }
        if (M.alternate !== A) throw Error(o(190));
      }
      if (M.tag !== 3) throw Error(o(188));
      return M.stateNode.current === M ? h : m;
    }
    function j(h) {
      return h = H(h), h !== null ? G(h) : null;
    }
    function G(h) {
      if (h.tag === 5 || h.tag === 6) return h;
      for (h = h.child; h !== null; ) {
        var m = G(h);
        if (m !== null) return m;
        h = h.sibling;
      }
      return null;
    }
    function X(h) {
      if (h.tag === 5 || h.tag === 6) return h;
      for (h = h.child; h !== null; ) {
        if (h.tag !== 4) {
          var m = X(h);
          if (m !== null) return m;
        }
        h = h.sibling;
      }
      return null;
    }
    var ae = Array.isArray, Z = e.getPublicInstance, K = e.getRootHostContext, B = e.getChildHostContext, Q = e.prepareForCommit, V = e.resetAfterCommit, q = e.createInstance, ne = e.appendInitialChild, ce = e.finalizeInitialChildren, ie = e.prepareUpdate, oe = e.shouldSetTextContent, he = e.createTextInstance, le = e.scheduleTimeout, ve = e.cancelTimeout, Ne = e.noTimeout, xe = e.isPrimaryRenderer, Me = e.supportsMutation, $ = e.supportsPersistence, Te = e.supportsHydration, se = e.getInstanceFromNode, Ie = e.preparePortalMount, be = e.getCurrentEventPriority, et = e.detachDeletedInstance, Xe = e.supportsMicrotasks, $e = e.scheduleMicrotask, te = e.supportsTestSelectors, Y = e.findFiberRoot, Se = e.getBoundingRect, Oe = e.getTextContent, Pe = e.isHiddenSubtree, Ve = e.matchAccessibilityRole, Ze = e.setFocusIfFocusable, nt = e.setupIntersectionObserver, ht = e.appendChild, pt = e.appendChildToContainer, Be = e.commitTextUpdate, ye = e.commitMount, Ue = e.commitUpdate, Ye = e.insertBefore, tt = e.insertInContainerBefore, st = e.removeChild, Tt = e.removeChildFromContainer, Rt = e.resetTextContent, ue = e.hideInstance, De = e.hideTextInstance, Ge = e.unhideInstance, We = e.unhideTextInstance, He = e.clearContainer, ut = e.cloneInstance, vt = e.createContainerChildSet, _t = e.appendChildToContainerChildSet, Wt = e.finalizeContainerChildren, lt = e.replaceContainerChildren, Ct = e.cloneHiddenInstance, un = e.cloneHiddenTextInstance, Nn = e.canHydrateInstance, xt = e.canHydrateTextInstance, Pt = e.canHydrateSuspenseInstance, Bt = e.isSuspenseInstancePending, Qt = e.isSuspenseInstanceFallback, vn = e.registerSuspenseInstanceRetry, Mn = e.getNextHydratableSibling, cr = e.getFirstHydratableChild, ge = e.getFirstHydratableChildWithinContainer, it = e.getFirstHydratableChildWithinSuspenseInstance, yt = e.hydrateInstance, Kt = e.hydrateTextInstance, Sn = e.hydrateSuspenseInstance, ee = e.getNextHydratableInstanceAfterSuspenseInstance, _e = e.commitHydratedContainer, Ae = e.commitHydratedSuspenseInstance, Ce = e.clearSuspenseBoundary, pe = e.clearSuspenseBoundaryFromContainer, je = e.shouldDeleteUnhydratedTailInstances, bt = e.didNotMatchHydratedContainerTextInstance, It = e.didNotMatchHydratedTextInstance, Lt;
    function Ht(h) {
      if (Lt === void 0) try {
        throw Error();
      } catch (M) {
        var m = M.stack.trim().match(/\n( *(at )?)/);
        Lt = m && m[1] || "";
      }
      return `
` + Lt + h;
    }
    var on = !1;
    function sn(h, m) {
      if (!h || on) return "";
      on = !0;
      var M = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (m) if (m = function() {
          throw Error();
        }, Object.defineProperty(m.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(m, []);
          } catch (Ot) {
            var A = Ot;
          }
          Reflect.construct(h, [], m);
        } else {
          try {
            m.call();
          } catch (Ot) {
            A = Ot;
          }
          h.call(m.prototype);
        }
        else {
          try {
            throw Error();
          } catch (Ot) {
            A = Ot;
          }
          h();
        }
      } catch (Ot) {
        if (Ot && A && typeof Ot.stack == "string") {
          for (var z = Ot.stack.split(`
`), W = A.stack.split(`
`), fe = z.length - 1, Le = W.length - 1; 1 <= fe && 0 <= Le && z[fe] !== W[Le]; ) Le--;
          for (; 1 <= fe && 0 <= Le; fe--, Le--) if (z[fe] !== W[Le]) {
            if (fe !== 1 || Le !== 1)
              do
                if (fe--, Le--, 0 > Le || z[fe] !== W[Le]) {
                  var ct = `
` + z[fe].replace(" at new ", " at ");
                  return h.displayName && ct.includes("<anonymous>") && (ct = ct.replace("<anonymous>", h.displayName)), ct;
                }
              while (1 <= fe && 0 <= Le);
            break;
          }
        }
      } finally {
        on = !1, Error.prepareStackTrace = M;
      }
      return (h = h ? h.displayName || h.name : "") ? Ht(h) : "";
    }
    var Rn = Object.prototype.hasOwnProperty, Vn = [], Kn = -1;
    function Zn(h) {
      return { current: h };
    }
    function Jt(h) {
      0 > Kn || (h.current = Vn[Kn], Vn[Kn] = null, Kn--);
    }
    function Nt(h, m) {
      Kn++, Vn[Kn] = h.current, h.current = m;
    }
    var rr = {}, hn = Zn(rr), Tn = Zn(!1), Xr = rr;
    function ur(h, m) {
      var M = h.type.contextTypes;
      if (!M) return rr;
      var A = h.stateNode;
      if (A && A.__reactInternalMemoizedUnmaskedChildContext === m) return A.__reactInternalMemoizedMaskedChildContext;
      var z = {}, W;
      for (W in M) z[W] = m[W];
      return A && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = m, h.__reactInternalMemoizedMaskedChildContext = z), z;
    }
    function cn(h) {
      return h = h.childContextTypes, h != null;
    }
    function en() {
      Jt(Tn), Jt(hn);
    }
    function gr(h, m, M) {
      if (hn.current !== rr) throw Error(o(168));
      Nt(hn, m), Nt(Tn, M);
    }
    function qr(h, m, M) {
      var A = h.stateNode;
      if (m = m.childContextTypes, typeof A.getChildContext != "function") return M;
      A = A.getChildContext();
      for (var z in A) if (!(z in m)) throw Error(o(108, U(h) || "Unknown", z));
      return a({}, M, A);
    }
    function Pn(h) {
      return h = (h = h.stateNode) && h.__reactInternalMemoizedMergedChildContext || rr, Xr = hn.current, Nt(hn, h), Nt(Tn, Tn.current), !0;
    }
    function Fr(h, m, M) {
      var A = h.stateNode;
      if (!A) throw Error(o(169));
      M ? (h = qr(h, m, Xr), A.__reactInternalMemoizedMergedChildContext = h, Jt(Tn), Jt(hn), Nt(hn, h)) : Jt(Tn), Nt(Tn, M);
    }
    var Sr = Math.clz32 ? Math.clz32 : Za, Oi = Math.log, fa = Math.LN2;
    function Za(h) {
      return h >>>= 0, h === 0 ? 32 : 31 - (Oi(h) / fa | 0) | 0;
    }
    var Pi = 64, Wi = 4194304;
    function yo(h) {
      switch (h & -h) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return h & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return h & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return h;
      }
    }
    function Qi(h, m) {
      var M = h.pendingLanes;
      if (M === 0) return 0;
      var A = 0, z = h.suspendedLanes, W = h.pingedLanes, fe = M & 268435455;
      if (fe !== 0) {
        var Le = fe & ~z;
        Le !== 0 ? A = yo(Le) : (W &= fe, W !== 0 && (A = yo(W)));
      } else fe = M & ~z, fe !== 0 ? A = yo(fe) : W !== 0 && (A = yo(W));
      if (A === 0) return 0;
      if (m !== 0 && m !== A && !(m & z) && (z = A & -A, W = m & -m, z >= W || z === 16 && (W & 4194240) !== 0)) return m;
      if (A & 4 && (A |= M & 16), m = h.entangledLanes, m !== 0) for (h = h.entanglements, m &= A; 0 < m; ) M = 31 - Sr(m), z = 1 << M, A |= h[M], m &= ~z;
      return A;
    }
    function ha(h, m) {
      switch (h) {
        case 1:
        case 2:
        case 4:
          return m + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return m + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function _a(h, m) {
      for (var M = h.suspendedLanes, A = h.pingedLanes, z = h.expirationTimes, W = h.pendingLanes; 0 < W; ) {
        var fe = 31 - Sr(W), Le = 1 << fe, ct = z[fe];
        ct === -1 ? (!(Le & M) || Le & A) && (z[fe] = ha(Le, m)) : ct <= m && (h.expiredLanes |= Le), W &= ~Le;
      }
    }
    function ri(h) {
      return h = h.pendingLanes & -1073741825, h !== 0 ? h : h & 1073741824 ? 1073741824 : 0;
    }
    function vs(h) {
      for (var m = [], M = 0; 31 > M; M++) m.push(h);
      return m;
    }
    function bo(h, m, M) {
      h.pendingLanes |= m, m !== 536870912 && (h.suspendedLanes = 0, h.pingedLanes = 0), h = h.eventTimes, m = 31 - Sr(m), h[m] = M;
    }
    function vc(h, m) {
      var M = h.pendingLanes & ~m;
      h.pendingLanes = m, h.suspendedLanes = 0, h.pingedLanes = 0, h.expiredLanes &= m, h.mutableReadLanes &= m, h.entangledLanes &= m, m = h.entanglements;
      var A = h.eventTimes;
      for (h = h.expirationTimes; 0 < M; ) {
        var z = 31 - Sr(M), W = 1 << z;
        m[z] = 0, A[z] = -1, h[z] = -1, M &= ~W;
      }
    }
    function Ys(h, m) {
      var M = h.entangledLanes |= m;
      for (h = h.entanglements; M; ) {
        var A = 31 - Sr(M), z = 1 << A;
        z & m | h[A] & m && (h[A] |= m), M &= ~z;
      }
    }
    var Qn = 0;
    function wu(h) {
      return h &= -h, 1 < h ? 4 < h ? h & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var So = i.unstable_scheduleCallback, Mu = i.unstable_cancelCallback, Zd = i.unstable_shouldYield, ln = i.unstable_requestPaint, nn = i.unstable_now, Br = i.unstable_ImmediatePriority, ui = i.unstable_UserBlockingPriority, Hr = i.unstable_NormalPriority, Tu = i.unstable_IdlePriority, Il = null, Qa = null;
    function Ru(h) {
      if (Qa && typeof Qa.onCommitFiberRoot == "function") try {
        Qa.onCommitFiberRoot(Il, h, void 0, (h.current.flags & 128) === 128);
      } catch {
      }
    }
    function pC(h, m) {
      return h === m && (h !== 0 || 1 / h === 1 / m) || h !== h && m !== m;
    }
    var ys = typeof Object.is == "function" ? Object.is : pC, Ks = null, Gh = !1, Rg = !1;
    function Ag(h) {
      Ks === null ? Ks = [h] : Ks.push(h);
    }
    function mC(h) {
      Gh = !0, Ag(h);
    }
    function bs() {
      if (!Rg && Ks !== null) {
        Rg = !0;
        var h = 0, m = Qn;
        try {
          var M = Ks;
          for (Qn = 1; h < M.length; h++) {
            var A = M[h];
            do
              A = A(!0);
            while (A !== null);
          }
          Ks = null, Gh = !1;
        } catch (z) {
          throw Ks !== null && (Ks = Ks.slice(h + 1)), So(Br, bs), z;
        } finally {
          Qn = m, Rg = !1;
        }
      }
      return null;
    }
    var gC = s.ReactCurrentBatchConfig;
    function Xh(h, m) {
      if (ys(h, m)) return !0;
      if (typeof h != "object" || h === null || typeof m != "object" || m === null) return !1;
      var M = Object.keys(h), A = Object.keys(m);
      if (M.length !== A.length) return !1;
      for (A = 0; A < M.length; A++) {
        var z = M[A];
        if (!Rn.call(m, z) || !ys(h[z], m[z])) return !1;
      }
      return !0;
    }
    function vC(h) {
      switch (h.tag) {
        case 5:
          return Ht(h.type);
        case 16:
          return Ht("Lazy");
        case 13:
          return Ht("Suspense");
        case 19:
          return Ht("SuspenseList");
        case 0:
        case 2:
        case 15:
          return h = sn(h.type, !1), h;
        case 11:
          return h = sn(h.type.render, !1), h;
        case 1:
          return h = sn(h.type, !0), h;
        default:
          return "";
      }
    }
    function jo(h, m) {
      if (h && h.defaultProps) {
        m = a({}, m), h = h.defaultProps;
        for (var M in h) m[M] === void 0 && (m[M] = h[M]);
        return m;
      }
      return m;
    }
    var Qd = Zn(null), Jd = null, Au = null, qh = null;
    function Og() {
      qh = Au = Jd = null;
    }
    function Pg(h, m, M) {
      xe ? (Nt(Qd, m._currentValue), m._currentValue = M) : (Nt(Qd, m._currentValue2), m._currentValue2 = M);
    }
    function Yh(h) {
      var m = Qd.current;
      Jt(Qd), xe ? h._currentValue = m : h._currentValue2 = m;
    }
    function Dg(h, m, M) {
      for (; h !== null; ) {
        var A = h.alternate;
        if ((h.childLanes & m) !== m ? (h.childLanes |= m, A !== null && (A.childLanes |= m)) : A !== null && (A.childLanes & m) !== m && (A.childLanes |= m), h === M) break;
        h = h.return;
      }
    }
    function Ou(h, m) {
      Jd = h, qh = Au = null, h = h.dependencies, h !== null && h.firstContext !== null && (h.lanes & m && (pa = !0), h.firstContext = null);
    }
    function _o(h) {
      var m = xe ? h._currentValue : h._currentValue2;
      if (qh !== h) if (h = { context: h, memoizedValue: m, next: null }, Au === null) {
        if (Jd === null) throw Error(o(308));
        Au = h, Jd.dependencies = { lanes: 0, firstContext: h };
      } else Au = Au.next = h;
      return m;
    }
    var Go = null, Ss = !1;
    function Ig(h) {
      h.updateQueue = { baseState: h.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function ef(h, m) {
      h = h.updateQueue, m.updateQueue === h && (m.updateQueue = { baseState: h.baseState, firstBaseUpdate: h.firstBaseUpdate, lastBaseUpdate: h.lastBaseUpdate, shared: h.shared, effects: h.effects });
    }
    function Zs(h, m) {
      return { eventTime: h, lane: m, tag: 0, payload: null, callback: null, next: null };
    }
    function Nl(h, m) {
      var M = h.updateQueue;
      M !== null && (M = M.shared, Ci !== null && h.mode & 1 && !(kn & 2) ? (h = M.interleaved, h === null ? (m.next = m, Go === null ? Go = [M] : Go.push(M)) : (m.next = h.next, h.next = m), M.interleaved = m) : (h = M.pending, h === null ? m.next = m : (m.next = h.next, h.next = m), M.pending = m));
    }
    function Kh(h, m, M) {
      if (m = m.updateQueue, m !== null && (m = m.shared, (M & 4194240) !== 0)) {
        var A = m.lanes;
        A &= h.pendingLanes, M |= A, m.lanes = M, Ys(h, M);
      }
    }
    function k0(h, m) {
      var M = h.updateQueue, A = h.alternate;
      if (A !== null && (A = A.updateQueue, M === A)) {
        var z = null, W = null;
        if (M = M.firstBaseUpdate, M !== null) {
          do {
            var fe = { eventTime: M.eventTime, lane: M.lane, tag: M.tag, payload: M.payload, callback: M.callback, next: null };
            W === null ? z = W = fe : W = W.next = fe, M = M.next;
          } while (M !== null);
          W === null ? z = W = m : W = W.next = m;
        } else z = W = m;
        M = { baseState: A.baseState, firstBaseUpdate: z, lastBaseUpdate: W, shared: A.shared, effects: A.effects }, h.updateQueue = M;
        return;
      }
      h = M.lastBaseUpdate, h === null ? M.firstBaseUpdate = m : h.next = m, M.lastBaseUpdate = m;
    }
    function Zh(h, m, M, A) {
      var z = h.updateQueue;
      Ss = !1;
      var W = z.firstBaseUpdate, fe = z.lastBaseUpdate, Le = z.shared.pending;
      if (Le !== null) {
        z.shared.pending = null;
        var ct = Le, Ot = ct.next;
        ct.next = null, fe === null ? W = Ot : fe.next = Ot, fe = ct;
        var Vt = h.alternate;
        Vt !== null && (Vt = Vt.updateQueue, Le = Vt.lastBaseUpdate, Le !== fe && (Le === null ? Vt.firstBaseUpdate = Ot : Le.next = Ot, Vt.lastBaseUpdate = ct));
      }
      if (W !== null) {
        var Cn = z.baseState;
        fe = 0, Vt = Ot = ct = null, Le = W;
        do {
          var _n = Le.lane, zr = Le.eventTime;
          if ((A & _n) === _n) {
            Vt !== null && (Vt = Vt.next = {
              eventTime: zr,
              lane: 0,
              tag: Le.tag,
              payload: Le.payload,
              callback: Le.callback,
              next: null
            });
            e: {
              var pn = h, na = Le;
              switch (_n = m, zr = M, na.tag) {
                case 1:
                  if (pn = na.payload, typeof pn == "function") {
                    Cn = pn.call(zr, Cn, _n);
                    break e;
                  }
                  Cn = pn;
                  break e;
                case 3:
                  pn.flags = pn.flags & -65537 | 128;
                case 0:
                  if (pn = na.payload, _n = typeof pn == "function" ? pn.call(zr, Cn, _n) : pn, _n == null) break e;
                  Cn = a({}, Cn, _n);
                  break e;
                case 2:
                  Ss = !0;
              }
            }
            Le.callback !== null && Le.lane !== 0 && (h.flags |= 64, _n = z.effects, _n === null ? z.effects = [Le] : _n.push(Le));
          } else zr = { eventTime: zr, lane: _n, tag: Le.tag, payload: Le.payload, callback: Le.callback, next: null }, Vt === null ? (Ot = Vt = zr, ct = Cn) : Vt = Vt.next = zr, fe |= _n;
          if (Le = Le.next, Le === null) {
            if (Le = z.shared.pending, Le === null) break;
            _n = Le, Le = _n.next, _n.next = null, z.lastBaseUpdate = _n, z.shared.pending = null;
          }
        } while (!0);
        if (Vt === null && (ct = Cn), z.baseState = ct, z.firstBaseUpdate = Ot, z.lastBaseUpdate = Vt, m = z.shared.interleaved, m !== null) {
          z = m;
          do
            fe |= z.lane, z = z.next;
          while (z !== m);
        } else W === null && (z.shared.lanes = 0);
        Rs |= fe, h.lanes = fe, h.memoizedState = Cn;
      }
    }
    function $0(h, m, M) {
      if (h = m.effects, m.effects = null, h !== null) for (m = 0; m < h.length; m++) {
        var A = h[m], z = A.callback;
        if (z !== null) {
          if (A.callback = null, A = M, typeof z != "function") throw Error(o(191, z));
          z.call(A);
        }
      }
    }
    var W0 = new r.Component().refs;
    function Qh(h, m, M, A) {
      m = h.memoizedState, M = M(A, m), M = M == null ? m : a({}, m, M), h.memoizedState = M, h.lanes === 0 && (h.updateQueue.baseState = M);
    }
    var Jh = { isMounted: function(h) {
      return (h = h._reactInternals) ? L(h) === h : !1;
    }, enqueueSetState: function(h, m, M) {
      h = h._reactInternals;
      var A = ma(), z = kl(h), W = Zs(A, z);
      W.payload = m, M != null && (W.callback = M), Nl(h, W), m = Ro(h, z, A), m !== null && Kh(m, h, z);
    }, enqueueReplaceState: function(h, m, M) {
      h = h._reactInternals;
      var A = ma(), z = kl(h), W = Zs(A, z);
      W.tag = 1, W.payload = m, M != null && (W.callback = M), Nl(h, W), m = Ro(h, z, A), m !== null && Kh(m, h, z);
    }, enqueueForceUpdate: function(h, m) {
      h = h._reactInternals;
      var M = ma(), A = kl(h), z = Zs(
        M,
        A
      );
      z.tag = 2, m != null && (z.callback = m), Nl(h, z), m = Ro(h, A, M), m !== null && Kh(m, h, A);
    } };
    function j0(h, m, M, A, z, W, fe) {
      return h = h.stateNode, typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(A, W, fe) : m.prototype && m.prototype.isPureReactComponent ? !Xh(M, A) || !Xh(z, W) : !0;
    }
    function G0(h, m, M) {
      var A = !1, z = rr, W = m.contextType;
      return typeof W == "object" && W !== null ? W = _o(W) : (z = cn(m) ? Xr : hn.current, A = m.contextTypes, W = (A = A != null) ? ur(h, z) : rr), m = new m(M, W), h.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = Jh, h.stateNode = m, m._reactInternals = h, A && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = z, h.__reactInternalMemoizedMaskedChildContext = W), m;
    }
    function X0(h, m, M, A) {
      h = m.state, typeof m.componentWillReceiveProps == "function" && m.componentWillReceiveProps(M, A), typeof m.UNSAFE_componentWillReceiveProps == "function" && m.UNSAFE_componentWillReceiveProps(M, A), m.state !== h && Jh.enqueueReplaceState(m, m.state, null);
    }
    function Ng(h, m, M, A) {
      var z = h.stateNode;
      z.props = M, z.state = h.memoizedState, z.refs = W0, Ig(h);
      var W = m.contextType;
      typeof W == "object" && W !== null ? z.context = _o(W) : (W = cn(m) ? Xr : hn.current, z.context = ur(h, W)), z.state = h.memoizedState, W = m.getDerivedStateFromProps, typeof W == "function" && (Qh(h, m, W, M), z.state = h.memoizedState), typeof m.getDerivedStateFromProps == "function" || typeof z.getSnapshotBeforeUpdate == "function" || typeof z.UNSAFE_componentWillMount != "function" && typeof z.componentWillMount != "function" || (m = z.state, typeof z.componentWillMount == "function" && z.componentWillMount(), typeof z.UNSAFE_componentWillMount == "function" && z.UNSAFE_componentWillMount(), m !== z.state && Jh.enqueueReplaceState(z, z.state, null), Zh(h, M, z, A), z.state = h.memoizedState), typeof z.componentDidMount == "function" && (h.flags |= 4194308);
    }
    var Pu = [], Du = 0, ep = null, tp = 0, xo = [], Eo = 0, yc = null, Qs = 1, Js = "";
    function bc(h, m) {
      Pu[Du++] = tp, Pu[Du++] = ep, ep = h, tp = m;
    }
    function q0(h, m, M) {
      xo[Eo++] = Qs, xo[Eo++] = Js, xo[Eo++] = yc, yc = h;
      var A = Qs;
      h = Js;
      var z = 32 - Sr(A) - 1;
      A &= ~(1 << z), M += 1;
      var W = 32 - Sr(m) + z;
      if (30 < W) {
        var fe = z - z % 5;
        W = (A & (1 << fe) - 1).toString(32), A >>= fe, z -= fe, Qs = 1 << 32 - Sr(m) + z | M << z | A, Js = W + h;
      } else Qs = 1 << W | M << z | A, Js = h;
    }
    function Lg(h) {
      h.return !== null && (bc(h, 1), q0(h, 1, 0));
    }
    function Fg(h) {
      for (; h === ep; ) ep = Pu[--Du], Pu[Du] = null, tp = Pu[--Du], Pu[Du] = null;
      for (; h === yc; ) yc = xo[--Eo], xo[Eo] = null, Js = xo[--Eo], xo[Eo] = null, Qs = xo[--Eo], xo[Eo] = null;
    }
    var Ja = null, Ji = null, Yr = !1, Iu = !1, Co = null;
    function Ug(h, m) {
      var M = ga(5, null, null, 0);
      M.elementType = "DELETED", M.stateNode = m, M.return = h, m = h.deletions, m === null ? (h.deletions = [M], h.flags |= 16) : m.push(M);
    }
    function zg(h, m) {
      switch (h.tag) {
        case 5:
          return m = Nn(m, h.type, h.pendingProps), m !== null ? (h.stateNode = m, Ja = h, Ji = cr(m), !0) : !1;
        case 6:
          return m = xt(m, h.pendingProps), m !== null ? (h.stateNode = m, Ja = h, Ji = null, !0) : !1;
        case 13:
          if (m = Pt(m), m !== null) {
            var M = yc !== null ? { id: Qs, overflow: Js } : null;
            return h.memoizedState = { dehydrated: m, treeContext: M, retryLane: 1073741824 }, M = ga(18, null, null, 0), M.stateNode = m, M.return = h, h.child = M, Ja = h, Ji = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function np(h) {
      return (h.mode & 1) !== 0 && (h.flags & 128) === 0;
    }
    function rp(h) {
      if (Yr) {
        var m = Ji;
        if (m) {
          var M = m;
          if (!zg(h, m)) {
            if (np(h)) throw Error(o(418));
            m = Mn(M);
            var A = Ja;
            m && zg(h, m) ? Ug(A, M) : (h.flags = h.flags & -4097 | 2, Yr = !1, Ja = h);
          }
        } else {
          if (np(h)) throw Error(o(418));
          h.flags = h.flags & -4097 | 2, Yr = !1, Ja = h;
        }
      }
    }
    function Bg(h) {
      for (h = h.return; h !== null && h.tag !== 5 && h.tag !== 3 && h.tag !== 13; ) h = h.return;
      Ja = h;
    }
    function tf(h) {
      if (!Te || h !== Ja) return !1;
      if (!Yr) return Bg(h), Yr = !0, !1;
      if (h.tag !== 3 && (h.tag !== 5 || je(h.type) && !oe(h.type, h.memoizedProps))) {
        var m = Ji;
        if (m) {
          if (np(h)) {
            for (h = Ji; h; ) h = Mn(h);
            throw Error(o(418));
          }
          for (; m; ) Ug(h, m), m = Mn(m);
        }
      }
      if (Bg(h), h.tag === 13) {
        if (!Te) throw Error(o(316));
        if (h = h.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(o(317));
        Ji = ee(h);
      } else Ji = Ja ? Mn(h.stateNode) : null;
      return !0;
    }
    function Nu() {
      Te && (Ji = Ja = null, Iu = Yr = !1);
    }
    function nf(h) {
      Co === null ? Co = [h] : Co.push(h);
    }
    function Sc(h, m, M) {
      if (h = M.ref, h !== null && typeof h != "function" && typeof h != "object") {
        if (M._owner) {
          if (M = M._owner, M) {
            if (M.tag !== 1) throw Error(o(309));
            var A = M.stateNode;
          }
          if (!A) throw Error(o(147, h));
          var z = A, W = "" + h;
          return m !== null && m.ref !== null && typeof m.ref == "function" && m.ref._stringRef === W ? m.ref : (m = function(fe) {
            var Le = z.refs;
            Le === W0 && (Le = z.refs = {}), fe === null ? delete Le[W] : Le[W] = fe;
          }, m._stringRef = W, m);
        }
        if (typeof h != "string") throw Error(o(284));
        if (!M._owner) throw Error(o(290, h));
      }
      return h;
    }
    function Xo(h, m) {
      throw h = Object.prototype.toString.call(m), Error(o(31, h === "[object Object]" ? "object with keys {" + Object.keys(m).join(", ") + "}" : h));
    }
    function ip(h) {
      var m = h._init;
      return m(h._payload);
    }
    function rf(h) {
      function m(Qe, ze) {
        if (h) {
          var rt = Qe.deletions;
          rt === null ? (Qe.deletions = [ze], Qe.flags |= 16) : rt.push(ze);
        }
      }
      function M(Qe, ze) {
        if (!h) return null;
        for (; ze !== null; ) m(Qe, ze), ze = ze.sibling;
        return null;
      }
      function A(Qe, ze) {
        for (Qe = /* @__PURE__ */ new Map(); ze !== null; ) ze.key !== null ? Qe.set(ze.key, ze) : Qe.set(ze.index, ze), ze = ze.sibling;
        return Qe;
      }
      function z(Qe, ze) {
        return Qe = Ua(Qe, ze), Qe.index = 0, Qe.sibling = null, Qe;
      }
      function W(Qe, ze, rt) {
        return Qe.index = rt, h ? (rt = Qe.alternate, rt !== null ? (rt = rt.index, rt < ze ? (Qe.flags |= 2, ze) : rt) : (Qe.flags |= 2, ze)) : (Qe.flags |= 1048576, ze);
      }
      function fe(Qe) {
        return h && Qe.alternate === null && (Qe.flags |= 2), Qe;
      }
      function Le(Qe, ze, rt, Xt) {
        return ze === null || ze.tag !== 6 ? (ze = Op(rt, Qe.mode, Xt), ze.return = Qe, ze) : (ze = z(ze, rt), ze.return = Qe, ze);
      }
      function ct(Qe, ze, rt, Xt) {
        var dn = rt.type;
        return dn === f ? Vt(Qe, ze, rt.props.children, Xt, rt.key) : ze !== null && (ze.elementType === dn || typeof dn == "object" && dn !== null && dn.$$typeof === C && ip(dn) === ze.type) ? (Xt = z(ze, rt.props), Xt.ref = Sc(Qe, ze, rt), Xt.return = Qe, Xt) : (Xt = zc(rt.type, rt.key, rt.props, null, Qe.mode, Xt), Xt.ref = Sc(Qe, ze, rt), Xt.return = Qe, Xt);
      }
      function Ot(Qe, ze, rt, Xt) {
        return ze === null || ze.tag !== 4 || ze.stateNode.containerInfo !== rt.containerInfo || ze.stateNode.implementation !== rt.implementation ? (ze = wf(rt, Qe.mode, Xt), ze.return = Qe, ze) : (ze = z(ze, rt.children || []), ze.return = Qe, ze);
      }
      function Vt(Qe, ze, rt, Xt, dn) {
        return ze === null || ze.tag !== 7 ? (ze = Wl(rt, Qe.mode, Xt, dn), ze.return = Qe, ze) : (ze = z(ze, rt), ze.return = Qe, ze);
      }
      function Cn(Qe, ze, rt) {
        if (typeof ze == "string" && ze !== "" || typeof ze == "number") return ze = Op("" + ze, Qe.mode, rt), ze.return = Qe, ze;
        if (typeof ze == "object" && ze !== null) {
          switch (ze.$$typeof) {
            case u:
              return rt = zc(ze.type, ze.key, ze.props, null, Qe.mode, rt), rt.ref = Sc(Qe, null, ze), rt.return = Qe, rt;
            case d:
              return ze = wf(ze, Qe.mode, rt), ze.return = Qe, ze;
            case C:
              var Xt = ze._init;
              return Cn(Qe, Xt(ze._payload), rt);
          }
          if (ae(ze) || D(ze)) return ze = Wl(ze, Qe.mode, rt, null), ze.return = Qe, ze;
          Xo(Qe, ze);
        }
        return null;
      }
      function _n(Qe, ze, rt, Xt) {
        var dn = ze !== null ? ze.key : null;
        if (typeof rt == "string" && rt !== "" || typeof rt == "number") return dn !== null ? null : Le(Qe, ze, "" + rt, Xt);
        if (typeof rt == "object" && rt !== null) {
          switch (rt.$$typeof) {
            case u:
              return rt.key === dn ? ct(Qe, ze, rt, Xt) : null;
            case d:
              return rt.key === dn ? Ot(Qe, ze, rt, Xt) : null;
            case C:
              return dn = rt._init, _n(
                Qe,
                ze,
                dn(rt._payload),
                Xt
              );
          }
          if (ae(rt) || D(rt)) return dn !== null ? null : Vt(Qe, ze, rt, Xt, null);
          Xo(Qe, rt);
        }
        return null;
      }
      function zr(Qe, ze, rt, Xt, dn) {
        if (typeof Xt == "string" && Xt !== "" || typeof Xt == "number") return Qe = Qe.get(rt) || null, Le(ze, Qe, "" + Xt, dn);
        if (typeof Xt == "object" && Xt !== null) {
          switch (Xt.$$typeof) {
            case u:
              return Qe = Qe.get(Xt.key === null ? rt : Xt.key) || null, ct(ze, Qe, Xt, dn);
            case d:
              return Qe = Qe.get(Xt.key === null ? rt : Xt.key) || null, Ot(ze, Qe, Xt, dn);
            case C:
              var Fn = Xt._init;
              return zr(Qe, ze, rt, Fn(Xt._payload), dn);
          }
          if (ae(Xt) || D(Xt)) return Qe = Qe.get(rt) || null, Vt(ze, Qe, Xt, dn, null);
          Xo(ze, Xt);
        }
        return null;
      }
      function pn(Qe, ze, rt, Xt) {
        for (var dn = null, Fn = null, xn = ze, $n = ze = 0, mi = null; xn !== null && $n < rt.length; $n++) {
          xn.index > $n ? (mi = xn, xn = null) : mi = xn.sibling;
          var or = _n(Qe, xn, rt[$n], Xt);
          if (or === null) {
            xn === null && (xn = mi);
            break;
          }
          h && xn && or.alternate === null && m(Qe, xn), ze = W(or, ze, $n), Fn === null ? dn = or : Fn.sibling = or, Fn = or, xn = mi;
        }
        if ($n === rt.length) return M(Qe, xn), Yr && bc(Qe, $n), dn;
        if (xn === null) {
          for (; $n < rt.length; $n++) xn = Cn(Qe, rt[$n], Xt), xn !== null && (ze = W(xn, ze, $n), Fn === null ? dn = xn : Fn.sibling = xn, Fn = xn);
          return Yr && bc(Qe, $n), dn;
        }
        for (xn = A(Qe, xn); $n < rt.length; $n++) mi = zr(xn, Qe, $n, rt[$n], Xt), mi !== null && (h && mi.alternate !== null && xn.delete(mi.key === null ? $n : mi.key), ze = W(mi, ze, $n), Fn === null ? dn = mi : Fn.sibling = mi, Fn = mi);
        return h && xn.forEach(function(jl) {
          return m(Qe, jl);
        }), Yr && bc(Qe, $n), dn;
      }
      function na(Qe, ze, rt, Xt) {
        var dn = D(rt);
        if (typeof dn != "function") throw Error(o(150));
        if (rt = dn.call(rt), rt == null) throw Error(o(151));
        for (var Fn = dn = null, xn = ze, $n = ze = 0, mi = null, or = rt.next(); xn !== null && !or.done; $n++, or = rt.next()) {
          xn.index > $n ? (mi = xn, xn = null) : mi = xn.sibling;
          var jl = _n(Qe, xn, or.value, Xt);
          if (jl === null) {
            xn === null && (xn = mi);
            break;
          }
          h && xn && jl.alternate === null && m(Qe, xn), ze = W(jl, ze, $n), Fn === null ? dn = jl : Fn.sibling = jl, Fn = jl, xn = mi;
        }
        if (or.done) return M(
          Qe,
          xn
        ), Yr && bc(Qe, $n), dn;
        if (xn === null) {
          for (; !or.done; $n++, or = rt.next()) or = Cn(Qe, or.value, Xt), or !== null && (ze = W(or, ze, $n), Fn === null ? dn = or : Fn.sibling = or, Fn = or);
          return Yr && bc(Qe, $n), dn;
        }
        for (xn = A(Qe, xn); !or.done; $n++, or = rt.next()) or = zr(xn, Qe, $n, or.value, Xt), or !== null && (h && or.alternate !== null && xn.delete(or.key === null ? $n : or.key), ze = W(or, ze, $n), Fn === null ? dn = or : Fn.sibling = or, Fn = or);
        return h && xn.forEach(function(Pp) {
          return m(Qe, Pp);
        }), Yr && bc(Qe, $n), dn;
      }
      function xa(Qe, ze, rt, Xt) {
        if (typeof rt == "object" && rt !== null && rt.type === f && rt.key === null && (rt = rt.props.children), typeof rt == "object" && rt !== null) {
          switch (rt.$$typeof) {
            case u:
              e: {
                for (var dn = rt.key, Fn = ze; Fn !== null; ) {
                  if (Fn.key === dn) {
                    if (dn = rt.type, dn === f) {
                      if (Fn.tag === 7) {
                        M(Qe, Fn.sibling), ze = z(Fn, rt.props.children), ze.return = Qe, Qe = ze;
                        break e;
                      }
                    } else if (Fn.elementType === dn || typeof dn == "object" && dn !== null && dn.$$typeof === C && ip(dn) === Fn.type) {
                      M(Qe, Fn.sibling), ze = z(Fn, rt.props), ze.ref = Sc(Qe, Fn, rt), ze.return = Qe, Qe = ze;
                      break e;
                    }
                    M(Qe, Fn);
                    break;
                  } else m(Qe, Fn);
                  Fn = Fn.sibling;
                }
                rt.type === f ? (ze = Wl(rt.props.children, Qe.mode, Xt, rt.key), ze.return = Qe, Qe = ze) : (Xt = zc(rt.type, rt.key, rt.props, null, Qe.mode, Xt), Xt.ref = Sc(Qe, ze, rt), Xt.return = Qe, Qe = Xt);
              }
              return fe(Qe);
            case d:
              e: {
                for (Fn = rt.key; ze !== null; ) {
                  if (ze.key === Fn) if (ze.tag === 4 && ze.stateNode.containerInfo === rt.containerInfo && ze.stateNode.implementation === rt.implementation) {
                    M(Qe, ze.sibling), ze = z(ze, rt.children || []), ze.return = Qe, Qe = ze;
                    break e;
                  } else {
                    M(Qe, ze);
                    break;
                  }
                  else m(Qe, ze);
                  ze = ze.sibling;
                }
                ze = wf(rt, Qe.mode, Xt), ze.return = Qe, Qe = ze;
              }
              return fe(Qe);
            case C:
              return Fn = rt._init, xa(Qe, ze, Fn(rt._payload), Xt);
          }
          if (ae(rt)) return pn(Qe, ze, rt, Xt);
          if (D(rt)) return na(Qe, ze, rt, Xt);
          Xo(Qe, rt);
        }
        return typeof rt == "string" && rt !== "" || typeof rt == "number" ? (rt = "" + rt, ze !== null && ze.tag === 6 ? (M(Qe, ze.sibling), ze = z(ze, rt), ze.return = Qe, Qe = ze) : (M(Qe, ze), ze = Op(rt, Qe.mode, Xt), ze.return = Qe, Qe = ze), fe(Qe)) : M(Qe, ze);
      }
      return xa;
    }
    var Lu = rf(!0), ap = rf(!1), af = {}, Ia = Zn(af), of = Zn(af), Ll = Zn(af);
    function qo(h) {
      if (h === af) throw Error(o(174));
      return h;
    }
    function op(h, m) {
      Nt(Ll, m), Nt(of, h), Nt(Ia, af), h = K(m), Jt(Ia), Nt(Ia, h);
    }
    function _c() {
      Jt(Ia), Jt(of), Jt(Ll);
    }
    function sf(h) {
      var m = qo(Ll.current), M = qo(Ia.current);
      m = B(M, h.type, m), M !== m && (Nt(of, h), Nt(Ia, m));
    }
    function eo(h) {
      of.current === h && (Jt(Ia), Jt(of));
    }
    var Kr = Zn(0);
    function xc(h) {
      for (var m = h; m !== null; ) {
        if (m.tag === 13) {
          var M = m.memoizedState;
          if (M !== null && (M = M.dehydrated, M === null || Bt(M) || Qt(M))) return m;
        } else if (m.tag === 19 && m.memoizedProps.revealOrder !== void 0) {
          if (m.flags & 128) return m;
        } else if (m.child !== null) {
          m.child.return = m, m = m.child;
          continue;
        }
        if (m === h) break;
        for (; m.sibling === null; ) {
          if (m.return === null || m.return === h) return null;
          m = m.return;
        }
        m.sibling.return = m.return, m = m.sibling;
      }
      return null;
    }
    var Yo = [];
    function _s() {
      for (var h = 0; h < Yo.length; h++) {
        var m = Yo[h];
        xe ? m._workInProgressVersionPrimary = null : m._workInProgressVersionSecondary = null;
      }
      Yo.length = 0;
    }
    var Di = s.ReactCurrentDispatcher, Tr = s.ReactCurrentBatchConfig, Fl = 0, ir = null, Qr = null, Ur = null, Fu = !1, xs = !1, Uu = 0, zu = 0;
    function Ii() {
      throw Error(o(321));
    }
    function wo(h, m) {
      if (m === null) return !1;
      for (var M = 0; M < m.length && M < h.length; M++) if (!ys(h[M], m[M])) return !1;
      return !0;
    }
    function Bu(h, m, M, A, z, W) {
      if (Fl = W, ir = m, m.memoizedState = null, m.updateQueue = null, m.lanes = 0, Di.current = h === null || h.memoizedState === null ? $g : Wg, h = M(A, z), xs) {
        W = 0;
        do {
          if (xs = !1, Uu = 0, 25 <= W) throw Error(o(301));
          W += 1, Ur = Qr = null, m.updateQueue = null, Di.current = jg, h = M(A, z);
        } while (xs);
      }
      if (Di.current = Wu, m = Qr !== null && Qr.next !== null, Fl = 0, Ur = Qr = ir = null, Fu = !1, m) throw Error(o(300));
      return h;
    }
    function lf() {
      var h = Uu !== 0;
      return Uu = 0, h;
    }
    function Es() {
      var h = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Ur === null ? ir.memoizedState = Ur = h : Ur = Ur.next = h, Ur;
    }
    function Ko() {
      if (Qr === null) {
        var h = ir.alternate;
        h = h !== null ? h.memoizedState : null;
      } else h = Qr.next;
      var m = Ur === null ? ir.memoizedState : Ur.next;
      if (m !== null) Ur = m, Qr = h;
      else {
        if (h === null) throw Error(o(310));
        Qr = h, h = { memoizedState: Qr.memoizedState, baseState: Qr.baseState, baseQueue: Qr.baseQueue, queue: Qr.queue, next: null }, Ur === null ? ir.memoizedState = Ur = h : Ur = Ur.next = h;
      }
      return Ur;
    }
    function Cs(h, m) {
      return typeof m == "function" ? m(h) : m;
    }
    function cf(h) {
      var m = Ko(), M = m.queue;
      if (M === null) throw Error(o(311));
      M.lastRenderedReducer = h;
      var A = Qr, z = A.baseQueue, W = M.pending;
      if (W !== null) {
        if (z !== null) {
          var fe = z.next;
          z.next = W.next, W.next = fe;
        }
        A.baseQueue = z = W, M.pending = null;
      }
      if (z !== null) {
        W = z.next, A = A.baseState;
        var Le = fe = null, ct = null, Ot = W;
        do {
          var Vt = Ot.lane;
          if ((Fl & Vt) === Vt) ct !== null && (ct = ct.next = { lane: 0, action: Ot.action, hasEagerState: Ot.hasEagerState, eagerState: Ot.eagerState, next: null }), A = Ot.hasEagerState ? Ot.eagerState : h(A, Ot.action);
          else {
            var Cn = {
              lane: Vt,
              action: Ot.action,
              hasEagerState: Ot.hasEagerState,
              eagerState: Ot.eagerState,
              next: null
            };
            ct === null ? (Le = ct = Cn, fe = A) : ct = ct.next = Cn, ir.lanes |= Vt, Rs |= Vt;
          }
          Ot = Ot.next;
        } while (Ot !== null && Ot !== W);
        ct === null ? fe = A : ct.next = Le, ys(A, m.memoizedState) || (pa = !0), m.memoizedState = A, m.baseState = fe, m.baseQueue = ct, M.lastRenderedState = A;
      }
      if (h = M.interleaved, h !== null) {
        z = h;
        do
          W = z.lane, ir.lanes |= W, Rs |= W, z = z.next;
        while (z !== h);
      } else z === null && (M.lanes = 0);
      return [m.memoizedState, M.dispatch];
    }
    function sp(h) {
      var m = Ko(), M = m.queue;
      if (M === null) throw Error(o(311));
      M.lastRenderedReducer = h;
      var A = M.dispatch, z = M.pending, W = m.memoizedState;
      if (z !== null) {
        M.pending = null;
        var fe = z = z.next;
        do
          W = h(W, fe.action), fe = fe.next;
        while (fe !== z);
        ys(W, m.memoizedState) || (pa = !0), m.memoizedState = W, m.baseQueue === null && (m.baseState = W), M.lastRenderedState = W;
      }
      return [W, A];
    }
    function Ec() {
    }
    function Hg(h, m) {
      var M = ir, A = Ko(), z = m(), W = !ys(A.memoizedState, z);
      if (W && (A.memoizedState = z, pa = !0), A = A.queue, wt(lr.bind(null, M, A, h), [h]), A.getSnapshot !== m || W || Ur !== null && Ur.memoizedState.tag & 1) {
        if (M.flags |= 2048, Hu(9, _r.bind(null, M, A, z, m), void 0, null), Ci === null) throw Error(o(349));
        Fl & 30 || An(M, m, z);
      }
      return z;
    }
    function An(h, m, M) {
      h.flags |= 16384, h = { getSnapshot: m, value: M }, m = ir.updateQueue, m === null ? (m = { lastEffect: null, stores: null }, ir.updateQueue = m, m.stores = [h]) : (M = m.stores, M === null ? m.stores = [h] : M.push(h));
    }
    function _r(h, m, M, A) {
      m.value = M, m.getSnapshot = A, di(m) && Ro(h, 1, -1);
    }
    function lr(h, m, M) {
      return M(function() {
        di(m) && Ro(h, 1, -1);
      });
    }
    function di(h) {
      var m = h.getSnapshot;
      h = h.value;
      try {
        var M = m();
        return !ys(h, M);
      } catch {
        return !0;
      }
    }
    function Mo(h) {
      var m = Es();
      return typeof h == "function" && (h = h()), m.memoizedState = m.baseState = h, h = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Cs, lastRenderedState: h }, m.queue = h, h = h.dispatch = kg.bind(null, ir, h), [m.memoizedState, h];
    }
    function Hu(h, m, M, A) {
      return h = { tag: h, create: m, destroy: M, deps: A, next: null }, m = ir.updateQueue, m === null ? (m = { lastEffect: null, stores: null }, ir.updateQueue = m, m.lastEffect = h.next = h) : (M = m.lastEffect, M === null ? m.lastEffect = h.next = h : (A = M.next, M.next = h, h.next = A, m.lastEffect = h)), h;
    }
    function Y0() {
      return Ko().memoizedState;
    }
    function lp(h, m, M, A) {
      var z = Es();
      ir.flags |= h, z.memoizedState = Hu(1 | m, M, void 0, A === void 0 ? null : A);
    }
    function cp(h, m, M, A) {
      var z = Ko();
      A = A === void 0 ? null : A;
      var W = void 0;
      if (Qr !== null) {
        var fe = Qr.memoizedState;
        if (W = fe.destroy, A !== null && wo(A, fe.deps)) {
          z.memoizedState = Hu(m, M, W, A);
          return;
        }
      }
      ir.flags |= h, z.memoizedState = Hu(1 | m, M, W, A);
    }
    function uf(h, m) {
      return lp(8390656, 8, h, m);
    }
    function wt(h, m) {
      return cp(2048, 8, h, m);
    }
    function Ni(h, m) {
      return cp(4, 2, h, m);
    }
    function Jn(h, m) {
      return cp(4, 4, h, m);
    }
    function Cc(h, m) {
      if (typeof m == "function") return h = h(), m(h), function() {
        m(null);
      };
      if (m != null) return h = h(), m.current = h, function() {
        m.current = null;
      };
    }
    function el(h, m, M) {
      return M = M != null ? M.concat([h]) : null, cp(4, 4, Cc.bind(null, m, h), M);
    }
    function tl() {
    }
    function ws(h, m) {
      var M = Ko();
      m = m === void 0 ? null : m;
      var A = M.memoizedState;
      return A !== null && m !== null && wo(m, A[1]) ? A[0] : (M.memoizedState = [h, m], h);
    }
    function Vu(h, m) {
      var M = Ko();
      m = m === void 0 ? null : m;
      var A = M.memoizedState;
      return A !== null && m !== null && wo(m, A[1]) ? A[0] : (h = h(), M.memoizedState = [h, m], h);
    }
    function ku(h, m) {
      var M = Qn;
      Qn = M !== 0 && 4 > M ? M : 4, h(!0);
      var A = Tr.transition;
      Tr.transition = {};
      try {
        h(!1), m();
      } finally {
        Qn = M, Tr.transition = A;
      }
    }
    function $u() {
      return Ko().memoizedState;
    }
    function Vg(h, m, M) {
      var A = kl(h);
      M = { lane: A, action: M, hasEagerState: !1, eagerState: null, next: null }, up(h) ? dp(m, M) : (fp(h, m, M), M = ma(), h = Ro(h, A, M), h !== null && hp(h, m, A));
    }
    function kg(h, m, M) {
      var A = kl(h), z = { lane: A, action: M, hasEagerState: !1, eagerState: null, next: null };
      if (up(h)) dp(m, z);
      else {
        fp(h, m, z);
        var W = h.alternate;
        if (h.lanes === 0 && (W === null || W.lanes === 0) && (W = m.lastRenderedReducer, W !== null)) try {
          var fe = m.lastRenderedState, Le = W(fe, M);
          if (z.hasEagerState = !0, z.eagerState = Le, ys(Le, fe)) return;
        } catch {
        } finally {
        }
        M = ma(), h = Ro(h, A, M), h !== null && hp(h, m, A);
      }
    }
    function up(h) {
      var m = h.alternate;
      return h === ir || m !== null && m === ir;
    }
    function dp(h, m) {
      xs = Fu = !0;
      var M = h.pending;
      M === null ? m.next = m : (m.next = M.next, M.next = m), h.pending = m;
    }
    function fp(h, m, M) {
      Ci !== null && h.mode & 1 && !(kn & 2) ? (h = m.interleaved, h === null ? (M.next = M, Go === null ? Go = [m] : Go.push(m)) : (M.next = h.next, h.next = M), m.interleaved = M) : (h = m.pending, h === null ? M.next = M : (M.next = h.next, h.next = M), m.pending = M);
    }
    function hp(h, m, M) {
      if (M & 4194240) {
        var A = m.lanes;
        A &= h.pendingLanes, M |= A, m.lanes = M, Ys(h, M);
      }
    }
    var Wu = { readContext: _o, useCallback: Ii, useContext: Ii, useEffect: Ii, useImperativeHandle: Ii, useInsertionEffect: Ii, useLayoutEffect: Ii, useMemo: Ii, useReducer: Ii, useRef: Ii, useState: Ii, useDebugValue: Ii, useDeferredValue: Ii, useTransition: Ii, useMutableSource: Ii, useSyncExternalStore: Ii, useId: Ii, unstable_isNewReconciler: !1 }, $g = { readContext: _o, useCallback: function(h, m) {
      return Es().memoizedState = [h, m === void 0 ? null : m], h;
    }, useContext: _o, useEffect: uf, useImperativeHandle: function(h, m, M) {
      return M = M != null ? M.concat([h]) : null, lp(
        4194308,
        4,
        Cc.bind(null, m, h),
        M
      );
    }, useLayoutEffect: function(h, m) {
      return lp(4194308, 4, h, m);
    }, useInsertionEffect: function(h, m) {
      return lp(4, 2, h, m);
    }, useMemo: function(h, m) {
      var M = Es();
      return m = m === void 0 ? null : m, h = h(), M.memoizedState = [h, m], h;
    }, useReducer: function(h, m, M) {
      var A = Es();
      return m = M !== void 0 ? M(m) : m, A.memoizedState = A.baseState = m, h = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: h, lastRenderedState: m }, A.queue = h, h = h.dispatch = Vg.bind(null, ir, h), [A.memoizedState, h];
    }, useRef: function(h) {
      var m = Es();
      return h = { current: h }, m.memoizedState = h;
    }, useState: Mo, useDebugValue: tl, useDeferredValue: function(h) {
      var m = Mo(h), M = m[0], A = m[1];
      return uf(function() {
        var z = Tr.transition;
        Tr.transition = {};
        try {
          A(h);
        } finally {
          Tr.transition = z;
        }
      }, [h]), M;
    }, useTransition: function() {
      var h = Mo(!1), m = h[0];
      return h = ku.bind(null, h[1]), Es().memoizedState = h, [m, h];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(h, m, M) {
      var A = ir, z = Es();
      if (Yr) {
        if (M === void 0) throw Error(o(407));
        M = M();
      } else {
        if (M = m(), Ci === null) throw Error(o(349));
        Fl & 30 || An(A, m, M);
      }
      z.memoizedState = M;
      var W = { value: M, getSnapshot: m };
      return z.queue = W, uf(lr.bind(null, A, W, h), [h]), A.flags |= 2048, Hu(9, _r.bind(null, A, W, M, m), void 0, null), M;
    }, useId: function() {
      var h = Es(), m = Ci.identifierPrefix;
      if (Yr) {
        var M = Js, A = Qs;
        M = (A & ~(1 << 32 - Sr(A) - 1)).toString(32) + M, m = ":" + m + "R" + M, M = Uu++, 0 < M && (m += "H" + M.toString(32)), m += ":";
      } else M = zu++, m = ":" + m + "r" + M.toString(32) + ":";
      return h.memoizedState = m;
    }, unstable_isNewReconciler: !1 }, Wg = {
      readContext: _o,
      useCallback: ws,
      useContext: _o,
      useEffect: wt,
      useImperativeHandle: el,
      useInsertionEffect: Ni,
      useLayoutEffect: Jn,
      useMemo: Vu,
      useReducer: cf,
      useRef: Y0,
      useState: function() {
        return cf(Cs);
      },
      useDebugValue: tl,
      useDeferredValue: function(h) {
        var m = cf(Cs), M = m[0], A = m[1];
        return wt(function() {
          var z = Tr.transition;
          Tr.transition = {};
          try {
            A(h);
          } finally {
            Tr.transition = z;
          }
        }, [h]), M;
      },
      useTransition: function() {
        var h = cf(Cs)[0], m = Ko().memoizedState;
        return [h, m];
      },
      useMutableSource: Ec,
      useSyncExternalStore: Hg,
      useId: $u,
      unstable_isNewReconciler: !1
    }, jg = {
      readContext: _o,
      useCallback: ws,
      useContext: _o,
      useEffect: wt,
      useImperativeHandle: el,
      useInsertionEffect: Ni,
      useLayoutEffect: Jn,
      useMemo: Vu,
      useReducer: sp,
      useRef: Y0,
      useState: function() {
        return sp(Cs);
      },
      useDebugValue: tl,
      useDeferredValue: function(h) {
        var m = sp(Cs), M = m[0], A = m[1];
        return wt(function() {
          var z = Tr.transition;
          Tr.transition = {};
          try {
            A(h);
          } finally {
            Tr.transition = z;
          }
        }, [h]), M;
      },
      useTransition: function() {
        var h = sp(Cs)[0], m = Ko().memoizedState;
        return [h, m];
      },
      useMutableSource: Ec,
      useSyncExternalStore: Hg,
      useId: $u,
      unstable_isNewReconciler: !1
    };
    function df(h, m) {
      try {
        var M = "", A = m;
        do
          M += vC(A), A = A.return;
        while (A);
        var z = M;
      } catch (W) {
        z = `
Error generating stack: ` + W.message + `
` + W.stack;
      }
      return { value: h, source: m, stack: z };
    }
    function ff(h, m) {
      try {
        console.error(m.value);
      } catch (M) {
        setTimeout(function() {
          throw M;
        });
      }
    }
    var Gg = typeof WeakMap == "function" ? WeakMap : Map;
    function pp(h, m, M) {
      M = Zs(-1, M), M.tag = 3, M.payload = { element: null };
      var A = m.value;
      return M.callback = function() {
        yf || (yf = !0, Mp = A), ff(h, m);
      }, M;
    }
    function mp(h, m, M) {
      M = Zs(-1, M), M.tag = 3;
      var A = h.type.getDerivedStateFromError;
      if (typeof A == "function") {
        var z = m.value;
        M.payload = function() {
          return A(z);
        }, M.callback = function() {
          ff(h, m);
        };
      }
      var W = h.stateNode;
      return W !== null && typeof W.componentDidCatch == "function" && (M.callback = function() {
        ff(h, m), typeof A != "function" && (Hl === null ? Hl = /* @__PURE__ */ new Set([this]) : Hl.add(this));
        var fe = m.stack;
        this.componentDidCatch(m.value, { componentStack: fe !== null ? fe : "" });
      }), M;
    }
    function hf(h, m, M) {
      var A = h.pingCache;
      if (A === null) {
        A = h.pingCache = new Gg();
        var z = /* @__PURE__ */ new Set();
        A.set(m, z);
      } else z = A.get(m), z === void 0 && (z = /* @__PURE__ */ new Set(), A.set(m, z));
      z.has(M) || (z.add(M), h = As.bind(null, h, m, M), m.then(h, h));
    }
    function wc(h) {
      do {
        var m;
        if ((m = h.tag === 13) && (m = h.memoizedState, m = m !== null ? m.dehydrated !== null : !0), m) return h;
        h = h.return;
      } while (h !== null);
      return null;
    }
    function gp(h, m, M, A, z) {
      return h.mode & 1 ? (h.flags |= 65536, h.lanes = z, h) : (h === m ? h.flags |= 65536 : (h.flags |= 128, M.flags |= 131072, M.flags &= -52805, M.tag === 1 && (M.alternate === null ? M.tag = 17 : (m = Zs(-1, 1), m.tag = 2, Nl(M, m))), M.lanes |= 1), h);
    }
    function To(h) {
      h.flags |= 4;
    }
    function vp(h, m) {
      if (h !== null && h.child === m.child) return !0;
      if (m.flags & 16) return !1;
      for (h = m.child; h !== null; ) {
        if (h.flags & 12854 || h.subtreeFlags & 12854) return !1;
        h = h.sibling;
      }
      return !0;
    }
    var Mc, ju, Ul, pf;
    if (Me) Mc = function(h, m) {
      for (var M = m.child; M !== null; ) {
        if (M.tag === 5 || M.tag === 6) ne(h, M.stateNode);
        else if (M.tag !== 4 && M.child !== null) {
          M.child.return = M, M = M.child;
          continue;
        }
        if (M === m) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === m) return;
          M = M.return;
        }
        M.sibling.return = M.return, M = M.sibling;
      }
    }, ju = function() {
    }, Ul = function(h, m, M, A, z) {
      if (h = h.memoizedProps, h !== A) {
        var W = m.stateNode, fe = qo(Ia.current);
        M = ie(W, M, h, A, z, fe), (m.updateQueue = M) && To(m);
      }
    }, pf = function(h, m, M, A) {
      M !== A && To(m);
    };
    else if ($) {
      Mc = function(h, m, M, A) {
        for (var z = m.child; z !== null; ) {
          if (z.tag === 5) {
            var W = z.stateNode;
            M && A && (W = Ct(W, z.type, z.memoizedProps, z)), ne(h, W);
          } else if (z.tag === 6) W = z.stateNode, M && A && (W = un(W, z.memoizedProps, z)), ne(h, W);
          else if (z.tag !== 4) {
            if (z.tag === 22 && z.memoizedState !== null) W = z.child, W !== null && (W.return = z), Mc(h, z, !0, !0);
            else if (z.child !== null) {
              z.child.return = z, z = z.child;
              continue;
            }
          }
          if (z === m) break;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === m) return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        }
      };
      var Gu = function(h, m, M, A) {
        for (var z = m.child; z !== null; ) {
          if (z.tag === 5) {
            var W = z.stateNode;
            M && A && (W = Ct(W, z.type, z.memoizedProps, z)), _t(h, W);
          } else if (z.tag === 6) W = z.stateNode, M && A && (W = un(W, z.memoizedProps, z)), _t(h, W);
          else if (z.tag !== 4) {
            if (z.tag === 22 && z.memoizedState !== null) W = z.child, W !== null && (W.return = z), Gu(h, z, !0, !0);
            else if (z.child !== null) {
              z.child.return = z, z = z.child;
              continue;
            }
          }
          if (z === m) break;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === m) return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        }
      };
      ju = function(h, m) {
        var M = m.stateNode;
        if (!vp(h, m)) {
          h = M.containerInfo;
          var A = vt(h);
          Gu(A, m, !1, !1), M.pendingChildren = A, To(m), Wt(h, A);
        }
      }, Ul = function(h, m, M, A, z) {
        var W = h.stateNode, fe = h.memoizedProps;
        if ((h = vp(h, m)) && fe === A) m.stateNode = W;
        else {
          var Le = m.stateNode, ct = qo(Ia.current), Ot = null;
          fe !== A && (Ot = ie(Le, M, fe, A, z, ct)), h && Ot === null ? m.stateNode = W : (W = ut(W, Ot, M, fe, A, m, h, Le), ce(W, M, A, z, ct) && To(m), m.stateNode = W, h ? To(m) : Mc(W, m, !1, !1));
        }
      }, pf = function(h, m, M, A) {
        M !== A ? (h = qo(Ll.current), M = qo(Ia.current), m.stateNode = he(A, h, M, m), To(m)) : m.stateNode = h.stateNode;
      };
    } else ju = function() {
    }, Ul = function() {
    }, pf = function() {
    };
    function Zo(h, m) {
      if (!Yr) switch (h.tailMode) {
        case "hidden":
          m = h.tail;
          for (var M = null; m !== null; ) m.alternate !== null && (M = m), m = m.sibling;
          M === null ? h.tail = null : M.sibling = null;
          break;
        case "collapsed":
          M = h.tail;
          for (var A = null; M !== null; ) M.alternate !== null && (A = M), M = M.sibling;
          A === null ? m || h.tail === null ? h.tail = null : h.tail.sibling = null : A.sibling = null;
      }
    }
    function Rr(h) {
      var m = h.alternate !== null && h.alternate.child === h.child, M = 0, A = 0;
      if (m) for (var z = h.child; z !== null; ) M |= z.lanes | z.childLanes, A |= z.subtreeFlags & 14680064, A |= z.flags & 14680064, z.return = h, z = z.sibling;
      else for (z = h.child; z !== null; ) M |= z.lanes | z.childLanes, A |= z.subtreeFlags, A |= z.flags, z.return = h, z = z.sibling;
      return h.subtreeFlags |= A, h.childLanes = M, m;
    }
    function yC(h, m, M) {
      var A = m.pendingProps;
      switch (Fg(m), m.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Rr(m), null;
        case 1:
          return cn(m.type) && en(), Rr(m), null;
        case 3:
          return A = m.stateNode, _c(), Jt(Tn), Jt(hn), _s(), A.pendingContext && (A.context = A.pendingContext, A.pendingContext = null), (h === null || h.child === null) && (tf(m) ? To(m) : h === null || h.memoizedState.isDehydrated && !(m.flags & 256) || (m.flags |= 1024, Co !== null && (_f(Co), Co = null))), ju(h, m), Rr(m), null;
        case 5:
          eo(m), M = qo(Ll.current);
          var z = m.type;
          if (h !== null && m.stateNode != null) Ul(h, m, z, A, M), h.ref !== m.ref && (m.flags |= 512, m.flags |= 2097152);
          else {
            if (!A) {
              if (m.stateNode === null) throw Error(o(166));
              return Rr(m), null;
            }
            if (h = qo(Ia.current), tf(m)) {
              if (!Te) throw Error(o(175));
              h = yt(m.stateNode, m.type, m.memoizedProps, M, h, m, !Iu), m.updateQueue = h, h !== null && To(m);
            } else {
              var W = q(z, A, M, h, m);
              Mc(W, m, !1, !1), m.stateNode = W, ce(W, z, A, M, h) && To(m);
            }
            m.ref !== null && (m.flags |= 512, m.flags |= 2097152);
          }
          return Rr(m), null;
        case 6:
          if (h && m.stateNode != null) pf(h, m, h.memoizedProps, A);
          else {
            if (typeof A != "string" && m.stateNode === null) throw Error(o(166));
            if (h = qo(Ll.current), M = qo(Ia.current), tf(m)) {
              if (!Te) throw Error(o(176));
              if (h = m.stateNode, A = m.memoizedProps, (M = Kt(h, A, m, !Iu)) && (z = Ja, z !== null)) switch (W = (z.mode & 1) !== 0, z.tag) {
                case 3:
                  bt(z.stateNode.containerInfo, h, A, W);
                  break;
                case 5:
                  It(z.type, z.memoizedProps, z.stateNode, h, A, W);
              }
              M && To(m);
            } else m.stateNode = he(A, h, M, m);
          }
          return Rr(m), null;
        case 13:
          if (Jt(Kr), A = m.memoizedState, Yr && Ji !== null && m.mode & 1 && !(m.flags & 128)) {
            for (h = Ji; h; ) h = Mn(h);
            return Nu(), m.flags |= 98560, m;
          }
          if (A !== null && A.dehydrated !== null) {
            if (A = tf(m), h === null) {
              if (!A) throw Error(o(318));
              if (!Te) throw Error(o(344));
              if (h = m.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(o(317));
              Sn(h, m);
            } else Nu(), !(m.flags & 128) && (m.memoizedState = null), m.flags |= 4;
            return Rr(m), null;
          }
          return Co !== null && (_f(Co), Co = null), m.flags & 128 ? (m.lanes = M, m) : (A = A !== null, M = !1, h === null ? tf(m) : M = h.memoizedState !== null, A && !M && (m.child.flags |= 8192, m.mode & 1 && (h === null || Kr.current & 1 ? Fi === 0 && (Fi = 3) : dv())), m.updateQueue !== null && (m.flags |= 4), Rr(m), null);
        case 4:
          return _c(), ju(h, m), h === null && Ie(m.stateNode.containerInfo), Rr(m), null;
        case 10:
          return Yh(m.type._context), Rr(m), null;
        case 17:
          return cn(m.type) && en(), Rr(m), null;
        case 19:
          if (Jt(Kr), z = m.memoizedState, z === null) return Rr(m), null;
          if (A = (m.flags & 128) !== 0, W = z.rendering, W === null) if (A) Zo(z, !1);
          else {
            if (Fi !== 0 || h !== null && h.flags & 128) for (h = m.child; h !== null; ) {
              if (W = xc(h), W !== null) {
                for (m.flags |= 128, Zo(z, !1), h = W.updateQueue, h !== null && (m.updateQueue = h, m.flags |= 4), m.subtreeFlags = 0, h = M, A = m.child; A !== null; ) M = A, z = h, M.flags &= 14680066, W = M.alternate, W === null ? (M.childLanes = 0, M.lanes = z, M.child = null, M.subtreeFlags = 0, M.memoizedProps = null, M.memoizedState = null, M.updateQueue = null, M.dependencies = null, M.stateNode = null) : (M.childLanes = W.childLanes, M.lanes = W.lanes, M.child = W.child, M.subtreeFlags = 0, M.deletions = null, M.memoizedProps = W.memoizedProps, M.memoizedState = W.memoizedState, M.updateQueue = W.updateQueue, M.type = W.type, z = W.dependencies, M.dependencies = z === null ? null : { lanes: z.lanes, firstContext: z.firstContext }), A = A.sibling;
                return Nt(Kr, Kr.current & 1 | 2), m.child;
              }
              h = h.sibling;
            }
            z.tail !== null && nn() > sv && (m.flags |= 128, A = !0, Zo(z, !1), m.lanes = 4194304);
          }
          else {
            if (!A) if (h = xc(W), h !== null) {
              if (m.flags |= 128, A = !0, h = h.updateQueue, h !== null && (m.updateQueue = h, m.flags |= 4), Zo(z, !0), z.tail === null && z.tailMode === "hidden" && !W.alternate && !Yr) return Rr(m), null;
            } else 2 * nn() - z.renderingStartTime > sv && M !== 1073741824 && (m.flags |= 128, A = !0, Zo(z, !1), m.lanes = 4194304);
            z.isBackwards ? (W.sibling = m.child, m.child = W) : (h = z.last, h !== null ? h.sibling = W : m.child = W, z.last = W);
          }
          return z.tail !== null ? (m = z.tail, z.rendering = m, z.tail = m.sibling, z.renderingStartTime = nn(), m.sibling = null, h = Kr.current, Nt(Kr, A ? h & 1 | 2 : h & 1), m) : (Rr(m), null);
        case 22:
        case 23:
          return Ao(), A = m.memoizedState !== null, h !== null && h.memoizedState !== null !== A && (m.flags |= 8192), A && m.mode & 1 ? no & 1073741824 && (Rr(m), Me && m.subtreeFlags & 6 && (m.flags |= 8192)) : Rr(m), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(o(156, m.tag));
    }
    var Vr = s.ReactCurrentOwner, pa = !1;
    function ji(h, m, M, A) {
      m.child = h === null ? ap(m, null, M, A) : Lu(m, h.child, M, A);
    }
    function Xu(h, m, M, A, z) {
      M = M.render;
      var W = m.ref;
      return Ou(m, z), A = Bu(h, m, M, A, W, z), M = lf(), h !== null && !pa ? (m.updateQueue = h.updateQueue, m.flags &= -2053, h.lanes &= ~z, fi(h, m, z)) : (Yr && M && Lg(m), m.flags |= 1, ji(h, m, A, z), m.child);
    }
    function mf(h, m, M, A, z) {
      if (h === null) {
        var W = M.type;
        return typeof W == "function" && !Uc(W) && W.defaultProps === void 0 && M.compare === null && M.defaultProps === void 0 ? (m.tag = 15, m.type = W, K0(h, m, W, A, z)) : (h = zc(M.type, null, A, m, m.mode, z), h.ref = m.ref, h.return = m, m.child = h);
      }
      if (W = h.child, !(h.lanes & z)) {
        var fe = W.memoizedProps;
        if (M = M.compare, M = M !== null ? M : Xh, M(fe, A) && h.ref === m.ref) return fi(h, m, z);
      }
      return m.flags |= 1, h = Ua(W, A), h.ref = m.ref, h.return = m, m.child = h;
    }
    function K0(h, m, M, A, z) {
      if (h !== null && Xh(h.memoizedProps, A) && h.ref === m.ref) if (pa = !1, (h.lanes & z) !== 0) h.flags & 131072 && (pa = !0);
      else return m.lanes = h.lanes, fi(h, m, z);
      return Xg(h, m, M, A, z);
    }
    function Z0(h, m, M) {
      var A = m.pendingProps, z = A.children, W = h !== null ? h.memoizedState : null;
      if (A.mode === "hidden") if (!(m.mode & 1)) m.memoizedState = { baseLanes: 0, cachePool: null }, Nt(ed, no), no |= M;
      else if (M & 1073741824) m.memoizedState = { baseLanes: 0, cachePool: null }, A = W !== null ? W.baseLanes : M, Nt(ed, no), no |= A;
      else return h = W !== null ? W.baseLanes | M : M, m.lanes = m.childLanes = 1073741824, m.memoizedState = { baseLanes: h, cachePool: null }, m.updateQueue = null, Nt(ed, no), no |= h, null;
      else W !== null ? (A = W.baseLanes | M, m.memoizedState = null) : A = M, Nt(ed, no), no |= A;
      return ji(h, m, z, M), m.child;
    }
    function Q0(h, m) {
      var M = m.ref;
      (h === null && M !== null || h !== null && h.ref !== M) && (m.flags |= 512, m.flags |= 2097152);
    }
    function Xg(h, m, M, A, z) {
      var W = cn(M) ? Xr : hn.current;
      return W = ur(m, W), Ou(m, z), M = Bu(h, m, M, A, W, z), A = lf(), h !== null && !pa ? (m.updateQueue = h.updateQueue, m.flags &= -2053, h.lanes &= ~z, fi(h, m, z)) : (Yr && A && Lg(m), m.flags |= 1, ji(h, m, M, z), m.child);
    }
    function yp(h, m, M, A, z) {
      if (cn(M)) {
        var W = !0;
        Pn(m);
      } else W = !1;
      if (Ou(m, z), m.stateNode === null) h !== null && (h.alternate = null, m.alternate = null, m.flags |= 2), G0(m, M, A), Ng(m, M, A, z), A = !0;
      else if (h === null) {
        var fe = m.stateNode, Le = m.memoizedProps;
        fe.props = Le;
        var ct = fe.context, Ot = M.contextType;
        typeof Ot == "object" && Ot !== null ? Ot = _o(Ot) : (Ot = cn(M) ? Xr : hn.current, Ot = ur(m, Ot));
        var Vt = M.getDerivedStateFromProps, Cn = typeof Vt == "function" || typeof fe.getSnapshotBeforeUpdate == "function";
        Cn || typeof fe.UNSAFE_componentWillReceiveProps != "function" && typeof fe.componentWillReceiveProps != "function" || (Le !== A || ct !== Ot) && X0(m, fe, A, Ot), Ss = !1;
        var _n = m.memoizedState;
        fe.state = _n, Zh(m, A, fe, z), ct = m.memoizedState, Le !== A || _n !== ct || Tn.current || Ss ? (typeof Vt == "function" && (Qh(m, M, Vt, A), ct = m.memoizedState), (Le = Ss || j0(m, M, Le, A, _n, ct, Ot)) ? (Cn || typeof fe.UNSAFE_componentWillMount != "function" && typeof fe.componentWillMount != "function" || (typeof fe.componentWillMount == "function" && fe.componentWillMount(), typeof fe.UNSAFE_componentWillMount == "function" && fe.UNSAFE_componentWillMount()), typeof fe.componentDidMount == "function" && (m.flags |= 4194308)) : (typeof fe.componentDidMount == "function" && (m.flags |= 4194308), m.memoizedProps = A, m.memoizedState = ct), fe.props = A, fe.state = ct, fe.context = Ot, A = Le) : (typeof fe.componentDidMount == "function" && (m.flags |= 4194308), A = !1);
      } else {
        fe = m.stateNode, ef(h, m), Le = m.memoizedProps, Ot = m.type === m.elementType ? Le : jo(m.type, Le), fe.props = Ot, Cn = m.pendingProps, _n = fe.context, ct = M.contextType, typeof ct == "object" && ct !== null ? ct = _o(ct) : (ct = cn(M) ? Xr : hn.current, ct = ur(m, ct));
        var zr = M.getDerivedStateFromProps;
        (Vt = typeof zr == "function" || typeof fe.getSnapshotBeforeUpdate == "function") || typeof fe.UNSAFE_componentWillReceiveProps != "function" && typeof fe.componentWillReceiveProps != "function" || (Le !== Cn || _n !== ct) && X0(m, fe, A, ct), Ss = !1, _n = m.memoizedState, fe.state = _n, Zh(m, A, fe, z);
        var pn = m.memoizedState;
        Le !== Cn || _n !== pn || Tn.current || Ss ? (typeof zr == "function" && (Qh(m, M, zr, A), pn = m.memoizedState), (Ot = Ss || j0(m, M, Ot, A, _n, pn, ct) || !1) ? (Vt || typeof fe.UNSAFE_componentWillUpdate != "function" && typeof fe.componentWillUpdate != "function" || (typeof fe.componentWillUpdate == "function" && fe.componentWillUpdate(
          A,
          pn,
          ct
        ), typeof fe.UNSAFE_componentWillUpdate == "function" && fe.UNSAFE_componentWillUpdate(A, pn, ct)), typeof fe.componentDidUpdate == "function" && (m.flags |= 4), typeof fe.getSnapshotBeforeUpdate == "function" && (m.flags |= 1024)) : (typeof fe.componentDidUpdate != "function" || Le === h.memoizedProps && _n === h.memoizedState || (m.flags |= 4), typeof fe.getSnapshotBeforeUpdate != "function" || Le === h.memoizedProps && _n === h.memoizedState || (m.flags |= 1024), m.memoizedProps = A, m.memoizedState = pn), fe.props = A, fe.state = pn, fe.context = ct, A = Ot) : (typeof fe.componentDidUpdate != "function" || Le === h.memoizedProps && _n === h.memoizedState || (m.flags |= 4), typeof fe.getSnapshotBeforeUpdate != "function" || Le === h.memoizedProps && _n === h.memoizedState || (m.flags |= 1024), A = !1);
      }
      return qg(h, m, M, A, W, z);
    }
    function qg(h, m, M, A, z, W) {
      Q0(h, m);
      var fe = (m.flags & 128) !== 0;
      if (!A && !fe) return z && Fr(m, M, !1), fi(h, m, W);
      A = m.stateNode, Vr.current = m;
      var Le = fe && typeof M.getDerivedStateFromError != "function" ? null : A.render();
      return m.flags |= 1, h !== null && fe ? (m.child = Lu(m, h.child, null, W), m.child = Lu(m, null, Le, W)) : ji(h, m, Le, W), m.memoizedState = A.state, z && Fr(m, M, !0), m.child;
    }
    function bp(h) {
      var m = h.stateNode;
      m.pendingContext ? gr(h, m.pendingContext, m.pendingContext !== m.context) : m.context && gr(h, m.context, !1), op(h, m.containerInfo);
    }
    function Yg(h, m, M, A, z) {
      return Nu(), nf(z), m.flags |= 256, ji(h, m, M, A), m.child;
    }
    var Sp = { dehydrated: null, treeContext: null, retryLane: 0 };
    function Tc(h) {
      return { baseLanes: h, cachePool: null };
    }
    function J0(h, m, M) {
      var A = m.pendingProps, z = Kr.current, W = !1, fe = (m.flags & 128) !== 0, Le;
      if ((Le = fe) || (Le = h !== null && h.memoizedState === null ? !1 : (z & 2) !== 0), Le ? (W = !0, m.flags &= -129) : (h === null || h.memoizedState !== null) && (z |= 1), Nt(Kr, z & 1), h === null)
        return rp(m), h = m.memoizedState, h !== null && (h = h.dehydrated, h !== null) ? (m.mode & 1 ? Qt(h) ? m.lanes = 8 : m.lanes = 1073741824 : m.lanes = 1, null) : (z = A.children, h = A.fallback, W ? (A = m.mode, W = m.child, z = { mode: "hidden", children: z }, !(A & 1) && W !== null ? (W.childLanes = 0, W.pendingProps = z) : W = Cf(z, A, 0, null), h = Wl(h, A, M, null), W.return = m, h.return = m, W.sibling = h, m.child = W, m.child.memoizedState = Tc(M), m.memoizedState = Sp, h) : _p(m, z));
      if (z = h.memoizedState, z !== null) {
        if (Le = z.dehydrated, Le !== null) {
          if (fe)
            return m.flags & 256 ? (m.flags &= -257, Ms(h, m, M, Error(o(422)))) : m.memoizedState !== null ? (m.child = h.child, m.flags |= 128, null) : (W = A.fallback, z = m.mode, A = Cf({ mode: "visible", children: A.children }, z, 0, null), W = Wl(W, z, M, null), W.flags |= 2, A.return = m, W.return = m, A.sibling = W, m.child = A, m.mode & 1 && Lu(
              m,
              h.child,
              null,
              M
            ), m.child.memoizedState = Tc(M), m.memoizedState = Sp, W);
          if (!(m.mode & 1)) m = Ms(h, m, M, null);
          else if (Qt(Le)) m = Ms(h, m, M, Error(o(419)));
          else if (A = (M & h.childLanes) !== 0, pa || A) {
            if (A = Ci, A !== null) {
              switch (M & -M) {
                case 4:
                  W = 2;
                  break;
                case 16:
                  W = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  W = 32;
                  break;
                case 536870912:
                  W = 268435456;
                  break;
                default:
                  W = 0;
              }
              A = W & (A.suspendedLanes | M) ? 0 : W, A !== 0 && A !== z.retryLane && (z.retryLane = A, Ro(h, A, -1));
            }
            dv(), m = Ms(h, m, M, Error(o(421)));
          } else Bt(Le) ? (m.flags |= 128, m.child = h.child, m = xC.bind(null, h), vn(Le, m), m = null) : (M = z.treeContext, Te && (Ji = it(Le), Ja = m, Yr = !0, Co = null, Iu = !1, M !== null && (xo[Eo++] = Qs, xo[Eo++] = Js, xo[Eo++] = yc, Qs = M.id, Js = M.overflow, yc = m)), m = _p(m, m.pendingProps.children), m.flags |= 4096);
          return m;
        }
        return W ? (A = tb(h, m, A.children, A.fallback, M), W = m.child, z = h.child.memoizedState, W.memoizedState = z === null ? Tc(M) : { baseLanes: z.baseLanes | M, cachePool: null }, W.childLanes = h.childLanes & ~M, m.memoizedState = Sp, A) : (M = eb(h, m, A.children, M), m.memoizedState = null, M);
      }
      return W ? (A = tb(h, m, A.children, A.fallback, M), W = m.child, z = h.child.memoizedState, W.memoizedState = z === null ? Tc(M) : { baseLanes: z.baseLanes | M, cachePool: null }, W.childLanes = h.childLanes & ~M, m.memoizedState = Sp, A) : (M = eb(h, m, A.children, M), m.memoizedState = null, M);
    }
    function _p(h, m) {
      return m = Cf({ mode: "visible", children: m }, h.mode, 0, null), m.return = h, h.child = m;
    }
    function eb(h, m, M, A) {
      var z = h.child;
      return h = z.sibling, M = Ua(z, { mode: "visible", children: M }), !(m.mode & 1) && (M.lanes = A), M.return = m, M.sibling = null, h !== null && (A = m.deletions, A === null ? (m.deletions = [h], m.flags |= 16) : A.push(h)), m.child = M;
    }
    function tb(h, m, M, A, z) {
      var W = m.mode;
      h = h.child;
      var fe = h.sibling, Le = { mode: "hidden", children: M };
      return !(W & 1) && m.child !== h ? (M = m.child, M.childLanes = 0, M.pendingProps = Le, m.deletions = null) : (M = Ua(h, Le), M.subtreeFlags = h.subtreeFlags & 14680064), fe !== null ? A = Ua(fe, A) : (A = Wl(A, W, z, null), A.flags |= 2), A.return = m, M.return = m, M.sibling = A, m.child = M, A;
    }
    function Ms(h, m, M, A) {
      return A !== null && nf(A), Lu(m, h.child, null, M), h = _p(m, m.pendingProps.children), h.flags |= 2, m.memoizedState = null, h;
    }
    function qu(h, m, M) {
      h.lanes |= m;
      var A = h.alternate;
      A !== null && (A.lanes |= m), Dg(h.return, m, M);
    }
    function nl(h, m, M, A, z) {
      var W = h.memoizedState;
      W === null ? h.memoizedState = { isBackwards: m, rendering: null, renderingStartTime: 0, last: A, tail: M, tailMode: z } : (W.isBackwards = m, W.rendering = null, W.renderingStartTime = 0, W.last = A, W.tail = M, W.tailMode = z);
    }
    function xp(h, m, M) {
      var A = m.pendingProps, z = A.revealOrder, W = A.tail;
      if (ji(h, m, A.children, M), A = Kr.current, A & 2) A = A & 1 | 2, m.flags |= 128;
      else {
        if (h !== null && h.flags & 128) e: for (h = m.child; h !== null; ) {
          if (h.tag === 13) h.memoizedState !== null && qu(h, M, m);
          else if (h.tag === 19) qu(h, M, m);
          else if (h.child !== null) {
            h.child.return = h, h = h.child;
            continue;
          }
          if (h === m) break e;
          for (; h.sibling === null; ) {
            if (h.return === null || h.return === m) break e;
            h = h.return;
          }
          h.sibling.return = h.return, h = h.sibling;
        }
        A &= 1;
      }
      if (Nt(Kr, A), !(m.mode & 1)) m.memoizedState = null;
      else switch (z) {
        case "forwards":
          for (M = m.child, z = null; M !== null; ) h = M.alternate, h !== null && xc(h) === null && (z = M), M = M.sibling;
          M = z, M === null ? (z = m.child, m.child = null) : (z = M.sibling, M.sibling = null), nl(m, !1, z, M, W);
          break;
        case "backwards":
          for (M = null, z = m.child, m.child = null; z !== null; ) {
            if (h = z.alternate, h !== null && xc(h) === null) {
              m.child = z;
              break;
            }
            h = z.sibling, z.sibling = M, M = z, z = h;
          }
          nl(m, !0, M, null, W);
          break;
        case "together":
          nl(m, !1, null, null, void 0);
          break;
        default:
          m.memoizedState = null;
      }
      return m.child;
    }
    function fi(h, m, M) {
      if (h !== null && (m.dependencies = h.dependencies), Rs |= m.lanes, !(M & m.childLanes)) return null;
      if (h !== null && m.child !== h.child) throw Error(o(153));
      if (m.child !== null) {
        for (h = m.child, M = Ua(h, h.pendingProps), m.child = M, M.return = m; h.sibling !== null; ) h = h.sibling, M = M.sibling = Ua(h, h.pendingProps), M.return = m;
        M.sibling = null;
      }
      return m.child;
    }
    function Yu(h, m, M) {
      switch (m.tag) {
        case 3:
          bp(m), Nu();
          break;
        case 5:
          sf(m);
          break;
        case 1:
          cn(m.type) && Pn(m);
          break;
        case 4:
          op(m, m.stateNode.containerInfo);
          break;
        case 10:
          Pg(m, m.type._context, m.memoizedProps.value);
          break;
        case 13:
          var A = m.memoizedState;
          if (A !== null)
            return A.dehydrated !== null ? (Nt(Kr, Kr.current & 1), m.flags |= 128, null) : M & m.child.childLanes ? J0(h, m, M) : (Nt(Kr, Kr.current & 1), h = fi(h, m, M), h !== null ? h.sibling : null);
          Nt(Kr, Kr.current & 1);
          break;
        case 19:
          if (A = (M & m.childLanes) !== 0, h.flags & 128) {
            if (A) return xp(
              h,
              m,
              M
            );
            m.flags |= 128;
          }
          var z = m.memoizedState;
          if (z !== null && (z.rendering = null, z.tail = null, z.lastEffect = null), Nt(Kr, Kr.current), A) break;
          return null;
        case 22:
        case 23:
          return m.lanes = 0, Z0(h, m, M);
      }
      return fi(h, m, M);
    }
    function Ln(h, m) {
      switch (Fg(m), m.tag) {
        case 1:
          return cn(m.type) && en(), h = m.flags, h & 65536 ? (m.flags = h & -65537 | 128, m) : null;
        case 3:
          return _c(), Jt(Tn), Jt(hn), _s(), h = m.flags, h & 65536 && !(h & 128) ? (m.flags = h & -65537 | 128, m) : null;
        case 5:
          return eo(m), null;
        case 13:
          if (Jt(Kr), h = m.memoizedState, h !== null && h.dehydrated !== null) {
            if (m.alternate === null) throw Error(o(340));
            Nu();
          }
          return h = m.flags, h & 65536 ? (m.flags = h & -65537 | 128, m) : null;
        case 19:
          return Jt(Kr), null;
        case 4:
          return _c(), null;
        case 10:
          return Yh(m.type._context), null;
        case 22:
        case 23:
          return Ao(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Rc = !1, zl = !1, CP = typeof WeakSet == "function" ? WeakSet : Set, qt = null;
    function Ku(h, m) {
      var M = h.ref;
      if (M !== null) if (typeof M == "function") try {
        M(null);
      } catch (A) {
        dr(h, m, A);
      }
      else M.current = null;
    }
    function Ac(h, m, M) {
      try {
        M();
      } catch (A) {
        dr(h, m, A);
      }
    }
    var nb = !1;
    function rb(h, m) {
      for (Q(h.containerInfo), qt = m; qt !== null; ) if (h = qt, m = h.child, (h.subtreeFlags & 1028) !== 0 && m !== null) m.return = h, qt = m;
      else for (; qt !== null; ) {
        h = qt;
        try {
          var M = h.alternate;
          if (h.flags & 1024) switch (h.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (M !== null) {
                var A = M.memoizedProps, z = M.memoizedState, W = h.stateNode, fe = W.getSnapshotBeforeUpdate(h.elementType === h.type ? A : jo(h.type, A), z);
                W.__reactInternalSnapshotBeforeUpdate = fe;
              }
              break;
            case 3:
              Me && He(h.stateNode.containerInfo);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(o(163));
          }
        } catch (Le) {
          dr(h, h.return, Le);
        }
        if (m = h.sibling, m !== null) {
          m.return = h.return, qt = m;
          break;
        }
        qt = h.return;
      }
      return M = nb, nb = !1, M;
    }
    function Oc(h, m, M) {
      var A = m.updateQueue;
      if (A = A !== null ? A.lastEffect : null, A !== null) {
        var z = A = A.next;
        do {
          if ((z.tag & h) === h) {
            var W = z.destroy;
            z.destroy = void 0, W !== void 0 && Ac(m, M, W);
          }
          z = z.next;
        } while (z !== A);
      }
    }
    function Pc(h, m) {
      if (m = m.updateQueue, m = m !== null ? m.lastEffect : null, m !== null) {
        var M = m = m.next;
        do {
          if ((M.tag & h) === h) {
            var A = M.create;
            M.destroy = A();
          }
          M = M.next;
        } while (M !== m);
      }
    }
    function Kg(h) {
      var m = h.ref;
      if (m !== null) {
        var M = h.stateNode;
        switch (h.tag) {
          case 5:
            h = Z(M);
            break;
          default:
            h = M;
        }
        typeof m == "function" ? m(h) : m.current = h;
      }
    }
    function Zg(h, m, M) {
      if (Qa && typeof Qa.onCommitFiberUnmount == "function") try {
        Qa.onCommitFiberUnmount(Il, m);
      } catch {
      }
      switch (m.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (h = m.updateQueue, h !== null && (h = h.lastEffect, h !== null)) {
            var A = h = h.next;
            do {
              var z = A, W = z.destroy;
              z = z.tag, W !== void 0 && (z & 2 || z & 4) && Ac(m, M, W), A = A.next;
            } while (A !== h);
          }
          break;
        case 1:
          if (Ku(m, M), h = m.stateNode, typeof h.componentWillUnmount == "function") try {
            h.props = m.memoizedProps, h.state = m.memoizedState, h.componentWillUnmount();
          } catch (fe) {
            dr(
              m,
              M,
              fe
            );
          }
          break;
        case 5:
          Ku(m, M);
          break;
        case 4:
          Me ? Li(h, m, M) : $ && $ && (m = m.stateNode.containerInfo, M = vt(m), lt(m, M));
      }
    }
    function Qg(h, m, M) {
      for (var A = m; ; ) if (Zg(h, A, M), A.child === null || Me && A.tag === 4) {
        if (A === m) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === m) return;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      } else A.child.return = A, A = A.child;
    }
    function Qo(h) {
      var m = h.alternate;
      m !== null && (h.alternate = null, Qo(m)), h.child = null, h.deletions = null, h.sibling = null, h.tag === 5 && (m = h.stateNode, m !== null && et(m)), h.stateNode = null, h.return = null, h.dependencies = null, h.memoizedProps = null, h.memoizedState = null, h.pendingProps = null, h.stateNode = null, h.updateQueue = null;
    }
    function Zu(h) {
      return h.tag === 5 || h.tag === 3 || h.tag === 4;
    }
    function Qu(h) {
      e: for (; ; ) {
        for (; h.sibling === null; ) {
          if (h.return === null || Zu(h.return)) return null;
          h = h.return;
        }
        for (h.sibling.return = h.return, h = h.sibling; h.tag !== 5 && h.tag !== 6 && h.tag !== 18; ) {
          if (h.flags & 2 || h.child === null || h.tag === 4) continue e;
          h.child.return = h, h = h.child;
        }
        if (!(h.flags & 2)) return h.stateNode;
      }
    }
    function Ep(h) {
      if (Me) {
        e: {
          for (var m = h.return; m !== null; ) {
            if (Zu(m)) break e;
            m = m.return;
          }
          throw Error(o(160));
        }
        var M = m;
        switch (M.tag) {
          case 5:
            m = M.stateNode, M.flags & 32 && (Rt(m), M.flags &= -33), M = Qu(h), to(h, M, m);
            break;
          case 3:
          case 4:
            m = M.stateNode.containerInfo, M = Qu(h), Dc(h, M, m);
            break;
          default:
            throw Error(o(161));
        }
      }
    }
    function Dc(h, m, M) {
      var A = h.tag;
      if (A === 5 || A === 6) h = h.stateNode, m ? tt(M, h, m) : pt(M, h);
      else if (A !== 4 && (h = h.child, h !== null)) for (Dc(h, m, M), h = h.sibling; h !== null; ) Dc(h, m, M), h = h.sibling;
    }
    function to(h, m, M) {
      var A = h.tag;
      if (A === 5 || A === 6) h = h.stateNode, m ? Ye(M, h, m) : ht(M, h);
      else if (A !== 4 && (h = h.child, h !== null)) for (to(h, m, M), h = h.sibling; h !== null; ) to(h, m, M), h = h.sibling;
    }
    function Li(h, m, M) {
      for (var A = m, z = !1, W, fe; ; ) {
        if (!z) {
          z = A.return;
          e: for (; ; ) {
            if (z === null) throw Error(o(160));
            switch (W = z.stateNode, z.tag) {
              case 5:
                fe = !1;
                break e;
              case 3:
                W = W.containerInfo, fe = !0;
                break e;
              case 4:
                W = W.containerInfo, fe = !0;
                break e;
            }
            z = z.return;
          }
          z = !0;
        }
        if (A.tag === 5 || A.tag === 6) Qg(h, A, M), fe ? Tt(W, A.stateNode) : st(W, A.stateNode);
        else if (A.tag === 18) fe ? pe(W, A.stateNode) : Ce(W, A.stateNode);
        else if (A.tag === 4) {
          if (A.child !== null) {
            W = A.stateNode.containerInfo, fe = !0, A.child.return = A, A = A.child;
            continue;
          }
        } else if (Zg(h, A, M), A.child !== null) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === m) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === m) return;
          A = A.return, A.tag === 4 && (z = !1);
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    }
    function Jg(h, m) {
      if (Me) {
        switch (m.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Oc(3, m, m.return), Pc(3, m), Oc(5, m, m.return);
            return;
          case 1:
            return;
          case 5:
            var M = m.stateNode;
            if (M != null) {
              var A = m.memoizedProps;
              h = h !== null ? h.memoizedProps : A;
              var z = m.type, W = m.updateQueue;
              m.updateQueue = null, W !== null && Ue(M, W, z, h, A, m);
            }
            return;
          case 6:
            if (m.stateNode === null) throw Error(o(162));
            M = m.memoizedProps, Be(m.stateNode, h !== null ? h.memoizedProps : M, M);
            return;
          case 3:
            Te && h !== null && h.memoizedState.isDehydrated && _e(m.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            Cp(m);
            return;
          case 19:
            Cp(m);
            return;
          case 17:
            return;
        }
        throw Error(o(163));
      }
      switch (m.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Oc(3, m, m.return), Pc(3, m), Oc(5, m, m.return);
          return;
        case 12:
          return;
        case 13:
          Cp(m);
          return;
        case 19:
          Cp(m);
          return;
        case 3:
          Te && h !== null && h.memoizedState.isDehydrated && _e(m.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e: if ($) {
        switch (m.tag) {
          case 1:
          case 5:
          case 6:
            break e;
          case 3:
          case 4:
            m = m.stateNode, lt(m.containerInfo, m.pendingChildren);
            break e;
        }
        throw Error(o(163));
      }
    }
    function Cp(h) {
      var m = h.updateQueue;
      if (m !== null) {
        h.updateQueue = null;
        var M = h.stateNode;
        M === null && (M = h.stateNode = new CP()), m.forEach(function(A) {
          var z = Fc.bind(null, h, A);
          M.has(A) || (M.add(A), A.then(z, z));
        });
      }
    }
    function bC(h, m) {
      for (qt = m; qt !== null; ) {
        m = qt;
        var M = m.deletions;
        if (M !== null) for (var A = 0; A < M.length; A++) {
          var z = M[A];
          try {
            var W = h;
            Me ? Li(W, z, m) : Qg(W, z, m);
            var fe = z.alternate;
            fe !== null && (fe.return = null), z.return = null;
          } catch (dn) {
            dr(z, m, dn);
          }
        }
        if (M = m.child, m.subtreeFlags & 12854 && M !== null) M.return = m, qt = M;
        else for (; qt !== null; ) {
          m = qt;
          try {
            var Le = m.flags;
            if (Le & 32 && Me && Rt(m.stateNode), Le & 512) {
              var ct = m.alternate;
              if (ct !== null) {
                var Ot = ct.ref;
                Ot !== null && (typeof Ot == "function" ? Ot(null) : Ot.current = null);
              }
            }
            if (Le & 8192) switch (m.tag) {
              case 13:
                if (m.memoizedState !== null) {
                  var Vt = m.alternate;
                  (Vt === null || Vt.memoizedState === null) && (ov = nn());
                }
                break;
              case 22:
                var Cn = m.memoizedState !== null, _n = m.alternate, zr = _n !== null && _n.memoizedState !== null;
                if (M = m, Me) {
                  e: if (A = M, z = Cn, W = null, Me) for (var pn = A; ; ) {
                    if (pn.tag === 5) {
                      if (W === null) {
                        W = pn;
                        var na = pn.stateNode;
                        z ? ue(na) : Ge(pn.stateNode, pn.memoizedProps);
                      }
                    } else if (pn.tag === 6) {
                      if (W === null) {
                        var xa = pn.stateNode;
                        z ? De(xa) : We(xa, pn.memoizedProps);
                      }
                    } else if ((pn.tag !== 22 && pn.tag !== 23 || pn.memoizedState === null || pn === A) && pn.child !== null) {
                      pn.child.return = pn, pn = pn.child;
                      continue;
                    }
                    if (pn === A) break;
                    for (; pn.sibling === null; ) {
                      if (pn.return === null || pn.return === A) break e;
                      W === pn && (W = null), pn = pn.return;
                    }
                    W === pn && (W = null), pn.sibling.return = pn.return, pn = pn.sibling;
                  }
                }
                if (Cn && !zr && M.mode & 1) {
                  qt = M;
                  for (var Qe = M.child; Qe !== null; ) {
                    for (M = qt = Qe; qt !== null; ) {
                      A = qt;
                      var ze = A.child;
                      switch (A.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          Oc(4, A, A.return);
                          break;
                        case 1:
                          Ku(A, A.return);
                          var rt = A.stateNode;
                          if (typeof rt.componentWillUnmount == "function") {
                            var Xt = A.return;
                            try {
                              rt.props = A.memoizedProps, rt.state = A.memoizedState, rt.componentWillUnmount();
                            } catch (dn) {
                              dr(
                                A,
                                Xt,
                                dn
                              );
                            }
                          }
                          break;
                        case 5:
                          Ku(A, A.return);
                          break;
                        case 22:
                          if (A.memoizedState !== null) {
                            ab(M);
                            continue;
                          }
                      }
                      ze !== null ? (ze.return = A, qt = ze) : ab(M);
                    }
                    Qe = Qe.sibling;
                  }
                }
            }
            switch (Le & 4102) {
              case 2:
                Ep(m), m.flags &= -3;
                break;
              case 6:
                Ep(m), m.flags &= -3, Jg(m.alternate, m);
                break;
              case 4096:
                m.flags &= -4097;
                break;
              case 4100:
                m.flags &= -4097, Jg(m.alternate, m);
                break;
              case 4:
                Jg(m.alternate, m);
            }
          } catch (dn) {
            dr(m, m.return, dn);
          }
          if (M = m.sibling, M !== null) {
            M.return = m.return, qt = M;
            break;
          }
          qt = m.return;
        }
      }
    }
    function ib(h, m, M) {
      qt = h, ev(h);
    }
    function ev(h, m, M) {
      for (var A = (h.mode & 1) !== 0; qt !== null; ) {
        var z = qt, W = z.child;
        if (z.tag === 22 && A) {
          var fe = z.memoizedState !== null || Rc;
          if (!fe) {
            var Le = z.alternate, ct = Le !== null && Le.memoizedState !== null || zl;
            Le = Rc;
            var Ot = zl;
            if (Rc = fe, (zl = ct) && !Ot) for (qt = z; qt !== null; ) fe = qt, ct = fe.child, fe.tag === 22 && fe.memoizedState !== null ? ob(z) : ct !== null ? (ct.return = fe, qt = ct) : ob(z);
            for (; W !== null; ) qt = W, ev(W), W = W.sibling;
            qt = z, Rc = Le, zl = Ot;
          }
          tv(h);
        } else z.subtreeFlags & 8772 && W !== null ? (W.return = z, qt = W) : tv(h);
      }
    }
    function tv(h) {
      for (; qt !== null; ) {
        var m = qt;
        if (m.flags & 8772) {
          var M = m.alternate;
          try {
            if (m.flags & 8772) switch (m.tag) {
              case 0:
              case 11:
              case 15:
                zl || Pc(5, m);
                break;
              case 1:
                var A = m.stateNode;
                if (m.flags & 4 && !zl) if (M === null) A.componentDidMount();
                else {
                  var z = m.elementType === m.type ? M.memoizedProps : jo(m.type, M.memoizedProps);
                  A.componentDidUpdate(z, M.memoizedState, A.__reactInternalSnapshotBeforeUpdate);
                }
                var W = m.updateQueue;
                W !== null && $0(m, W, A);
                break;
              case 3:
                var fe = m.updateQueue;
                if (fe !== null) {
                  if (M = null, m.child !== null) switch (m.child.tag) {
                    case 5:
                      M = Z(m.child.stateNode);
                      break;
                    case 1:
                      M = m.child.stateNode;
                  }
                  $0(m, fe, M);
                }
                break;
              case 5:
                var Le = m.stateNode;
                M === null && m.flags & 4 && ye(Le, m.type, m.memoizedProps, m);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (Te && m.memoizedState === null) {
                  var ct = m.alternate;
                  if (ct !== null) {
                    var Ot = ct.memoizedState;
                    if (Ot !== null) {
                      var Vt = Ot.dehydrated;
                      Vt !== null && Ae(Vt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
            zl || m.flags & 512 && Kg(m);
          } catch (Cn) {
            dr(m, m.return, Cn);
          }
        }
        if (m === h) {
          qt = null;
          break;
        }
        if (M = m.sibling, M !== null) {
          M.return = m.return, qt = M;
          break;
        }
        qt = m.return;
      }
    }
    function ab(h) {
      for (; qt !== null; ) {
        var m = qt;
        if (m === h) {
          qt = null;
          break;
        }
        var M = m.sibling;
        if (M !== null) {
          M.return = m.return, qt = M;
          break;
        }
        qt = m.return;
      }
    }
    function ob(h) {
      for (; qt !== null; ) {
        var m = qt;
        try {
          switch (m.tag) {
            case 0:
            case 11:
            case 15:
              var M = m.return;
              try {
                Pc(4, m);
              } catch (ct) {
                dr(m, M, ct);
              }
              break;
            case 1:
              var A = m.stateNode;
              if (typeof A.componentDidMount == "function") {
                var z = m.return;
                try {
                  A.componentDidMount();
                } catch (ct) {
                  dr(m, z, ct);
                }
              }
              var W = m.return;
              try {
                Kg(m);
              } catch (ct) {
                dr(m, W, ct);
              }
              break;
            case 5:
              var fe = m.return;
              try {
                Kg(m);
              } catch (ct) {
                dr(m, fe, ct);
              }
          }
        } catch (ct) {
          dr(m, m.return, ct);
        }
        if (m === h) {
          qt = null;
          break;
        }
        var Le = m.sibling;
        if (Le !== null) {
          Le.return = m.return, qt = Le;
          break;
        }
        qt = m.return;
      }
    }
    var wp = 0, hi = 1, Ic = 2, gf = 3, rl = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Ju = Symbol.for;
      wp = Ju("selector.component"), hi = Ju("selector.has_pseudo_class"), Ic = Ju("selector.role"), gf = Ju("selector.test_id"), rl = Ju("selector.text");
    }
    function nv(h) {
      var m = se(h);
      if (m != null) {
        if (typeof m.memoizedProps["data-testname"] != "string") throw Error(o(364));
        return m;
      }
      if (h = Y(h), h === null) throw Error(o(362));
      return h.stateNode.current;
    }
    function rv(h, m) {
      switch (m.$$typeof) {
        case wp:
          if (h.type === m.value) return !0;
          break;
        case hi:
          e: {
            m = m.value, h = [h, 0];
            for (var M = 0; M < h.length; ) {
              var A = h[M++], z = h[M++], W = m[z];
              if (A.tag !== 5 || !Pe(A)) {
                for (; W != null && rv(A, W); ) z++, W = m[z];
                if (z === m.length) {
                  m = !0;
                  break e;
                } else for (A = A.child; A !== null; ) h.push(A, z), A = A.sibling;
              }
            }
            m = !1;
          }
          return m;
        case Ic:
          if (h.tag === 5 && Ve(h.stateNode, m.value)) return !0;
          break;
        case rl:
          if ((h.tag === 5 || h.tag === 6) && (h = Oe(h), h !== null && 0 <= h.indexOf(m.value))) return !0;
          break;
        case gf:
          if (h.tag === 5 && (h = h.memoizedProps["data-testname"], typeof h == "string" && h.toLowerCase() === m.value.toLowerCase())) return !0;
          break;
        default:
          throw Error(o(365));
      }
      return !1;
    }
    function Bl(h) {
      switch (h.$$typeof) {
        case wp:
          return "<" + (I(h.value) || "Unknown") + ">";
        case hi:
          return ":has(" + (Bl(h) || "") + ")";
        case Ic:
          return '[role="' + h.value + '"]';
        case rl:
          return '"' + h.value + '"';
        case gf:
          return '[data-testname="' + h.value + '"]';
        default:
          throw Error(o(365));
      }
    }
    function ea(h, m) {
      var M = [];
      h = [h, 0];
      for (var A = 0; A < h.length; ) {
        var z = h[A++], W = h[A++], fe = m[W];
        if (z.tag !== 5 || !Pe(z)) {
          for (; fe != null && rv(z, fe); ) W++, fe = m[W];
          if (W === m.length) M.push(z);
          else for (z = z.child; z !== null; ) h.push(z, W), z = z.sibling;
        }
      }
      return M;
    }
    function Gt(h, m) {
      if (!te) throw Error(o(363));
      h = nv(h), h = ea(h, m), m = [], h = Array.from(h);
      for (var M = 0; M < h.length; ) {
        var A = h[M++];
        if (A.tag === 5) Pe(A) || m.push(A.stateNode);
        else for (A = A.child; A !== null; ) h.push(A), A = A.sibling;
      }
      return m;
    }
    var Ts = Math.ceil, Na = s.ReactCurrentDispatcher, iv = s.ReactCurrentOwner, pi = s.ReactCurrentBatchConfig, kn = 0, Ci = null, wi = null, ar = 0, no = 0, ed = Zn(0), Fi = 0, td = null, Rs = 0, il = 0, av = 0, vf = null, La = null, ov = 0, sv = 1 / 0;
    function nd() {
      sv = nn() + 500;
    }
    var yf = !1, Mp = null, Hl = null, Tp = !1, Vl = null, Rp = 0, bf = 0, lv = null, Sf = -1, Ap = 0;
    function ma() {
      return kn & 6 ? nn() : Sf !== -1 ? Sf : Sf = nn();
    }
    function kl(h) {
      return h.mode & 1 ? kn & 2 && ar !== 0 ? ar & -ar : gC.transition !== null ? (Ap === 0 && (h = Pi, Pi <<= 1, !(Pi & 4194240) && (Pi = 64), Ap = h), Ap) : (h = Qn, h !== 0 ? h : be()) : 1;
    }
    function Ro(h, m, M) {
      if (50 < bf) throw bf = 0, lv = null, Error(o(185));
      var A = rd(h, m);
      return A === null ? null : (bo(A, m, M), (!(kn & 2) || A !== Ci) && (A === Ci && (!(kn & 2) && (il |= m), Fi === 4 && al(A, ar)), Fa(A, M), m === 1 && kn === 0 && !(h.mode & 1) && (nd(), Gh && bs())), A);
    }
    function rd(h, m) {
      h.lanes |= m;
      var M = h.alternate;
      for (M !== null && (M.lanes |= m), M = h, h = h.return; h !== null; ) h.childLanes |= m, M = h.alternate, M !== null && (M.childLanes |= m), M = h, h = h.return;
      return M.tag === 3 ? M.stateNode : null;
    }
    function Fa(h, m) {
      var M = h.callbackNode;
      _a(h, m);
      var A = Qi(h, h === Ci ? ar : 0);
      if (A === 0) M !== null && Mu(M), h.callbackNode = null, h.callbackPriority = 0;
      else if (m = A & -A, h.callbackPriority !== m) {
        if (M != null && Mu(M), m === 1) h.tag === 0 ? mC(sb.bind(null, h)) : Ag(sb.bind(null, h)), Xe ? $e(function() {
          kn === 0 && bs();
        }) : So(Br, bs), M = null;
        else {
          switch (wu(A)) {
            case 1:
              M = Br;
              break;
            case 4:
              M = ui;
              break;
            case 16:
              M = Hr;
              break;
            case 536870912:
              M = Tu;
              break;
            default:
              M = Hr;
          }
          M = ad(M, ro.bind(null, h));
        }
        h.callbackPriority = m, h.callbackNode = M;
      }
    }
    function ro(h, m) {
      if (Sf = -1, Ap = 0, kn & 6) throw Error(o(327));
      var M = h.callbackNode;
      if (Lc() && h.callbackNode !== M) return null;
      var A = Qi(h, h === Ci ? ar : 0);
      if (A === 0) return null;
      if (A & 30 || A & h.expiredLanes || m) m = Nc(h, A);
      else {
        m = A;
        var z = kn;
        kn |= 2;
        var W = cb();
        (Ci !== h || ar !== m) && (nd(), $l(h, m));
        do
          try {
            ub();
            break;
          } catch (Le) {
            lb(h, Le);
          }
        while (!0);
        Og(), Na.current = W, kn = z, wi !== null ? m = 0 : (Ci = null, ar = 0, m = Fi);
      }
      if (m !== 0) {
        if (m === 2 && (z = ri(h), z !== 0 && (A = z, m = Jo(h, z))), m === 1) throw M = td, $l(h, 0), al(h, A), Fa(h, nn()), M;
        if (m === 6) al(h, A);
        else {
          if (z = h.current.alternate, !(A & 30) && !cv(z) && (m = Nc(h, A), m === 2 && (W = ri(h), W !== 0 && (A = W, m = Jo(h, W))), m === 1)) throw M = td, $l(h, 0), al(h, A), Fa(h, nn()), M;
          switch (h.finishedWork = z, h.finishedLanes = A, m) {
            case 0:
            case 1:
              throw Error(o(345));
            case 2:
              es(h, La);
              break;
            case 3:
              if (al(h, A), (A & 130023424) === A && (m = ov + 500 - nn(), 10 < m)) {
                if (Qi(h, 0) !== 0) break;
                if (z = h.suspendedLanes, (z & A) !== A) {
                  ma(), h.pingedLanes |= h.suspendedLanes & z;
                  break;
                }
                h.timeoutHandle = le(es.bind(null, h, La), m);
                break;
              }
              es(h, La);
              break;
            case 4:
              if (al(h, A), (A & 4194240) === A) break;
              for (m = h.eventTimes, z = -1; 0 < A; ) {
                var fe = 31 - Sr(A);
                W = 1 << fe, fe = m[fe], fe > z && (z = fe), A &= ~W;
              }
              if (A = z, A = nn() - A, A = (120 > A ? 120 : 480 > A ? 480 : 1080 > A ? 1080 : 1920 > A ? 1920 : 3e3 > A ? 3e3 : 4320 > A ? 4320 : 1960 * Ts(A / 1960)) - A, 10 < A) {
                h.timeoutHandle = le(es.bind(null, h, La), A);
                break;
              }
              es(h, La);
              break;
            case 5:
              es(h, La);
              break;
            default:
              throw Error(o(329));
          }
        }
      }
      return Fa(h, nn()), h.callbackNode === M ? ro.bind(null, h) : null;
    }
    function Jo(h, m) {
      var M = vf;
      return h.current.memoizedState.isDehydrated && ($l(h, m).flags |= 256), h = Nc(h, m), h !== 2 && (m = La, La = M, m !== null && _f(m)), h;
    }
    function _f(h) {
      La === null ? La = h : La.push.apply(La, h);
    }
    function cv(h) {
      for (var m = h; ; ) {
        if (m.flags & 16384) {
          var M = m.updateQueue;
          if (M !== null && (M = M.stores, M !== null)) for (var A = 0; A < M.length; A++) {
            var z = M[A], W = z.getSnapshot;
            z = z.value;
            try {
              if (!ys(W(), z)) return !1;
            } catch {
              return !1;
            }
          }
        }
        if (M = m.child, m.subtreeFlags & 16384 && M !== null) M.return = m, m = M;
        else {
          if (m === h) break;
          for (; m.sibling === null; ) {
            if (m.return === null || m.return === h) return !0;
            m = m.return;
          }
          m.sibling.return = m.return, m = m.sibling;
        }
      }
      return !0;
    }
    function al(h, m) {
      for (m &= ~av, m &= ~il, h.suspendedLanes |= m, h.pingedLanes &= ~m, h = h.expirationTimes; 0 < m; ) {
        var M = 31 - Sr(m), A = 1 << M;
        h[M] = -1, m &= ~A;
      }
    }
    function sb(h) {
      if (kn & 6) throw Error(o(327));
      Lc();
      var m = Qi(h, 0);
      if (!(m & 1)) return Fa(h, nn()), null;
      var M = Nc(h, m);
      if (h.tag !== 0 && M === 2) {
        var A = ri(h);
        A !== 0 && (m = A, M = Jo(h, A));
      }
      if (M === 1) throw M = td, $l(h, 0), al(h, m), Fa(h, nn()), M;
      if (M === 6) throw Error(o(345));
      return h.finishedWork = h.current.alternate, h.finishedLanes = m, es(h, La), Fa(h, nn()), null;
    }
    function uv(h) {
      Vl !== null && Vl.tag === 0 && !(kn & 6) && Lc();
      var m = kn;
      kn |= 1;
      var M = pi.transition, A = Qn;
      try {
        if (pi.transition = null, Qn = 1, h) return h();
      } finally {
        Qn = A, pi.transition = M, kn = m, !(kn & 6) && bs();
      }
    }
    function Ao() {
      no = ed.current, Jt(ed);
    }
    function $l(h, m) {
      h.finishedWork = null, h.finishedLanes = 0;
      var M = h.timeoutHandle;
      if (M !== Ne && (h.timeoutHandle = Ne, ve(M)), wi !== null) for (M = wi.return; M !== null; ) {
        var A = M;
        switch (Fg(A), A.tag) {
          case 1:
            A = A.type.childContextTypes, A != null && en();
            break;
          case 3:
            _c(), Jt(Tn), Jt(hn), _s();
            break;
          case 5:
            eo(A);
            break;
          case 4:
            _c();
            break;
          case 13:
            Jt(Kr);
            break;
          case 19:
            Jt(Kr);
            break;
          case 10:
            Yh(A.type._context);
            break;
          case 22:
          case 23:
            Ao();
        }
        M = M.return;
      }
      if (Ci = h, wi = h = Ua(h.current, null), ar = no = m, Fi = 0, td = null, av = il = Rs = 0, La = vf = null, Go !== null) {
        for (m = 0; m < Go.length; m++) if (M = Go[m], A = M.interleaved, A !== null) {
          M.interleaved = null;
          var z = A.next, W = M.pending;
          if (W !== null) {
            var fe = W.next;
            W.next = z, A.next = fe;
          }
          M.pending = A;
        }
        Go = null;
      }
      return h;
    }
    function lb(h, m) {
      do {
        var M = wi;
        try {
          if (Og(), Di.current = Wu, Fu) {
            for (var A = ir.memoizedState; A !== null; ) {
              var z = A.queue;
              z !== null && (z.pending = null), A = A.next;
            }
            Fu = !1;
          }
          if (Fl = 0, Ur = Qr = ir = null, xs = !1, Uu = 0, iv.current = null, M === null || M.return === null) {
            Fi = 1, td = m, wi = null;
            break;
          }
          e: {
            var W = h, fe = M.return, Le = M, ct = m;
            if (m = ar, Le.flags |= 32768, ct !== null && typeof ct == "object" && typeof ct.then == "function") {
              var Ot = ct, Vt = Le, Cn = Vt.tag;
              if (!(Vt.mode & 1) && (Cn === 0 || Cn === 11 || Cn === 15)) {
                var _n = Vt.alternate;
                _n ? (Vt.updateQueue = _n.updateQueue, Vt.memoizedState = _n.memoizedState, Vt.lanes = _n.lanes) : (Vt.updateQueue = null, Vt.memoizedState = null);
              }
              var zr = wc(fe);
              if (zr !== null) {
                zr.flags &= -257, gp(zr, fe, Le, W, m), zr.mode & 1 && hf(W, Ot, m), m = zr, ct = Ot;
                var pn = m.updateQueue;
                if (pn === null) {
                  var na = /* @__PURE__ */ new Set();
                  na.add(ct), m.updateQueue = na;
                } else pn.add(ct);
                break e;
              } else {
                if (!(m & 1)) {
                  hf(W, Ot, m), dv();
                  break e;
                }
                ct = Error(o(426));
              }
            } else if (Yr && Le.mode & 1) {
              var xa = wc(fe);
              if (xa !== null) {
                !(xa.flags & 65536) && (xa.flags |= 256), gp(xa, fe, Le, W, m), nf(ct);
                break e;
              }
            }
            W = ct, Fi !== 4 && (Fi = 2), vf === null ? vf = [W] : vf.push(W), ct = df(ct, Le), Le = fe;
            do {
              switch (Le.tag) {
                case 3:
                  Le.flags |= 65536, m &= -m, Le.lanes |= m;
                  var Qe = pp(Le, ct, m);
                  k0(Le, Qe);
                  break e;
                case 1:
                  W = ct;
                  var ze = Le.type, rt = Le.stateNode;
                  if (!(Le.flags & 128) && (typeof ze.getDerivedStateFromError == "function" || rt !== null && typeof rt.componentDidCatch == "function" && (Hl === null || !Hl.has(rt)))) {
                    Le.flags |= 65536, m &= -m, Le.lanes |= m;
                    var Xt = mp(Le, W, m);
                    k0(Le, Xt);
                    break e;
                  }
              }
              Le = Le.return;
            } while (Le !== null);
          }
          io(M);
        } catch (dn) {
          m = dn, wi === M && M !== null && (wi = M = M.return);
          continue;
        }
        break;
      } while (!0);
    }
    function cb() {
      var h = Na.current;
      return Na.current = Wu, h === null ? Wu : h;
    }
    function dv() {
      (Fi === 0 || Fi === 3 || Fi === 2) && (Fi = 4), Ci === null || !(Rs & 268435455) && !(il & 268435455) || al(Ci, ar);
    }
    function Nc(h, m) {
      var M = kn;
      kn |= 2;
      var A = cb();
      Ci === h && ar === m || $l(h, m);
      do
        try {
          SC();
          break;
        } catch (z) {
          lb(h, z);
        }
      while (!0);
      if (Og(), kn = M, Na.current = A, wi !== null) throw Error(o(261));
      return Ci = null, ar = 0, Fi;
    }
    function SC() {
      for (; wi !== null; ) fv(wi);
    }
    function ub() {
      for (; wi !== null && !Zd(); ) fv(wi);
    }
    function fv(h) {
      var m = id(h.alternate, h, no);
      h.memoizedProps = h.pendingProps, m === null ? io(h) : wi = m, iv.current = null;
    }
    function io(h) {
      var m = h;
      do {
        var M = m.alternate;
        if (h = m.return, m.flags & 32768) {
          if (M = Ln(M, m), M !== null) {
            M.flags &= 32767, wi = M;
            return;
          }
          if (h !== null) h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null;
          else {
            Fi = 6, wi = null;
            return;
          }
        } else if (M = yC(M, m, no), M !== null) {
          wi = M;
          return;
        }
        if (m = m.sibling, m !== null) {
          wi = m;
          return;
        }
        wi = m = h;
      } while (m !== null);
      Fi === 0 && (Fi = 5);
    }
    function es(h, m) {
      var M = Qn, A = pi.transition;
      try {
        pi.transition = null, Qn = 1, _C(h, m, M);
      } finally {
        pi.transition = A, Qn = M;
      }
      return null;
    }
    function _C(h, m, M) {
      do
        Lc();
      while (Vl !== null);
      if (kn & 6) throw Error(o(327));
      var A = h.finishedWork, z = h.finishedLanes;
      if (A === null) return null;
      if (h.finishedWork = null, h.finishedLanes = 0, A === h.current) throw Error(o(177));
      h.callbackNode = null, h.callbackPriority = 0;
      var W = A.lanes | A.childLanes;
      if (vc(h, W), h === Ci && (wi = Ci = null, ar = 0), !(A.subtreeFlags & 2064) && !(A.flags & 2064) || Tp || (Tp = !0, ad(Hr, function() {
        return Lc(), null;
      })), W = (A.flags & 15990) !== 0, A.subtreeFlags & 15990 || W) {
        W = pi.transition, pi.transition = null;
        var fe = Qn;
        Qn = 1;
        var Le = kn;
        kn |= 4, iv.current = null, rb(h, A), bC(h, A), V(h.containerInfo), h.current = A, ib(A), ln(), kn = Le, Qn = fe, pi.transition = W;
      } else h.current = A;
      if (Tp && (Tp = !1, Vl = h, Rp = z), W = h.pendingLanes, W === 0 && (Hl = null), Ru(A.stateNode), Fa(h, nn()), m !== null) for (M = h.onRecoverableError, A = 0; A < m.length; A++) M(m[A]);
      if (yf) throw yf = !1, h = Mp, Mp = null, h;
      return Rp & 1 && h.tag !== 0 && Lc(), W = h.pendingLanes, W & 1 ? h === lv ? bf++ : (bf = 0, lv = h) : bf = 0, bs(), null;
    }
    function Lc() {
      if (Vl !== null) {
        var h = wu(Rp), m = pi.transition, M = Qn;
        try {
          if (pi.transition = null, Qn = 16 > h ? 16 : h, Vl === null) var A = !1;
          else {
            if (h = Vl, Vl = null, Rp = 0, kn & 6) throw Error(o(331));
            var z = kn;
            for (kn |= 4, qt = h.current; qt !== null; ) {
              var W = qt, fe = W.child;
              if (qt.flags & 16) {
                var Le = W.deletions;
                if (Le !== null) {
                  for (var ct = 0; ct < Le.length; ct++) {
                    var Ot = Le[ct];
                    for (qt = Ot; qt !== null; ) {
                      var Vt = qt;
                      switch (Vt.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Oc(8, Vt, W);
                      }
                      var Cn = Vt.child;
                      if (Cn !== null) Cn.return = Vt, qt = Cn;
                      else for (; qt !== null; ) {
                        Vt = qt;
                        var _n = Vt.sibling, zr = Vt.return;
                        if (Qo(Vt), Vt === Ot) {
                          qt = null;
                          break;
                        }
                        if (_n !== null) {
                          _n.return = zr, qt = _n;
                          break;
                        }
                        qt = zr;
                      }
                    }
                  }
                  var pn = W.alternate;
                  if (pn !== null) {
                    var na = pn.child;
                    if (na !== null) {
                      pn.child = null;
                      do {
                        var xa = na.sibling;
                        na.sibling = null, na = xa;
                      } while (na !== null);
                    }
                  }
                  qt = W;
                }
              }
              if (W.subtreeFlags & 2064 && fe !== null) fe.return = W, qt = fe;
              else e: for (; qt !== null; ) {
                if (W = qt, W.flags & 2048) switch (W.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Oc(9, W, W.return);
                }
                var Qe = W.sibling;
                if (Qe !== null) {
                  Qe.return = W.return, qt = Qe;
                  break e;
                }
                qt = W.return;
              }
            }
            var ze = h.current;
            for (qt = ze; qt !== null; ) {
              fe = qt;
              var rt = fe.child;
              if (fe.subtreeFlags & 2064 && rt !== null) rt.return = fe, qt = rt;
              else e: for (fe = ze; qt !== null; ) {
                if (Le = qt, Le.flags & 2048) try {
                  switch (Le.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pc(9, Le);
                  }
                } catch (dn) {
                  dr(Le, Le.return, dn);
                }
                if (Le === fe) {
                  qt = null;
                  break e;
                }
                var Xt = Le.sibling;
                if (Xt !== null) {
                  Xt.return = Le.return, qt = Xt;
                  break e;
                }
                qt = Le.return;
              }
            }
            if (kn = z, bs(), Qa && typeof Qa.onPostCommitFiberRoot == "function") try {
              Qa.onPostCommitFiberRoot(Il, h);
            } catch {
            }
            A = !0;
          }
          return A;
        } finally {
          Qn = M, pi.transition = m;
        }
      }
      return !1;
    }
    function ta(h, m, M) {
      m = df(M, m), m = pp(h, m, 1), Nl(h, m), m = ma(), h = rd(h, 1), h !== null && (bo(h, 1, m), Fa(h, m));
    }
    function dr(h, m, M) {
      if (h.tag === 3) ta(h, h, M);
      else for (; m !== null; ) {
        if (m.tag === 3) {
          ta(m, h, M);
          break;
        } else if (m.tag === 1) {
          var A = m.stateNode;
          if (typeof m.type.getDerivedStateFromError == "function" || typeof A.componentDidCatch == "function" && (Hl === null || !Hl.has(A))) {
            h = df(M, h), h = mp(m, h, 1), Nl(m, h), h = ma(), m = rd(m, 1), m !== null && (bo(m, 1, h), Fa(m, h));
            break;
          }
        }
        m = m.return;
      }
    }
    function As(h, m, M) {
      var A = h.pingCache;
      A !== null && A.delete(m), m = ma(), h.pingedLanes |= h.suspendedLanes & M, Ci === h && (ar & M) === M && (Fi === 4 || Fi === 3 && (ar & 130023424) === ar && 500 > nn() - ov ? $l(h, 0) : av |= M), Fa(h, m);
    }
    function Oo(h, m) {
      m === 0 && (h.mode & 1 ? (m = Wi, Wi <<= 1, !(Wi & 130023424) && (Wi = 4194304)) : m = 1);
      var M = ma();
      h = rd(h, m), h !== null && (bo(h, m, M), Fa(h, M));
    }
    function xC(h) {
      var m = h.memoizedState, M = 0;
      m !== null && (M = m.retryLane), Oo(h, M);
    }
    function Fc(h, m) {
      var M = 0;
      switch (h.tag) {
        case 13:
          var A = h.stateNode, z = h.memoizedState;
          z !== null && (M = z.retryLane);
          break;
        case 19:
          A = h.stateNode;
          break;
        default:
          throw Error(o(314));
      }
      A !== null && A.delete(m), Oo(h, M);
    }
    var id;
    id = function(h, m, M) {
      if (h !== null) if (h.memoizedProps !== m.pendingProps || Tn.current) pa = !0;
      else {
        if (!(h.lanes & M) && !(m.flags & 128)) return pa = !1, Yu(h, m, M);
        pa = !!(h.flags & 131072);
      }
      else pa = !1, Yr && m.flags & 1048576 && q0(m, tp, m.index);
      switch (m.lanes = 0, m.tag) {
        case 2:
          var A = m.type;
          h !== null && (h.alternate = null, m.alternate = null, m.flags |= 2), h = m.pendingProps;
          var z = ur(m, hn.current);
          Ou(m, M), z = Bu(null, m, A, h, z, M);
          var W = lf();
          return m.flags |= 1, typeof z == "object" && z !== null && typeof z.render == "function" && z.$$typeof === void 0 ? (m.tag = 1, m.memoizedState = null, m.updateQueue = null, cn(A) ? (W = !0, Pn(m)) : W = !1, m.memoizedState = z.state !== null && z.state !== void 0 ? z.state : null, Ig(m), z.updater = Jh, m.stateNode = z, z._reactInternals = m, Ng(m, A, h, M), m = qg(null, m, A, !0, W, M)) : (m.tag = 0, Yr && W && Lg(m), ji(null, m, z, M), m = m.child), m;
        case 16:
          A = m.elementType;
          e: {
            switch (h !== null && (h.alternate = null, m.alternate = null, m.flags |= 2), h = m.pendingProps, z = A._init, A = z(A._payload), m.type = A, z = m.tag = Ef(A), h = jo(A, h), z) {
              case 0:
                m = Xg(null, m, A, h, M);
                break e;
              case 1:
                m = yp(
                  null,
                  m,
                  A,
                  h,
                  M
                );
                break e;
              case 11:
                m = Xu(null, m, A, h, M);
                break e;
              case 14:
                m = mf(null, m, A, jo(A.type, h), M);
                break e;
            }
            throw Error(o(306, A, ""));
          }
          return m;
        case 0:
          return A = m.type, z = m.pendingProps, z = m.elementType === A ? z : jo(A, z), Xg(h, m, A, z, M);
        case 1:
          return A = m.type, z = m.pendingProps, z = m.elementType === A ? z : jo(A, z), yp(h, m, A, z, M);
        case 3:
          e: {
            if (bp(m), h === null) throw Error(o(387));
            A = m.pendingProps, W = m.memoizedState, z = W.element, ef(h, m), Zh(m, A, null, M);
            var fe = m.memoizedState;
            if (A = fe.element, Te && W.isDehydrated) if (W = {
              element: A,
              isDehydrated: !1,
              cache: fe.cache,
              transitions: fe.transitions
            }, m.updateQueue.baseState = W, m.memoizedState = W, m.flags & 256) {
              z = Error(o(423)), m = Yg(h, m, A, M, z);
              break e;
            } else if (A !== z) {
              z = Error(o(424)), m = Yg(h, m, A, M, z);
              break e;
            } else for (Te && (Ji = ge(m.stateNode.containerInfo), Ja = m, Yr = !0, Co = null, Iu = !1), M = ap(m, null, A, M), m.child = M; M; ) M.flags = M.flags & -3 | 4096, M = M.sibling;
            else {
              if (Nu(), A === z) {
                m = fi(h, m, M);
                break e;
              }
              ji(h, m, A, M);
            }
            m = m.child;
          }
          return m;
        case 5:
          return sf(m), h === null && rp(m), A = m.type, z = m.pendingProps, W = h !== null ? h.memoizedProps : null, fe = z.children, oe(A, z) ? fe = null : W !== null && oe(A, W) && (m.flags |= 32), Q0(h, m), ji(h, m, fe, M), m.child;
        case 6:
          return h === null && rp(m), null;
        case 13:
          return J0(h, m, M);
        case 4:
          return op(m, m.stateNode.containerInfo), A = m.pendingProps, h === null ? m.child = Lu(m, null, A, M) : ji(h, m, A, M), m.child;
        case 11:
          return A = m.type, z = m.pendingProps, z = m.elementType === A ? z : jo(A, z), Xu(h, m, A, z, M);
        case 7:
          return ji(h, m, m.pendingProps, M), m.child;
        case 8:
          return ji(h, m, m.pendingProps.children, M), m.child;
        case 12:
          return ji(h, m, m.pendingProps.children, M), m.child;
        case 10:
          e: {
            if (A = m.type._context, z = m.pendingProps, W = m.memoizedProps, fe = z.value, Pg(m, A, fe), W !== null) if (ys(W.value, fe)) {
              if (W.children === z.children && !Tn.current) {
                m = fi(h, m, M);
                break e;
              }
            } else for (W = m.child, W !== null && (W.return = m); W !== null; ) {
              var Le = W.dependencies;
              if (Le !== null) {
                fe = W.child;
                for (var ct = Le.firstContext; ct !== null; ) {
                  if (ct.context === A) {
                    if (W.tag === 1) {
                      ct = Zs(-1, M & -M), ct.tag = 2;
                      var Ot = W.updateQueue;
                      if (Ot !== null) {
                        Ot = Ot.shared;
                        var Vt = Ot.pending;
                        Vt === null ? ct.next = ct : (ct.next = Vt.next, Vt.next = ct), Ot.pending = ct;
                      }
                    }
                    W.lanes |= M, ct = W.alternate, ct !== null && (ct.lanes |= M), Dg(W.return, M, m), Le.lanes |= M;
                    break;
                  }
                  ct = ct.next;
                }
              } else if (W.tag === 10) fe = W.type === m.type ? null : W.child;
              else if (W.tag === 18) {
                if (fe = W.return, fe === null) throw Error(o(341));
                fe.lanes |= M, Le = fe.alternate, Le !== null && (Le.lanes |= M), Dg(fe, M, m), fe = W.sibling;
              } else fe = W.child;
              if (fe !== null) fe.return = W;
              else for (fe = W; fe !== null; ) {
                if (fe === m) {
                  fe = null;
                  break;
                }
                if (W = fe.sibling, W !== null) {
                  W.return = fe.return, fe = W;
                  break;
                }
                fe = fe.return;
              }
              W = fe;
            }
            ji(h, m, z.children, M), m = m.child;
          }
          return m;
        case 9:
          return z = m.type, A = m.pendingProps.children, Ou(m, M), z = _o(z), A = A(z), m.flags |= 1, ji(h, m, A, M), m.child;
        case 14:
          return A = m.type, z = jo(A, m.pendingProps), z = jo(A.type, z), mf(h, m, A, z, M);
        case 15:
          return K0(h, m, m.type, m.pendingProps, M);
        case 17:
          return A = m.type, z = m.pendingProps, z = m.elementType === A ? z : jo(A, z), h !== null && (h.alternate = null, m.alternate = null, m.flags |= 2), m.tag = 1, cn(A) ? (h = !0, Pn(m)) : h = !1, Ou(m, M), G0(m, A, z), Ng(m, A, z, M), qg(null, m, A, !0, h, M);
        case 19:
          return xp(h, m, M);
        case 22:
          return Z0(h, m, M);
      }
      throw Error(o(156, m.tag));
    };
    function ad(h, m) {
      return So(h, m);
    }
    function xf(h, m, M, A) {
      this.tag = h, this.key = M, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = m, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = A, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function ga(h, m, M, A) {
      return new xf(h, m, M, A);
    }
    function Uc(h) {
      return h = h.prototype, !(!h || !h.isReactComponent);
    }
    function Ef(h) {
      if (typeof h == "function") return Uc(h) ? 1 : 0;
      if (h != null) {
        if (h = h.$$typeof, h === E) return 11;
        if (h === w) return 14;
      }
      return 2;
    }
    function Ua(h, m) {
      var M = h.alternate;
      return M === null ? (M = ga(h.tag, m, h.key, h.mode), M.elementType = h.elementType, M.type = h.type, M.stateNode = h.stateNode, M.alternate = h, h.alternate = M) : (M.pendingProps = m, M.type = h.type, M.flags = 0, M.subtreeFlags = 0, M.deletions = null), M.flags = h.flags & 14680064, M.childLanes = h.childLanes, M.lanes = h.lanes, M.child = h.child, M.memoizedProps = h.memoizedProps, M.memoizedState = h.memoizedState, M.updateQueue = h.updateQueue, m = h.dependencies, M.dependencies = m === null ? null : { lanes: m.lanes, firstContext: m.firstContext }, M.sibling = h.sibling, M.index = h.index, M.ref = h.ref, M;
    }
    function zc(h, m, M, A, z, W) {
      var fe = 2;
      if (A = h, typeof h == "function") Uc(h) && (fe = 1);
      else if (typeof h == "string") fe = 5;
      else e: switch (h) {
        case f:
          return Wl(M.children, z, W, m);
        case p:
          fe = 8, z |= 8;
          break;
        case g:
          return h = ga(12, M, m, z | 2), h.elementType = g, h.lanes = W, h;
        case S:
          return h = ga(13, M, m, z), h.elementType = S, h.lanes = W, h;
        case _:
          return h = ga(19, M, m, z), h.elementType = _, h.lanes = W, h;
        case R:
          return Cf(M, z, W, m);
        default:
          if (typeof h == "object" && h !== null) switch (h.$$typeof) {
            case v:
              fe = 10;
              break e;
            case b:
              fe = 9;
              break e;
            case E:
              fe = 11;
              break e;
            case w:
              fe = 14;
              break e;
            case C:
              fe = 16, A = null;
              break e;
          }
          throw Error(o(130, h == null ? h : typeof h, ""));
      }
      return m = ga(fe, M, m, z), m.elementType = h, m.type = A, m.lanes = W, m;
    }
    function Wl(h, m, M, A) {
      return h = ga(7, h, A, m), h.lanes = M, h;
    }
    function Cf(h, m, M, A) {
      return h = ga(22, h, A, m), h.elementType = R, h.lanes = M, h.stateNode = {}, h;
    }
    function Op(h, m, M) {
      return h = ga(6, h, null, m), h.lanes = M, h;
    }
    function wf(h, m, M) {
      return m = ga(4, h.children !== null ? h.children : [], h.key, m), m.lanes = M, m.stateNode = { containerInfo: h.containerInfo, pendingChildren: null, implementation: h.implementation }, m;
    }
    function EC(h, m, M, A, z) {
      this.tag = m, this.containerInfo = h, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ne, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = vs(0), this.expirationTimes = vs(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = vs(0), this.identifierPrefix = A, this.onRecoverableError = z, Te && (this.mutableSourceEagerHydrationData = null);
    }
    function db(h, m, M, A, z, W, fe, Le, ct) {
      return h = new EC(h, m, M, Le, ct), m === 1 ? (m = 1, W === !0 && (m |= 8)) : m = 0, W = ga(3, null, null, m), h.current = W, W.stateNode = h, W.memoizedState = { element: A, isDehydrated: M, cache: null, transitions: null }, Ig(W), h;
    }
    function Po(h) {
      if (!h) return rr;
      h = h._reactInternals;
      e: {
        if (L(h) !== h || h.tag !== 1) throw Error(o(170));
        var m = h;
        do {
          switch (m.tag) {
            case 3:
              m = m.stateNode.context;
              break e;
            case 1:
              if (cn(m.type)) {
                m = m.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          m = m.return;
        } while (m !== null);
        throw Error(o(171));
      }
      if (h.tag === 1) {
        var M = h.type;
        if (cn(M)) return qr(h, M, m);
      }
      return m;
    }
    function Mf(h) {
      var m = h._reactInternals;
      if (m === void 0)
        throw typeof h.render == "function" ? Error(o(188)) : (h = Object.keys(h).join(","), Error(o(268, h)));
      return h = j(m), h === null ? null : h.stateNode;
    }
    function od(h, m) {
      if (h = h.memoizedState, h !== null && h.dehydrated !== null) {
        var M = h.retryLane;
        h.retryLane = M !== 0 && M < m ? M : m;
      }
    }
    function sd(h, m) {
      od(h, m), (h = h.alternate) && od(h, m);
    }
    function ld(h) {
      return h = j(h), h === null ? null : h.stateNode;
    }
    function hv() {
      return null;
    }
    return t.attemptContinuousHydration = function(h) {
      if (h.tag === 13) {
        var m = ma();
        Ro(h, 134217728, m), sd(h, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(h) {
      if (h.tag === 13) {
        var m = ma(), M = kl(h);
        Ro(h, M, m), sd(h, M);
      }
    }, t.attemptSynchronousHydration = function(h) {
      switch (h.tag) {
        case 3:
          var m = h.stateNode;
          if (m.current.memoizedState.isDehydrated) {
            var M = yo(m.pendingLanes);
            M !== 0 && (Ys(m, M | 1), Fa(m, nn()), !(kn & 6) && (nd(), bs()));
          }
          break;
        case 13:
          var A = ma();
          uv(function() {
            return Ro(h, 1, A);
          }), sd(h, 1);
      }
    }, t.batchedUpdates = function(h, m) {
      var M = kn;
      kn |= 1;
      try {
        return h(m);
      } finally {
        kn = M, kn === 0 && (nd(), Gh && bs());
      }
    }, t.createComponentSelector = function(h) {
      return { $$typeof: wp, value: h };
    }, t.createContainer = function(h, m, M, A, z, W, fe) {
      return db(h, m, !1, null, M, A, z, W, fe);
    }, t.createHasPseudoClassSelector = function(h) {
      return { $$typeof: hi, value: h };
    }, t.createHydrationContainer = function(h, m, M, A, z, W, fe, Le, ct) {
      return h = db(M, A, !0, h, z, W, fe, Le, ct), h.context = Po(null), M = h.current, A = ma(), z = kl(M), W = Zs(A, z), W.callback = m ?? null, Nl(M, W), h.current.lanes = z, bo(h, z, A), Fa(h, A), h;
    }, t.createPortal = function(h, m, M) {
      var A = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: d, key: A == null ? null : "" + A, children: h, containerInfo: m, implementation: M };
    }, t.createRoleSelector = function(h) {
      return { $$typeof: Ic, value: h };
    }, t.createTestNameSelector = function(h) {
      return { $$typeof: gf, value: h };
    }, t.createTextSelector = function(h) {
      return { $$typeof: rl, value: h };
    }, t.deferredUpdates = function(h) {
      var m = Qn, M = pi.transition;
      try {
        return pi.transition = null, Qn = 16, h();
      } finally {
        Qn = m, pi.transition = M;
      }
    }, t.discreteUpdates = function(h, m, M, A, z) {
      var W = Qn, fe = pi.transition;
      try {
        return pi.transition = null, Qn = 1, h(m, M, A, z);
      } finally {
        Qn = W, pi.transition = fe, kn === 0 && nd();
      }
    }, t.findAllNodes = Gt, t.findBoundingRects = function(h, m) {
      if (!te) throw Error(o(363));
      m = Gt(h, m), h = [];
      for (var M = 0; M < m.length; M++) h.push(Se(m[M]));
      for (m = h.length - 1; 0 < m; m--) {
        M = h[m];
        for (var A = M.x, z = A + M.width, W = M.y, fe = W + M.height, Le = m - 1; 0 <= Le; Le--) if (m !== Le) {
          var ct = h[Le], Ot = ct.x, Vt = Ot + ct.width, Cn = ct.y, _n = Cn + ct.height;
          if (A >= Ot && W >= Cn && z <= Vt && fe <= _n) {
            h.splice(m, 1);
            break;
          } else if (A !== Ot || M.width !== ct.width || _n < W || Cn > fe) {
            if (!(W !== Cn || M.height !== ct.height || Vt < A || Ot > z)) {
              Ot > A && (ct.width += Ot - A, ct.x = A), Vt < z && (ct.width = z - Ot), h.splice(m, 1);
              break;
            }
          } else {
            Cn > W && (ct.height += Cn - W, ct.y = W), _n < fe && (ct.height = fe - Cn), h.splice(m, 1);
            break;
          }
        }
      }
      return h;
    }, t.findHostInstance = Mf, t.findHostInstanceWithNoPortals = function(h) {
      return h = H(h), h = h !== null ? X(h) : null, h === null ? null : h.stateNode;
    }, t.findHostInstanceWithWarning = function(h) {
      return Mf(h);
    }, t.flushControlled = function(h) {
      var m = kn;
      kn |= 1;
      var M = pi.transition, A = Qn;
      try {
        pi.transition = null, Qn = 1, h();
      } finally {
        Qn = A, pi.transition = M, kn = m, kn === 0 && (nd(), bs());
      }
    }, t.flushPassiveEffects = Lc, t.flushSync = uv, t.focusWithin = function(h, m) {
      if (!te) throw Error(o(363));
      for (h = nv(h), m = ea(h, m), m = Array.from(m), h = 0; h < m.length; ) {
        var M = m[h++];
        if (!Pe(M)) {
          if (M.tag === 5 && Ze(M.stateNode)) return !0;
          for (M = M.child; M !== null; ) m.push(M), M = M.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return Qn;
    }, t.getFindAllNodesFailureDescription = function(h, m) {
      if (!te) throw Error(o(363));
      var M = 0, A = [];
      h = [nv(h), 0];
      for (var z = 0; z < h.length; ) {
        var W = h[z++], fe = h[z++], Le = m[fe];
        if ((W.tag !== 5 || !Pe(W)) && (rv(W, Le) && (A.push(Bl(Le)), fe++, fe > M && (M = fe)), fe < m.length)) for (W = W.child; W !== null; ) h.push(W, fe), W = W.sibling;
      }
      if (M < m.length) {
        for (h = []; M < m.length; M++) h.push(Bl(m[M]));
        return `findAllNodes was able to match part of the selector:
  ` + (A.join(" > ") + `

No matching component was found for:
  `) + h.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(h) {
      if (h = h.current, !h.child) return null;
      switch (h.child.tag) {
        case 5:
          return Z(h.child.stateNode);
        default:
          return h.child.stateNode;
      }
    }, t.injectIntoDevTools = function(h) {
      if (h = { bundleType: h.bundleType, version: h.version, rendererPackageName: h.rendererPackageName, rendererConfig: h.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: s.ReactCurrentDispatcher, findHostInstanceByFiber: ld, findFiberByHostInstance: h.findFiberByHostInstance || hv, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") h = !1;
      else {
        var m = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (m.isDisabled || !m.supportsFiber) h = !0;
        else {
          try {
            Il = m.inject(h), Qa = m;
          } catch {
          }
          h = !!m.checkDCE;
        }
      }
      return h;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(h, m, M, A) {
      if (!te) throw Error(o(363));
      h = Gt(h, m);
      var z = nt(h, M, A).disconnect;
      return { disconnect: function() {
        z();
      } };
    }, t.registerMutableSourceForHydration = function(h, m) {
      var M = m._getVersion;
      M = M(m._source), h.mutableSourceEagerHydrationData == null ? h.mutableSourceEagerHydrationData = [m, M] : h.mutableSourceEagerHydrationData.push(m, M);
    }, t.runWithPriority = function(h, m) {
      var M = Qn;
      try {
        return Qn = h, m();
      } finally {
        Qn = M;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(h, m, M, A) {
      var z = m.current, W = ma(), fe = kl(z);
      return M = Po(M), m.context === null ? m.context = M : m.pendingContext = M, m = Zs(W, fe), m.payload = { element: h }, A = A === void 0 ? null : A, A !== null && (m.callback = A), Nl(z, m), h = Ro(z, fe, W), h !== null && Kh(h, z, fe), fe;
    }, t;
  }), uT;
}
var dT = { exports: {} }, nU;
function Xhe() {
  return nU || (nU = 1, Ee.env.NODE_ENV !== "production" && (dT.exports = function(e) {
    var t = {}, r = Fe, i = L$(), a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, o = !1;
    function s(l) {
      o = l;
    }
    function u(l) {
      if (!o) {
        for (var c = arguments.length, y = new Array(c > 1 ? c - 1 : 0), x = 1; x < c; x++)
          y[x - 1] = arguments[x];
        f("warn", l, y);
      }
    }
    function d(l) {
      if (!o) {
        for (var c = arguments.length, y = new Array(c > 1 ? c - 1 : 0), x = 1; x < c; x++)
          y[x - 1] = arguments[x];
        f("error", l, y);
      }
    }
    function f(l, c, y) {
      {
        var x = a.ReactDebugCurrentFrame, T = x.getStackAddendum();
        T !== "" && (c += "%s", y = y.concat([T]));
        var F = y.map(function(k) {
          return String(k);
        });
        F.unshift("Warning: " + c), Function.prototype.apply.call(console[l], console, F);
      }
    }
    var p = Object.assign;
    function g(l) {
      return l._reactInternals;
    }
    function v(l, c) {
      l._reactInternals = c;
    }
    var b = !1, E = !1, S = !1, _ = !1, w = !1, C = !1, R = !0, P = !0, D = !0, I = 0, U = 1, L = 2, N = 3, H = 4, j = 5, G = 6, X = 7, ae = 8, Z = 9, K = 10, B = 11, Q = 12, V = 13, q = 14, ne = 15, ce = 16, ie = 17, oe = 18, he = 19, le = 21, ve = 22, Ne = 23, xe = 24, Me = 25, $ = Symbol.for("react.element"), Te = Symbol.for("react.portal"), se = Symbol.for("react.fragment"), Ie = Symbol.for("react.strict_mode"), be = Symbol.for("react.profiler"), et = Symbol.for("react.provider"), Xe = Symbol.for("react.context"), $e = Symbol.for("react.forward_ref"), te = Symbol.for("react.suspense"), Y = Symbol.for("react.suspense_list"), Se = Symbol.for("react.memo"), Oe = Symbol.for("react.lazy"), Pe = Symbol.for("react.scope"), Ve = Symbol.for("react.debug_trace_mode"), Ze = Symbol.for("react.offscreen"), nt = Symbol.for("react.legacy_hidden"), ht = Symbol.for("react.cache"), pt = Symbol.for("react.tracing_marker"), Be = Symbol.iterator, ye = "@@iterator";
    function Ue(l) {
      if (l === null || typeof l != "object")
        return null;
      var c = Be && l[Be] || l[ye];
      return typeof c == "function" ? c : null;
    }
    function Ye(l, c, y) {
      var x = l.displayName;
      if (x)
        return x;
      var T = c.displayName || c.name || "";
      return T !== "" ? y + "(" + T + ")" : y;
    }
    function tt(l) {
      return l.displayName || "Context";
    }
    function st(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && d("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case se:
          return "Fragment";
        case Te:
          return "Portal";
        case be:
          return "Profiler";
        case Ie:
          return "StrictMode";
        case te:
          return "Suspense";
        case Y:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case Xe:
            var c = l;
            return tt(c) + ".Consumer";
          case et:
            var y = l;
            return tt(y._context) + ".Provider";
          case $e:
            return Ye(l, l.render, "ForwardRef");
          case Se:
            var x = l.displayName || null;
            return x !== null ? x : st(l.type) || "Memo";
          case Oe: {
            var T = l, F = T._payload, k = T._init;
            try {
              return st(k(F));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Tt(l, c, y) {
      var x = c.displayName || c.name || "";
      return l.displayName || (x !== "" ? y + "(" + x + ")" : y);
    }
    function Rt(l) {
      return l.displayName || "Context";
    }
    function ue(l) {
      var c = l.tag, y = l.type;
      switch (c) {
        case xe:
          return "Cache";
        case Z:
          var x = y;
          return Rt(x) + ".Consumer";
        case K:
          var T = y;
          return Rt(T._context) + ".Provider";
        case oe:
          return "DehydratedFragment";
        case B:
          return Tt(y, y.render, "ForwardRef");
        case X:
          return "Fragment";
        case j:
          return y;
        case H:
          return "Portal";
        case N:
          return "Root";
        case G:
          return "Text";
        case ce:
          return st(y);
        case ae:
          return y === Ie ? "StrictMode" : "Mode";
        case ve:
          return "Offscreen";
        case Q:
          return "Profiler";
        case le:
          return "Scope";
        case V:
          return "Suspense";
        case he:
          return "SuspenseList";
        case Me:
          return "TracingMarker";
        case U:
        case I:
        case ie:
        case L:
        case q:
        case ne:
          if (typeof y == "function")
            return y.displayName || y.name || null;
          if (typeof y == "string")
            return y;
          break;
      }
      return null;
    }
    var De = (
      /*                      */
      0
    ), Ge = (
      /*                */
      1
    ), We = (
      /*                    */
      2
    ), He = (
      /*                       */
      4
    ), ut = (
      /*           */
      We | He
    ), vt = (
      /*                */
      16
    ), _t = (
      /*                 */
      32
    ), Wt = (
      /*                     */
      64
    ), lt = (
      /*                   */
      128
    ), Ct = (
      /*            */
      256
    ), un = (
      /*                          */
      512
    ), Nn = (
      /*                     */
      1024
    ), xt = (
      /*                      */
      2048
    ), Pt = (
      /*                    */
      4096
    ), Bt = (
      /*           */
      Pt | He
    ), Qt = (
      /*                   */
      8192
    ), vn = (
      /*             */
      16384
    ), Mn = xt | He | Wt | un | Nn | vn, cr = (
      /*               */
      32767
    ), ge = (
      /*                   */
      32768
    ), it = (
      /*                */
      65536
    ), yt = (
      /* */
      131072
    ), Kt = (
      /*                       */
      1048576
    ), Sn = (
      /*                    */
      2097152
    ), ee = (
      /*                 */
      4194304
    ), _e = (
      /*                */
      8388608
    ), Ae = (
      /*               */
      16777216
    ), Ce = (
      /*              */
      33554432
    ), pe = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      He | Nn | 0
    ), je = We | He | vt | _t | un | Pt | Qt, bt = He | Wt | un | Qt, It = xt | vt, Lt = ee | _e | Sn, Ht = a.ReactCurrentOwner;
    function on(l) {
      var c = l, y = l;
      if (l.alternate)
        for (; c.return; )
          c = c.return;
      else {
        var x = c;
        do
          c = x, (c.flags & (We | Pt)) !== De && (y = c.return), x = c.return;
        while (x);
      }
      return c.tag === N ? y : null;
    }
    function sn(l) {
      return on(l) === l;
    }
    function Rn(l) {
      {
        var c = Ht.current;
        if (c !== null && c.tag === U) {
          var y = c, x = y.stateNode;
          x._warnedAboutRefsInRender || d("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", ue(y) || "A component"), x._warnedAboutRefsInRender = !0;
        }
      }
      var T = g(l);
      return T ? on(T) === T : !1;
    }
    function Vn(l) {
      if (on(l) !== l)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Kn(l) {
      var c = l.alternate;
      if (!c) {
        var y = on(l);
        if (y === null)
          throw new Error("Unable to find node on an unmounted component.");
        return y !== l ? null : l;
      }
      for (var x = l, T = c; ; ) {
        var F = x.return;
        if (F === null)
          break;
        var k = F.alternate;
        if (k === null) {
          var J = F.return;
          if (J !== null) {
            x = T = J;
            continue;
          }
          break;
        }
        if (F.child === k.child) {
          for (var re = F.child; re; ) {
            if (re === x)
              return Vn(F), l;
            if (re === T)
              return Vn(F), c;
            re = re.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (x.return !== T.return)
          x = F, T = k;
        else {
          for (var me = !1, we = F.child; we; ) {
            if (we === x) {
              me = !0, x = F, T = k;
              break;
            }
            if (we === T) {
              me = !0, T = F, x = k;
              break;
            }
            we = we.sibling;
          }
          if (!me) {
            for (we = k.child; we; ) {
              if (we === x) {
                me = !0, x = k, T = F;
                break;
              }
              if (we === T) {
                me = !0, T = k, x = F;
                break;
              }
              we = we.sibling;
            }
            if (!me)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (x.alternate !== T)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (x.tag !== N)
        throw new Error("Unable to find node on an unmounted component.");
      return x.stateNode.current === x ? l : c;
    }
    function Zn(l) {
      var c = Kn(l);
      return c !== null ? Jt(c) : null;
    }
    function Jt(l) {
      if (l.tag === j || l.tag === G)
        return l;
      for (var c = l.child; c !== null; ) {
        var y = Jt(c);
        if (y !== null)
          return y;
        c = c.sibling;
      }
      return null;
    }
    function Nt(l) {
      var c = Kn(l);
      return c !== null ? rr(c) : null;
    }
    function rr(l) {
      if (l.tag === j || l.tag === G)
        return l;
      for (var c = l.child; c !== null; ) {
        if (c.tag !== H) {
          var y = rr(c);
          if (y !== null)
            return y;
        }
        c = c.sibling;
      }
      return null;
    }
    var hn = Array.isArray;
    function Tn(l) {
      return hn(l);
    }
    var Xr = e.getPublicInstance, ur = e.getRootHostContext, cn = e.getChildHostContext, en = e.prepareForCommit, gr = e.resetAfterCommit, qr = e.createInstance, Pn = e.appendInitialChild, Fr = e.finalizeInitialChildren, Sr = e.prepareUpdate, Oi = e.shouldSetTextContent, fa = e.createTextInstance, Za = e.scheduleTimeout, Pi = e.cancelTimeout, Wi = e.noTimeout;
    e.now;
    var yo = e.isPrimaryRenderer, Qi = e.warnsIfNotActing, ha = e.supportsMutation, _a = e.supportsPersistence, ri = e.supportsHydration, vs = e.getInstanceFromNode;
    e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
    var bo = e.preparePortalMount;
    e.preparePortalMount, e.getInstanceFromScope;
    var vc = e.getCurrentEventPriority, Ys = e.detachDeletedInstance, Qn = e.supportsMicrotasks, wu = e.scheduleMicrotask, So = e.supportsTestSelectors, Mu = e.findFiberRoot, Zd = e.getBoundingRect, ln = e.getTextContent, nn = e.isHiddenSubtree, Br = e.matchAccessibilityRole, ui = e.setFocusIfFocusable, Hr = e.setupIntersectionObserver, Tu = e.appendChild, Il = e.appendChildToContainer, Qa = e.commitTextUpdate, Ru = e.commitMount, pC = e.commitUpdate, ys = e.insertBefore, Ks = e.insertInContainerBefore, Gh = e.removeChild, Rg = e.removeChildFromContainer, Ag = e.resetTextContent, mC = e.hideInstance, bs = e.hideTextInstance, gC = e.unhideInstance, Xh = e.unhideTextInstance, vC = e.clearContainer, jo = e.cloneInstance, Qd = e.createContainerChildSet, Jd = e.appendChildToContainerChildSet, Au = e.finalizeContainerChildren, qh = e.replaceContainerChildren;
    e.getOffscreenContainerType;
    var Og = e.getOffscreenContainerProps, Pg = e.cloneHiddenInstance, Yh = e.cloneHiddenTextInstance, Dg = e.canHydrateInstance, Ou = e.canHydrateTextInstance, _o = e.canHydrateSuspenseInstance, Go = e.isSuspenseInstancePending, Ss = e.isSuspenseInstanceFallback, Ig = e.registerSuspenseInstanceRetry, ef = e.getNextHydratableSibling, Zs = e.getFirstHydratableChild, Nl = e.getFirstHydratableChildWithinContainer, Kh = e.getFirstHydratableChildWithinSuspenseInstance, k0 = e.hydrateInstance, Zh = e.hydrateTextInstance, $0 = e.hydrateSuspenseInstance, W0 = e.getNextHydratableInstanceAfterSuspenseInstance, Qh = e.commitHydratedContainer, Jh = e.commitHydratedSuspenseInstance, j0 = e.clearSuspenseBoundary, G0 = e.clearSuspenseBoundaryFromContainer, X0 = e.shouldDeleteUnhydratedTailInstances, Ng = e.didNotMatchHydratedContainerTextInstance, Pu = e.didNotMatchHydratedTextInstance, Du = e.didNotHydrateInstanceWithinContainer, ep = e.didNotHydrateInstanceWithinSuspenseInstance, tp = e.didNotHydrateInstance, xo = e.didNotFindHydratableInstanceWithinContainer, Eo = e.didNotFindHydratableTextInstanceWithinContainer, yc = e.didNotFindHydratableSuspenseInstanceWithinContainer, Qs = e.didNotFindHydratableInstanceWithinSuspenseInstance, Js = e.didNotFindHydratableTextInstanceWithinSuspenseInstance, bc = e.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, q0 = e.didNotFindHydratableInstance, Lg = e.didNotFindHydratableTextInstance, Fg = e.didNotFindHydratableSuspenseInstance, Ja = e.errorHydratingContainer, Ji = 0, Yr, Iu, Co, Ug, zg, np, rp;
    function Bg() {
    }
    Bg.__reactDisabledLog = !0;
    function tf() {
      {
        if (Ji === 0) {
          Yr = console.log, Iu = console.info, Co = console.warn, Ug = console.error, zg = console.group, np = console.groupCollapsed, rp = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: Bg,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Ji++;
      }
    }
    function Nu() {
      {
        if (Ji--, Ji === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: p({}, l, {
              value: Yr
            }),
            info: p({}, l, {
              value: Iu
            }),
            warn: p({}, l, {
              value: Co
            }),
            error: p({}, l, {
              value: Ug
            }),
            group: p({}, l, {
              value: zg
            }),
            groupCollapsed: p({}, l, {
              value: np
            }),
            groupEnd: p({}, l, {
              value: rp
            })
          });
        }
        Ji < 0 && d("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var nf = a.ReactCurrentDispatcher, Sc;
    function Xo(l, c, y) {
      {
        if (Sc === void 0)
          try {
            throw Error();
          } catch (T) {
            var x = T.stack.trim().match(/\n( *(at )?)/);
            Sc = x && x[1] || "";
          }
        return `
` + Sc + l;
      }
    }
    var ip = !1, rf;
    {
      var Lu = typeof WeakMap == "function" ? WeakMap : Map;
      rf = new Lu();
    }
    function ap(l, c) {
      if (!l || ip)
        return "";
      {
        var y = rf.get(l);
        if (y !== void 0)
          return y;
      }
      var x;
      ip = !0;
      var T = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var F;
      F = nf.current, nf.current = null, tf();
      try {
        if (c) {
          var k = function() {
            throw Error();
          };
          if (Object.defineProperty(k.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(k, []);
            } catch (At) {
              x = At;
            }
            Reflect.construct(l, [], k);
          } else {
            try {
              k.call();
            } catch (At) {
              x = At;
            }
            l.call(k.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (At) {
            x = At;
          }
          l();
        }
      } catch (At) {
        if (At && x && typeof At.stack == "string") {
          for (var J = At.stack.split(`
`), re = x.stack.split(`
`), me = J.length - 1, we = re.length - 1; me >= 1 && we >= 0 && J[me] !== re[we]; )
            we--;
          for (; me >= 1 && we >= 0; me--, we--)
            if (J[me] !== re[we]) {
              if (me !== 1 || we !== 1)
                do
                  if (me--, we--, we < 0 || J[me] !== re[we]) {
                    var qe = `
` + J[me].replace(" at new ", " at ");
                    return l.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", l.displayName)), typeof l == "function" && rf.set(l, qe), qe;
                  }
                while (me >= 1 && we >= 0);
              break;
            }
        }
      } finally {
        ip = !1, nf.current = F, Nu(), Error.prepareStackTrace = T;
      }
      var at = l ? l.displayName || l.name : "", dt = at ? Xo(at) : "";
      return typeof l == "function" && rf.set(l, dt), dt;
    }
    function af(l, c, y) {
      return ap(l, !0);
    }
    function Ia(l, c, y) {
      return ap(l, !1);
    }
    function of(l) {
      var c = l.prototype;
      return !!(c && c.isReactComponent);
    }
    function Ll(l, c, y) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return ap(l, of(l));
      if (typeof l == "string")
        return Xo(l);
      switch (l) {
        case te:
          return Xo("Suspense");
        case Y:
          return Xo("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case $e:
            return Ia(l.render);
          case Se:
            return Ll(l.type, c, y);
          case Oe: {
            var x = l, T = x._payload, F = x._init;
            try {
              return Ll(F(T), c, y);
            } catch {
            }
          }
        }
      return "";
    }
    var qo = Object.prototype.hasOwnProperty, op = {}, _c = a.ReactDebugCurrentFrame;
    function sf(l) {
      if (l) {
        var c = l._owner, y = Ll(l.type, l._source, c ? c.type : null);
        _c.setExtraStackFrame(y);
      } else
        _c.setExtraStackFrame(null);
    }
    function eo(l, c, y, x, T) {
      {
        var F = Function.call.bind(qo);
        for (var k in l)
          if (F(l, k)) {
            var J = void 0;
            try {
              if (typeof l[k] != "function") {
                var re = Error((x || "React class") + ": " + y + " type `" + k + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[k] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw re.name = "Invariant Violation", re;
              }
              J = l[k](c, k, x, y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (me) {
              J = me;
            }
            J && !(J instanceof Error) && (sf(T), d("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", x || "React class", y, k, typeof J), sf(null)), J instanceof Error && !(J.message in op) && (op[J.message] = !0, sf(T), d("Failed %s type: %s", y, J.message), sf(null));
          }
      }
    }
    var Kr = [], xc;
    xc = [];
    var Yo = -1;
    function _s(l) {
      return {
        current: l
      };
    }
    function Di(l, c) {
      if (Yo < 0) {
        d("Unexpected pop.");
        return;
      }
      c !== xc[Yo] && d("Unexpected Fiber popped."), l.current = Kr[Yo], Kr[Yo] = null, xc[Yo] = null, Yo--;
    }
    function Tr(l, c, y) {
      Yo++, Kr[Yo] = l.current, xc[Yo] = y, l.current = c;
    }
    var Fl;
    Fl = {};
    var ir = {};
    Object.freeze(ir);
    var Qr = _s(ir), Ur = _s(!1), Fu = ir;
    function xs(l, c, y) {
      return y && wo(c) ? Fu : Qr.current;
    }
    function Uu(l, c, y) {
      {
        var x = l.stateNode;
        x.__reactInternalMemoizedUnmaskedChildContext = c, x.__reactInternalMemoizedMaskedChildContext = y;
      }
    }
    function zu(l, c) {
      {
        var y = l.type, x = y.contextTypes;
        if (!x)
          return ir;
        var T = l.stateNode;
        if (T && T.__reactInternalMemoizedUnmaskedChildContext === c)
          return T.__reactInternalMemoizedMaskedChildContext;
        var F = {};
        for (var k in x)
          F[k] = c[k];
        {
          var J = ue(l) || "Unknown";
          eo(x, F, "context", J);
        }
        return T && Uu(l, c, F), F;
      }
    }
    function Ii() {
      return Ur.current;
    }
    function wo(l) {
      {
        var c = l.childContextTypes;
        return c != null;
      }
    }
    function Bu(l) {
      Di(Ur, l), Di(Qr, l);
    }
    function lf(l) {
      Di(Ur, l), Di(Qr, l);
    }
    function Es(l, c, y) {
      {
        if (Qr.current !== ir)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Tr(Qr, c, l), Tr(Ur, y, l);
      }
    }
    function Ko(l, c, y) {
      {
        var x = l.stateNode, T = c.childContextTypes;
        if (typeof x.getChildContext != "function") {
          {
            var F = ue(l) || "Unknown";
            Fl[F] || (Fl[F] = !0, d("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", F, F));
          }
          return y;
        }
        var k = x.getChildContext();
        for (var J in k)
          if (!(J in T))
            throw new Error((ue(l) || "Unknown") + '.getChildContext(): key "' + J + '" is not defined in childContextTypes.');
        {
          var re = ue(l) || "Unknown";
          eo(T, k, "child context", re);
        }
        return p({}, y, k);
      }
    }
    function Cs(l) {
      {
        var c = l.stateNode, y = c && c.__reactInternalMemoizedMergedChildContext || ir;
        return Fu = Qr.current, Tr(Qr, y, l), Tr(Ur, Ur.current, l), !0;
      }
    }
    function cf(l, c, y) {
      {
        var x = l.stateNode;
        if (!x)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (y) {
          var T = Ko(l, c, Fu);
          x.__reactInternalMemoizedMergedChildContext = T, Di(Ur, l), Di(Qr, l), Tr(Qr, T, l), Tr(Ur, y, l);
        } else
          Di(Ur, l), Tr(Ur, y, l);
      }
    }
    function sp(l) {
      {
        if (!sn(l) || l.tag !== U)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var c = l;
        do {
          switch (c.tag) {
            case N:
              return c.stateNode.context;
            case U: {
              var y = c.type;
              if (wo(y))
                return c.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          c = c.return;
        } while (c !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Ec = 0, Hg = 1, An = (
      /*                         */
      0
    ), _r = (
      /*                 */
      1
    ), lr = (
      /*                    */
      2
    ), di = (
      /*               */
      8
    ), Mo = (
      /*              */
      16
    ), Hu = Math.clz32 ? Math.clz32 : cp, Y0 = Math.log, lp = Math.LN2;
    function cp(l) {
      var c = l >>> 0;
      return c === 0 ? 32 : 31 - (Y0(c) / lp | 0) | 0;
    }
    var uf = 31, wt = (
      /*                        */
      0
    ), Ni = (
      /*                          */
      0
    ), Jn = (
      /*                        */
      1
    ), Cc = (
      /*    */
      2
    ), el = (
      /*            */
      4
    ), tl = (
      /*            */
      8
    ), ws = (
      /*                    */
      16
    ), Vu = (
      /*                */
      32
    ), ku = (
      /*                       */
      4194240
    ), $u = (
      /*                        */
      64
    ), Vg = (
      /*                        */
      128
    ), kg = (
      /*                        */
      256
    ), up = (
      /*                        */
      512
    ), dp = (
      /*                        */
      1024
    ), fp = (
      /*                        */
      2048
    ), hp = (
      /*                        */
      4096
    ), Wu = (
      /*                        */
      8192
    ), $g = (
      /*                        */
      16384
    ), Wg = (
      /*                       */
      32768
    ), jg = (
      /*                       */
      65536
    ), df = (
      /*                       */
      131072
    ), ff = (
      /*                       */
      262144
    ), Gg = (
      /*                       */
      524288
    ), pp = (
      /*                       */
      1048576
    ), mp = (
      /*                       */
      2097152
    ), hf = (
      /*                            */
      130023424
    ), wc = (
      /*                             */
      4194304
    ), gp = (
      /*                             */
      8388608
    ), To = (
      /*                             */
      16777216
    ), vp = (
      /*                             */
      33554432
    ), Mc = (
      /*                             */
      67108864
    ), ju = wc, Ul = (
      /*          */
      134217728
    ), pf = (
      /*                                 */
      268435455
    ), Gu = (
      /*               */
      268435456
    ), Zo = (
      /*                       */
      536870912
    ), Rr = (
      /*                   */
      1073741824
    );
    function yC(l) {
      {
        if (l & Jn)
          return "Sync";
        if (l & Cc)
          return "InputContinuousHydration";
        if (l & el)
          return "InputContinuous";
        if (l & tl)
          return "DefaultHydration";
        if (l & ws)
          return "Default";
        if (l & Vu)
          return "TransitionHydration";
        if (l & ku)
          return "Transition";
        if (l & hf)
          return "Retry";
        if (l & Ul)
          return "SelectiveHydration";
        if (l & Gu)
          return "IdleHydration";
        if (l & Zo)
          return "Idle";
        if (l & Rr)
          return "Offscreen";
      }
    }
    var Vr = -1, pa = $u, ji = wc;
    function Xu(l) {
      switch (Ms(l)) {
        case Jn:
          return Jn;
        case Cc:
          return Cc;
        case el:
          return el;
        case tl:
          return tl;
        case ws:
          return ws;
        case Vu:
          return Vu;
        case $u:
        case Vg:
        case kg:
        case up:
        case dp:
        case fp:
        case hp:
        case Wu:
        case $g:
        case Wg:
        case jg:
        case df:
        case ff:
        case Gg:
        case pp:
        case mp:
          return l & ku;
        case wc:
        case gp:
        case To:
        case vp:
        case Mc:
          return l & hf;
        case Ul:
          return Ul;
        case Gu:
          return Gu;
        case Zo:
          return Zo;
        case Rr:
          return Rr;
        default:
          return d("Should have found matching lanes. This is a bug in React."), l;
      }
    }
    function mf(l, c) {
      var y = l.pendingLanes;
      if (y === wt)
        return wt;
      var x = wt, T = l.suspendedLanes, F = l.pingedLanes, k = y & pf;
      if (k !== wt) {
        var J = k & ~T;
        if (J !== wt)
          x = Xu(J);
        else {
          var re = k & F;
          re !== wt && (x = Xu(re));
        }
      } else {
        var me = y & ~T;
        me !== wt ? x = Xu(me) : F !== wt && (x = Xu(F));
      }
      if (x === wt)
        return wt;
      if (c !== wt && c !== x && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (c & T) === wt) {
        var we = Ms(x), qe = Ms(c);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          we >= qe || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          we === ws && (qe & ku) !== wt
        )
          return c;
      }
      (x & el) !== wt && (x |= y & ws);
      var at = l.entangledLanes;
      if (at !== wt)
        for (var dt = l.entanglements, At = x & at; At > 0; ) {
          var Dt = nl(At), yn = 1 << Dt;
          x |= dt[Dt], At &= ~yn;
        }
      return x;
    }
    function K0(l, c) {
      for (var y = l.eventTimes, x = Vr; c > 0; ) {
        var T = nl(c), F = 1 << T, k = y[T];
        k > x && (x = k), c &= ~F;
      }
      return x;
    }
    function Z0(l, c) {
      switch (l) {
        case Jn:
        case Cc:
        case el:
          return c + 250;
        case tl:
        case ws:
        case Vu:
        case $u:
        case Vg:
        case kg:
        case up:
        case dp:
        case fp:
        case hp:
        case Wu:
        case $g:
        case Wg:
        case jg:
        case df:
        case ff:
        case Gg:
        case pp:
        case mp:
          return c + 5e3;
        case wc:
        case gp:
        case To:
        case vp:
        case Mc:
          return Vr;
        case Ul:
        case Gu:
        case Zo:
        case Rr:
          return Vr;
        default:
          return d("Should have found matching lanes. This is a bug in React."), Vr;
      }
    }
    function Q0(l, c) {
      for (var y = l.pendingLanes, x = l.suspendedLanes, T = l.pingedLanes, F = l.expirationTimes, k = y; k > 0; ) {
        var J = nl(k), re = 1 << J, me = F[J];
        me === Vr ? ((re & x) === wt || (re & T) !== wt) && (F[J] = Z0(re, c)) : me <= c && (l.expiredLanes |= re), k &= ~re;
      }
    }
    function Xg(l) {
      return Xu(l.pendingLanes);
    }
    function yp(l) {
      var c = l.pendingLanes & ~Rr;
      return c !== wt ? c : c & Rr ? Rr : wt;
    }
    function qg(l) {
      return (l & Jn) !== wt;
    }
    function bp(l) {
      return (l & pf) !== wt;
    }
    function Yg(l) {
      return (l & hf) === l;
    }
    function Sp(l) {
      return (l & ku) === l;
    }
    function Tc(l, c) {
      var y = Cc | el | tl | ws;
      return (c & y) !== wt;
    }
    function J0(l, c) {
      return (c & l.expiredLanes) !== wt;
    }
    function _p(l) {
      return (l & ku) !== 0;
    }
    function eb() {
      var l = pa;
      return pa <<= 1, pa & ku || (pa = $u), l;
    }
    function tb() {
      var l = ji;
      return ji <<= 1, ji & hf || (ji = wc), l;
    }
    function Ms(l) {
      return l & -l;
    }
    function qu(l) {
      return Ms(l);
    }
    function nl(l) {
      return 31 - Hu(l);
    }
    function xp(l) {
      return nl(l);
    }
    function fi(l, c) {
      return (l & c) !== wt;
    }
    function Yu(l, c) {
      return (l & c) === c;
    }
    function Ln(l, c) {
      return l | c;
    }
    function Rc(l, c) {
      return l & ~c;
    }
    function zl(l, c) {
      return l & c;
    }
    function CP(l) {
      return l;
    }
    function qt(l, c) {
      return l !== Ni && l < c ? l : c;
    }
    function Ku(l) {
      for (var c = [], y = 0; y < uf; y++)
        c.push(l);
      return c;
    }
    function Ac(l, c, y) {
      l.pendingLanes |= c, c !== Zo && (l.suspendedLanes = wt, l.pingedLanes = wt);
      var x = l.eventTimes, T = xp(c);
      x[T] = y;
    }
    function nb(l, c) {
      l.suspendedLanes |= c, l.pingedLanes &= ~c;
      for (var y = l.expirationTimes, x = c; x > 0; ) {
        var T = nl(x), F = 1 << T;
        y[T] = Vr, x &= ~F;
      }
    }
    function rb(l, c, y) {
      l.pingedLanes |= l.suspendedLanes & c;
    }
    function Oc(l, c) {
      var y = l.pendingLanes & ~c;
      l.pendingLanes = c, l.suspendedLanes = 0, l.pingedLanes = 0, l.expiredLanes &= c, l.mutableReadLanes &= c, l.entangledLanes &= c;
      for (var x = l.entanglements, T = l.eventTimes, F = l.expirationTimes, k = y; k > 0; ) {
        var J = nl(k), re = 1 << J;
        x[J] = wt, T[J] = Vr, F[J] = Vr, k &= ~re;
      }
    }
    function Pc(l, c) {
      for (var y = l.entangledLanes |= c, x = l.entanglements, T = y; T; ) {
        var F = nl(T), k = 1 << F;
        // Is this one of the newly entangled lanes?
        k & c | // Is this lane transitively entangled with the newly entangled lanes?
        x[F] & c && (x[F] |= c), T &= ~k;
      }
    }
    function Kg(l, c) {
      var y = Ms(c), x;
      switch (y) {
        case el:
          x = Cc;
          break;
        case ws:
          x = tl;
          break;
        case $u:
        case Vg:
        case kg:
        case up:
        case dp:
        case fp:
        case hp:
        case Wu:
        case $g:
        case Wg:
        case jg:
        case df:
        case ff:
        case Gg:
        case pp:
        case mp:
        case wc:
        case gp:
        case To:
        case vp:
        case Mc:
          x = Vu;
          break;
        case Zo:
          x = Gu;
          break;
        default:
          x = Ni;
          break;
      }
      return (x & (l.suspendedLanes | c)) !== Ni ? Ni : x;
    }
    function Zg(l, c, y) {
      if (Na)
        for (var x = l.pendingUpdatersLaneMap; y > 0; ) {
          var T = xp(y), F = 1 << T, k = x[T];
          k.add(c), y &= ~F;
        }
    }
    function Qg(l, c) {
      if (Na)
        for (var y = l.pendingUpdatersLaneMap, x = l.memoizedUpdaters; c > 0; ) {
          var T = xp(c), F = 1 << T, k = y[T];
          k.size > 0 && (k.forEach(function(J) {
            var re = J.alternate;
            (re === null || !x.has(re)) && x.add(J);
          }), k.clear()), c &= ~F;
        }
    }
    var Qo = Jn, Zu = el, Qu = ws, Ep = Zo, Dc = Ni;
    function to() {
      return Dc;
    }
    function Li(l) {
      Dc = l;
    }
    function Jg(l, c) {
      var y = Dc;
      try {
        return Dc = l, c();
      } finally {
        Dc = y;
      }
    }
    function Cp(l, c) {
      return l !== 0 && l < c ? l : c;
    }
    function bC(l, c) {
      return l > c ? l : c;
    }
    function ib(l, c) {
      return l !== 0 && l < c;
    }
    function ev(l) {
      var c = Ms(l);
      return ib(Qo, c) ? ib(Zu, c) ? bp(c) ? Qu : Ep : Zu : Qo;
    }
    var tv = i.unstable_scheduleCallback, ab = i.unstable_cancelCallback, ob = i.unstable_shouldYield, wp = i.unstable_requestPaint, hi = i.unstable_now, Ic = i.unstable_ImmediatePriority, gf = i.unstable_UserBlockingPriority, rl = i.unstable_NormalPriority, Ju = i.unstable_IdlePriority, nv = i.unstable_yieldValue, rv = i.unstable_setDisableYieldValue, Bl = null, ea = null, Gt = null, Ts = !1, Na = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function iv(l) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (c.isDisabled)
        return !0;
      if (!c.supportsFiber)
        return d("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        R && (l = p({}, l, {
          getLaneLabelMap: ed,
          injectProfilingHooks: no
        })), Bl = c.inject(l), ea = c;
      } catch (y) {
        d("React instrumentation encountered an error: %s.", y);
      }
      return !!c.checkDCE;
    }
    function pi(l, c) {
      if (ea && typeof ea.onScheduleFiberRoot == "function")
        try {
          ea.onScheduleFiberRoot(Bl, l, c);
        } catch (y) {
          Ts || (Ts = !0, d("React instrumentation encountered an error: %s", y));
        }
    }
    function kn(l, c) {
      if (ea && typeof ea.onCommitFiberRoot == "function")
        try {
          var y = (l.current.flags & lt) === lt;
          if (P) {
            var x;
            switch (c) {
              case Qo:
                x = Ic;
                break;
              case Zu:
                x = gf;
                break;
              case Qu:
                x = rl;
                break;
              case Ep:
                x = Ju;
                break;
              default:
                x = rl;
                break;
            }
            ea.onCommitFiberRoot(Bl, l, x, y);
          }
        } catch (T) {
          Ts || (Ts = !0, d("React instrumentation encountered an error: %s", T));
        }
    }
    function Ci(l) {
      if (ea && typeof ea.onPostCommitFiberRoot == "function")
        try {
          ea.onPostCommitFiberRoot(Bl, l);
        } catch (c) {
          Ts || (Ts = !0, d("React instrumentation encountered an error: %s", c));
        }
    }
    function wi(l) {
      if (ea && typeof ea.onCommitFiberUnmount == "function")
        try {
          ea.onCommitFiberUnmount(Bl, l);
        } catch (c) {
          Ts || (Ts = !0, d("React instrumentation encountered an error: %s", c));
        }
    }
    function ar(l) {
      if (typeof nv == "function" && (rv(l), s(l)), ea && typeof ea.setStrictMode == "function")
        try {
          ea.setStrictMode(Bl, l);
        } catch (c) {
          Ts || (Ts = !0, d("React instrumentation encountered an error: %s", c));
        }
    }
    function no(l) {
      Gt = l;
    }
    function ed() {
      {
        for (var l = /* @__PURE__ */ new Map(), c = 1, y = 0; y < uf; y++) {
          var x = yC(c);
          l.set(c, x), c *= 2;
        }
        return l;
      }
    }
    function Fi(l) {
      Gt !== null && typeof Gt.markCommitStarted == "function" && Gt.markCommitStarted(l);
    }
    function td() {
      Gt !== null && typeof Gt.markCommitStopped == "function" && Gt.markCommitStopped();
    }
    function Rs(l) {
      Gt !== null && typeof Gt.markComponentRenderStarted == "function" && Gt.markComponentRenderStarted(l);
    }
    function il() {
      Gt !== null && typeof Gt.markComponentRenderStopped == "function" && Gt.markComponentRenderStopped();
    }
    function av(l) {
      Gt !== null && typeof Gt.markComponentPassiveEffectMountStarted == "function" && Gt.markComponentPassiveEffectMountStarted(l);
    }
    function vf() {
      Gt !== null && typeof Gt.markComponentPassiveEffectMountStopped == "function" && Gt.markComponentPassiveEffectMountStopped();
    }
    function La(l) {
      Gt !== null && typeof Gt.markComponentPassiveEffectUnmountStarted == "function" && Gt.markComponentPassiveEffectUnmountStarted(l);
    }
    function ov() {
      Gt !== null && typeof Gt.markComponentPassiveEffectUnmountStopped == "function" && Gt.markComponentPassiveEffectUnmountStopped();
    }
    function sv(l) {
      Gt !== null && typeof Gt.markComponentLayoutEffectMountStarted == "function" && Gt.markComponentLayoutEffectMountStarted(l);
    }
    function nd() {
      Gt !== null && typeof Gt.markComponentLayoutEffectMountStopped == "function" && Gt.markComponentLayoutEffectMountStopped();
    }
    function yf(l) {
      Gt !== null && typeof Gt.markComponentLayoutEffectUnmountStarted == "function" && Gt.markComponentLayoutEffectUnmountStarted(l);
    }
    function Mp() {
      Gt !== null && typeof Gt.markComponentLayoutEffectUnmountStopped == "function" && Gt.markComponentLayoutEffectUnmountStopped();
    }
    function Hl(l, c, y) {
      Gt !== null && typeof Gt.markComponentErrored == "function" && Gt.markComponentErrored(l, c, y);
    }
    function Tp(l, c, y) {
      Gt !== null && typeof Gt.markComponentSuspended == "function" && Gt.markComponentSuspended(l, c, y);
    }
    function Vl(l) {
      Gt !== null && typeof Gt.markLayoutEffectsStarted == "function" && Gt.markLayoutEffectsStarted(l);
    }
    function Rp() {
      Gt !== null && typeof Gt.markLayoutEffectsStopped == "function" && Gt.markLayoutEffectsStopped();
    }
    function bf(l) {
      Gt !== null && typeof Gt.markPassiveEffectsStarted == "function" && Gt.markPassiveEffectsStarted(l);
    }
    function lv() {
      Gt !== null && typeof Gt.markPassiveEffectsStopped == "function" && Gt.markPassiveEffectsStopped();
    }
    function Sf(l) {
      Gt !== null && typeof Gt.markRenderStarted == "function" && Gt.markRenderStarted(l);
    }
    function Ap() {
      Gt !== null && typeof Gt.markRenderYielded == "function" && Gt.markRenderYielded();
    }
    function ma() {
      Gt !== null && typeof Gt.markRenderStopped == "function" && Gt.markRenderStopped();
    }
    function kl(l) {
      Gt !== null && typeof Gt.markRenderScheduled == "function" && Gt.markRenderScheduled(l);
    }
    function Ro(l, c) {
      Gt !== null && typeof Gt.markForceUpdateScheduled == "function" && Gt.markForceUpdateScheduled(l, c);
    }
    function rd(l, c) {
      Gt !== null && typeof Gt.markStateUpdateScheduled == "function" && Gt.markStateUpdateScheduled(l, c);
    }
    function Fa(l, c) {
      return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
    }
    var ro = typeof Object.is == "function" ? Object.is : Fa, Jo = null, _f = !1, cv = !1;
    function al(l) {
      Jo === null ? Jo = [l] : Jo.push(l);
    }
    function sb(l) {
      _f = !0, al(l);
    }
    function uv() {
      _f && Ao();
    }
    function Ao() {
      if (!cv && Jo !== null) {
        cv = !0;
        var l = 0, c = to();
        try {
          var y = !0, x = Jo;
          for (Li(Qo); l < x.length; l++) {
            var T = x[l];
            do
              T = T(y);
            while (T !== null);
          }
          Jo = null, _f = !1;
        } catch (F) {
          throw Jo !== null && (Jo = Jo.slice(l + 1)), tv(Ic, Ao), F;
        } finally {
          Li(c), cv = !1;
        }
      }
      return null;
    }
    function $l(l) {
      var c = l.current.memoizedState;
      return c.isDehydrated;
    }
    var lb = a.ReactCurrentBatchConfig, cb = null;
    function dv() {
      return lb.transition;
    }
    function Nc(l, c) {
      if (ro(l, c))
        return !0;
      if (typeof l != "object" || l === null || typeof c != "object" || c === null)
        return !1;
      var y = Object.keys(l), x = Object.keys(c);
      if (y.length !== x.length)
        return !1;
      for (var T = 0; T < y.length; T++) {
        var F = y[T];
        if (!qo.call(c, F) || !ro(l[F], c[F]))
          return !1;
      }
      return !0;
    }
    function SC(l) {
      switch (l._debugOwner && l._debugOwner.type, l._debugSource, l.tag) {
        case j:
          return Xo(l.type);
        case ce:
          return Xo("Lazy");
        case V:
          return Xo("Suspense");
        case he:
          return Xo("SuspenseList");
        case I:
        case L:
        case ne:
          return Ia(l.type);
        case B:
          return Ia(l.type.render);
        case U:
          return af(l.type);
        default:
          return "";
      }
    }
    function ub(l) {
      try {
        var c = "", y = l;
        do
          c += SC(y), y = y.return;
        while (y);
        return c;
      } catch (x) {
        return `
Error generating stack: ` + x.message + `
` + x.stack;
      }
    }
    var fv = a.ReactDebugCurrentFrame, io = null, es = !1;
    function _C() {
      {
        if (io === null)
          return null;
        var l = io._debugOwner;
        if (l !== null && typeof l < "u")
          return ue(l);
      }
      return null;
    }
    function Lc() {
      return io === null ? "" : ub(io);
    }
    function ta() {
      fv.getCurrentStack = null, io = null, es = !1;
    }
    function dr(l) {
      fv.getCurrentStack = Lc, io = l, es = !1;
    }
    function As(l) {
      es = l;
    }
    var Oo = {
      recordUnsafeLifecycleWarnings: function(l, c) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(l, c) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var xC = function(l) {
        for (var c = null, y = l; y !== null; )
          y.mode & di && (c = y), y = y.return;
        return c;
      }, Fc = function(l) {
        var c = [];
        return l.forEach(function(y) {
          c.push(y);
        }), c.sort().join(", ");
      }, id = [], ad = [], xf = [], ga = [], Uc = [], Ef = [], Ua = /* @__PURE__ */ new Set();
      Oo.recordUnsafeLifecycleWarnings = function(l, c) {
        Ua.has(l.type) || (typeof c.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        c.componentWillMount.__suppressDeprecationWarning !== !0 && id.push(l), l.mode & di && typeof c.UNSAFE_componentWillMount == "function" && ad.push(l), typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && xf.push(l), l.mode & di && typeof c.UNSAFE_componentWillReceiveProps == "function" && ga.push(l), typeof c.componentWillUpdate == "function" && c.componentWillUpdate.__suppressDeprecationWarning !== !0 && Uc.push(l), l.mode & di && typeof c.UNSAFE_componentWillUpdate == "function" && Ef.push(l));
      }, Oo.flushPendingUnsafeLifecycleWarnings = function() {
        var l = /* @__PURE__ */ new Set();
        id.length > 0 && (id.forEach(function(at) {
          l.add(ue(at) || "Component"), Ua.add(at.type);
        }), id = []);
        var c = /* @__PURE__ */ new Set();
        ad.length > 0 && (ad.forEach(function(at) {
          c.add(ue(at) || "Component"), Ua.add(at.type);
        }), ad = []);
        var y = /* @__PURE__ */ new Set();
        xf.length > 0 && (xf.forEach(function(at) {
          y.add(ue(at) || "Component"), Ua.add(at.type);
        }), xf = []);
        var x = /* @__PURE__ */ new Set();
        ga.length > 0 && (ga.forEach(function(at) {
          x.add(ue(at) || "Component"), Ua.add(at.type);
        }), ga = []);
        var T = /* @__PURE__ */ new Set();
        Uc.length > 0 && (Uc.forEach(function(at) {
          T.add(ue(at) || "Component"), Ua.add(at.type);
        }), Uc = []);
        var F = /* @__PURE__ */ new Set();
        if (Ef.length > 0 && (Ef.forEach(function(at) {
          F.add(ue(at) || "Component"), Ua.add(at.type);
        }), Ef = []), c.size > 0) {
          var k = Fc(c);
          d(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, k);
        }
        if (x.size > 0) {
          var J = Fc(x);
          d(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, J);
        }
        if (F.size > 0) {
          var re = Fc(F);
          d(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, re);
        }
        if (l.size > 0) {
          var me = Fc(l);
          u(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, me);
        }
        if (y.size > 0) {
          var we = Fc(y);
          u(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, we);
        }
        if (T.size > 0) {
          var qe = Fc(T);
          u(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, qe);
        }
      };
      var zc = /* @__PURE__ */ new Map(), Wl = /* @__PURE__ */ new Set();
      Oo.recordLegacyContextWarning = function(l, c) {
        var y = xC(l);
        if (y === null) {
          d("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Wl.has(l.type)) {
          var x = zc.get(y);
          (l.type.contextTypes != null || l.type.childContextTypes != null || c !== null && typeof c.getChildContext == "function") && (x === void 0 && (x = [], zc.set(y, x)), x.push(l));
        }
      }, Oo.flushLegacyContextWarning = function() {
        zc.forEach(function(l, c) {
          if (l.length !== 0) {
            var y = l[0], x = /* @__PURE__ */ new Set();
            l.forEach(function(F) {
              x.add(ue(F) || "Component"), Wl.add(F.type);
            });
            var T = Fc(x);
            try {
              dr(y), d(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, T);
            } finally {
              ta();
            }
          }
        });
      }, Oo.discardPendingWarnings = function() {
        id = [], ad = [], xf = [], ga = [], Uc = [], Ef = [], zc = /* @__PURE__ */ new Map();
      };
    }
    function Cf(l) {
      {
        var c = typeof Symbol == "function" && Symbol.toStringTag, y = c && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return y;
      }
    }
    function Op(l) {
      try {
        return wf(l), !1;
      } catch {
        return !0;
      }
    }
    function wf(l) {
      return "" + l;
    }
    function EC(l) {
      if (Op(l))
        return d("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Cf(l)), wf(l);
    }
    function db(l, c) {
      if (Op(l))
        return d("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", c, Cf(l)), wf(l);
    }
    function Po(l, c) {
      if (l && l.defaultProps) {
        var y = p({}, c), x = l.defaultProps;
        for (var T in x)
          y[T] === void 0 && (y[T] = x[T]);
        return y;
      }
      return c;
    }
    var Mf = _s(null), od;
    od = {};
    var sd = null, ld = null, hv = null, h = !1;
    function m() {
      sd = null, ld = null, hv = null, h = !1;
    }
    function M() {
      h = !0;
    }
    function A() {
      h = !1;
    }
    function z(l, c, y) {
      yo ? (Tr(Mf, c._currentValue, l), c._currentValue = y, c._currentRenderer !== void 0 && c._currentRenderer !== null && c._currentRenderer !== od && d("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer = od) : (Tr(Mf, c._currentValue2, l), c._currentValue2 = y, c._currentRenderer2 !== void 0 && c._currentRenderer2 !== null && c._currentRenderer2 !== od && d("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer2 = od);
    }
    function W(l, c) {
      var y = Mf.current;
      Di(Mf, c), yo ? l._currentValue = y : l._currentValue2 = y;
    }
    function fe(l, c, y) {
      for (var x = l; x !== null; ) {
        var T = x.alternate;
        if (Yu(x.childLanes, c) ? T !== null && !Yu(T.childLanes, c) && (T.childLanes = Ln(T.childLanes, c)) : (x.childLanes = Ln(x.childLanes, c), T !== null && (T.childLanes = Ln(T.childLanes, c))), x === y)
          break;
        x = x.return;
      }
      x !== y && d("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Le(l, c, y) {
      ct(l, c, y);
    }
    function ct(l, c, y) {
      var x = l.child;
      for (x !== null && (x.return = l); x !== null; ) {
        var T = void 0, F = x.dependencies;
        if (F !== null) {
          T = x.child;
          for (var k = F.firstContext; k !== null; ) {
            if (k.context === c) {
              if (x.tag === U) {
                var J = qu(y), re = xn(Vr, J);
                re.tag = xa;
                var me = x.updateQueue;
                if (me !== null) {
                  var we = me.shared, qe = we.pending;
                  qe === null ? re.next = re : (re.next = qe.next, qe.next = re), we.pending = re;
                }
              }
              x.lanes = Ln(x.lanes, y);
              var at = x.alternate;
              at !== null && (at.lanes = Ln(at.lanes, y)), fe(x.return, y, l), F.lanes = Ln(F.lanes, y);
              break;
            }
            k = k.next;
          }
        } else if (x.tag === K)
          T = x.type === l.type ? null : x.child;
        else if (x.tag === oe) {
          var dt = x.return;
          if (dt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          dt.lanes = Ln(dt.lanes, y);
          var At = dt.alternate;
          At !== null && (At.lanes = Ln(At.lanes, y)), fe(dt, y, l), T = x.sibling;
        } else
          T = x.child;
        if (T !== null)
          T.return = x;
        else
          for (T = x; T !== null; ) {
            if (T === l) {
              T = null;
              break;
            }
            var Dt = T.sibling;
            if (Dt !== null) {
              Dt.return = T.return, T = Dt;
              break;
            }
            T = T.return;
          }
        x = T;
      }
    }
    function Ot(l, c) {
      sd = l, ld = null, hv = null;
      var y = l.dependencies;
      if (y !== null) {
        var x = y.firstContext;
        x !== null && (fi(y.lanes, c) && qb(), y.firstContext = null);
      }
    }
    function Vt(l) {
      h && d("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var c = yo ? l._currentValue : l._currentValue2;
      if (hv !== l) {
        var y = {
          context: l,
          memoizedValue: c,
          next: null
        };
        if (ld === null) {
          if (sd === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          ld = y, sd.dependencies = {
            lanes: wt,
            firstContext: y
          };
        } else
          ld = ld.next = y;
      }
      return c;
    }
    var Cn = null;
    function _n(l) {
      Cn === null ? Cn = [l] : Cn.push(l);
    }
    function zr() {
      if (Cn !== null) {
        for (var l = 0; l < Cn.length; l++) {
          var c = Cn[l], y = c.interleaved;
          if (y !== null) {
            c.interleaved = null;
            var x = y.next, T = c.pending;
            if (T !== null) {
              var F = T.next;
              T.next = x, y.next = F;
            }
            c.pending = y;
          }
        }
        Cn = null;
      }
    }
    var pn = 0, na = 1, xa = 2, Qe = 3, ze = !1, rt, Xt;
    rt = !1, Xt = null;
    function dn(l) {
      var c = {
        baseState: l.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: wt
        },
        effects: null
      };
      l.updateQueue = c;
    }
    function Fn(l, c) {
      var y = c.updateQueue, x = l.updateQueue;
      if (y === x) {
        var T = {
          baseState: x.baseState,
          firstBaseUpdate: x.firstBaseUpdate,
          lastBaseUpdate: x.lastBaseUpdate,
          shared: x.shared,
          effects: x.effects
        };
        c.updateQueue = T;
      }
    }
    function xn(l, c) {
      var y = {
        eventTime: l,
        lane: c,
        tag: pn,
        payload: null,
        callback: null,
        next: null
      };
      return y;
    }
    function $n(l, c, y) {
      var x = l.updateQueue;
      if (x !== null) {
        var T = x.shared;
        if (wI(l)) {
          var F = T.interleaved;
          F === null ? (c.next = c, _n(T)) : (c.next = F.next, F.next = c), T.interleaved = c;
        } else {
          var k = T.pending;
          k === null ? c.next = c : (c.next = k.next, k.next = c), T.pending = c;
        }
        Xt === T && !rt && (d("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), rt = !0);
      }
    }
    function mi(l, c, y) {
      var x = c.updateQueue;
      if (x !== null) {
        var T = x.shared;
        if (_p(y)) {
          var F = T.lanes;
          F = zl(F, l.pendingLanes);
          var k = Ln(F, y);
          T.lanes = k, Pc(l, k);
        }
      }
    }
    function or(l, c) {
      var y = l.updateQueue, x = l.alternate;
      if (x !== null) {
        var T = x.updateQueue;
        if (y === T) {
          var F = null, k = null, J = y.firstBaseUpdate;
          if (J !== null) {
            var re = J;
            do {
              var me = {
                eventTime: re.eventTime,
                lane: re.lane,
                tag: re.tag,
                payload: re.payload,
                callback: re.callback,
                next: null
              };
              k === null ? F = k = me : (k.next = me, k = me), re = re.next;
            } while (re !== null);
            k === null ? F = k = c : (k.next = c, k = c);
          } else
            F = k = c;
          y = {
            baseState: T.baseState,
            firstBaseUpdate: F,
            lastBaseUpdate: k,
            shared: T.shared,
            effects: T.effects
          }, l.updateQueue = y;
          return;
        }
      }
      var we = y.lastBaseUpdate;
      we === null ? y.firstBaseUpdate = c : we.next = c, y.lastBaseUpdate = c;
    }
    function jl(l, c, y, x, T, F) {
      switch (y.tag) {
        case na: {
          var k = y.payload;
          if (typeof k == "function") {
            M();
            var J = k.call(F, x, T);
            {
              if (l.mode & di) {
                ar(!0);
                try {
                  k.call(F, x, T);
                } finally {
                  ar(!1);
                }
              }
              A();
            }
            return J;
          }
          return k;
        }
        case Qe:
          l.flags = l.flags & ~it | lt;
        case pn: {
          var re = y.payload, me;
          if (typeof re == "function") {
            M(), me = re.call(F, x, T);
            {
              if (l.mode & di) {
                ar(!0);
                try {
                  re.call(F, x, T);
                } finally {
                  ar(!1);
                }
              }
              A();
            }
          } else
            me = re;
          return me == null ? x : p({}, x, me);
        }
        case xa:
          return ze = !0, x;
      }
      return x;
    }
    function Pp(l, c, y, x) {
      var T = l.updateQueue;
      ze = !1, Xt = T.shared;
      var F = T.firstBaseUpdate, k = T.lastBaseUpdate, J = T.shared.pending;
      if (J !== null) {
        T.shared.pending = null;
        var re = J, me = re.next;
        re.next = null, k === null ? F = me : k.next = me, k = re;
        var we = l.alternate;
        if (we !== null) {
          var qe = we.updateQueue, at = qe.lastBaseUpdate;
          at !== k && (at === null ? qe.firstBaseUpdate = me : at.next = me, qe.lastBaseUpdate = re);
        }
      }
      if (F !== null) {
        var dt = T.baseState, At = wt, Dt = null, yn = null, Un = null, En = F;
        do {
          var ii = En.lane, ai = En.eventTime;
          if (Yu(x, ii)) {
            if (Un !== null) {
              var mt = {
                eventTime: ai,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Ni,
                tag: En.tag,
                payload: En.payload,
                callback: En.callback,
                next: null
              };
              Un = Un.next = mt;
            }
            dt = jl(l, T, En, dt, c, y);
            var Ke = En.callback;
            if (Ke !== null && // If the update was already committed, we should not queue its
            // callback again.
            En.lane !== Ni) {
              l.flags |= Wt;
              var Ut = T.effects;
              Ut === null ? T.effects = [En] : Ut.push(En);
            }
          } else {
            var Je = {
              eventTime: ai,
              lane: ii,
              tag: En.tag,
              payload: En.payload,
              callback: En.callback,
              next: null
            };
            Un === null ? (yn = Un = Je, Dt = dt) : Un = Un.next = Je, At = Ln(At, ii);
          }
          if (En = En.next, En === null) {
            if (J = T.shared.pending, J === null)
              break;
            var mn = J, rn = mn.next;
            mn.next = null, En = rn, T.lastBaseUpdate = mn, T.shared.pending = null;
          }
        } while (!0);
        Un === null && (Dt = dt), T.baseState = Dt, T.firstBaseUpdate = yn, T.lastBaseUpdate = Un;
        var nr = T.shared.interleaved;
        if (nr !== null) {
          var xr = nr;
          do
            At = Ln(At, xr.lane), xr = xr.next;
          while (xr !== nr);
        } else F === null && (T.shared.lanes = wt);
        vS(At), l.lanes = At, l.memoizedState = dt;
      }
      Xt = null;
    }
    function t5(l, c) {
      if (typeof l != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + l));
      l.call(c);
    }
    function wP() {
      ze = !1;
    }
    function fb() {
      return ze;
    }
    function MP(l, c, y) {
      var x = c.effects;
      if (c.effects = null, x !== null)
        for (var T = 0; T < x.length; T++) {
          var F = x[T], k = F.callback;
          k !== null && (F.callback = null, t5(k, y));
        }
    }
    var CC = {}, TP = new r.Component().refs, wC, MC, TC, RC, AC, RP, hb, OC, PC, DC;
    {
      wC = /* @__PURE__ */ new Set(), MC = /* @__PURE__ */ new Set(), TC = /* @__PURE__ */ new Set(), RC = /* @__PURE__ */ new Set(), OC = /* @__PURE__ */ new Set(), AC = /* @__PURE__ */ new Set(), PC = /* @__PURE__ */ new Set(), DC = /* @__PURE__ */ new Set();
      var AP = /* @__PURE__ */ new Set();
      hb = function(l, c) {
        if (!(l === null || typeof l == "function")) {
          var y = c + "_" + l;
          AP.has(y) || (AP.add(y), d("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", c, l));
        }
      }, RP = function(l, c) {
        if (c === void 0) {
          var y = st(l) || "Component";
          AC.has(y) || (AC.add(y), d("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", y));
        }
      }, Object.defineProperty(CC, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(CC);
    }
    function IC(l, c, y, x) {
      var T = l.memoizedState, F = y(x, T);
      {
        if (l.mode & di) {
          ar(!0);
          try {
            F = y(x, T);
          } finally {
            ar(!1);
          }
        }
        RP(c, F);
      }
      var k = F == null ? T : p({}, T, F);
      if (l.memoizedState = k, l.lanes === wt) {
        var J = l.updateQueue;
        J.baseState = k;
      }
    }
    var NC = {
      isMounted: Rn,
      enqueueSetState: function(l, c, y) {
        var x = g(l), T = oo(), F = gd(x), k = xn(T, F);
        k.payload = c, y != null && (hb(y, "setState"), k.callback = y), $n(x, k);
        var J = oa(x, F, T);
        J !== null && mi(J, x, F), rd(x, F);
      },
      enqueueReplaceState: function(l, c, y) {
        var x = g(l), T = oo(), F = gd(x), k = xn(T, F);
        k.tag = na, k.payload = c, y != null && (hb(y, "replaceState"), k.callback = y), $n(x, k);
        var J = oa(x, F, T);
        J !== null && mi(J, x, F), rd(x, F);
      },
      enqueueForceUpdate: function(l, c) {
        var y = g(l), x = oo(), T = gd(y), F = xn(x, T);
        F.tag = xa, c != null && (hb(c, "forceUpdate"), F.callback = c), $n(y, F);
        var k = oa(y, T, x);
        k !== null && mi(k, y, T), Ro(y, T);
      }
    };
    function OP(l, c, y, x, T, F, k) {
      var J = l.stateNode;
      if (typeof J.shouldComponentUpdate == "function") {
        var re = J.shouldComponentUpdate(x, F, k);
        {
          if (l.mode & di) {
            ar(!0);
            try {
              re = J.shouldComponentUpdate(x, F, k);
            } finally {
              ar(!1);
            }
          }
          re === void 0 && d("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", st(c) || "Component");
        }
        return re;
      }
      return c.prototype && c.prototype.isPureReactComponent ? !Nc(y, x) || !Nc(T, F) : !0;
    }
    function n5(l, c, y) {
      var x = l.stateNode;
      {
        var T = st(c) || "Component", F = x.render;
        F || (c.prototype && typeof c.prototype.render == "function" ? d("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", T) : d("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", T)), x.getInitialState && !x.getInitialState.isReactClassApproved && !x.state && d("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", T), x.getDefaultProps && !x.getDefaultProps.isReactClassApproved && d("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", T), x.propTypes && d("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", T), x.contextType && d("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", T), x.contextTypes && d("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", T), c.contextType && c.contextTypes && !PC.has(c) && (PC.add(c), d("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", T)), typeof x.componentShouldUpdate == "function" && d("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", T), c.prototype && c.prototype.isPureReactComponent && typeof x.shouldComponentUpdate < "u" && d("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", st(c) || "A pure component"), typeof x.componentDidUnmount == "function" && d("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", T), typeof x.componentDidReceiveProps == "function" && d("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", T), typeof x.componentWillRecieveProps == "function" && d("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", T), typeof x.UNSAFE_componentWillRecieveProps == "function" && d("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", T);
        var k = x.props !== y;
        x.props !== void 0 && k && d("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", T, T), x.defaultProps && d("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", T, T), typeof x.getSnapshotBeforeUpdate == "function" && typeof x.componentDidUpdate != "function" && !TC.has(c) && (TC.add(c), d("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", st(c))), typeof x.getDerivedStateFromProps == "function" && d("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", T), typeof x.getDerivedStateFromError == "function" && d("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", T), typeof c.getSnapshotBeforeUpdate == "function" && d("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", T);
        var J = x.state;
        J && (typeof J != "object" || Tn(J)) && d("%s.state: must be set to an object or null", T), typeof x.getChildContext == "function" && typeof c.childContextTypes != "object" && d("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", T);
      }
    }
    function PP(l, c) {
      c.updater = NC, l.stateNode = c, v(c, l), c._reactInternalInstance = CC;
    }
    function DP(l, c, y) {
      var x = !1, T = ir, F = ir, k = c.contextType;
      if ("contextType" in c) {
        var J = (
          // Allow null for conditional declaration
          k === null || k !== void 0 && k.$$typeof === Xe && k._context === void 0
        );
        if (!J && !DC.has(c)) {
          DC.add(c);
          var re = "";
          k === void 0 ? re = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof k != "object" ? re = " However, it is set to a " + typeof k + "." : k.$$typeof === et ? re = " Did you accidentally pass the Context.Provider instead?" : k._context !== void 0 ? re = " Did you accidentally pass the Context.Consumer instead?" : re = " However, it is set to an object with keys {" + Object.keys(k).join(", ") + "}.", d("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", st(c) || "Component", re);
        }
      }
      if (typeof k == "object" && k !== null)
        F = Vt(k);
      else {
        T = xs(l, c, !0);
        var me = c.contextTypes;
        x = me != null, F = x ? zu(l, T) : ir;
      }
      var we = new c(y, F);
      if (l.mode & di) {
        ar(!0);
        try {
          we = new c(y, F);
        } finally {
          ar(!1);
        }
      }
      var qe = l.memoizedState = we.state !== null && we.state !== void 0 ? we.state : null;
      PP(l, we);
      {
        if (typeof c.getDerivedStateFromProps == "function" && qe === null) {
          var at = st(c) || "Component";
          MC.has(at) || (MC.add(at), d("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", at, we.state === null ? "null" : "undefined", at));
        }
        if (typeof c.getDerivedStateFromProps == "function" || typeof we.getSnapshotBeforeUpdate == "function") {
          var dt = null, At = null, Dt = null;
          if (typeof we.componentWillMount == "function" && we.componentWillMount.__suppressDeprecationWarning !== !0 ? dt = "componentWillMount" : typeof we.UNSAFE_componentWillMount == "function" && (dt = "UNSAFE_componentWillMount"), typeof we.componentWillReceiveProps == "function" && we.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? At = "componentWillReceiveProps" : typeof we.UNSAFE_componentWillReceiveProps == "function" && (At = "UNSAFE_componentWillReceiveProps"), typeof we.componentWillUpdate == "function" && we.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Dt = "componentWillUpdate" : typeof we.UNSAFE_componentWillUpdate == "function" && (Dt = "UNSAFE_componentWillUpdate"), dt !== null || At !== null || Dt !== null) {
            var yn = st(c) || "Component", Un = typeof c.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            RC.has(yn) || (RC.add(yn), d(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, yn, Un, dt !== null ? `
  ` + dt : "", At !== null ? `
  ` + At : "", Dt !== null ? `
  ` + Dt : ""));
          }
        }
      }
      return x && Uu(l, T, F), we;
    }
    function r5(l, c) {
      var y = c.state;
      typeof c.componentWillMount == "function" && c.componentWillMount(), typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount(), y !== c.state && (d("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", ue(l) || "Component"), NC.enqueueReplaceState(c, c.state, null));
    }
    function IP(l, c, y, x) {
      var T = c.state;
      if (typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(y, x), typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(y, x), c.state !== T) {
        {
          var F = ue(l) || "Component";
          wC.has(F) || (wC.add(F), d("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", F));
        }
        NC.enqueueReplaceState(c, c.state, null);
      }
    }
    function LC(l, c, y, x) {
      n5(l, c, y);
      var T = l.stateNode;
      T.props = y, T.state = l.memoizedState, T.refs = TP, dn(l);
      var F = c.contextType;
      if (typeof F == "object" && F !== null)
        T.context = Vt(F);
      else {
        var k = xs(l, c, !0);
        T.context = zu(l, k);
      }
      {
        if (T.state === y) {
          var J = st(c) || "Component";
          OC.has(J) || (OC.add(J), d("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", J));
        }
        l.mode & di && Oo.recordLegacyContextWarning(l, T), Oo.recordUnsafeLifecycleWarnings(l, T);
      }
      T.state = l.memoizedState;
      var re = c.getDerivedStateFromProps;
      if (typeof re == "function" && (IC(l, c, re, y), T.state = l.memoizedState), typeof c.getDerivedStateFromProps != "function" && typeof T.getSnapshotBeforeUpdate != "function" && (typeof T.UNSAFE_componentWillMount == "function" || typeof T.componentWillMount == "function") && (r5(l, T), Pp(l, y, T, x), T.state = l.memoizedState), typeof T.componentDidMount == "function") {
        var me = He;
        me |= ee, (l.mode & Mo) !== An && (me |= Ae), l.flags |= me;
      }
    }
    function i5(l, c, y, x) {
      var T = l.stateNode, F = l.memoizedProps;
      T.props = F;
      var k = T.context, J = c.contextType, re = ir;
      if (typeof J == "object" && J !== null)
        re = Vt(J);
      else {
        var me = xs(l, c, !0);
        re = zu(l, me);
      }
      var we = c.getDerivedStateFromProps, qe = typeof we == "function" || typeof T.getSnapshotBeforeUpdate == "function";
      !qe && (typeof T.UNSAFE_componentWillReceiveProps == "function" || typeof T.componentWillReceiveProps == "function") && (F !== y || k !== re) && IP(l, T, y, re), wP();
      var at = l.memoizedState, dt = T.state = at;
      if (Pp(l, y, T, x), dt = l.memoizedState, F === y && at === dt && !Ii() && !fb()) {
        if (typeof T.componentDidMount == "function") {
          var At = He;
          At |= ee, (l.mode & Mo) !== An && (At |= Ae), l.flags |= At;
        }
        return !1;
      }
      typeof we == "function" && (IC(l, c, we, y), dt = l.memoizedState);
      var Dt = fb() || OP(l, c, F, y, at, dt, re);
      if (Dt) {
        if (!qe && (typeof T.UNSAFE_componentWillMount == "function" || typeof T.componentWillMount == "function") && (typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount()), typeof T.componentDidMount == "function") {
          var yn = He;
          yn |= ee, (l.mode & Mo) !== An && (yn |= Ae), l.flags |= yn;
        }
      } else {
        if (typeof T.componentDidMount == "function") {
          var Un = He;
          Un |= ee, (l.mode & Mo) !== An && (Un |= Ae), l.flags |= Un;
        }
        l.memoizedProps = y, l.memoizedState = dt;
      }
      return T.props = y, T.state = dt, T.context = re, Dt;
    }
    function a5(l, c, y, x, T) {
      var F = c.stateNode;
      Fn(l, c);
      var k = c.memoizedProps, J = c.type === c.elementType ? k : Po(c.type, k);
      F.props = J;
      var re = c.pendingProps, me = F.context, we = y.contextType, qe = ir;
      if (typeof we == "object" && we !== null)
        qe = Vt(we);
      else {
        var at = xs(c, y, !0);
        qe = zu(c, at);
      }
      var dt = y.getDerivedStateFromProps, At = typeof dt == "function" || typeof F.getSnapshotBeforeUpdate == "function";
      !At && (typeof F.UNSAFE_componentWillReceiveProps == "function" || typeof F.componentWillReceiveProps == "function") && (k !== re || me !== qe) && IP(c, F, x, qe), wP();
      var Dt = c.memoizedState, yn = F.state = Dt;
      if (Pp(c, x, F, T), yn = c.memoizedState, k === re && Dt === yn && !Ii() && !fb() && !S)
        return typeof F.componentDidUpdate == "function" && (k !== l.memoizedProps || Dt !== l.memoizedState) && (c.flags |= He), typeof F.getSnapshotBeforeUpdate == "function" && (k !== l.memoizedProps || Dt !== l.memoizedState) && (c.flags |= Nn), !1;
      typeof dt == "function" && (IC(c, y, dt, x), yn = c.memoizedState);
      var Un = fb() || OP(c, y, J, x, Dt, yn, qe) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      S;
      return Un ? (!At && (typeof F.UNSAFE_componentWillUpdate == "function" || typeof F.componentWillUpdate == "function") && (typeof F.componentWillUpdate == "function" && F.componentWillUpdate(x, yn, qe), typeof F.UNSAFE_componentWillUpdate == "function" && F.UNSAFE_componentWillUpdate(x, yn, qe)), typeof F.componentDidUpdate == "function" && (c.flags |= He), typeof F.getSnapshotBeforeUpdate == "function" && (c.flags |= Nn)) : (typeof F.componentDidUpdate == "function" && (k !== l.memoizedProps || Dt !== l.memoizedState) && (c.flags |= He), typeof F.getSnapshotBeforeUpdate == "function" && (k !== l.memoizedProps || Dt !== l.memoizedState) && (c.flags |= Nn), c.memoizedProps = x, c.memoizedState = yn), F.props = x, F.state = yn, F.context = qe, Un;
    }
    var Dp = [], Ip = 0, pb = null, mb = 0, Os = [], Ps = 0, Tf = null, Bc = 1, Hc = "";
    function o5(l) {
      return Af(), (l.flags & Kt) !== De;
    }
    function s5(l) {
      return Af(), mb;
    }
    function l5() {
      var l = Hc, c = Bc, y = c & ~c5(c);
      return y.toString(32) + l;
    }
    function Rf(l, c) {
      Af(), Dp[Ip++] = mb, Dp[Ip++] = pb, pb = l, mb = c;
    }
    function NP(l, c, y) {
      Af(), Os[Ps++] = Bc, Os[Ps++] = Hc, Os[Ps++] = Tf, Tf = l;
      var x = Bc, T = Hc, F = gb(x) - 1, k = x & ~(1 << F), J = y + 1, re = gb(c) + F;
      if (re > 30) {
        var me = F - F % 5, we = (1 << me) - 1, qe = (k & we).toString(32), at = k >> me, dt = F - me, At = gb(c) + dt, Dt = J << dt, yn = Dt | at, Un = qe + T;
        Bc = 1 << At | yn, Hc = Un;
      } else {
        var En = J << F, ii = En | k, ai = T;
        Bc = 1 << re | ii, Hc = ai;
      }
    }
    function FC(l) {
      Af();
      var c = l.return;
      if (c !== null) {
        var y = 1, x = 0;
        Rf(l, y), NP(l, y, x);
      }
    }
    function gb(l) {
      return 32 - Hu(l);
    }
    function c5(l) {
      return 1 << gb(l) - 1;
    }
    function UC(l) {
      for (; l === pb; )
        pb = Dp[--Ip], Dp[Ip] = null, mb = Dp[--Ip], Dp[Ip] = null;
      for (; l === Tf; )
        Tf = Os[--Ps], Os[Ps] = null, Hc = Os[--Ps], Os[Ps] = null, Bc = Os[--Ps], Os[Ps] = null;
    }
    function u5() {
      return Af(), Tf !== null ? {
        id: Bc,
        overflow: Hc
      } : null;
    }
    function d5(l, c) {
      Af(), Os[Ps++] = Bc, Os[Ps++] = Hc, Os[Ps++] = Tf, Bc = c.id, Hc = c.overflow, Tf = l;
    }
    function Af() {
      za() || d("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Ea = null, Ds = null, ol = !1, Of = !1, cd = null;
    function f5() {
      ol && d("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function h5() {
      Of = !0;
    }
    function p5(l) {
      if (!ri)
        return !1;
      var c = l.stateNode.containerInfo;
      return Ds = Nl(c), Ea = l, ol = !0, cd = null, Of = !1, !0;
    }
    function m5(l, c, y) {
      return ri ? (Ds = Kh(c), Ea = l, ol = !0, cd = null, Of = !1, y !== null && d5(l, y), !0) : !1;
    }
    function LP(l, c) {
      switch (l.tag) {
        case N:
          Du(l.stateNode.containerInfo, c);
          break;
        case j:
          tp(l.type, l.memoizedProps, l.stateNode, c);
          break;
        case V:
          var y = l.memoizedState;
          y.dehydrated !== null && ep(y.dehydrated, c);
          break;
      }
    }
    function FP(l, c) {
      LP(l, c);
      var y = g8();
      y.stateNode = c, y.return = l;
      var x = l.deletions;
      x === null ? (l.deletions = [y], l.flags |= vt) : x.push(y);
    }
    function zC(l, c) {
      {
        if (Of)
          return;
        switch (l.tag) {
          case N: {
            var y = l.stateNode.containerInfo;
            switch (c.tag) {
              case j:
                var x = c.type, T = c.pendingProps;
                xo(y, x, T);
                break;
              case G:
                var F = c.pendingProps;
                Eo(y, F);
                break;
              case V:
                yc(y);
                break;
            }
            break;
          }
          case j: {
            var k = l.type, J = l.memoizedProps, re = l.stateNode;
            switch (c.tag) {
              case j:
                var me = c.type, we = c.pendingProps;
                q0(k, J, re, me, we);
                break;
              case G:
                var qe = c.pendingProps;
                Lg(k, J, re, qe);
                break;
              case V:
                Fg(k, J, re);
                break;
            }
            break;
          }
          case V: {
            var at = l.memoizedState, dt = at.dehydrated;
            if (dt !== null) switch (c.tag) {
              case j:
                var At = c.type, Dt = c.pendingProps;
                Qs(dt, At, Dt);
                break;
              case G:
                var yn = c.pendingProps;
                Js(dt, yn);
                break;
              case V:
                bc(dt);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function UP(l, c) {
      c.flags = c.flags & ~Pt | We, zC(l, c);
    }
    function zP(l, c) {
      switch (l.tag) {
        case j: {
          var y = l.type, x = l.pendingProps, T = Dg(c, y, x);
          return T !== null ? (l.stateNode = T, Ea = l, Ds = Zs(T), !0) : !1;
        }
        case G: {
          var F = l.pendingProps, k = Ou(c, F);
          return k !== null ? (l.stateNode = k, Ea = l, Ds = null, !0) : !1;
        }
        case V: {
          {
            var J = _o(c);
            if (J !== null) {
              var re = {
                dehydrated: J,
                treeContext: u5(),
                retryLane: Rr
              };
              l.memoizedState = re;
              var me = v8(J);
              return me.return = l, l.child = me, Ea = l, Ds = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function BC(l) {
      return (l.mode & _r) !== An && (l.flags & lt) === De;
    }
    function HC(l) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function VC(l) {
      if (ol) {
        var c = Ds;
        if (!c) {
          BC(l) && (zC(Ea, l), HC()), UP(Ea, l), ol = !1, Ea = l;
          return;
        }
        var y = c;
        if (!zP(l, c)) {
          BC(l) && (zC(Ea, l), HC()), c = ef(y);
          var x = Ea;
          if (!c || !zP(l, c)) {
            UP(Ea, l), ol = !1, Ea = l;
            return;
          }
          FP(x, y);
        }
      }
    }
    function g5(l, c, y) {
      if (!ri)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var x = l.stateNode, T = !Of, F = k0(x, l.type, l.memoizedProps, c, y, l, T);
      return l.updateQueue = F, F !== null;
    }
    function v5(l) {
      if (!ri)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var c = l.stateNode, y = l.memoizedProps, x = !Of, T = Zh(c, y, l, x);
      if (T) {
        var F = Ea;
        if (F !== null) {
          var k = (F.mode & _r) !== An;
          switch (F.tag) {
            case N: {
              var J = F.stateNode.containerInfo;
              Ng(
                J,
                c,
                y,
                // TODO: Delete this argument when we remove the legacy root API.
                k
              );
              break;
            }
            case j: {
              var re = F.type, me = F.memoizedProps, we = F.stateNode;
              Pu(
                re,
                me,
                we,
                c,
                y,
                // TODO: Delete this argument when we remove the legacy root API.
                k
              );
              break;
            }
          }
        }
      }
      return T;
    }
    function y5(l) {
      if (!ri)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var c = l.memoizedState, y = c !== null ? c.dehydrated : null;
      if (!y)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      $0(y, l);
    }
    function b5(l) {
      if (!ri)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var c = l.memoizedState, y = c !== null ? c.dehydrated : null;
      if (!y)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return W0(y);
    }
    function BP(l) {
      for (var c = l.return; c !== null && c.tag !== j && c.tag !== N && c.tag !== V; )
        c = c.return;
      Ea = c;
    }
    function pv(l) {
      if (!ri || l !== Ea)
        return !1;
      if (!ol)
        return BP(l), ol = !0, !1;
      if (l.tag !== N && (l.tag !== j || X0(l.type) && !Oi(l.type, l.memoizedProps))) {
        var c = Ds;
        if (c)
          if (BC(l))
            HP(l), HC();
          else
            for (; c; )
              FP(l, c), c = ef(c);
      }
      return BP(l), l.tag === V ? Ds = b5(l) : Ds = Ea ? ef(l.stateNode) : null, !0;
    }
    function S5() {
      return ol && Ds !== null;
    }
    function HP(l) {
      for (var c = Ds; c; )
        LP(l, c), c = ef(c);
    }
    function Np() {
      ri && (Ea = null, Ds = null, ol = !1, Of = !1);
    }
    function VP() {
      cd !== null && (TI(cd), cd = null);
    }
    function za() {
      return ol;
    }
    function kC(l) {
      cd === null ? cd = [l] : cd.push(l);
    }
    var $C, WC, jC, GC, XC, kP = function(l, c) {
    };
    $C = !1, WC = !1, jC = {}, GC = {}, XC = {}, kP = function(l, c) {
      if (!(l === null || typeof l != "object") && !(!l._store || l._store.validated || l.key != null)) {
        if (typeof l._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        l._store.validated = !0;
        var y = ue(c) || "Component";
        GC[y] || (GC[y] = !0, d('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function mv(l, c, y) {
      var x = y.ref;
      if (x !== null && typeof x != "function" && typeof x != "object") {
        if ((l.mode & di || C) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(y._owner && y._self && y._owner.stateNode !== y._self)) {
          var T = ue(l) || "Component";
          jC[T] || (d('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', x), jC[T] = !0);
        }
        if (y._owner) {
          var F = y._owner, k;
          if (F) {
            var J = F;
            if (J.tag !== U)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            k = J.stateNode;
          }
          if (!k)
            throw new Error("Missing owner for string ref " + x + ". This error is likely caused by a bug in React. Please file an issue.");
          var re = k;
          db(x, "ref");
          var me = "" + x;
          if (c !== null && c.ref !== null && typeof c.ref == "function" && c.ref._stringRef === me)
            return c.ref;
          var we = function(qe) {
            var at = re.refs;
            at === TP && (at = re.refs = {}), qe === null ? delete at[me] : at[me] = qe;
          };
          return we._stringRef = me, we;
        } else {
          if (typeof x != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!y._owner)
            throw new Error("Element ref was specified as a string (" + x + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return x;
    }
    function vb(l, c) {
      var y = Object.prototype.toString.call(c);
      throw new Error("Objects are not valid as a React child (found: " + (y === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : y) + "). If you meant to render a collection of children, use an array instead.");
    }
    function yb(l) {
      {
        var c = ue(l) || "Component";
        if (XC[c])
          return;
        XC[c] = !0, d("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function $P(l) {
      var c = l._payload, y = l._init;
      return y(c);
    }
    function WP(l) {
      function c(Je, mt) {
        if (l) {
          var Ke = Je.deletions;
          Ke === null ? (Je.deletions = [mt], Je.flags |= vt) : Ke.push(mt);
        }
      }
      function y(Je, mt) {
        if (!l)
          return null;
        for (var Ke = mt; Ke !== null; )
          c(Je, Ke), Ke = Ke.sibling;
        return null;
      }
      function x(Je, mt) {
        for (var Ke = /* @__PURE__ */ new Map(), Ut = mt; Ut !== null; )
          Ut.key !== null ? Ke.set(Ut.key, Ut) : Ke.set(Ut.index, Ut), Ut = Ut.sibling;
        return Ke;
      }
      function T(Je, mt) {
        var Ke = Uf(Je, mt);
        return Ke.index = 0, Ke.sibling = null, Ke;
      }
      function F(Je, mt, Ke) {
        if (Je.index = Ke, !l)
          return Je.flags |= Kt, mt;
        var Ut = Je.alternate;
        if (Ut !== null) {
          var mn = Ut.index;
          return mn < mt ? (Je.flags |= We, mt) : mn;
        } else
          return Je.flags |= We, mt;
      }
      function k(Je) {
        return l && Je.alternate === null && (Je.flags |= We), Je;
      }
      function J(Je, mt, Ke, Ut) {
        if (mt === null || mt.tag !== G) {
          var mn = g1(Ke, Je.mode, Ut);
          return mn.return = Je, mn;
        } else {
          var rn = T(mt, Ke);
          return rn.return = Je, rn;
        }
      }
      function re(Je, mt, Ke, Ut) {
        var mn = Ke.type;
        if (mn === se)
          return we(Je, mt, Ke.props.children, Ut, Ke.key);
        if (mt !== null && (mt.elementType === mn || // Keep this check inline so it only runs on the false path:
        kI(mt, Ke) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof mn == "object" && mn !== null && mn.$$typeof === Oe && $P(mn) === mt.type)) {
          var rn = T(mt, Ke.props);
          return rn.ref = mv(Je, mt, Ke), rn.return = Je, rn._debugSource = Ke._source, rn._debugOwner = Ke._owner, rn;
        }
        var nr = m1(Ke, Je.mode, Ut);
        return nr.ref = mv(Je, mt, Ke), nr.return = Je, nr;
      }
      function me(Je, mt, Ke, Ut) {
        if (mt === null || mt.tag !== H || mt.stateNode.containerInfo !== Ke.containerInfo || mt.stateNode.implementation !== Ke.implementation) {
          var mn = v1(Ke, Je.mode, Ut);
          return mn.return = Je, mn;
        } else {
          var rn = T(mt, Ke.children || []);
          return rn.return = Je, rn;
        }
      }
      function we(Je, mt, Ke, Ut, mn) {
        if (mt === null || mt.tag !== X) {
          var rn = yd(Ke, Je.mode, Ut, mn);
          return rn.return = Je, rn;
        } else {
          var nr = T(mt, Ke);
          return nr.return = Je, nr;
        }
      }
      function qe(Je, mt, Ke) {
        if (typeof mt == "string" && mt !== "" || typeof mt == "number") {
          var Ut = g1("" + mt, Je.mode, Ke);
          return Ut.return = Je, Ut;
        }
        if (typeof mt == "object" && mt !== null) {
          switch (mt.$$typeof) {
            case $: {
              var mn = m1(mt, Je.mode, Ke);
              return mn.ref = mv(Je, null, mt), mn.return = Je, mn;
            }
            case Te: {
              var rn = v1(mt, Je.mode, Ke);
              return rn.return = Je, rn;
            }
            case Oe: {
              var nr = mt._payload, xr = mt._init;
              return qe(Je, xr(nr), Ke);
            }
          }
          if (Tn(mt) || Ue(mt)) {
            var Zr = yd(mt, Je.mode, Ke, null);
            return Zr.return = Je, Zr;
          }
          vb(Je, mt);
        }
        return typeof mt == "function" && yb(Je), null;
      }
      function at(Je, mt, Ke, Ut) {
        var mn = mt !== null ? mt.key : null;
        if (typeof Ke == "string" && Ke !== "" || typeof Ke == "number")
          return mn !== null ? null : J(Je, mt, "" + Ke, Ut);
        if (typeof Ke == "object" && Ke !== null) {
          switch (Ke.$$typeof) {
            case $:
              return Ke.key === mn ? re(Je, mt, Ke, Ut) : null;
            case Te:
              return Ke.key === mn ? me(Je, mt, Ke, Ut) : null;
            case Oe: {
              var rn = Ke._payload, nr = Ke._init;
              return at(Je, mt, nr(rn), Ut);
            }
          }
          if (Tn(Ke) || Ue(Ke))
            return mn !== null ? null : we(Je, mt, Ke, Ut, null);
          vb(Je, Ke);
        }
        return typeof Ke == "function" && yb(Je), null;
      }
      function dt(Je, mt, Ke, Ut, mn) {
        if (typeof Ut == "string" && Ut !== "" || typeof Ut == "number") {
          var rn = Je.get(Ke) || null;
          return J(mt, rn, "" + Ut, mn);
        }
        if (typeof Ut == "object" && Ut !== null) {
          switch (Ut.$$typeof) {
            case $: {
              var nr = Je.get(Ut.key === null ? Ke : Ut.key) || null;
              return re(mt, nr, Ut, mn);
            }
            case Te: {
              var xr = Je.get(Ut.key === null ? Ke : Ut.key) || null;
              return me(mt, xr, Ut, mn);
            }
            case Oe: {
              var Zr = Ut._payload, Er = Ut._init;
              return dt(Je, mt, Ke, Er(Zr), mn);
            }
          }
          if (Tn(Ut) || Ue(Ut)) {
            var bi = Je.get(Ke) || null;
            return we(mt, bi, Ut, mn, null);
          }
          vb(mt, Ut);
        }
        return typeof Ut == "function" && yb(mt), null;
      }
      function At(Je, mt, Ke) {
        {
          if (typeof Je != "object" || Je === null)
            return mt;
          switch (Je.$$typeof) {
            case $:
            case Te:
              kP(Je, Ke);
              var Ut = Je.key;
              if (typeof Ut != "string")
                break;
              if (mt === null) {
                mt = /* @__PURE__ */ new Set(), mt.add(Ut);
                break;
              }
              if (!mt.has(Ut)) {
                mt.add(Ut);
                break;
              }
              d("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", Ut);
              break;
            case Oe: {
              var mn = Je._payload, rn = Je._init;
              At(rn(mn), mt, Ke);
              break;
            }
          }
        }
        return mt;
      }
      function Dt(Je, mt, Ke, Ut) {
        for (var mn = null, rn = 0; rn < Ke.length; rn++) {
          var nr = Ke[rn];
          mn = At(nr, mn, Je);
        }
        for (var xr = null, Zr = null, Er = mt, bi = 0, fr = 0, er = null; Er !== null && fr < Ke.length; fr++) {
          Er.index > fr ? (er = Er, Er = null) : er = Er.sibling;
          var zi = at(Je, Er, Ke[fr], Ut);
          if (zi === null) {
            Er === null && (Er = er);
            break;
          }
          l && Er && zi.alternate === null && c(Je, Er), bi = F(zi, bi, fr), Zr === null ? xr = zi : Zr.sibling = zi, Zr = zi, Er = er;
        }
        if (fr === Ke.length) {
          if (y(Je, Er), za()) {
            var Si = fr;
            Rf(Je, Si);
          }
          return xr;
        }
        if (Er === null) {
          for (; fr < Ke.length; fr++) {
            var zs = qe(Je, Ke[fr], Ut);
            zs !== null && (bi = F(zs, bi, fr), Zr === null ? xr = zs : Zr.sibling = zs, Zr = zs);
          }
          if (za()) {
            var Ra = fr;
            Rf(Je, Ra);
          }
          return xr;
        }
        for (var ns = x(Je, Er); fr < Ke.length; fr++) {
          var rs = dt(ns, Je, fr, Ke[fr], Ut);
          rs !== null && (l && rs.alternate !== null && ns.delete(rs.key === null ? fr : rs.key), bi = F(rs, bi, fr), Zr === null ? xr = rs : Zr.sibling = rs, Zr = rs);
        }
        if (l && ns.forEach(function(Kp) {
          return c(Je, Kp);
        }), za()) {
          var Ql = fr;
          Rf(Je, Ql);
        }
        return xr;
      }
      function yn(Je, mt, Ke, Ut) {
        var mn = Ue(Ke);
        if (typeof mn != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Ke[Symbol.toStringTag] === "Generator" && (WC || d("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), WC = !0), Ke.entries === mn && ($C || d("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), $C = !0);
          var rn = mn.call(Ke);
          if (rn)
            for (var nr = null, xr = rn.next(); !xr.done; xr = rn.next()) {
              var Zr = xr.value;
              nr = At(Zr, nr, Je);
            }
        }
        var Er = mn.call(Ke);
        if (Er == null)
          throw new Error("An iterable object provided no iterator.");
        for (var bi = null, fr = null, er = mt, zi = 0, Si = 0, zs = null, Ra = Er.next(); er !== null && !Ra.done; Si++, Ra = Er.next()) {
          er.index > Si ? (zs = er, er = null) : zs = er.sibling;
          var ns = at(Je, er, Ra.value, Ut);
          if (ns === null) {
            er === null && (er = zs);
            break;
          }
          l && er && ns.alternate === null && c(Je, er), zi = F(ns, zi, Si), fr === null ? bi = ns : fr.sibling = ns, fr = ns, er = zs;
        }
        if (Ra.done) {
          if (y(Je, er), za()) {
            var rs = Si;
            Rf(Je, rs);
          }
          return bi;
        }
        if (er === null) {
          for (; !Ra.done; Si++, Ra = Er.next()) {
            var Ql = qe(Je, Ra.value, Ut);
            Ql !== null && (zi = F(Ql, zi, Si), fr === null ? bi = Ql : fr.sibling = Ql, fr = Ql);
          }
          if (za()) {
            var Kp = Si;
            Rf(Je, Kp);
          }
          return bi;
        }
        for (var Zp = x(Je, er); !Ra.done; Si++, Ra = Er.next()) {
          var is = dt(Zp, Je, Si, Ra.value, Ut);
          is !== null && (l && is.alternate !== null && Zp.delete(is.key === null ? Si : is.key), zi = F(is, zi, Si), fr === null ? bi = is : fr.sibling = is, fr = is);
        }
        if (l && Zp.forEach(function(x1) {
          return c(Je, x1);
        }), za()) {
          var zf = Si;
          Rf(Je, zf);
        }
        return bi;
      }
      function Un(Je, mt, Ke, Ut) {
        if (mt !== null && mt.tag === G) {
          y(Je, mt.sibling);
          var mn = T(mt, Ke);
          return mn.return = Je, mn;
        }
        y(Je, mt);
        var rn = g1(Ke, Je.mode, Ut);
        return rn.return = Je, rn;
      }
      function En(Je, mt, Ke, Ut) {
        for (var mn = Ke.key, rn = mt; rn !== null; ) {
          if (rn.key === mn) {
            var nr = Ke.type;
            if (nr === se) {
              if (rn.tag === X) {
                y(Je, rn.sibling);
                var xr = T(rn, Ke.props.children);
                return xr.return = Je, xr._debugSource = Ke._source, xr._debugOwner = Ke._owner, xr;
              }
            } else if (rn.elementType === nr || // Keep this check inline so it only runs on the false path:
            kI(rn, Ke) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof nr == "object" && nr !== null && nr.$$typeof === Oe && $P(nr) === rn.type) {
              y(Je, rn.sibling);
              var Zr = T(rn, Ke.props);
              return Zr.ref = mv(Je, rn, Ke), Zr.return = Je, Zr._debugSource = Ke._source, Zr._debugOwner = Ke._owner, Zr;
            }
            y(Je, rn);
            break;
          } else
            c(Je, rn);
          rn = rn.sibling;
        }
        if (Ke.type === se) {
          var Er = yd(Ke.props.children, Je.mode, Ut, Ke.key);
          return Er.return = Je, Er;
        } else {
          var bi = m1(Ke, Je.mode, Ut);
          return bi.ref = mv(Je, mt, Ke), bi.return = Je, bi;
        }
      }
      function ii(Je, mt, Ke, Ut) {
        for (var mn = Ke.key, rn = mt; rn !== null; ) {
          if (rn.key === mn)
            if (rn.tag === H && rn.stateNode.containerInfo === Ke.containerInfo && rn.stateNode.implementation === Ke.implementation) {
              y(Je, rn.sibling);
              var nr = T(rn, Ke.children || []);
              return nr.return = Je, nr;
            } else {
              y(Je, rn);
              break;
            }
          else
            c(Je, rn);
          rn = rn.sibling;
        }
        var xr = v1(Ke, Je.mode, Ut);
        return xr.return = Je, xr;
      }
      function ai(Je, mt, Ke, Ut) {
        var mn = typeof Ke == "object" && Ke !== null && Ke.type === se && Ke.key === null;
        if (mn && (Ke = Ke.props.children), typeof Ke == "object" && Ke !== null) {
          switch (Ke.$$typeof) {
            case $:
              return k(En(Je, mt, Ke, Ut));
            case Te:
              return k(ii(Je, mt, Ke, Ut));
            case Oe: {
              var rn = Ke._payload, nr = Ke._init;
              return ai(Je, mt, nr(rn), Ut);
            }
          }
          if (Tn(Ke))
            return Dt(Je, mt, Ke, Ut);
          if (Ue(Ke))
            return yn(Je, mt, Ke, Ut);
          vb(Je, Ke);
        }
        return typeof Ke == "string" && Ke !== "" || typeof Ke == "number" ? k(Un(Je, mt, "" + Ke, Ut)) : (typeof Ke == "function" && yb(Je), y(Je, mt));
      }
      return ai;
    }
    var Lp = WP(!0), jP = WP(!1);
    function _5(l, c) {
      if (l !== null && c.child !== l.child)
        throw new Error("Resuming work not yet implemented.");
      if (c.child !== null) {
        var y = c.child, x = Uf(y, y.pendingProps);
        for (c.child = x, x.return = c; y.sibling !== null; )
          y = y.sibling, x = x.sibling = Uf(y, y.pendingProps), x.return = c;
        x.sibling = null;
      }
    }
    function x5(l, c) {
      for (var y = l.child; y !== null; )
        d8(y, c), y = y.sibling;
    }
    var gv = {}, ud = _s(gv), vv = _s(gv), bb = _s(gv);
    function Sb(l) {
      if (l === gv)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return l;
    }
    function qC() {
      var l = Sb(bb.current);
      return l;
    }
    function YC(l, c) {
      Tr(bb, c, l), Tr(vv, l, l), Tr(ud, gv, l);
      var y = ur(c);
      Di(ud, l), Tr(ud, y, l);
    }
    function Fp(l) {
      Di(ud, l), Di(vv, l), Di(bb, l);
    }
    function yv() {
      var l = Sb(ud.current);
      return l;
    }
    function GP(l) {
      var c = Sb(bb.current), y = Sb(ud.current), x = cn(y, l.type, c);
      y !== x && (Tr(vv, l, l), Tr(ud, x, l));
    }
    function KC(l) {
      vv.current === l && (Di(ud, l), Di(vv, l));
    }
    var E5 = 0, XP = 1, qP = 1, bv = 2, sl = _s(E5);
    function ZC(l, c) {
      return (l & c) !== 0;
    }
    function Up(l) {
      return l & XP;
    }
    function QC(l, c) {
      return l & XP | c;
    }
    function C5(l, c) {
      return l | c;
    }
    function dd(l, c) {
      Tr(sl, c, l);
    }
    function zp(l) {
      Di(sl, l);
    }
    function w5(l, c) {
      var y = l.memoizedState;
      return y !== null ? y.dehydrated !== null : (l.memoizedProps, !0);
    }
    function _b(l) {
      for (var c = l; c !== null; ) {
        if (c.tag === V) {
          var y = c.memoizedState;
          if (y !== null) {
            var x = y.dehydrated;
            if (x === null || Go(x) || Ss(x))
              return c;
          }
        } else if (c.tag === he && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        c.memoizedProps.revealOrder !== void 0) {
          var T = (c.flags & lt) !== De;
          if (T)
            return c;
        } else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === l)
          return null;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === l)
            return null;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return null;
    }
    var Gl = (
      /*   */
      0
    ), gi = (
      /* */
      1
    ), fd = (
      /*  */
      2
    ), Ui = (
      /*    */
      4
    ), Ca = (
      /*   */
      8
    ), JC = [];
    function ew() {
      for (var l = 0; l < JC.length; l++) {
        var c = JC[l];
        yo ? c._workInProgressVersionPrimary = null : c._workInProgressVersionSecondary = null;
      }
      JC.length = 0;
    }
    function M5(l, c) {
      var y = c._getVersion, x = y(c._source);
      l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [c, x] : l.mutableSourceEagerHydrationData.push(c, x);
    }
    var tn = a.ReactCurrentDispatcher, Do = a.ReactCurrentBatchConfig, tw, Bp;
    tw = /* @__PURE__ */ new Set();
    var Hp = wt, kr = null, Ba = null, ra = null, xb = !1, Sv = !1, _v = 0, T5 = 0, R5 = 25, gt = null, Is = null, hd = -1, nw = !1;
    function vr() {
      {
        var l = gt;
        Is === null ? Is = [l] : Is.push(l);
      }
    }
    function $t() {
      {
        var l = gt;
        Is !== null && (hd++, Is[hd] !== l && A5(l));
      }
    }
    function Vp(l) {
      l != null && !Tn(l) && d("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", gt, typeof l);
    }
    function A5(l) {
      {
        var c = ue(kr);
        if (!tw.has(c) && (tw.add(c), Is !== null)) {
          for (var y = "", x = 30, T = 0; T <= hd; T++) {
            for (var F = Is[T], k = T === hd ? l : F, J = T + 1 + ". " + F; J.length < x; )
              J += " ";
            J += k + `
`, y += J;
          }
          d(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, c, y);
        }
      }
    }
    function Ha() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function rw(l, c) {
      if (nw)
        return !1;
      if (c === null)
        return d("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", gt), !1;
      l.length !== c.length && d(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, gt, "[" + c.join(", ") + "]", "[" + l.join(", ") + "]");
      for (var y = 0; y < c.length && y < l.length; y++)
        if (!ro(l[y], c[y]))
          return !1;
      return !0;
    }
    function kp(l, c, y, x, T, F) {
      Hp = F, kr = c, Is = l !== null ? l._debugHookTypes : null, hd = -1, nw = l !== null && l.type !== c.type, c.memoizedState = null, c.updateQueue = null, c.lanes = wt, l !== null && l.memoizedState !== null ? tn.current = gD : Is !== null ? tn.current = mD : tn.current = pD;
      var k = y(x, T);
      if (Sv) {
        var J = 0;
        do {
          if (Sv = !1, _v = 0, J >= R5)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          J += 1, nw = !1, Ba = null, ra = null, c.updateQueue = null, hd = -1, tn.current = vD, k = y(x, T);
        } while (Sv);
      }
      tn.current = Lb, c._debugHookTypes = Is;
      var re = Ba !== null && Ba.next !== null;
      if (Hp = wt, kr = null, Ba = null, ra = null, gt = null, Is = null, hd = -1, l !== null && (l.flags & Lt) !== (c.flags & Lt) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (l.mode & _r) !== An && d("Internal React error: Expected static flag was missing. Please notify the React team."), xb = !1, re)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return k;
    }
    function $p() {
      var l = _v !== 0;
      return _v = 0, l;
    }
    function YP(l, c, y) {
      c.updateQueue = l.updateQueue, (c.mode & Mo) !== An ? c.flags &= ~(Ce | Ae | xt | He) : c.flags &= ~(xt | He), l.lanes = Rc(l.lanes, y);
    }
    function KP() {
      if (tn.current = Lb, xb) {
        for (var l = kr.memoizedState; l !== null; ) {
          var c = l.queue;
          c !== null && (c.pending = null), l = l.next;
        }
        xb = !1;
      }
      Hp = wt, kr = null, Ba = null, ra = null, Is = null, hd = -1, gt = null, lD = !1, Sv = !1, _v = 0;
    }
    function Vc() {
      var l = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return ra === null ? kr.memoizedState = ra = l : ra = ra.next = l, ra;
    }
    function Xl() {
      var l;
      if (Ba === null) {
        var c = kr.alternate;
        c !== null ? l = c.memoizedState : l = null;
      } else
        l = Ba.next;
      var y;
      if (ra === null ? y = kr.memoizedState : y = ra.next, y !== null)
        ra = y, y = ra.next, Ba = l;
      else {
        if (l === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Ba = l;
        var x = {
          memoizedState: Ba.memoizedState,
          baseState: Ba.baseState,
          baseQueue: Ba.baseQueue,
          queue: Ba.queue,
          next: null
        };
        ra === null ? kr.memoizedState = ra = x : ra = ra.next = x;
      }
      return ra;
    }
    function ZP() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function iw(l, c) {
      return typeof c == "function" ? c(l) : c;
    }
    function aw(l, c, y) {
      var x = Vc(), T;
      y !== void 0 ? T = y(c) : T = c, x.memoizedState = x.baseState = T;
      var F = {
        pending: null,
        interleaved: null,
        lanes: wt,
        dispatch: null,
        lastRenderedReducer: l,
        lastRenderedState: T
      };
      x.queue = F;
      var k = F.dispatch = I5.bind(null, kr, F);
      return [x.memoizedState, k];
    }
    function ow(l, c, y) {
      var x = Xl(), T = x.queue;
      if (T === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      T.lastRenderedReducer = l;
      var F = Ba, k = F.baseQueue, J = T.pending;
      if (J !== null) {
        if (k !== null) {
          var re = k.next, me = J.next;
          k.next = me, J.next = re;
        }
        F.baseQueue !== k && d("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), F.baseQueue = k = J, T.pending = null;
      }
      if (k !== null) {
        var we = k.next, qe = F.baseState, at = null, dt = null, At = null, Dt = we;
        do {
          var yn = Dt.lane;
          if (Yu(Hp, yn)) {
            if (At !== null) {
              var En = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Ni,
                action: Dt.action,
                hasEagerState: Dt.hasEagerState,
                eagerState: Dt.eagerState,
                next: null
              };
              At = At.next = En;
            }
            if (Dt.hasEagerState)
              qe = Dt.eagerState;
            else {
              var ii = Dt.action;
              qe = l(qe, ii);
            }
          } else {
            var Un = {
              lane: yn,
              action: Dt.action,
              hasEagerState: Dt.hasEagerState,
              eagerState: Dt.eagerState,
              next: null
            };
            At === null ? (dt = At = Un, at = qe) : At = At.next = Un, kr.lanes = Ln(kr.lanes, yn), vS(yn);
          }
          Dt = Dt.next;
        } while (Dt !== null && Dt !== we);
        At === null ? at = qe : At.next = dt, ro(qe, x.memoizedState) || qb(), x.memoizedState = qe, x.baseState = at, x.baseQueue = At, T.lastRenderedState = qe;
      }
      var ai = T.interleaved;
      if (ai !== null) {
        var Je = ai;
        do {
          var mt = Je.lane;
          kr.lanes = Ln(kr.lanes, mt), vS(mt), Je = Je.next;
        } while (Je !== ai);
      } else k === null && (T.lanes = wt);
      var Ke = T.dispatch;
      return [x.memoizedState, Ke];
    }
    function sw(l, c, y) {
      var x = Xl(), T = x.queue;
      if (T === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      T.lastRenderedReducer = l;
      var F = T.dispatch, k = T.pending, J = x.memoizedState;
      if (k !== null) {
        T.pending = null;
        var re = k.next, me = re;
        do {
          var we = me.action;
          J = l(J, we), me = me.next;
        } while (me !== re);
        ro(J, x.memoizedState) || qb(), x.memoizedState = J, x.baseQueue === null && (x.baseState = J), T.lastRenderedState = J;
      }
      return [J, F];
    }
    function Zpe(l, c, y) {
    }
    function Qpe(l, c, y) {
    }
    function lw(l, c, y) {
      var x = kr, T = Vc(), F, k = za();
      if (k) {
        if (y === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        F = y(), Bp || F !== y() && (d("The result of getServerSnapshot should be cached to avoid an infinite loop"), Bp = !0);
      } else {
        if (F = c(), !Bp) {
          var J = c();
          ro(F, J) || (d("The result of getSnapshot should be cached to avoid an infinite loop"), Bp = !0);
        }
        var re = hS();
        if (re === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Tc(re, Hp) || QP(x, c, F);
      }
      T.memoizedState = F;
      var me = {
        value: F,
        getSnapshot: c
      };
      return T.queue = me, wv(eD.bind(null, x, me, l), [l]), x.flags |= xt, Ev(gi | Ca, JP.bind(null, x, me, F, c), void 0, null), F;
    }
    function Eb(l, c, y) {
      var x = kr, T = Xl(), F = c();
      if (!Bp) {
        var k = c();
        ro(F, k) || (d("The result of getSnapshot should be cached to avoid an infinite loop"), Bp = !0);
      }
      var J = T.memoizedState, re = !ro(J, F);
      re && (T.memoizedState = F, qb());
      var me = T.queue;
      if (Pf(eD.bind(null, x, me, l), [l]), me.getSnapshot !== c || re || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      ra !== null && ra.memoizedState.tag & gi) {
        x.flags |= xt, Ev(gi | Ca, JP.bind(null, x, me, F, c), void 0, null);
        var we = hS();
        if (we === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Tc(we, Hp) || QP(x, c, F);
      }
      return F;
    }
    function QP(l, c, y) {
      l.flags |= vn;
      var x = {
        getSnapshot: c,
        value: y
      }, T = kr.updateQueue;
      if (T === null)
        T = ZP(), kr.updateQueue = T, T.stores = [x];
      else {
        var F = T.stores;
        F === null ? T.stores = [x] : F.push(x);
      }
    }
    function JP(l, c, y, x) {
      c.value = y, c.getSnapshot = x, tD(c) && nD(l);
    }
    function eD(l, c, y) {
      var x = function() {
        tD(c) && nD(l);
      };
      return y(x);
    }
    function tD(l) {
      var c = l.getSnapshot, y = l.value;
      try {
        var x = c();
        return !ro(y, x);
      } catch {
        return !0;
      }
    }
    function nD(l) {
      oa(l, Jn, Vr);
    }
    function xv(l) {
      var c = Vc();
      typeof l == "function" && (l = l()), c.memoizedState = c.baseState = l;
      var y = {
        pending: null,
        interleaved: null,
        lanes: wt,
        dispatch: null,
        lastRenderedReducer: iw,
        lastRenderedState: l
      };
      c.queue = y;
      var x = y.dispatch = N5.bind(null, kr, y);
      return [c.memoizedState, x];
    }
    function Cb(l) {
      return ow(iw);
    }
    function wb(l) {
      return sw(iw);
    }
    function Ev(l, c, y, x) {
      var T = {
        tag: l,
        create: c,
        destroy: y,
        deps: x,
        // Circular
        next: null
      }, F = kr.updateQueue;
      if (F === null)
        F = ZP(), kr.updateQueue = F, F.lastEffect = T.next = T;
      else {
        var k = F.lastEffect;
        if (k === null)
          F.lastEffect = T.next = T;
        else {
          var J = k.next;
          k.next = T, T.next = J, F.lastEffect = T;
        }
      }
      return T;
    }
    function cw(l) {
      var c = Vc();
      {
        var y = {
          current: l
        };
        return c.memoizedState = y, y;
      }
    }
    function Mb(l) {
      var c = Xl();
      return c.memoizedState;
    }
    function Cv(l, c, y, x) {
      var T = Vc(), F = x === void 0 ? null : x;
      kr.flags |= l, T.memoizedState = Ev(gi | c, y, void 0, F);
    }
    function Tb(l, c, y, x) {
      var T = Xl(), F = x === void 0 ? null : x, k = void 0;
      if (Ba !== null) {
        var J = Ba.memoizedState;
        if (k = J.destroy, F !== null) {
          var re = J.deps;
          if (rw(F, re)) {
            T.memoizedState = Ev(c, y, k, F);
            return;
          }
        }
      }
      kr.flags |= l, T.memoizedState = Ev(gi | c, y, k, F);
    }
    function wv(l, c) {
      return (kr.mode & Mo) !== An ? Cv(Ce | xt | _e, Ca, l, c) : Cv(xt | _e, Ca, l, c);
    }
    function Pf(l, c) {
      return Tb(xt, Ca, l, c);
    }
    function uw(l, c) {
      return Cv(He, fd, l, c);
    }
    function Rb(l, c) {
      return Tb(He, fd, l, c);
    }
    function dw(l, c) {
      var y = He;
      return y |= ee, (kr.mode & Mo) !== An && (y |= Ae), Cv(y, Ui, l, c);
    }
    function Ab(l, c) {
      return Tb(He, Ui, l, c);
    }
    function rD(l, c) {
      if (typeof c == "function") {
        var y = c, x = l();
        return y(x), function() {
          y(null);
        };
      } else if (c != null) {
        var T = c;
        T.hasOwnProperty("current") || d("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(T).join(", ") + "}");
        var F = l();
        return T.current = F, function() {
          T.current = null;
        };
      }
    }
    function fw(l, c, y) {
      typeof c != "function" && d("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", c !== null ? typeof c : "null");
      var x = y != null ? y.concat([l]) : null, T = He;
      return T |= ee, (kr.mode & Mo) !== An && (T |= Ae), Cv(T, Ui, rD.bind(null, c, l), x);
    }
    function Ob(l, c, y) {
      typeof c != "function" && d("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", c !== null ? typeof c : "null");
      var x = y != null ? y.concat([l]) : null;
      return Tb(He, Ui, rD.bind(null, c, l), x);
    }
    function O5(l, c) {
    }
    var Pb = O5;
    function hw(l, c) {
      var y = Vc(), x = c === void 0 ? null : c;
      return y.memoizedState = [l, x], l;
    }
    function Db(l, c) {
      var y = Xl(), x = c === void 0 ? null : c, T = y.memoizedState;
      if (T !== null && x !== null) {
        var F = T[1];
        if (rw(x, F))
          return T[0];
      }
      return y.memoizedState = [l, x], l;
    }
    function pw(l, c) {
      var y = Vc(), x = c === void 0 ? null : c, T = l();
      return y.memoizedState = [T, x], T;
    }
    function Ib(l, c) {
      var y = Xl(), x = c === void 0 ? null : c, T = y.memoizedState;
      if (T !== null && x !== null) {
        var F = T[1];
        if (rw(x, F))
          return T[0];
      }
      var k = l();
      return y.memoizedState = [k, x], k;
    }
    function mw(l) {
      var c = xv(l), y = c[0], x = c[1];
      return wv(function() {
        var T = Do.transition;
        Do.transition = {};
        try {
          x(l);
        } finally {
          Do.transition = T;
        }
      }, [l]), y;
    }
    function iD(l) {
      var c = Cb(), y = c[0], x = c[1];
      return Pf(function() {
        var T = Do.transition;
        Do.transition = {};
        try {
          x(l);
        } finally {
          Do.transition = T;
        }
      }, [l]), y;
    }
    function aD(l) {
      var c = wb(), y = c[0], x = c[1];
      return Pf(function() {
        var T = Do.transition;
        Do.transition = {};
        try {
          x(l);
        } finally {
          Do.transition = T;
        }
      }, [l]), y;
    }
    function P5(l, c, y) {
      var x = to();
      Li(Cp(x, Zu)), l(!0);
      var T = Do.transition;
      Do.transition = {};
      var F = Do.transition;
      Do.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        l(!1), c();
      } finally {
        if (Li(x), Do.transition = T, T === null && F._updatedFibers) {
          var k = F._updatedFibers.size;
          k > 10 && u("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), F._updatedFibers.clear();
        }
      }
    }
    function gw() {
      var l = xv(!1), c = l[0], y = l[1], x = P5.bind(null, y), T = Vc();
      return T.memoizedState = x, [c, x];
    }
    function oD() {
      var l = Cb(), c = l[0], y = Xl(), x = y.memoizedState;
      return [c, x];
    }
    function sD() {
      var l = wb(), c = l[0], y = Xl(), x = y.memoizedState;
      return [c, x];
    }
    var lD = !1;
    function D5() {
      return lD;
    }
    function vw() {
      var l = Vc(), c = hS(), y = c.identifierPrefix, x;
      if (za()) {
        var T = l5();
        x = ":" + y + "R" + T;
        var F = _v++;
        F > 0 && (x += "H" + F.toString(32)), x += ":";
      } else {
        var k = T5++;
        x = ":" + y + "r" + k.toString(32) + ":";
      }
      return l.memoizedState = x, x;
    }
    function Nb() {
      var l = Xl(), c = l.memoizedState;
      return c;
    }
    function I5(l, c, y) {
      typeof arguments[3] == "function" && d("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var x = gd(l), T = {
        lane: x,
        action: y,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (cD(l))
        uD(c, T);
      else {
        dD(l, c, T);
        var F = oo(), k = oa(l, x, F);
        k !== null && fD(k, c, x);
      }
      hD(l, x);
    }
    function N5(l, c, y) {
      typeof arguments[3] == "function" && d("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var x = gd(l), T = {
        lane: x,
        action: y,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (cD(l))
        uD(c, T);
      else {
        dD(l, c, T);
        var F = l.alternate;
        if (l.lanes === wt && (F === null || F.lanes === wt)) {
          var k = c.lastRenderedReducer;
          if (k !== null) {
            var J;
            J = tn.current, tn.current = ll;
            try {
              var re = c.lastRenderedState, me = k(re, y);
              if (T.hasEagerState = !0, T.eagerState = me, ro(me, re))
                return;
            } catch {
            } finally {
              tn.current = J;
            }
          }
        }
        var we = oo(), qe = oa(l, x, we);
        qe !== null && fD(qe, c, x);
      }
      hD(l, x);
    }
    function cD(l) {
      var c = l.alternate;
      return l === kr || c !== null && c === kr;
    }
    function uD(l, c) {
      Sv = xb = !0;
      var y = l.pending;
      y === null ? c.next = c : (c.next = y.next, y.next = c), l.pending = c;
    }
    function dD(l, c, y, x) {
      if (wI(l)) {
        var T = c.interleaved;
        T === null ? (y.next = y, _n(c)) : (y.next = T.next, T.next = y), c.interleaved = y;
      } else {
        var F = c.pending;
        F === null ? y.next = y : (y.next = F.next, F.next = y), c.pending = y;
      }
    }
    function fD(l, c, y) {
      if (_p(y)) {
        var x = c.lanes;
        x = zl(x, l.pendingLanes);
        var T = Ln(x, y);
        c.lanes = T, Pc(l, T);
      }
    }
    function hD(l, c, y) {
      rd(l, c);
    }
    var Lb = {
      readContext: Vt,
      useCallback: Ha,
      useContext: Ha,
      useEffect: Ha,
      useImperativeHandle: Ha,
      useInsertionEffect: Ha,
      useLayoutEffect: Ha,
      useMemo: Ha,
      useReducer: Ha,
      useRef: Ha,
      useState: Ha,
      useDebugValue: Ha,
      useDeferredValue: Ha,
      useTransition: Ha,
      useMutableSource: Ha,
      useSyncExternalStore: Ha,
      useId: Ha,
      unstable_isNewReconciler: E
    }, pD = null, mD = null, gD = null, vD = null, ql = null, ll = null, Fb = null;
    {
      var yw = function() {
        d("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, On = function() {
        d("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      pD = {
        readContext: function(l) {
          return Vt(l);
        },
        useCallback: function(l, c) {
          return gt = "useCallback", vr(), Vp(c), hw(l, c);
        },
        useContext: function(l) {
          return gt = "useContext", vr(), Vt(l);
        },
        useEffect: function(l, c) {
          return gt = "useEffect", vr(), Vp(c), wv(l, c);
        },
        useImperativeHandle: function(l, c, y) {
          return gt = "useImperativeHandle", vr(), Vp(y), fw(l, c, y);
        },
        useInsertionEffect: function(l, c) {
          return gt = "useInsertionEffect", vr(), Vp(c), uw(l, c);
        },
        useLayoutEffect: function(l, c) {
          return gt = "useLayoutEffect", vr(), Vp(c), dw(l, c);
        },
        useMemo: function(l, c) {
          gt = "useMemo", vr(), Vp(c);
          var y = tn.current;
          tn.current = ql;
          try {
            return pw(l, c);
          } finally {
            tn.current = y;
          }
        },
        useReducer: function(l, c, y) {
          gt = "useReducer", vr();
          var x = tn.current;
          tn.current = ql;
          try {
            return aw(l, c, y);
          } finally {
            tn.current = x;
          }
        },
        useRef: function(l) {
          return gt = "useRef", vr(), cw(l);
        },
        useState: function(l) {
          gt = "useState", vr();
          var c = tn.current;
          tn.current = ql;
          try {
            return xv(l);
          } finally {
            tn.current = c;
          }
        },
        useDebugValue: function(l, c) {
          return gt = "useDebugValue", vr(), void 0;
        },
        useDeferredValue: function(l) {
          return gt = "useDeferredValue", vr(), mw(l);
        },
        useTransition: function() {
          return gt = "useTransition", vr(), gw();
        },
        useMutableSource: function(l, c, y) {
          return gt = "useMutableSource", vr(), void 0;
        },
        useSyncExternalStore: function(l, c, y) {
          return gt = "useSyncExternalStore", vr(), lw(l, c, y);
        },
        useId: function() {
          return gt = "useId", vr(), vw();
        },
        unstable_isNewReconciler: E
      }, mD = {
        readContext: function(l) {
          return Vt(l);
        },
        useCallback: function(l, c) {
          return gt = "useCallback", $t(), hw(l, c);
        },
        useContext: function(l) {
          return gt = "useContext", $t(), Vt(l);
        },
        useEffect: function(l, c) {
          return gt = "useEffect", $t(), wv(l, c);
        },
        useImperativeHandle: function(l, c, y) {
          return gt = "useImperativeHandle", $t(), fw(l, c, y);
        },
        useInsertionEffect: function(l, c) {
          return gt = "useInsertionEffect", $t(), uw(l, c);
        },
        useLayoutEffect: function(l, c) {
          return gt = "useLayoutEffect", $t(), dw(l, c);
        },
        useMemo: function(l, c) {
          gt = "useMemo", $t();
          var y = tn.current;
          tn.current = ql;
          try {
            return pw(l, c);
          } finally {
            tn.current = y;
          }
        },
        useReducer: function(l, c, y) {
          gt = "useReducer", $t();
          var x = tn.current;
          tn.current = ql;
          try {
            return aw(l, c, y);
          } finally {
            tn.current = x;
          }
        },
        useRef: function(l) {
          return gt = "useRef", $t(), cw(l);
        },
        useState: function(l) {
          gt = "useState", $t();
          var c = tn.current;
          tn.current = ql;
          try {
            return xv(l);
          } finally {
            tn.current = c;
          }
        },
        useDebugValue: function(l, c) {
          return gt = "useDebugValue", $t(), void 0;
        },
        useDeferredValue: function(l) {
          return gt = "useDeferredValue", $t(), mw(l);
        },
        useTransition: function() {
          return gt = "useTransition", $t(), gw();
        },
        useMutableSource: function(l, c, y) {
          return gt = "useMutableSource", $t(), void 0;
        },
        useSyncExternalStore: function(l, c, y) {
          return gt = "useSyncExternalStore", $t(), lw(l, c, y);
        },
        useId: function() {
          return gt = "useId", $t(), vw();
        },
        unstable_isNewReconciler: E
      }, gD = {
        readContext: function(l) {
          return Vt(l);
        },
        useCallback: function(l, c) {
          return gt = "useCallback", $t(), Db(l, c);
        },
        useContext: function(l) {
          return gt = "useContext", $t(), Vt(l);
        },
        useEffect: function(l, c) {
          return gt = "useEffect", $t(), Pf(l, c);
        },
        useImperativeHandle: function(l, c, y) {
          return gt = "useImperativeHandle", $t(), Ob(l, c, y);
        },
        useInsertionEffect: function(l, c) {
          return gt = "useInsertionEffect", $t(), Rb(l, c);
        },
        useLayoutEffect: function(l, c) {
          return gt = "useLayoutEffect", $t(), Ab(l, c);
        },
        useMemo: function(l, c) {
          gt = "useMemo", $t();
          var y = tn.current;
          tn.current = ll;
          try {
            return Ib(l, c);
          } finally {
            tn.current = y;
          }
        },
        useReducer: function(l, c, y) {
          gt = "useReducer", $t();
          var x = tn.current;
          tn.current = ll;
          try {
            return ow(l, c, y);
          } finally {
            tn.current = x;
          }
        },
        useRef: function(l) {
          return gt = "useRef", $t(), Mb();
        },
        useState: function(l) {
          gt = "useState", $t();
          var c = tn.current;
          tn.current = ll;
          try {
            return Cb(l);
          } finally {
            tn.current = c;
          }
        },
        useDebugValue: function(l, c) {
          return gt = "useDebugValue", $t(), Pb();
        },
        useDeferredValue: function(l) {
          return gt = "useDeferredValue", $t(), iD(l);
        },
        useTransition: function() {
          return gt = "useTransition", $t(), oD();
        },
        useMutableSource: function(l, c, y) {
          return gt = "useMutableSource", $t(), void 0;
        },
        useSyncExternalStore: function(l, c, y) {
          return gt = "useSyncExternalStore", $t(), Eb(l, c);
        },
        useId: function() {
          return gt = "useId", $t(), Nb();
        },
        unstable_isNewReconciler: E
      }, vD = {
        readContext: function(l) {
          return Vt(l);
        },
        useCallback: function(l, c) {
          return gt = "useCallback", $t(), Db(l, c);
        },
        useContext: function(l) {
          return gt = "useContext", $t(), Vt(l);
        },
        useEffect: function(l, c) {
          return gt = "useEffect", $t(), Pf(l, c);
        },
        useImperativeHandle: function(l, c, y) {
          return gt = "useImperativeHandle", $t(), Ob(l, c, y);
        },
        useInsertionEffect: function(l, c) {
          return gt = "useInsertionEffect", $t(), Rb(l, c);
        },
        useLayoutEffect: function(l, c) {
          return gt = "useLayoutEffect", $t(), Ab(l, c);
        },
        useMemo: function(l, c) {
          gt = "useMemo", $t();
          var y = tn.current;
          tn.current = Fb;
          try {
            return Ib(l, c);
          } finally {
            tn.current = y;
          }
        },
        useReducer: function(l, c, y) {
          gt = "useReducer", $t();
          var x = tn.current;
          tn.current = Fb;
          try {
            return sw(l, c, y);
          } finally {
            tn.current = x;
          }
        },
        useRef: function(l) {
          return gt = "useRef", $t(), Mb();
        },
        useState: function(l) {
          gt = "useState", $t();
          var c = tn.current;
          tn.current = Fb;
          try {
            return wb(l);
          } finally {
            tn.current = c;
          }
        },
        useDebugValue: function(l, c) {
          return gt = "useDebugValue", $t(), Pb();
        },
        useDeferredValue: function(l) {
          return gt = "useDeferredValue", $t(), aD(l);
        },
        useTransition: function() {
          return gt = "useTransition", $t(), sD();
        },
        useMutableSource: function(l, c, y) {
          return gt = "useMutableSource", $t(), void 0;
        },
        useSyncExternalStore: function(l, c, y) {
          return gt = "useSyncExternalStore", $t(), Eb(l, c);
        },
        useId: function() {
          return gt = "useId", $t(), Nb();
        },
        unstable_isNewReconciler: E
      }, ql = {
        readContext: function(l) {
          return yw(), Vt(l);
        },
        useCallback: function(l, c) {
          return gt = "useCallback", On(), vr(), hw(l, c);
        },
        useContext: function(l) {
          return gt = "useContext", On(), vr(), Vt(l);
        },
        useEffect: function(l, c) {
          return gt = "useEffect", On(), vr(), wv(l, c);
        },
        useImperativeHandle: function(l, c, y) {
          return gt = "useImperativeHandle", On(), vr(), fw(l, c, y);
        },
        useInsertionEffect: function(l, c) {
          return gt = "useInsertionEffect", On(), vr(), uw(l, c);
        },
        useLayoutEffect: function(l, c) {
          return gt = "useLayoutEffect", On(), vr(), dw(l, c);
        },
        useMemo: function(l, c) {
          gt = "useMemo", On(), vr();
          var y = tn.current;
          tn.current = ql;
          try {
            return pw(l, c);
          } finally {
            tn.current = y;
          }
        },
        useReducer: function(l, c, y) {
          gt = "useReducer", On(), vr();
          var x = tn.current;
          tn.current = ql;
          try {
            return aw(l, c, y);
          } finally {
            tn.current = x;
          }
        },
        useRef: function(l) {
          return gt = "useRef", On(), vr(), cw(l);
        },
        useState: function(l) {
          gt = "useState", On(), vr();
          var c = tn.current;
          tn.current = ql;
          try {
            return xv(l);
          } finally {
            tn.current = c;
          }
        },
        useDebugValue: function(l, c) {
          return gt = "useDebugValue", On(), vr(), void 0;
        },
        useDeferredValue: function(l) {
          return gt = "useDeferredValue", On(), vr(), mw(l);
        },
        useTransition: function() {
          return gt = "useTransition", On(), vr(), gw();
        },
        useMutableSource: function(l, c, y) {
          return gt = "useMutableSource", On(), vr(), void 0;
        },
        useSyncExternalStore: function(l, c, y) {
          return gt = "useSyncExternalStore", On(), vr(), lw(l, c, y);
        },
        useId: function() {
          return gt = "useId", On(), vr(), vw();
        },
        unstable_isNewReconciler: E
      }, ll = {
        readContext: function(l) {
          return yw(), Vt(l);
        },
        useCallback: function(l, c) {
          return gt = "useCallback", On(), $t(), Db(l, c);
        },
        useContext: function(l) {
          return gt = "useContext", On(), $t(), Vt(l);
        },
        useEffect: function(l, c) {
          return gt = "useEffect", On(), $t(), Pf(l, c);
        },
        useImperativeHandle: function(l, c, y) {
          return gt = "useImperativeHandle", On(), $t(), Ob(l, c, y);
        },
        useInsertionEffect: function(l, c) {
          return gt = "useInsertionEffect", On(), $t(), Rb(l, c);
        },
        useLayoutEffect: function(l, c) {
          return gt = "useLayoutEffect", On(), $t(), Ab(l, c);
        },
        useMemo: function(l, c) {
          gt = "useMemo", On(), $t();
          var y = tn.current;
          tn.current = ll;
          try {
            return Ib(l, c);
          } finally {
            tn.current = y;
          }
        },
        useReducer: function(l, c, y) {
          gt = "useReducer", On(), $t();
          var x = tn.current;
          tn.current = ll;
          try {
            return ow(l, c, y);
          } finally {
            tn.current = x;
          }
        },
        useRef: function(l) {
          return gt = "useRef", On(), $t(), Mb();
        },
        useState: function(l) {
          gt = "useState", On(), $t();
          var c = tn.current;
          tn.current = ll;
          try {
            return Cb(l);
          } finally {
            tn.current = c;
          }
        },
        useDebugValue: function(l, c) {
          return gt = "useDebugValue", On(), $t(), Pb();
        },
        useDeferredValue: function(l) {
          return gt = "useDeferredValue", On(), $t(), iD(l);
        },
        useTransition: function() {
          return gt = "useTransition", On(), $t(), oD();
        },
        useMutableSource: function(l, c, y) {
          return gt = "useMutableSource", On(), $t(), void 0;
        },
        useSyncExternalStore: function(l, c, y) {
          return gt = "useSyncExternalStore", On(), $t(), Eb(l, c);
        },
        useId: function() {
          return gt = "useId", On(), $t(), Nb();
        },
        unstable_isNewReconciler: E
      }, Fb = {
        readContext: function(l) {
          return yw(), Vt(l);
        },
        useCallback: function(l, c) {
          return gt = "useCallback", On(), $t(), Db(l, c);
        },
        useContext: function(l) {
          return gt = "useContext", On(), $t(), Vt(l);
        },
        useEffect: function(l, c) {
          return gt = "useEffect", On(), $t(), Pf(l, c);
        },
        useImperativeHandle: function(l, c, y) {
          return gt = "useImperativeHandle", On(), $t(), Ob(l, c, y);
        },
        useInsertionEffect: function(l, c) {
          return gt = "useInsertionEffect", On(), $t(), Rb(l, c);
        },
        useLayoutEffect: function(l, c) {
          return gt = "useLayoutEffect", On(), $t(), Ab(l, c);
        },
        useMemo: function(l, c) {
          gt = "useMemo", On(), $t();
          var y = tn.current;
          tn.current = ll;
          try {
            return Ib(l, c);
          } finally {
            tn.current = y;
          }
        },
        useReducer: function(l, c, y) {
          gt = "useReducer", On(), $t();
          var x = tn.current;
          tn.current = ll;
          try {
            return sw(l, c, y);
          } finally {
            tn.current = x;
          }
        },
        useRef: function(l) {
          return gt = "useRef", On(), $t(), Mb();
        },
        useState: function(l) {
          gt = "useState", On(), $t();
          var c = tn.current;
          tn.current = ll;
          try {
            return wb(l);
          } finally {
            tn.current = c;
          }
        },
        useDebugValue: function(l, c) {
          return gt = "useDebugValue", On(), $t(), Pb();
        },
        useDeferredValue: function(l) {
          return gt = "useDeferredValue", On(), $t(), aD(l);
        },
        useTransition: function() {
          return gt = "useTransition", On(), $t(), sD();
        },
        useMutableSource: function(l, c, y) {
          return gt = "useMutableSource", On(), $t(), void 0;
        },
        useSyncExternalStore: function(l, c, y) {
          return gt = "useSyncExternalStore", On(), $t(), Eb(l, c);
        },
        useId: function() {
          return gt = "useId", On(), $t(), Nb();
        },
        unstable_isNewReconciler: E
      };
    }
    var pd = i.unstable_now, yD = 0, Ub = -1, Mv = -1, zb = -1, bw = !1, Bb = !1;
    function bD() {
      return bw;
    }
    function L5() {
      Bb = !0;
    }
    function F5() {
      bw = !1, Bb = !1;
    }
    function U5() {
      bw = Bb, Bb = !1;
    }
    function SD() {
      return yD;
    }
    function _D() {
      yD = pd();
    }
    function Sw(l) {
      Mv = pd(), l.actualStartTime < 0 && (l.actualStartTime = pd());
    }
    function xD(l) {
      Mv = -1;
    }
    function Hb(l, c) {
      if (Mv >= 0) {
        var y = pd() - Mv;
        l.actualDuration += y, c && (l.selfBaseDuration = y), Mv = -1;
      }
    }
    function Ns(l) {
      if (Ub >= 0) {
        var c = pd() - Ub;
        Ub = -1;
        for (var y = l.return; y !== null; ) {
          switch (y.tag) {
            case N:
              var x = y.stateNode;
              x.effectDuration += c;
              return;
            case Q:
              var T = y.stateNode;
              T.effectDuration += c;
              return;
          }
          y = y.return;
        }
      }
    }
    function _w(l) {
      if (zb >= 0) {
        var c = pd() - zb;
        zb = -1;
        for (var y = l.return; y !== null; ) {
          switch (y.tag) {
            case N:
              var x = y.stateNode;
              x !== null && (x.passiveEffectDuration += c);
              return;
            case Q:
              var T = y.stateNode;
              T !== null && (T.passiveEffectDuration += c);
              return;
          }
          y = y.return;
        }
      }
    }
    function Ls() {
      Ub = pd();
    }
    function xw() {
      zb = pd();
    }
    function Ew(l) {
      for (var c = l.child; c; )
        l.actualDuration += c.actualDuration, c = c.sibling;
    }
    function Vb(l, c) {
      return {
        value: l,
        source: c,
        stack: ub(c)
      };
    }
    function z5(l, c) {
      return !0;
    }
    function Cw(l, c) {
      try {
        var y = z5(l, c);
        if (y === !1)
          return;
        var x = c.value, T = c.source, F = c.stack, k = F !== null ? F : "";
        if (x != null && x._suppressLogging) {
          if (l.tag === U)
            return;
          console.error(x);
        }
        var J = T ? ue(T) : null, re = J ? "The above error occurred in the <" + J + "> component:" : "The above error occurred in one of your React components:", me;
        if (l.tag === N)
          me = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var we = ue(l) || "Anonymous";
          me = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + we + ".");
        }
        var qe = re + `
` + k + `

` + ("" + me);
        console.error(qe);
      } catch (at) {
        setTimeout(function() {
          throw at;
        });
      }
    }
    var B5 = typeof WeakMap == "function" ? WeakMap : Map;
    function ED(l, c, y) {
      var x = xn(Vr, y);
      x.tag = Qe, x.payload = {
        element: null
      };
      var T = c.value;
      return x.callback = function() {
        jW(T), Cw(l, c);
      }, x;
    }
    function ww(l, c, y) {
      var x = xn(Vr, y);
      x.tag = Qe;
      var T = l.type.getDerivedStateFromError;
      if (typeof T == "function") {
        var F = c.value;
        x.payload = function() {
          return T(F);
        }, x.callback = function() {
          $I(l), Cw(l, c);
        };
      }
      var k = l.stateNode;
      return k !== null && typeof k.componentDidCatch == "function" && (x.callback = function() {
        $I(l), Cw(l, c), typeof T != "function" && $W(this);
        var re = c.value, me = c.stack;
        this.componentDidCatch(re, {
          componentStack: me !== null ? me : ""
        }), typeof T != "function" && (fi(l.lanes, Jn) || d("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", ue(l) || "Unknown"));
      }), x;
    }
    function CD(l, c, y) {
      var x = l.pingCache, T;
      if (x === null ? (x = l.pingCache = new B5(), T = /* @__PURE__ */ new Set(), x.set(c, T)) : (T = x.get(c), T === void 0 && (T = /* @__PURE__ */ new Set(), x.set(c, T))), !T.has(y)) {
        T.add(y);
        var F = GW.bind(null, l, c, y);
        Na && kv(l, y), c.then(F, F);
      }
    }
    function H5(l, c, y, x) {
      var T = l.updateQueue;
      if (T === null) {
        var F = /* @__PURE__ */ new Set();
        F.add(y), l.updateQueue = F;
      } else
        T.add(y);
    }
    function V5(l, c) {
      var y = l.tag;
      if ((l.mode & _r) === An && (y === I || y === B || y === ne)) {
        var x = l.alternate;
        x ? (l.updateQueue = x.updateQueue, l.memoizedState = x.memoizedState, l.lanes = x.lanes) : (l.updateQueue = null, l.memoizedState = null);
      }
    }
    function wD(l) {
      var c = l;
      do {
        if (c.tag === V && w5(c))
          return c;
        c = c.return;
      } while (c !== null);
      return null;
    }
    function MD(l, c, y, x, T) {
      if ((l.mode & _r) === An) {
        if (l === c)
          l.flags |= it;
        else {
          if (l.flags |= lt, y.flags |= yt, y.flags &= ~(Mn | ge), _a && b) {
            var F = l.alternate;
            if (F === null) {
              var k = l.child, J = k.child;
              if (J !== null) {
                var re = J.memoizedProps.children, me = Og("hidden", re);
                J.pendingProps = me, J.memoizedProps = me;
              }
            }
          }
          if (y.tag === U) {
            var we = y.alternate;
            if (we === null)
              y.tag = ie;
            else {
              var qe = xn(Vr, Jn);
              qe.tag = xa, $n(y, qe);
            }
          }
          y.lanes = Ln(y.lanes, Jn);
        }
        return l;
      }
      return l.flags |= it, l.lanes = T, l;
    }
    function k5(l, c, y, x, T) {
      if (y.flags |= ge, Na && kv(l, T), x !== null && typeof x == "object" && typeof x.then == "function") {
        var F = x;
        V5(y);
        var k = wD(c);
        if (k !== null) {
          k.flags &= ~Ct, MD(k, c, y, l, T), k.mode & _r && CD(l, F, T), H5(k, l, F);
          return;
        } else {
          if (!qg(T)) {
            CD(l, F, T), i1();
            return;
          }
          var J = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          x = J;
        }
      } else if (za() && y.mode & _r) {
        h5();
        var re = wD(c);
        if (re !== null) {
          (re.flags & it) === De && (re.flags |= Ct), MD(re, c, y, l, T), kC(x);
          return;
        }
      }
      LW(x), x = Vb(x, y);
      var me = c;
      do {
        switch (me.tag) {
          case N: {
            var we = x;
            me.flags |= it;
            var qe = qu(T);
            me.lanes = Ln(me.lanes, qe);
            var at = ED(me, we, qe);
            or(me, at);
            return;
          }
          case U:
            var dt = x, At = me.type, Dt = me.stateNode;
            if ((me.flags & lt) === De && (typeof At.getDerivedStateFromError == "function" || Dt !== null && typeof Dt.componentDidCatch == "function" && !NI(Dt))) {
              me.flags |= it;
              var yn = qu(T);
              me.lanes = Ln(me.lanes, yn);
              var Un = ww(me, dt, yn);
              or(me, Un);
              return;
            }
            break;
        }
        me = me.return;
      } while (me !== null);
    }
    function $5() {
      return null;
    }
    function Yl(l) {
      l.flags |= He;
    }
    function TD(l) {
      l.flags |= un, l.flags |= Sn;
    }
    function RD(l, c) {
      var y = l !== null && l.child === c.child;
      if (y)
        return !0;
      if ((c.flags & vt) !== De)
        return !1;
      for (var x = c.child; x !== null; ) {
        if ((x.flags & je) !== De || (x.subtreeFlags & je) !== De)
          return !1;
        x = x.sibling;
      }
      return !0;
    }
    var Tv, Rv, kb, $b;
    if (ha)
      Tv = function(l, c, y, x) {
        for (var T = c.child; T !== null; ) {
          if (T.tag === j || T.tag === G)
            Pn(l, T.stateNode);
          else if (T.tag !== H) {
            if (T.child !== null) {
              T.child.return = T, T = T.child;
              continue;
            }
          }
          if (T === c)
            return;
          for (; T.sibling === null; ) {
            if (T.return === null || T.return === c)
              return;
            T = T.return;
          }
          T.sibling.return = T.return, T = T.sibling;
        }
      }, Rv = function(l, c) {
      }, kb = function(l, c, y, x, T) {
        var F = l.memoizedProps;
        if (F !== x) {
          var k = c.stateNode, J = yv(), re = Sr(k, y, F, x, T, J);
          c.updateQueue = re, re && Yl(c);
        }
      }, $b = function(l, c, y, x) {
        y !== x && Yl(c);
      };
    else if (_a) {
      Tv = function(l, c, y, x) {
        for (var T = c.child; T !== null; ) {
          if (T.tag === j) {
            var F = T.stateNode;
            if (y && x) {
              var k = T.memoizedProps, J = T.type;
              F = Pg(F, J, k, T);
            }
            Pn(l, F);
          } else if (T.tag === G) {
            var re = T.stateNode;
            if (y && x) {
              var me = T.memoizedProps;
              re = Yh(re, me, T);
            }
            Pn(l, re);
          } else if (T.tag !== H) {
            if (T.tag === ve && T.memoizedState !== null) {
              var we = T.child;
              we !== null && (we.return = T), Tv(l, T, !0, !0);
            } else if (T.child !== null) {
              T.child.return = T, T = T.child;
              continue;
            }
          }
          if (T = T, T === c)
            return;
          for (; T.sibling === null; ) {
            if (T.return === null || T.return === c)
              return;
            T = T.return;
          }
          T.sibling.return = T.return, T = T.sibling;
        }
      };
      var AD = function(l, c, y, x) {
        for (var T = c.child; T !== null; ) {
          if (T.tag === j) {
            var F = T.stateNode;
            if (y && x) {
              var k = T.memoizedProps, J = T.type;
              F = Pg(F, J, k, T);
            }
            Jd(l, F);
          } else if (T.tag === G) {
            var re = T.stateNode;
            if (y && x) {
              var me = T.memoizedProps;
              re = Yh(re, me, T);
            }
            Jd(l, re);
          } else if (T.tag !== H) {
            if (T.tag === ve && T.memoizedState !== null) {
              var we = T.child;
              we !== null && (we.return = T), AD(l, T, !0, !0);
            } else if (T.child !== null) {
              T.child.return = T, T = T.child;
              continue;
            }
          }
          if (T = T, T === c)
            return;
          for (; T.sibling === null; ) {
            if (T.return === null || T.return === c)
              return;
            T = T.return;
          }
          T.sibling.return = T.return, T = T.sibling;
        }
      };
      Rv = function(l, c) {
        var y = c.stateNode, x = RD(l, c);
        if (!x) {
          var T = y.containerInfo, F = Qd(T);
          AD(F, c, !1, !1), y.pendingChildren = F, Yl(c), Au(T, F);
        }
      }, kb = function(l, c, y, x, T) {
        var F = l.stateNode, k = l.memoizedProps, J = RD(l, c);
        if (J && k === x) {
          c.stateNode = F;
          return;
        }
        var re = c.stateNode, me = yv(), we = null;
        if (k !== x && (we = Sr(re, y, k, x, T, me)), J && we === null) {
          c.stateNode = F;
          return;
        }
        var qe = jo(F, we, y, k, x, c, J, re);
        Fr(qe, y, x, T, me) && Yl(c), c.stateNode = qe, J ? Yl(c) : Tv(qe, c, !1, !1);
      }, $b = function(l, c, y, x) {
        if (y !== x) {
          var T = qC(), F = yv();
          c.stateNode = fa(x, T, F, c), Yl(c);
        } else
          c.stateNode = l.stateNode;
      };
    } else
      Rv = function(l, c) {
      }, kb = function(l, c, y, x, T) {
      }, $b = function(l, c, y, x) {
      };
    function Av(l, c) {
      if (!za())
        switch (l.tailMode) {
          case "hidden": {
            for (var y = l.tail, x = null; y !== null; )
              y.alternate !== null && (x = y), y = y.sibling;
            x === null ? l.tail = null : x.sibling = null;
            break;
          }
          case "collapsed": {
            for (var T = l.tail, F = null; T !== null; )
              T.alternate !== null && (F = T), T = T.sibling;
            F === null ? !c && l.tail !== null ? l.tail.sibling = null : l.tail = null : F.sibling = null;
            break;
          }
        }
    }
    function wa(l) {
      var c = l.alternate !== null && l.alternate.child === l.child, y = wt, x = De;
      if (c) {
        if ((l.mode & lr) !== An) {
          for (var re = l.selfBaseDuration, me = l.child; me !== null; )
            y = Ln(y, Ln(me.lanes, me.childLanes)), x |= me.subtreeFlags & Lt, x |= me.flags & Lt, re += me.treeBaseDuration, me = me.sibling;
          l.treeBaseDuration = re;
        } else
          for (var we = l.child; we !== null; )
            y = Ln(y, Ln(we.lanes, we.childLanes)), x |= we.subtreeFlags & Lt, x |= we.flags & Lt, we.return = l, we = we.sibling;
        l.subtreeFlags |= x;
      } else {
        if ((l.mode & lr) !== An) {
          for (var T = l.actualDuration, F = l.selfBaseDuration, k = l.child; k !== null; )
            y = Ln(y, Ln(k.lanes, k.childLanes)), x |= k.subtreeFlags, x |= k.flags, T += k.actualDuration, F += k.treeBaseDuration, k = k.sibling;
          l.actualDuration = T, l.treeBaseDuration = F;
        } else
          for (var J = l.child; J !== null; )
            y = Ln(y, Ln(J.lanes, J.childLanes)), x |= J.subtreeFlags, x |= J.flags, J.return = l, J = J.sibling;
        l.subtreeFlags |= x;
      }
      return l.childLanes = y, c;
    }
    function OD(l, c, y) {
      var x = c.pendingProps;
      switch (UC(c), c.tag) {
        case L:
        case ce:
        case ne:
        case I:
        case B:
        case X:
        case ae:
        case Q:
        case Z:
        case q:
          return wa(c), null;
        case U: {
          var T = c.type;
          return wo(T) && Bu(c), wa(c), null;
        }
        case N: {
          var F = c.stateNode;
          if (Fp(c), lf(c), ew(), F.pendingContext && (F.context = F.pendingContext, F.pendingContext = null), l === null || l.child === null) {
            var k = pv(c);
            if (k)
              Yl(c);
            else if (l !== null) {
              var J = l.memoizedState;
              // Check if this is a client root
              (!J.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (c.flags & Ct) !== De) && (c.flags |= Nn, VP());
            }
          }
          return Rv(l, c), wa(c), null;
        }
        case j: {
          KC(c);
          var re = qC(), me = c.type;
          if (l !== null && c.stateNode != null)
            kb(l, c, me, x, re), l.ref !== c.ref && TD(c);
          else {
            if (!x) {
              if (c.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return wa(c), null;
            }
            var we = yv(), qe = pv(c);
            if (qe)
              g5(c, re, we) && Yl(c);
            else {
              var at = qr(me, x, re, we, c);
              Tv(at, c, !1, !1), c.stateNode = at, Fr(at, me, x, re, we) && Yl(c);
            }
            c.ref !== null && TD(c);
          }
          return wa(c), null;
        }
        case G: {
          var dt = x;
          if (l && c.stateNode != null) {
            var At = l.memoizedProps;
            $b(l, c, At, dt);
          } else {
            if (typeof dt != "string" && c.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Dt = qC(), yn = yv(), Un = pv(c);
            Un ? v5(c) && Yl(c) : c.stateNode = fa(dt, Dt, yn, c);
          }
          return wa(c), null;
        }
        case V: {
          zp(c);
          var En = c.memoizedState;
          {
            if (S5() && (c.mode & _r) !== An && (c.flags & lt) === De)
              return HP(c), Np(), c.flags |= Ct | ge | it, c;
            if (En !== null && En.dehydrated !== null) {
              var ii = pv(c);
              if (l === null) {
                if (!ii)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (y5(c), wa(c), (c.mode & lr) !== An) {
                  var ai = En !== null;
                  if (ai) {
                    var Je = c.child;
                    Je !== null && (c.treeBaseDuration -= Je.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (Np(), (c.flags & lt) === De && (c.memoizedState = null), c.flags |= He, wa(c), (c.mode & lr) !== An) {
                  var mt = En !== null;
                  if (mt) {
                    var Ke = c.child;
                    Ke !== null && (c.treeBaseDuration -= Ke.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            VP();
          }
          if ((c.flags & lt) !== De)
            return c.lanes = y, (c.mode & lr) !== An && Ew(c), c;
          var Ut = En !== null, mn = !1;
          if (l === null)
            pv(c);
          else {
            var rn = l.memoizedState;
            mn = rn !== null;
          }
          if (Ut && !mn) {
            var nr = c.child;
            if (nr.flags |= Qt, (c.mode & _r) !== An) {
              var xr = l === null && (c.memoizedProps.unstable_avoidThisFallback !== !0 || !w);
              xr || ZC(sl.current, qP) ? NW() : i1();
            }
          }
          var Zr = c.updateQueue;
          if (Zr !== null && (c.flags |= He), wa(c), (c.mode & lr) !== An && Ut) {
            var Er = c.child;
            Er !== null && (c.treeBaseDuration -= Er.treeBaseDuration);
          }
          return null;
        }
        case H:
          return Fp(c), Rv(l, c), l === null && bo(c.stateNode.containerInfo), wa(c), null;
        case K:
          var bi = c.type._context;
          return W(bi, c), wa(c), null;
        case ie: {
          var fr = c.type;
          return wo(fr) && Bu(c), wa(c), null;
        }
        case he: {
          zp(c);
          var er = c.memoizedState;
          if (er === null)
            return wa(c), null;
          var zi = (c.flags & lt) !== De, Si = er.rendering;
          if (Si === null)
            if (zi)
              Av(er, !1);
            else {
              var zs = FW() && (l === null || (l.flags & lt) === De);
              if (!zs)
                for (var Ra = c.child; Ra !== null; ) {
                  var ns = _b(Ra);
                  if (ns !== null) {
                    zi = !0, c.flags |= lt, Av(er, !1);
                    var rs = ns.updateQueue;
                    return rs !== null && (c.updateQueue = rs, c.flags |= He), c.subtreeFlags = De, x5(c, y), dd(c, QC(sl.current, bv)), c.child;
                  }
                  Ra = Ra.sibling;
                }
              er.tail !== null && hi() > CI() && (c.flags |= lt, zi = !0, Av(er, !1), c.lanes = ju);
            }
          else {
            if (!zi) {
              var Ql = _b(Si);
              if (Ql !== null) {
                c.flags |= lt, zi = !0;
                var Kp = Ql.updateQueue;
                if (Kp !== null && (c.updateQueue = Kp, c.flags |= He), Av(er, !0), er.tail === null && er.tailMode === "hidden" && !Si.alternate && !za())
                  return wa(c), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              hi() * 2 - er.renderingStartTime > CI() && y !== Rr && (c.flags |= lt, zi = !0, Av(er, !1), c.lanes = ju);
            }
            if (er.isBackwards)
              Si.sibling = c.child, c.child = Si;
            else {
              var Zp = er.last;
              Zp !== null ? Zp.sibling = Si : c.child = Si, er.last = Si;
            }
          }
          if (er.tail !== null) {
            var is = er.tail;
            er.rendering = is, er.tail = is.sibling, er.renderingStartTime = hi(), is.sibling = null;
            var zf = sl.current;
            return zi ? zf = QC(zf, bv) : zf = Up(zf), dd(c, zf), is;
          }
          return wa(c), null;
        }
        case le:
          break;
        case ve:
        case Ne: {
          r1(c);
          var x1 = c.memoizedState, gN = x1 !== null;
          if (l !== null) {
            var N8 = l.memoizedState, L8 = N8 !== null;
            L8 !== gN && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !_ && (c.flags |= Qt);
          }
          return !gN || (c.mode & _r) === An ? wa(c) : fi(Kl, Rr) && (wa(c), ha && c.subtreeFlags & (We | He) && (c.flags |= Qt)), null;
        }
        case xe:
          return null;
        case Me:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + c.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var Ov = a.ReactCurrentOwner, cl = !1, Mw, Pv, Tw, Rw, Aw, Df, Ow, Wb;
    Mw = {}, Pv = {}, Tw = {}, Rw = {}, Aw = {}, Df = !1, Ow = {}, Wb = {};
    function ao(l, c, y, x) {
      l === null ? c.child = jP(c, null, y, x) : c.child = Lp(c, l.child, y, x);
    }
    function W5(l, c, y, x) {
      c.child = Lp(c, l.child, null, x), c.child = Lp(c, null, y, x);
    }
    function PD(l, c, y, x, T) {
      if (c.type !== c.elementType) {
        var F = y.propTypes;
        F && eo(
          F,
          x,
          // Resolved props
          "prop",
          st(y)
        );
      }
      var k = y.render, J = c.ref, re, me;
      Ot(c, T), Rs(c);
      {
        if (Ov.current = c, As(!0), re = kp(l, c, k, x, J, T), me = $p(), c.mode & di) {
          ar(!0);
          try {
            re = kp(l, c, k, x, J, T), me = $p();
          } finally {
            ar(!1);
          }
        }
        As(!1);
      }
      return il(), l !== null && !cl ? (YP(l, c, T), kc(l, c, T)) : (za() && me && FC(c), c.flags |= Ge, ao(l, c, re, T), c.child);
    }
    function DD(l, c, y, x, T) {
      if (l === null) {
        var F = y.type;
        if (c8(F) && y.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        y.defaultProps === void 0) {
          var k = F;
          return k = Yp(F), c.tag = ne, c.type = k, Iw(c, F), ID(l, c, k, x, T);
        }
        {
          var J = F.propTypes;
          J && eo(
            J,
            x,
            // Resolved props
            "prop",
            st(F)
          );
        }
        var re = p1(y.type, null, x, c, c.mode, T);
        return re.ref = c.ref, re.return = c, c.child = re, re;
      }
      {
        var me = y.type, we = me.propTypes;
        we && eo(
          we,
          x,
          // Resolved props
          "prop",
          st(me)
        );
      }
      var qe = l.child, at = Uw(l, T);
      if (!at) {
        var dt = qe.memoizedProps, At = y.compare;
        if (At = At !== null ? At : Nc, At(dt, x) && l.ref === c.ref)
          return kc(l, c, T);
      }
      c.flags |= Ge;
      var Dt = Uf(qe, x);
      return Dt.ref = c.ref, Dt.return = c, c.child = Dt, Dt;
    }
    function ID(l, c, y, x, T) {
      if (c.type !== c.elementType) {
        var F = c.elementType;
        if (F.$$typeof === Oe) {
          var k = F, J = k._payload, re = k._init;
          try {
            F = re(J);
          } catch {
            F = null;
          }
          var me = F && F.propTypes;
          me && eo(
            me,
            x,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            st(F)
          );
        }
      }
      if (l !== null) {
        var we = l.memoizedProps;
        if (Nc(we, x) && l.ref === c.ref && // Prevent bailout if the implementation changed due to hot reload.
        c.type === l.type)
          if (cl = !1, Uw(l, T))
            (l.flags & yt) !== De && (cl = !0);
          else return c.lanes = l.lanes, kc(l, c, T);
      }
      return Pw(l, c, y, x, T);
    }
    function ND(l, c, y) {
      var x = c.pendingProps, T = x.children, F = l !== null ? l.memoizedState : null;
      if (x.mode === "hidden" || _)
        if ((c.mode & _r) === An) {
          var k = {
            baseLanes: wt,
            cachePool: null
          };
          c.memoizedState = k, gS(c, y);
        } else if (fi(y, Rr)) {
          var qe = {
            baseLanes: wt,
            cachePool: null
          };
          c.memoizedState = qe;
          var at = F !== null ? F.baseLanes : y;
          gS(c, at);
        } else {
          var J = null, re;
          if (F !== null) {
            var me = F.baseLanes;
            re = Ln(me, y);
          } else
            re = y;
          c.lanes = c.childLanes = Rr;
          var we = {
            baseLanes: re,
            cachePool: J
          };
          return c.memoizedState = we, c.updateQueue = null, gS(c, re), null;
        }
      else {
        var dt;
        F !== null ? (dt = Ln(F.baseLanes, y), c.memoizedState = null) : dt = y, gS(c, dt);
      }
      return ao(l, c, T, y), c.child;
    }
    function j5(l, c, y) {
      var x = c.pendingProps;
      return ao(l, c, x, y), c.child;
    }
    function G5(l, c, y) {
      var x = c.pendingProps.children;
      return ao(l, c, x, y), c.child;
    }
    function X5(l, c, y) {
      {
        c.flags |= He;
        {
          var x = c.stateNode;
          x.effectDuration = 0, x.passiveEffectDuration = 0;
        }
      }
      var T = c.pendingProps, F = T.children;
      return ao(l, c, F, y), c.child;
    }
    function LD(l, c) {
      var y = c.ref;
      (l === null && y !== null || l !== null && l.ref !== y) && (c.flags |= un, c.flags |= Sn);
    }
    function Pw(l, c, y, x, T) {
      if (c.type !== c.elementType) {
        var F = y.propTypes;
        F && eo(
          F,
          x,
          // Resolved props
          "prop",
          st(y)
        );
      }
      var k;
      {
        var J = xs(c, y, !0);
        k = zu(c, J);
      }
      var re, me;
      Ot(c, T), Rs(c);
      {
        if (Ov.current = c, As(!0), re = kp(l, c, y, x, k, T), me = $p(), c.mode & di) {
          ar(!0);
          try {
            re = kp(l, c, y, x, k, T), me = $p();
          } finally {
            ar(!1);
          }
        }
        As(!1);
      }
      return il(), l !== null && !cl ? (YP(l, c, T), kc(l, c, T)) : (za() && me && FC(c), c.flags |= Ge, ao(l, c, re, T), c.child);
    }
    function FD(l, c, y, x, T) {
      {
        switch (QI(c)) {
          case !1: {
            var F = c.stateNode, k = c.type, J = new k(c.memoizedProps, F.context), re = J.state;
            F.updater.enqueueSetState(F, re, null);
            break;
          }
          case !0: {
            c.flags |= lt, c.flags |= it;
            var me = new Error("Simulated error coming from DevTools"), we = qu(T);
            c.lanes = Ln(c.lanes, we);
            var qe = ww(c, Vb(me, c), we);
            or(c, qe);
            break;
          }
        }
        if (c.type !== c.elementType) {
          var at = y.propTypes;
          at && eo(
            at,
            x,
            // Resolved props
            "prop",
            st(y)
          );
        }
      }
      var dt;
      wo(y) ? (dt = !0, Cs(c)) : dt = !1, Ot(c, T);
      var At = c.stateNode, Dt;
      At === null ? (l !== null && (l.alternate = null, c.alternate = null, c.flags |= We), DP(c, y, x), LC(c, y, x, T), Dt = !0) : l === null ? Dt = i5(c, y, x, T) : Dt = a5(l, c, y, x, T);
      var yn = Dw(l, c, y, Dt, dt, T);
      {
        var Un = c.stateNode;
        Dt && Un.props !== x && (Df || d("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", ue(c) || "a component"), Df = !0);
      }
      return yn;
    }
    function Dw(l, c, y, x, T, F) {
      LD(l, c);
      var k = (c.flags & lt) !== De;
      if (!x && !k)
        return T && cf(c, y, !1), kc(l, c, F);
      var J = c.stateNode;
      Ov.current = c;
      var re;
      if (k && typeof y.getDerivedStateFromError != "function")
        re = null, xD();
      else {
        Rs(c);
        {
          if (As(!0), re = J.render(), c.mode & di) {
            ar(!0);
            try {
              J.render();
            } finally {
              ar(!1);
            }
          }
          As(!1);
        }
        il();
      }
      return c.flags |= Ge, l !== null && k ? W5(l, c, re, F) : ao(l, c, re, F), c.memoizedState = J.state, T && cf(c, y, !0), c.child;
    }
    function UD(l) {
      var c = l.stateNode;
      c.pendingContext ? Es(l, c.pendingContext, c.pendingContext !== c.context) : c.context && Es(l, c.context, !1), YC(l, c.containerInfo);
    }
    function q5(l, c, y) {
      if (UD(c), l === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var x = c.pendingProps, T = c.memoizedState, F = T.element;
      Fn(l, c), Pp(c, x, null, y);
      var k = c.memoizedState;
      c.stateNode;
      var J = k.element;
      if (ri && T.isDehydrated) {
        var re = {
          element: J,
          isDehydrated: !1,
          cache: k.cache,
          transitions: k.transitions
        }, me = c.updateQueue;
        if (me.baseState = re, c.memoizedState = re, c.flags & Ct) {
          var we = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return zD(l, c, J, y, we);
        } else if (J !== F) {
          var qe = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return zD(l, c, J, y, qe);
        } else {
          p5(c);
          var at = jP(c, null, J, y);
          c.child = at;
          for (var dt = at; dt; )
            dt.flags = dt.flags & ~We | Pt, dt = dt.sibling;
        }
      } else {
        if (Np(), J === F)
          return kc(l, c, y);
        ao(l, c, J, y);
      }
      return c.child;
    }
    function zD(l, c, y, x, T) {
      return Np(), kC(T), c.flags |= Ct, ao(l, c, y, x), c.child;
    }
    function Y5(l, c, y) {
      GP(c), l === null && VC(c);
      var x = c.type, T = c.pendingProps, F = l !== null ? l.memoizedProps : null, k = T.children, J = Oi(x, T);
      return J ? k = null : F !== null && Oi(x, F) && (c.flags |= _t), LD(l, c), ao(l, c, k, y), c.child;
    }
    function K5(l, c) {
      return l === null && VC(c), null;
    }
    function Z5(l, c, y, x) {
      l !== null && (l.alternate = null, c.alternate = null, c.flags |= We);
      var T = c.pendingProps, F = y, k = F._payload, J = F._init, re = J(k);
      c.type = re;
      var me = c.tag = u8(re), we = Po(re, T), qe;
      switch (me) {
        case I:
          return Iw(c, re), c.type = re = Yp(re), qe = Pw(null, c, re, we, x), qe;
        case U:
          return c.type = re = l1(re), qe = FD(null, c, re, we, x), qe;
        case B:
          return c.type = re = c1(re), qe = PD(null, c, re, we, x), qe;
        case q: {
          if (c.type !== c.elementType) {
            var at = re.propTypes;
            at && eo(
              at,
              we,
              // Resolved for outer only
              "prop",
              st(re)
            );
          }
          return qe = DD(
            null,
            c,
            re,
            Po(re.type, we),
            // The inner type can have defaults too
            x
          ), qe;
        }
      }
      var dt = "";
      throw re !== null && typeof re == "object" && re.$$typeof === Oe && (dt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + re + ". " + ("Lazy element type must resolve to a class or function." + dt));
    }
    function Q5(l, c, y, x, T) {
      l !== null && (l.alternate = null, c.alternate = null, c.flags |= We), c.tag = U;
      var F;
      return wo(y) ? (F = !0, Cs(c)) : F = !1, Ot(c, T), DP(c, y, x), LC(c, y, x, T), Dw(null, c, y, !0, F, T);
    }
    function J5(l, c, y, x) {
      l !== null && (l.alternate = null, c.alternate = null, c.flags |= We);
      var T = c.pendingProps, F;
      {
        var k = xs(c, y, !1);
        F = zu(c, k);
      }
      Ot(c, x);
      var J, re;
      Rs(c);
      {
        if (y.prototype && typeof y.prototype.render == "function") {
          var me = st(y) || "Unknown";
          Mw[me] || (d("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", me, me), Mw[me] = !0);
        }
        c.mode & di && Oo.recordLegacyContextWarning(c, null), As(!0), Ov.current = c, J = kp(null, c, y, T, F, x), re = $p(), As(!1);
      }
      if (il(), c.flags |= Ge, typeof J == "object" && J !== null && typeof J.render == "function" && J.$$typeof === void 0) {
        var we = st(y) || "Unknown";
        Pv[we] || (d("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", we, we, we), Pv[we] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof J == "object" && J !== null && typeof J.render == "function" && J.$$typeof === void 0
      ) {
        {
          var qe = st(y) || "Unknown";
          Pv[qe] || (d("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", qe, qe, qe), Pv[qe] = !0);
        }
        c.tag = U, c.memoizedState = null, c.updateQueue = null;
        var at = !1;
        return wo(y) ? (at = !0, Cs(c)) : at = !1, c.memoizedState = J.state !== null && J.state !== void 0 ? J.state : null, dn(c), PP(c, J), LC(c, y, T, x), Dw(null, c, y, !0, at, x);
      } else {
        if (c.tag = I, c.mode & di) {
          ar(!0);
          try {
            J = kp(null, c, y, T, F, x), re = $p();
          } finally {
            ar(!1);
          }
        }
        return za() && re && FC(c), ao(null, c, J, x), Iw(c, y), c.child;
      }
    }
    function Iw(l, c) {
      {
        if (c && c.childContextTypes && d("%s(...): childContextTypes cannot be defined on a function component.", c.displayName || c.name || "Component"), l.ref !== null) {
          var y = "", x = _C();
          x && (y += `

Check the render method of \`` + x + "`.");
          var T = x || "", F = l._debugSource;
          F && (T = F.fileName + ":" + F.lineNumber), Aw[T] || (Aw[T] = !0, d("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", y));
        }
        if (typeof c.getDerivedStateFromProps == "function") {
          var k = st(c) || "Unknown";
          Rw[k] || (d("%s: Function components do not support getDerivedStateFromProps.", k), Rw[k] = !0);
        }
        if (typeof c.contextType == "object" && c.contextType !== null) {
          var J = st(c) || "Unknown";
          Tw[J] || (d("%s: Function components do not support contextType.", J), Tw[J] = !0);
        }
      }
    }
    var jb = {
      dehydrated: null,
      treeContext: null,
      retryLane: Ni
    };
    function Gb(l) {
      return {
        baseLanes: l,
        cachePool: $5()
      };
    }
    function BD(l, c) {
      var y = null;
      return {
        baseLanes: Ln(l.baseLanes, c),
        cachePool: y
      };
    }
    function e6(l, c, y, x) {
      if (c !== null) {
        var T = c.memoizedState;
        if (T === null)
          return !1;
      }
      return ZC(l, bv);
    }
    function HD(l, c) {
      return Rc(l.childLanes, c);
    }
    function VD(l, c, y) {
      var x = c.pendingProps;
      eN(c) && (c.flags |= lt);
      var T = sl.current, F = !1, k = (c.flags & lt) !== De;
      if (k || e6(T, l) ? (F = !0, c.flags &= ~lt) : (l === null || l.memoizedState !== null) && (T = C5(T, qP)), T = Up(T), dd(c, T), l === null) {
        VC(c);
        {
          var J = c.memoizedState;
          if (J !== null) {
            var re = J.dehydrated;
            if (re !== null)
              return r6(c, re);
          }
        }
        var me = x.children, we = x.fallback;
        if (F) {
          var qe = t6(c, me, we, y), at = c.child;
          return at.memoizedState = Gb(y), c.memoizedState = jb, qe;
        } else
          return Nw(c, me);
      } else {
        var dt = l.memoizedState;
        if (dt !== null) {
          {
            var At = dt.dehydrated;
            if (At !== null)
              if (k) {
                if (c.flags & Ct)
                  return c.flags &= ~Ct, Xb(l, c, y, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (c.memoizedState !== null)
                  return c.child = l.child, c.flags |= lt, null;
                var Dt = x.children, yn = x.fallback, Un = n6(l, c, Dt, yn, y), En = c.child;
                return En.memoizedState = Gb(y), c.memoizedState = jb, Un;
              } else return i6(l, c, At, dt, y);
          }
          if (F) {
            var ii = x.fallback, ai = x.children, Je = WD(l, c, ai, ii, y), mt = c.child, Ke = l.child.memoizedState;
            return mt.memoizedState = Ke === null ? Gb(y) : BD(Ke, y), mt.childLanes = HD(l, y), c.memoizedState = jb, Je;
          } else {
            var Ut = x.children, mn = $D(l, c, Ut, y);
            return c.memoizedState = null, mn;
          }
        } else if (F) {
          var rn = x.fallback, nr = x.children, xr = WD(l, c, nr, rn, y), Zr = c.child, Er = l.child.memoizedState;
          return Zr.memoizedState = Er === null ? Gb(y) : BD(Er, y), Zr.childLanes = HD(l, y), c.memoizedState = jb, xr;
        } else {
          var bi = x.children, fr = $D(l, c, bi, y);
          return c.memoizedState = null, fr;
        }
      }
    }
    function Nw(l, c, y) {
      var x = l.mode, T = {
        mode: "visible",
        children: c
      }, F = Lw(T, x);
      return F.return = l, l.child = F, F;
    }
    function t6(l, c, y, x) {
      var T = l.mode, F = l.child, k = {
        mode: "hidden",
        children: c
      }, J, re;
      return (T & _r) === An && F !== null ? (J = F, J.childLanes = wt, J.pendingProps = k, l.mode & lr && (J.actualDuration = 0, J.actualStartTime = -1, J.selfBaseDuration = 0, J.treeBaseDuration = 0), re = yd(y, T, x, null)) : (J = Lw(k, T), re = yd(y, T, x, null)), J.return = l, re.return = l, J.sibling = re, l.child = J, re;
    }
    function Lw(l, c, y) {
      return jI(l, c, wt, null);
    }
    function kD(l, c) {
      return Uf(l, c);
    }
    function $D(l, c, y, x) {
      var T = l.child, F = T.sibling, k = kD(T, {
        mode: "visible",
        children: y
      });
      if ((c.mode & _r) === An && (k.lanes = x), k.return = c, k.sibling = null, F !== null) {
        var J = c.deletions;
        J === null ? (c.deletions = [F], c.flags |= vt) : J.push(F);
      }
      return c.child = k, k;
    }
    function WD(l, c, y, x, T) {
      var F = c.mode, k = l.child, J = k.sibling, re = {
        mode: "hidden",
        children: y
      }, me;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (F & _r) === An && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        c.child !== k
      ) {
        var we = c.child;
        me = we, me.childLanes = wt, me.pendingProps = re, c.mode & lr && (me.actualDuration = 0, me.actualStartTime = -1, me.selfBaseDuration = k.selfBaseDuration, me.treeBaseDuration = k.treeBaseDuration), c.deletions = null;
      } else
        me = kD(k, re), me.subtreeFlags = k.subtreeFlags & Lt;
      var qe;
      return J !== null ? qe = Uf(J, x) : (qe = yd(x, F, T, null), qe.flags |= We), qe.return = c, me.return = c, me.sibling = qe, c.child = me, qe;
    }
    function Xb(l, c, y, x) {
      x !== null && kC(x), Lp(c, l.child, null, y);
      var T = c.pendingProps, F = T.children, k = Nw(c, F);
      return k.flags |= We, c.memoizedState = null, k;
    }
    function n6(l, c, y, x, T) {
      var F = c.mode, k = {
        mode: "visible",
        children: y
      }, J = Lw(k, F), re = yd(x, F, T, null);
      return re.flags |= We, J.return = c, re.return = c, J.sibling = re, c.child = J, (c.mode & _r) !== An && Lp(c, l.child, null, T), re;
    }
    function r6(l, c, y) {
      return (l.mode & _r) === An ? (d("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), l.lanes = Jn) : Ss(c) ? l.lanes = tl : l.lanes = Rr, null;
    }
    function i6(l, c, y, x, T) {
      if (f5(), (c.mode & _r) === An)
        return Xb(
          l,
          c,
          T,
          // TODO: When we delete legacy mode, we should make this error argument
          // required  every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (Ss(y))
        return Xb(
          l,
          c,
          T,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var F = fi(T, l.childLanes);
      if (cl || F) {
        var k = hS();
        if (k !== null) {
          var J = Kg(k, T);
          if (J !== Ni && J !== x.retryLane) {
            x.retryLane = J;
            var re = Vr;
            oa(l, J, re);
          }
        }
        return i1(), Xb(l, c, T, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (Go(y)) {
        c.flags |= lt, c.child = l.child;
        var me = XW.bind(null, l);
        return Ig(y, me), null;
      } else {
        m5(c, y, x.treeContext);
        var we = c.pendingProps, qe = we.children, at = Nw(c, qe);
        return at.flags |= Pt, at;
      }
    }
    function jD(l, c, y) {
      l.lanes = Ln(l.lanes, c);
      var x = l.alternate;
      x !== null && (x.lanes = Ln(x.lanes, c)), fe(l.return, c, y);
    }
    function a6(l, c, y) {
      for (var x = c; x !== null; ) {
        if (x.tag === V) {
          var T = x.memoizedState;
          T !== null && jD(x, y, l);
        } else if (x.tag === he)
          jD(x, y, l);
        else if (x.child !== null) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === l)
          return;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === l)
            return;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }
    function o6(l) {
      for (var c = l, y = null; c !== null; ) {
        var x = c.alternate;
        x !== null && _b(x) === null && (y = c), c = c.sibling;
      }
      return y;
    }
    function s6(l) {
      if (l !== void 0 && l !== "forwards" && l !== "backwards" && l !== "together" && !Ow[l])
        if (Ow[l] = !0, typeof l == "string")
          switch (l.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              d('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', l, l.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              d('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', l, l.toLowerCase());
              break;
            }
            default:
              d('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', l);
              break;
          }
        else
          d('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', l);
    }
    function l6(l, c) {
      l !== void 0 && !Wb[l] && (l !== "collapsed" && l !== "hidden" ? (Wb[l] = !0, d('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', l)) : c !== "forwards" && c !== "backwards" && (Wb[l] = !0, d('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', l)));
    }
    function GD(l, c) {
      {
        var y = Tn(l), x = !y && typeof Ue(l) == "function";
        if (y || x) {
          var T = y ? "array" : "iterable";
          return d("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", T, c, T), !1;
        }
      }
      return !0;
    }
    function c6(l, c) {
      if ((c === "forwards" || c === "backwards") && l !== void 0 && l !== null && l !== !1)
        if (Tn(l)) {
          for (var y = 0; y < l.length; y++)
            if (!GD(l[y], y))
              return;
        } else {
          var x = Ue(l);
          if (typeof x == "function") {
            var T = x.call(l);
            if (T)
              for (var F = T.next(), k = 0; !F.done; F = T.next()) {
                if (!GD(F.value, k))
                  return;
                k++;
              }
          } else
            d('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', c);
        }
    }
    function Fw(l, c, y, x, T) {
      var F = l.memoizedState;
      F === null ? l.memoizedState = {
        isBackwards: c,
        rendering: null,
        renderingStartTime: 0,
        last: x,
        tail: y,
        tailMode: T
      } : (F.isBackwards = c, F.rendering = null, F.renderingStartTime = 0, F.last = x, F.tail = y, F.tailMode = T);
    }
    function XD(l, c, y) {
      var x = c.pendingProps, T = x.revealOrder, F = x.tail, k = x.children;
      s6(T), l6(F, T), c6(k, T), ao(l, c, k, y);
      var J = sl.current, re = ZC(J, bv);
      if (re)
        J = QC(J, bv), c.flags |= lt;
      else {
        var me = l !== null && (l.flags & lt) !== De;
        me && a6(c, c.child, y), J = Up(J);
      }
      if (dd(c, J), (c.mode & _r) === An)
        c.memoizedState = null;
      else
        switch (T) {
          case "forwards": {
            var we = o6(c.child), qe;
            we === null ? (qe = c.child, c.child = null) : (qe = we.sibling, we.sibling = null), Fw(
              c,
              !1,
              // isBackwards
              qe,
              we,
              F
            );
            break;
          }
          case "backwards": {
            var at = null, dt = c.child;
            for (c.child = null; dt !== null; ) {
              var At = dt.alternate;
              if (At !== null && _b(At) === null) {
                c.child = dt;
                break;
              }
              var Dt = dt.sibling;
              dt.sibling = at, at = dt, dt = Dt;
            }
            Fw(
              c,
              !0,
              // isBackwards
              at,
              null,
              // last
              F
            );
            break;
          }
          case "together": {
            Fw(
              c,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            c.memoizedState = null;
        }
      return c.child;
    }
    function u6(l, c, y) {
      YC(c, c.stateNode.containerInfo);
      var x = c.pendingProps;
      return l === null ? c.child = Lp(c, null, x, y) : ao(l, c, x, y), c.child;
    }
    var qD = !1;
    function d6(l, c, y) {
      var x = c.type, T = x._context, F = c.pendingProps, k = c.memoizedProps, J = F.value;
      {
        "value" in F || qD || (qD = !0, d("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var re = c.type.propTypes;
        re && eo(re, F, "prop", "Context.Provider");
      }
      if (z(c, T, J), k !== null) {
        var me = k.value;
        if (ro(me, J)) {
          if (k.children === F.children && !Ii())
            return kc(l, c, y);
        } else
          Le(c, T, y);
      }
      var we = F.children;
      return ao(l, c, we, y), c.child;
    }
    var YD = !1;
    function f6(l, c, y) {
      var x = c.type;
      x._context === void 0 ? x !== x.Consumer && (YD || (YD = !0, d("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : x = x._context;
      var T = c.pendingProps, F = T.children;
      typeof F != "function" && d("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Ot(c, y);
      var k = Vt(x);
      Rs(c);
      var J;
      return Ov.current = c, As(!0), J = F(k), As(!1), il(), c.flags |= Ge, ao(l, c, J, y), c.child;
    }
    function qb() {
      cl = !0;
    }
    function kc(l, c, y) {
      return l !== null && (c.dependencies = l.dependencies), xD(), vS(c.lanes), fi(y, c.childLanes) ? (_5(l, c), c.child) : null;
    }
    function h6(l, c, y) {
      {
        var x = c.return;
        if (x === null)
          throw new Error("Cannot swap the root fiber.");
        if (l.alternate = null, c.alternate = null, y.index = c.index, y.sibling = c.sibling, y.return = c.return, y.ref = c.ref, c === x.child)
          x.child = y;
        else {
          var T = x.child;
          if (T === null)
            throw new Error("Expected parent to have a child.");
          for (; T.sibling !== c; )
            if (T = T.sibling, T === null)
              throw new Error("Expected to find the previous sibling.");
          T.sibling = y;
        }
        var F = x.deletions;
        return F === null ? (x.deletions = [l], x.flags |= vt) : F.push(l), y.flags |= We, y;
      }
    }
    function Uw(l, c) {
      var y = l.lanes;
      return !!fi(y, c);
    }
    function p6(l, c, y) {
      switch (c.tag) {
        case N:
          UD(c), c.stateNode, Np();
          break;
        case j:
          GP(c);
          break;
        case U: {
          var x = c.type;
          wo(x) && Cs(c);
          break;
        }
        case H:
          YC(c, c.stateNode.containerInfo);
          break;
        case K: {
          var T = c.memoizedProps.value, F = c.type._context;
          z(c, F, T);
          break;
        }
        case Q:
          {
            var k = fi(y, c.childLanes);
            k && (c.flags |= He);
            {
              var J = c.stateNode;
              J.effectDuration = 0, J.passiveEffectDuration = 0;
            }
          }
          break;
        case V: {
          var re = c.memoizedState;
          if (re !== null) {
            if (re.dehydrated !== null)
              return dd(c, Up(sl.current)), c.flags |= lt, null;
            var me = c.child, we = me.childLanes;
            if (fi(y, we))
              return VD(l, c, y);
            dd(c, Up(sl.current));
            var qe = kc(l, c, y);
            return qe !== null ? qe.sibling : null;
          } else
            dd(c, Up(sl.current));
          break;
        }
        case he: {
          var at = (l.flags & lt) !== De, dt = fi(y, c.childLanes);
          if (at) {
            if (dt)
              return XD(l, c, y);
            c.flags |= lt;
          }
          var At = c.memoizedState;
          if (At !== null && (At.rendering = null, At.tail = null, At.lastEffect = null), dd(c, sl.current), dt)
            break;
          return null;
        }
        case ve:
        case Ne:
          return c.lanes = wt, ND(l, c, y);
      }
      return kc(l, c, y);
    }
    function KD(l, c, y) {
      if (c._debugNeedsRemount && l !== null)
        return h6(l, c, p1(c.type, c.key, c.pendingProps, c._debugOwner || null, c.mode, c.lanes));
      if (l !== null) {
        var x = l.memoizedProps, T = c.pendingProps;
        if (x !== T || Ii() || // Force a re-render if the implementation changed due to hot reload:
        c.type !== l.type)
          cl = !0;
        else {
          var F = Uw(l, y);
          if (!F && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (c.flags & lt) === De)
            return cl = !1, p6(l, c, y);
          (l.flags & yt) !== De ? cl = !0 : cl = !1;
        }
      } else if (cl = !1, za() && o5(c)) {
        var k = c.index, J = s5();
        NP(c, J, k);
      }
      switch (c.lanes = wt, c.tag) {
        case L:
          return J5(l, c, c.type, y);
        case ce: {
          var re = c.elementType;
          return Z5(l, c, re, y);
        }
        case I: {
          var me = c.type, we = c.pendingProps, qe = c.elementType === me ? we : Po(me, we);
          return Pw(l, c, me, qe, y);
        }
        case U: {
          var at = c.type, dt = c.pendingProps, At = c.elementType === at ? dt : Po(at, dt);
          return FD(l, c, at, At, y);
        }
        case N:
          return q5(l, c, y);
        case j:
          return Y5(l, c, y);
        case G:
          return K5(l, c);
        case V:
          return VD(l, c, y);
        case H:
          return u6(l, c, y);
        case B: {
          var Dt = c.type, yn = c.pendingProps, Un = c.elementType === Dt ? yn : Po(Dt, yn);
          return PD(l, c, Dt, Un, y);
        }
        case X:
          return j5(l, c, y);
        case ae:
          return G5(l, c, y);
        case Q:
          return X5(l, c, y);
        case K:
          return d6(l, c, y);
        case Z:
          return f6(l, c, y);
        case q: {
          var En = c.type, ii = c.pendingProps, ai = Po(En, ii);
          if (c.type !== c.elementType) {
            var Je = En.propTypes;
            Je && eo(
              Je,
              ai,
              // Resolved for outer only
              "prop",
              st(En)
            );
          }
          return ai = Po(En.type, ai), DD(l, c, En, ai, y);
        }
        case ne:
          return ID(l, c, c.type, c.pendingProps, y);
        case ie: {
          var mt = c.type, Ke = c.pendingProps, Ut = c.elementType === mt ? Ke : Po(mt, Ke);
          return Q5(l, c, mt, Ut, y);
        }
        case he:
          return XD(l, c, y);
        case le:
          break;
        case ve:
          return ND(l, c, y);
      }
      throw new Error("Unknown unit of work tag (" + c.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function m6(l, c, y) {
      switch (UC(c), c.tag) {
        case U: {
          var x = c.type;
          wo(x) && Bu(c);
          var T = c.flags;
          return T & it ? (c.flags = T & ~it | lt, (c.mode & lr) !== An && Ew(c), c) : null;
        }
        case N: {
          Fp(c), lf(c), ew();
          var F = c.flags;
          return (F & it) !== De && (F & lt) === De ? (c.flags = F & ~it | lt, c) : null;
        }
        case j:
          return KC(c), null;
        case V: {
          zp(c);
          {
            var k = c.memoizedState;
            if (k !== null && k.dehydrated !== null) {
              if (c.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              Np();
            }
          }
          var J = c.flags;
          return J & it ? (c.flags = J & ~it | lt, (c.mode & lr) !== An && Ew(c), c) : null;
        }
        case he:
          return zp(c), null;
        case H:
          return Fp(c), null;
        case K:
          var re = c.type._context;
          return W(re, c), null;
        case ve:
        case Ne:
          return r1(c), null;
        case xe:
          return null;
        default:
          return null;
      }
    }
    function ZD(l, c, y) {
      switch (UC(c), c.tag) {
        case U: {
          var x = c.type.childContextTypes;
          x != null && Bu(c);
          break;
        }
        case N: {
          Fp(c), lf(c), ew();
          break;
        }
        case j: {
          KC(c);
          break;
        }
        case H:
          Fp(c);
          break;
        case V:
          zp(c);
          break;
        case he:
          zp(c);
          break;
        case K:
          var T = c.type._context;
          W(T, c);
          break;
        case ve:
        case Ne:
          r1(c);
          break;
      }
    }
    function QD(l, c, y, x, T, F, k, J, re) {
      var me = Array.prototype.slice.call(arguments, 3);
      try {
        c.apply(y, me);
      } catch (we) {
        this.onError(we);
      }
    }
    var JD = QD;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var zw = document.createElement("react");
      JD = function(c, y, x, T, F, k, J, re, me) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var we = document.createEvent("Event"), qe = !1, at = !0, dt = window.event, At = Object.getOwnPropertyDescriptor(window, "event");
        function Dt() {
          zw.removeEventListener(mt, Un, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = dt);
        }
        var yn = Array.prototype.slice.call(arguments, 3);
        function Un() {
          qe = !0, Dt(), y.apply(x, yn), at = !1;
        }
        var En, ii = !1, ai = !1;
        function Je(Ke) {
          if (En = Ke.error, ii = !0, En === null && Ke.colno === 0 && Ke.lineno === 0 && (ai = !0), Ke.defaultPrevented && En != null && typeof En == "object")
            try {
              En._suppressLogging = !0;
            } catch {
            }
        }
        var mt = "react-" + (c || "invokeguardedcallback");
        if (window.addEventListener("error", Je), zw.addEventListener(mt, Un, !1), we.initEvent(mt, !1, !1), zw.dispatchEvent(we), At && Object.defineProperty(window, "event", At), qe && at && (ii ? ai && (En = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : En = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(En)), window.removeEventListener("error", Je), !qe)
          return Dt(), QD.apply(this, arguments);
      };
    }
    var g6 = JD, Dv = !1, Yb = null, v6 = {
      onError: function(l) {
        Dv = !0, Yb = l;
      }
    };
    function eI(l, c, y, x, T, F, k, J, re) {
      Dv = !1, Yb = null, g6.apply(v6, arguments);
    }
    function y6() {
      return Dv;
    }
    function tI() {
      if (Dv) {
        var l = Yb;
        return Dv = !1, Yb = null, l;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var nI = null;
    nI = /* @__PURE__ */ new Set();
    var Kb = !1, md = !1, b6 = typeof WeakSet == "function" ? WeakSet : Set, Zt = null, Wp = null, jp = null;
    function Ma(l) {
      eI(null, function() {
        throw l;
      }), tI();
    }
    var S6 = function(l, c) {
      if (c.props = l.memoizedProps, c.state = l.memoizedState, l.mode & lr)
        try {
          Ls(), c.componentWillUnmount();
        } finally {
          Ns(l);
        }
      else
        c.componentWillUnmount();
    };
    function rI(l, c) {
      try {
        $c(Ui, l);
      } catch (y) {
        Ma(y), Ta(l, c, y);
      }
    }
    function Bw(l, c, y) {
      try {
        S6(l, y);
      } catch (x) {
        Ma(x), Ta(l, c, x);
      }
    }
    function _6(l, c, y) {
      try {
        y.componentDidMount();
      } catch (x) {
        Ma(x), Ta(l, c, x);
      }
    }
    function iI(l, c) {
      try {
        oI(l);
      } catch (y) {
        Ma(y), Ta(l, c, y);
      }
    }
    function Zb(l, c) {
      var y = l.ref;
      if (y !== null)
        if (typeof y == "function") {
          var x;
          try {
            if (P && D && l.mode & lr)
              try {
                Ls(), x = y(null);
              } finally {
                Ns(l);
              }
            else
              x = y(null);
          } catch (T) {
            Ma(T), Ta(l, c, T);
          }
          typeof x == "function" && d("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", ue(l));
        } else
          y.current = null;
    }
    function Qb(l, c, y) {
      try {
        y();
      } catch (x) {
        Ma(x), Ta(l, c, x);
      }
    }
    var aI = !1;
    function x6(l, c) {
      en(l.containerInfo), Zt = c, E6();
      var y = aI;
      return aI = !1, y;
    }
    function E6() {
      for (; Zt !== null; ) {
        var l = Zt, c = l.child;
        (l.subtreeFlags & pe) !== De && c !== null ? (Fs(c, l), Zt = c) : C6();
      }
    }
    function C6() {
      for (; Zt !== null; ) {
        var l = Zt;
        dr(l);
        try {
          w6(l);
        } catch (y) {
          Ma(y), Ta(l, l.return, y);
        }
        ta();
        var c = l.sibling;
        if (c !== null) {
          Fs(c, l.return), Zt = c;
          return;
        }
        Zt = l.return;
      }
    }
    function w6(l) {
      var c = l.alternate, y = l.flags;
      if ((y & Nn) !== De) {
        switch (dr(l), l.tag) {
          case I:
          case B:
          case ne:
            break;
          case U: {
            if (c !== null) {
              var x = c.memoizedProps, T = c.memoizedState, F = l.stateNode;
              l.type === l.elementType && !Df && (F.props !== l.memoizedProps && d("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ue(l) || "instance"), F.state !== l.memoizedState && d("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ue(l) || "instance"));
              var k = F.getSnapshotBeforeUpdate(l.elementType === l.type ? x : Po(l.type, x), T);
              {
                var J = nI;
                k === void 0 && !J.has(l.type) && (J.add(l.type), d("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", ue(l)));
              }
              F.__reactInternalSnapshotBeforeUpdate = k;
            }
            break;
          }
          case N: {
            if (ha) {
              var re = l.stateNode;
              vC(re.containerInfo);
            }
            break;
          }
          case j:
          case G:
          case H:
          case ie:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        ta();
      }
    }
    function Io(l, c, y) {
      var x = c.updateQueue, T = x !== null ? x.lastEffect : null;
      if (T !== null) {
        var F = T.next, k = F;
        do {
          if ((k.tag & l) === l) {
            var J = k.destroy;
            k.destroy = void 0, J !== void 0 && ((l & Ca) !== Gl ? La(c) : (l & Ui) !== Gl && yf(c), Qb(c, y, J), (l & Ca) !== Gl ? ov() : (l & Ui) !== Gl && Mp());
          }
          k = k.next;
        } while (k !== F);
      }
    }
    function $c(l, c) {
      var y = c.updateQueue, x = y !== null ? y.lastEffect : null;
      if (x !== null) {
        var T = x.next, F = T;
        do {
          if ((F.tag & l) === l) {
            (l & Ca) !== Gl ? av(c) : (l & Ui) !== Gl && sv(c);
            var k = F.create;
            F.destroy = k(), (l & Ca) !== Gl ? vf() : (l & Ui) !== Gl && nd();
            {
              var J = F.destroy;
              if (J !== void 0 && typeof J != "function") {
                var re = void 0;
                (F.tag & Ui) !== De ? re = "useLayoutEffect" : (F.tag & fd) !== De ? re = "useInsertionEffect" : re = "useEffect";
                var me = void 0;
                J === null ? me = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof J.then == "function" ? me = `

It looks like you wrote ` + re + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + re + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : me = " You returned: " + J, d("%s must not return anything besides a function, which is used for clean-up.%s", re, me);
              }
            }
          }
          F = F.next;
        } while (F !== T);
      }
    }
    function M6(l, c) {
      if ((c.flags & He) !== De)
        switch (c.tag) {
          case Q: {
            var y = c.stateNode.passiveEffectDuration, x = c.memoizedProps, T = x.id, F = x.onPostCommit, k = SD(), J = c.alternate === null ? "mount" : "update";
            bD() && (J = "nested-update"), typeof F == "function" && F(T, J, y, k);
            var re = c.return;
            e: for (; re !== null; ) {
              switch (re.tag) {
                case N:
                  var me = re.stateNode;
                  me.passiveEffectDuration += y;
                  break e;
                case Q:
                  var we = re.stateNode;
                  we.passiveEffectDuration += y;
                  break e;
              }
              re = re.return;
            }
            break;
          }
        }
    }
    function T6(l, c, y, x) {
      if ((y.flags & bt) !== De)
        switch (y.tag) {
          case I:
          case B:
          case ne: {
            if (!md)
              if (y.mode & lr)
                try {
                  Ls(), $c(Ui | gi, y);
                } finally {
                  Ns(y);
                }
              else
                $c(Ui | gi, y);
            break;
          }
          case U: {
            var T = y.stateNode;
            if (y.flags & He && !md)
              if (c === null)
                if (y.type === y.elementType && !Df && (T.props !== y.memoizedProps && d("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ue(y) || "instance"), T.state !== y.memoizedState && d("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ue(y) || "instance")), y.mode & lr)
                  try {
                    Ls(), T.componentDidMount();
                  } finally {
                    Ns(y);
                  }
                else
                  T.componentDidMount();
              else {
                var F = y.elementType === y.type ? c.memoizedProps : Po(y.type, c.memoizedProps), k = c.memoizedState;
                if (y.type === y.elementType && !Df && (T.props !== y.memoizedProps && d("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ue(y) || "instance"), T.state !== y.memoizedState && d("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ue(y) || "instance")), y.mode & lr)
                  try {
                    Ls(), T.componentDidUpdate(F, k, T.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Ns(y);
                  }
                else
                  T.componentDidUpdate(F, k, T.__reactInternalSnapshotBeforeUpdate);
              }
            var J = y.updateQueue;
            J !== null && (y.type === y.elementType && !Df && (T.props !== y.memoizedProps && d("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", ue(y) || "instance"), T.state !== y.memoizedState && d("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", ue(y) || "instance")), MP(y, J, T));
            break;
          }
          case N: {
            var re = y.updateQueue;
            if (re !== null) {
              var me = null;
              if (y.child !== null)
                switch (y.child.tag) {
                  case j:
                    me = Xr(y.child.stateNode);
                    break;
                  case U:
                    me = y.child.stateNode;
                    break;
                }
              MP(y, re, me);
            }
            break;
          }
          case j: {
            var we = y.stateNode;
            if (c === null && y.flags & He) {
              var qe = y.type, at = y.memoizedProps;
              Ru(we, qe, at, y);
            }
            break;
          }
          case G:
            break;
          case H:
            break;
          case Q: {
            {
              var dt = y.memoizedProps, At = dt.onCommit, Dt = dt.onRender, yn = y.stateNode.effectDuration, Un = SD(), En = c === null ? "mount" : "update";
              bD() && (En = "nested-update"), typeof Dt == "function" && Dt(y.memoizedProps.id, En, y.actualDuration, y.treeBaseDuration, y.actualStartTime, Un);
              {
                typeof At == "function" && At(y.memoizedProps.id, En, yn, Un), VW(y);
                var ii = y.return;
                e: for (; ii !== null; ) {
                  switch (ii.tag) {
                    case N:
                      var ai = ii.stateNode;
                      ai.effectDuration += yn;
                      break e;
                    case Q:
                      var Je = ii.stateNode;
                      Je.effectDuration += yn;
                      break e;
                  }
                  ii = ii.return;
                }
              }
            }
            break;
          }
          case V: {
            F6(l, y);
            break;
          }
          case he:
          case ie:
          case le:
          case ve:
          case Ne:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      md || y.flags & un && oI(y);
    }
    function R6(l) {
      switch (l.tag) {
        case I:
        case B:
        case ne: {
          if (l.mode & lr)
            try {
              Ls(), rI(l, l.return);
            } finally {
              Ns(l);
            }
          else
            rI(l, l.return);
          break;
        }
        case U: {
          var c = l.stateNode;
          typeof c.componentDidMount == "function" && _6(l, l.return, c), iI(l, l.return);
          break;
        }
        case j: {
          iI(l, l.return);
          break;
        }
      }
    }
    function A6(l, c) {
      var y = null;
      if (ha)
        for (var x = l; ; ) {
          if (x.tag === j) {
            if (y === null) {
              y = x;
              var T = x.stateNode;
              c ? mC(T) : gC(x.stateNode, x.memoizedProps);
            }
          } else if (x.tag === G) {
            if (y === null) {
              var F = x.stateNode;
              c ? bs(F) : Xh(F, x.memoizedProps);
            }
          } else if (!((x.tag === ve || x.tag === Ne) && x.memoizedState !== null && x !== l)) {
            if (x.child !== null) {
              x.child.return = x, x = x.child;
              continue;
            }
          }
          if (x === l)
            return;
          for (; x.sibling === null; ) {
            if (x.return === null || x.return === l)
              return;
            y === x && (y = null), x = x.return;
          }
          y === x && (y = null), x.sibling.return = x.return, x = x.sibling;
        }
    }
    function oI(l) {
      var c = l.ref;
      if (c !== null) {
        var y = l.stateNode, x;
        switch (l.tag) {
          case j:
            x = Xr(y);
            break;
          default:
            x = y;
        }
        if (typeof c == "function") {
          var T;
          if (l.mode & lr)
            try {
              Ls(), T = c(x);
            } finally {
              Ns(l);
            }
          else
            T = c(x);
          typeof T == "function" && d("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", ue(l));
        } else
          c.hasOwnProperty("current") || d("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", ue(l)), c.current = x;
      }
    }
    function O6(l) {
      var c = l.ref;
      if (c !== null)
        if (typeof c == "function")
          if (l.mode & lr)
            try {
              Ls(), c(null);
            } finally {
              Ns(l);
            }
          else
            c(null);
        else
          c.current = null;
    }
    function sI(l, c, y) {
      switch (wi(c), c.tag) {
        case I:
        case B:
        case q:
        case ne: {
          var x = c.updateQueue;
          if (x !== null) {
            var T = x.lastEffect;
            if (T !== null) {
              var F = T.next, k = F;
              do {
                var J = k, re = J.destroy, me = J.tag;
                re !== void 0 && ((me & fd) !== Gl ? Qb(c, y, re) : (me & Ui) !== Gl && (yf(c), c.mode & lr ? (Ls(), Qb(c, y, re), Ns(c)) : Qb(c, y, re), Mp())), k = k.next;
              } while (k !== F);
            }
          }
          return;
        }
        case U: {
          Zb(c, y);
          var we = c.stateNode;
          typeof we.componentWillUnmount == "function" && Bw(c, y, we);
          return;
        }
        case j: {
          Zb(c, y);
          return;
        }
        case H: {
          ha ? hI(l, c, y) : _a && D6(c);
          return;
        }
        case oe:
          return;
        case le:
          return;
      }
    }
    function lI(l, c, y) {
      for (var x = c; ; ) {
        if (sI(l, x, y), x.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!ha || x.tag !== H)) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === c)
          return;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === c)
            return;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }
    function P6(l) {
      var c = l.alternate;
      c !== null && (c.return = null), l.return = null;
    }
    function cI(l) {
      var c = l.alternate;
      c !== null && (l.alternate = null, cI(c));
      {
        if (l.child = null, l.deletions = null, l.sibling = null, l.tag === j) {
          var y = l.stateNode;
          y !== null && Ys(y);
        }
        l.stateNode = null, l._debugOwner = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
      }
    }
    function D6(l) {
      if (_a) {
        var c = l.stateNode, y = c.containerInfo, x = Qd(y);
        qh(y, x);
      }
    }
    function I6(l) {
      if (_a) {
        switch (l.tag) {
          case U:
          case j:
          case G:
            return;
          case N:
          case H: {
            var c = l.stateNode, y = c.containerInfo, x = c.pendingChildren;
            qh(y, x);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function N6(l) {
      for (var c = l.return; c !== null; ) {
        if (uI(c))
          return c;
        c = c.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function uI(l) {
      return l.tag === j || l.tag === N || l.tag === H;
    }
    function dI(l) {
      var c = l;
      e: for (; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || uI(c.return))
            return null;
          c = c.return;
        }
        for (c.sibling.return = c.return, c = c.sibling; c.tag !== j && c.tag !== G && c.tag !== oe; ) {
          if (c.flags & We || c.child === null || c.tag === H)
            continue e;
          c.child.return = c, c = c.child;
        }
        if (!(c.flags & We))
          return c.stateNode;
      }
    }
    function fI(l) {
      if (ha) {
        var c = N6(l);
        switch (c.tag) {
          case j: {
            var y = c.stateNode;
            c.flags & _t && (Ag(y), c.flags &= ~_t);
            var x = dI(l);
            Vw(l, x, y);
            break;
          }
          case N:
          case H: {
            var T = c.stateNode.containerInfo, F = dI(l);
            Hw(l, F, T);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function Hw(l, c, y) {
      var x = l.tag, T = x === j || x === G;
      if (T) {
        var F = l.stateNode;
        c ? Ks(y, F, c) : Il(y, F);
      } else if (x !== H) {
        var k = l.child;
        if (k !== null) {
          Hw(k, c, y);
          for (var J = k.sibling; J !== null; )
            Hw(J, c, y), J = J.sibling;
        }
      }
    }
    function Vw(l, c, y) {
      var x = l.tag, T = x === j || x === G;
      if (T) {
        var F = l.stateNode;
        c ? ys(y, F, c) : Tu(y, F);
      } else if (x !== H) {
        var k = l.child;
        if (k !== null) {
          Vw(k, c, y);
          for (var J = k.sibling; J !== null; )
            Vw(J, c, y), J = J.sibling;
        }
      }
    }
    function hI(l, c, y) {
      for (var x = c, T = !1, F, k; ; ) {
        if (!T) {
          var J = x.return;
          e: for (; ; ) {
            if (J === null)
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            var re = J.stateNode;
            switch (J.tag) {
              case j:
                F = re, k = !1;
                break e;
              case N:
                F = re.containerInfo, k = !0;
                break e;
              case H:
                F = re.containerInfo, k = !0;
                break e;
            }
            J = J.return;
          }
          T = !0;
        }
        if (x.tag === j || x.tag === G)
          lI(l, x, y), k ? Rg(F, x.stateNode) : Gh(F, x.stateNode);
        else if (x.tag === oe)
          k ? G0(F, x.stateNode) : j0(F, x.stateNode);
        else if (x.tag === H) {
          if (x.child !== null) {
            F = x.stateNode.containerInfo, k = !0, x.child.return = x, x = x.child;
            continue;
          }
        } else if (sI(l, x, y), x.child !== null) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === c)
          return;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === c)
            return;
          x = x.return, x.tag === H && (T = !1);
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }
    function L6(l, c, y) {
      ha ? hI(l, c, y) : lI(l, c, y), P6(c);
    }
    function kw(l, c) {
      if (!ha) {
        switch (c.tag) {
          case I:
          case B:
          case q:
          case ne: {
            if (Io(fd | gi, c, c.return), $c(fd | gi, c), c.mode & lr)
              try {
                Ls(), Io(Ui | gi, c, c.return);
              } finally {
                Ns(c);
              }
            else
              Io(Ui | gi, c, c.return);
            return;
          }
          case Q:
            return;
          case V: {
            pI(c), Jb(c);
            return;
          }
          case he: {
            Jb(c);
            return;
          }
          case N: {
            if (ri && l !== null) {
              var y = l.memoizedState;
              if (y.isDehydrated) {
                var x = c.stateNode;
                Qh(x.containerInfo);
              }
            }
            break;
          }
          case ve:
          case Ne:
            return;
        }
        I6(c);
        return;
      }
      switch (c.tag) {
        case I:
        case B:
        case q:
        case ne: {
          if (Io(fd | gi, c, c.return), $c(fd | gi, c), c.mode & lr)
            try {
              Ls(), Io(Ui | gi, c, c.return);
            } finally {
              Ns(c);
            }
          else
            Io(Ui | gi, c, c.return);
          return;
        }
        case U:
          return;
        case j: {
          var T = c.stateNode;
          if (T != null) {
            var F = c.memoizedProps, k = l !== null ? l.memoizedProps : F, J = c.type, re = c.updateQueue;
            c.updateQueue = null, re !== null && pC(T, re, J, k, F, c);
          }
          return;
        }
        case G: {
          if (c.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var me = c.stateNode, we = c.memoizedProps, qe = l !== null ? l.memoizedProps : we;
          Qa(me, qe, we);
          return;
        }
        case N: {
          if (ri && l !== null) {
            var at = l.memoizedState;
            if (at.isDehydrated) {
              var dt = c.stateNode;
              Qh(dt.containerInfo);
            }
          }
          return;
        }
        case Q:
          return;
        case V: {
          pI(c), Jb(c);
          return;
        }
        case he: {
          Jb(c);
          return;
        }
        case ie:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function pI(l) {
      l.memoizedState;
    }
    function F6(l, c) {
      if (ri) {
        var y = c.memoizedState;
        if (y === null) {
          var x = c.alternate;
          if (x !== null) {
            var T = x.memoizedState;
            if (T !== null) {
              var F = T.dehydrated;
              F !== null && Jh(F);
            }
          }
        }
      }
    }
    function Jb(l) {
      var c = l.updateQueue;
      if (c !== null) {
        l.updateQueue = null;
        var y = l.stateNode;
        y === null && (y = l.stateNode = new b6()), c.forEach(function(x) {
          var T = qW.bind(null, l, x);
          if (!y.has(x)) {
            if (y.add(x), Na)
              if (Wp !== null && jp !== null)
                kv(jp, Wp);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            x.then(T, T);
          }
        });
      }
    }
    function U6(l) {
      ha && Ag(l.stateNode);
    }
    function z6(l, c, y) {
      Wp = y, jp = l, Zt = c, B6(l, y), Wp = null, jp = null;
    }
    function B6(l, c) {
      for (; Zt !== null; ) {
        var y = Zt, x = y.deletions;
        if (x !== null)
          for (var T = 0; T < x.length; T++) {
            var F = x[T];
            try {
              L6(l, F, y);
            } catch (J) {
              Ma(J), Ta(F, y, J);
            }
          }
        var k = y.child;
        (y.subtreeFlags & je) !== De && k !== null ? (Fs(k, y), Zt = k) : H6(l, c);
      }
    }
    function H6(l, c) {
      for (; Zt !== null; ) {
        var y = Zt;
        dr(y);
        try {
          V6(y, l, c);
        } catch (T) {
          Ma(T), Ta(y, y.return, T);
        }
        ta();
        var x = y.sibling;
        if (x !== null) {
          Fs(x, y.return), Zt = x;
          return;
        }
        Zt = y.return;
      }
    }
    function V6(l, c, y) {
      var x = l.flags;
      if (x & _t && U6(l), x & un) {
        var T = l.alternate;
        T !== null && O6(T);
      }
      if (x & Qt)
        switch (l.tag) {
          case V: {
            var F = l.memoizedState, k = F !== null;
            if (k) {
              var J = l.alternate, re = J !== null && J.memoizedState !== null;
              re || IW();
            }
            break;
          }
          case ve: {
            var me = l.memoizedState, we = me !== null, qe = l.alternate, at = qe !== null && qe.memoizedState !== null, dt = l;
            ha && A6(dt, we);
            {
              if (we && !at && (dt.mode & _r) !== An) {
                Zt = dt;
                for (var At = dt.child; At !== null; )
                  Zt = At, $6(At), At = At.sibling;
              }
              break;
            }
          }
        }
      var Dt = x & (We | He | Pt);
      switch (Dt) {
        case We: {
          fI(l), l.flags &= ~We;
          break;
        }
        case ut: {
          fI(l), l.flags &= ~We;
          var yn = l.alternate;
          kw(yn, l);
          break;
        }
        case Pt: {
          l.flags &= ~Pt;
          break;
        }
        case Bt: {
          l.flags &= ~Pt;
          var Un = l.alternate;
          kw(Un, l);
          break;
        }
        case He: {
          var En = l.alternate;
          kw(En, l);
          break;
        }
      }
    }
    function k6(l, c, y) {
      Wp = y, jp = c, Zt = l, mI(l, c, y), Wp = null, jp = null;
    }
    function mI(l, c, y) {
      for (var x = (l.mode & _r) !== An; Zt !== null; ) {
        var T = Zt, F = T.child;
        if (T.tag === ve && x) {
          var k = T.memoizedState !== null, J = k || Kb;
          if (J) {
            $w(l, c, y);
            continue;
          } else {
            var re = T.alternate, me = re !== null && re.memoizedState !== null, we = me || md, qe = Kb, at = md;
            Kb = J, md = we, md && !at && (Zt = T, W6(T));
            for (var dt = F; dt !== null; )
              Zt = dt, mI(
                dt,
                // New root; bubble back up to here and stop.
                c,
                y
              ), dt = dt.sibling;
            Zt = T, Kb = qe, md = at, $w(l, c, y);
            continue;
          }
        }
        (T.subtreeFlags & bt) !== De && F !== null ? (Fs(F, T), Zt = F) : $w(l, c, y);
      }
    }
    function $w(l, c, y) {
      for (; Zt !== null; ) {
        var x = Zt;
        if ((x.flags & bt) !== De) {
          var T = x.alternate;
          dr(x);
          try {
            T6(c, T, x, y);
          } catch (k) {
            Ma(k), Ta(x, x.return, k);
          }
          ta();
        }
        if (x === l) {
          Zt = null;
          return;
        }
        var F = x.sibling;
        if (F !== null) {
          Fs(F, x.return), Zt = F;
          return;
        }
        Zt = x.return;
      }
    }
    function $6(l) {
      for (; Zt !== null; ) {
        var c = Zt, y = c.child;
        switch (c.tag) {
          case I:
          case B:
          case q:
          case ne: {
            if (c.mode & lr)
              try {
                Ls(), Io(Ui, c, c.return);
              } finally {
                Ns(c);
              }
            else
              Io(Ui, c, c.return);
            break;
          }
          case U: {
            Zb(c, c.return);
            var x = c.stateNode;
            typeof x.componentWillUnmount == "function" && Bw(c, c.return, x);
            break;
          }
          case j: {
            Zb(c, c.return);
            break;
          }
          case ve: {
            var T = c.memoizedState !== null;
            if (T) {
              gI(l);
              continue;
            }
            break;
          }
        }
        y !== null ? (y.return = c, Zt = y) : gI(l);
      }
    }
    function gI(l) {
      for (; Zt !== null; ) {
        var c = Zt;
        if (c === l) {
          Zt = null;
          return;
        }
        var y = c.sibling;
        if (y !== null) {
          y.return = c.return, Zt = y;
          return;
        }
        Zt = c.return;
      }
    }
    function W6(l) {
      for (; Zt !== null; ) {
        var c = Zt, y = c.child;
        if (c.tag === ve) {
          var x = c.memoizedState !== null;
          if (x) {
            vI(l);
            continue;
          }
        }
        y !== null ? (y.return = c, Zt = y) : vI(l);
      }
    }
    function vI(l) {
      for (; Zt !== null; ) {
        var c = Zt;
        dr(c);
        try {
          R6(c);
        } catch (x) {
          Ma(x), Ta(c, c.return, x);
        }
        if (ta(), c === l) {
          Zt = null;
          return;
        }
        var y = c.sibling;
        if (y !== null) {
          y.return = c.return, Zt = y;
          return;
        }
        Zt = c.return;
      }
    }
    function j6(l, c) {
      Zt = c, G6(c, l);
    }
    function G6(l, c) {
      for (; Zt !== null; ) {
        var y = Zt, x = y.child;
        (y.subtreeFlags & It) !== De && x !== null ? (Fs(x, y), Zt = x) : X6(l, c);
      }
    }
    function X6(l, c) {
      for (; Zt !== null; ) {
        var y = Zt;
        if ((y.flags & xt) !== De) {
          dr(y);
          try {
            q6(c, y);
          } catch (T) {
            Ma(T), Ta(y, y.return, T);
          }
          ta();
        }
        if (y === l) {
          Zt = null;
          return;
        }
        var x = y.sibling;
        if (x !== null) {
          Fs(x, y.return), Zt = x;
          return;
        }
        Zt = y.return;
      }
    }
    function q6(l, c) {
      switch (c.tag) {
        case I:
        case B:
        case ne: {
          if (c.mode & lr) {
            xw();
            try {
              $c(Ca | gi, c);
            } finally {
              _w(c);
            }
          } else
            $c(Ca | gi, c);
          break;
        }
      }
    }
    function Y6(l) {
      Zt = l, K6();
    }
    function K6() {
      for (; Zt !== null; ) {
        var l = Zt, c = l.child;
        if ((Zt.flags & vt) !== De) {
          var y = l.deletions;
          if (y !== null) {
            for (var x = 0; x < y.length; x++) {
              var T = y[x];
              Zt = T, J6(T, l);
            }
            {
              var F = l.alternate;
              if (F !== null) {
                var k = F.child;
                if (k !== null) {
                  F.child = null;
                  do {
                    var J = k.sibling;
                    k.sibling = null, k = J;
                  } while (k !== null);
                }
              }
            }
            Zt = l;
          }
        }
        (l.subtreeFlags & It) !== De && c !== null ? (Fs(c, l), Zt = c) : Z6();
      }
    }
    function Z6() {
      for (; Zt !== null; ) {
        var l = Zt;
        (l.flags & xt) !== De && (dr(l), Q6(l), ta());
        var c = l.sibling;
        if (c !== null) {
          Fs(c, l.return), Zt = c;
          return;
        }
        Zt = l.return;
      }
    }
    function Q6(l) {
      switch (l.tag) {
        case I:
        case B:
        case ne: {
          l.mode & lr ? (xw(), Io(Ca | gi, l, l.return), _w(l)) : Io(Ca | gi, l, l.return);
          break;
        }
      }
    }
    function J6(l, c) {
      for (; Zt !== null; ) {
        var y = Zt;
        dr(y), tW(y, c), ta();
        var x = y.child;
        x !== null ? (Fs(x, y), Zt = x) : eW(l);
      }
    }
    function eW(l) {
      for (; Zt !== null; ) {
        var c = Zt, y = c.sibling, x = c.return;
        if (cI(c), c === l) {
          Zt = null;
          return;
        }
        if (y !== null) {
          Fs(y, x), Zt = y;
          return;
        }
        Zt = x;
      }
    }
    function tW(l, c) {
      switch (l.tag) {
        case I:
        case B:
        case ne: {
          l.mode & lr ? (xw(), Io(Ca, l, c), _w(l)) : Io(Ca, l, c);
          break;
        }
      }
    }
    var yI = !1;
    function Fs(l, c) {
      !yI && l.return !== c && (yI = !0, d("Internal React error: Return pointer is inconsistent with parent.")), l.return = c;
    }
    function nW(l) {
      switch (l.tag) {
        case I:
        case B:
        case ne: {
          try {
            $c(Ui | gi, l);
          } catch (y) {
            Ma(y), Ta(l, l.return, y);
          }
          break;
        }
        case U: {
          var c = l.stateNode;
          try {
            c.componentDidMount();
          } catch (y) {
            Ma(y), Ta(l, l.return, y);
          }
          break;
        }
      }
    }
    function rW(l) {
      switch (l.tag) {
        case I:
        case B:
        case ne: {
          try {
            $c(Ca | gi, l);
          } catch (c) {
            Ma(c), Ta(l, l.return, c);
          }
          break;
        }
      }
    }
    function iW(l) {
      switch (l.tag) {
        case I:
        case B:
        case ne: {
          try {
            Io(Ui | gi, l, l.return);
          } catch (y) {
            Ma(y), Ta(l, l.return, y);
          }
          break;
        }
        case U: {
          var c = l.stateNode;
          typeof c.componentWillUnmount == "function" && Bw(l, l.return, c);
          break;
        }
      }
    }
    function aW(l) {
      switch (l.tag) {
        case I:
        case B:
        case ne:
          try {
            Io(Ca | gi, l, l.return);
          } catch (c) {
            Ma(c), Ta(l, l.return, c);
          }
      }
    }
    var eS = 0, tS = 1, nS = 2, rS = 3, iS = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Iv = Symbol.for;
      eS = Iv("selector.component"), tS = Iv("selector.has_pseudo_class"), nS = Iv("selector.role"), rS = Iv("selector.test_id"), iS = Iv("selector.text");
    }
    function oW(l) {
      return {
        $$typeof: eS,
        value: l
      };
    }
    function sW(l) {
      return {
        $$typeof: tS,
        value: l
      };
    }
    function lW(l) {
      return {
        $$typeof: nS,
        value: l
      };
    }
    function cW(l) {
      return {
        $$typeof: iS,
        value: l
      };
    }
    function uW(l) {
      return {
        $$typeof: rS,
        value: l
      };
    }
    function Ww(l) {
      var c = vs(l);
      if (c != null) {
        if (typeof c.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return c;
      } else {
        var y = Mu(l);
        if (y === null)
          throw new Error("Could not find React container within specified host subtree.");
        return y.stateNode.current;
      }
    }
    function jw(l, c) {
      switch (c.$$typeof) {
        case eS:
          if (l.type === c.value)
            return !0;
          break;
        case tS:
          return dW(l, c.value);
        case nS:
          if (l.tag === j) {
            var y = l.stateNode;
            if (Br(y, c.value))
              return !0;
          }
          break;
        case iS:
          if (l.tag === j || l.tag === G) {
            var x = ln(l);
            if (x !== null && x.indexOf(c.value) >= 0)
              return !0;
          }
          break;
        case rS:
          if (l.tag === j) {
            var T = l.memoizedProps["data-testname"];
            if (typeof T == "string" && T.toLowerCase() === c.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function Gw(l) {
      switch (l.$$typeof) {
        case eS:
          var c = st(l.value) || "Unknown";
          return "<" + c + ">";
        case tS:
          return ":has(" + (Gw(l) || "") + ")";
        case nS:
          return '[role="' + l.value + '"]';
        case iS:
          return '"' + l.value + '"';
        case rS:
          return '[data-testname="' + l.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function bI(l, c) {
      for (var y = [], x = [l, 0], T = 0; T < x.length; ) {
        var F = x[T++], k = x[T++], J = c[k];
        if (!(F.tag === j && nn(F))) {
          for (; J != null && jw(F, J); )
            k++, J = c[k];
          if (k === c.length)
            y.push(F);
          else
            for (var re = F.child; re !== null; )
              x.push(re, k), re = re.sibling;
        }
      }
      return y;
    }
    function dW(l, c) {
      for (var y = [l, 0], x = 0; x < y.length; ) {
        var T = y[x++], F = y[x++], k = c[F];
        if (!(T.tag === j && nn(T))) {
          for (; k != null && jw(T, k); )
            F++, k = c[F];
          if (F === c.length)
            return !0;
          for (var J = T.child; J !== null; )
            y.push(J, F), J = J.sibling;
        }
      }
      return !1;
    }
    function aS(l, c) {
      if (!So)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var y = Ww(l), x = bI(y, c), T = [], F = Array.from(x), k = 0; k < F.length; ) {
        var J = F[k++];
        if (J.tag === j) {
          if (nn(J))
            continue;
          T.push(J.stateNode);
        } else
          for (var re = J.child; re !== null; )
            F.push(re), re = re.sibling;
      }
      return T;
    }
    function fW(l, c) {
      if (!So)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var y = Ww(l), x = 0, T = [], F = [y, 0], k = 0; k < F.length; ) {
        var J = F[k++], re = F[k++], me = c[re];
        if (!(J.tag === j && nn(J)) && (jw(J, me) && (T.push(Gw(me)), re++, re > x && (x = re)), re < c.length))
          for (var we = J.child; we !== null; )
            F.push(we, re), we = we.sibling;
      }
      if (x < c.length) {
        for (var qe = [], at = x; at < c.length; at++)
          qe.push(Gw(c[at]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + T.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + qe.join(" > "));
      }
      return null;
    }
    function hW(l, c) {
      if (!So)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var y = aS(l, c), x = [], T = 0; T < y.length; T++)
        x.push(Zd(y[T]));
      for (var F = x.length - 1; F > 0; F--)
        for (var k = x[F], J = k.x, re = J + k.width, me = k.y, we = me + k.height, qe = F - 1; qe >= 0; qe--)
          if (F !== qe) {
            var at = x[qe], dt = at.x, At = dt + at.width, Dt = at.y, yn = Dt + at.height;
            if (J >= dt && me >= Dt && re <= At && we <= yn) {
              x.splice(F, 1);
              break;
            } else if (J === dt && k.width === at.width && !(yn < me) && !(Dt > we)) {
              Dt > me && (at.height += Dt - me, at.y = me), yn < we && (at.height = we - Dt), x.splice(F, 1);
              break;
            } else if (me === Dt && k.height === at.height && !(At < J) && !(dt > re)) {
              dt > J && (at.width += dt - J, at.x = J), At < re && (at.width = re - dt), x.splice(F, 1);
              break;
            }
          }
      return x;
    }
    function pW(l, c) {
      if (!So)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var y = Ww(l), x = bI(y, c), T = Array.from(x), F = 0; F < T.length; ) {
        var k = T[F++];
        if (!nn(k)) {
          if (k.tag === j) {
            var J = k.stateNode;
            if (ui(J))
              return !0;
          }
          for (var re = k.child; re !== null; )
            T.push(re), re = re.sibling;
        }
      }
      return !1;
    }
    var oS = [];
    function mW() {
      So && oS.forEach(function(l) {
        return l();
      });
    }
    function gW(l, c, y, x) {
      if (!So)
        throw new Error("Test selector API is not supported by this renderer.");
      var T = aS(l, c), F = Hr(T, y, x), k = F.disconnect, J = F.observe, re = F.unobserve, me = function() {
        var we = aS(l, c);
        T.forEach(function(qe) {
          we.indexOf(qe) < 0 && re(qe);
        }), we.forEach(function(qe) {
          T.indexOf(qe) < 0 && J(qe);
        });
      };
      return oS.push(me), {
        disconnect: function() {
          var we = oS.indexOf(me);
          we >= 0 && oS.splice(we, 1), k();
        }
      };
    }
    var vW = a.ReactCurrentActQueue;
    function yW(l) {
      {
        var c = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), y = typeof jest < "u";
        return Qi && y && c !== !1;
      }
    }
    function SI() {
      {
        var l = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !l && vW.current !== null && d("The current testing environment is not configured to support act(...)"), l;
      }
    }
    var bW = Math.ceil, Xw = a.ReactCurrentDispatcher, qw = a.ReactCurrentOwner, vi = a.ReactCurrentBatchConfig, ul = a.ReactCurrentActQueue, Gi = (
      /*             */
      0
    ), Yw = (
      /*               */
      1
    ), Va = (
      /*                */
      2
    ), dl = (
      /*                */
      4
    ), Wc = 0, Nv = 1, If = 2, sS = 3, Lv = 4, _I = 5, Kw = 6, Wn = Gi, ka = null, yi = null, ia = wt, Kl = wt, Zw = _s(wt), aa = Wc, Fv = null, lS = wt, Uv = wt, cS = wt, zv = null, No = null, Qw = 0, xI = 500, EI = 1 / 0, SW = 500;
    function Gp() {
      EI = hi() + SW;
    }
    function CI() {
      return EI;
    }
    var uS = !1, Jw = null, Xp = null, Nf = !1, jc = null, Bv = wt, e1 = [], _W = 50, Hv = 0, t1 = null, xW = 50, dS = 0, Vv = Vr, fS = wt;
    function hS() {
      return ka;
    }
    function oo() {
      return (Wn & (Va | dl)) !== Gi ? hi() : (Vv !== Vr || (Vv = hi()), Vv);
    }
    function gd(l) {
      var c = l.mode;
      if ((c & _r) === An)
        return Jn;
      if ((Wn & Va) !== Gi && ia !== wt)
        return qu(ia);
      var y = dv() !== cb;
      if (y) {
        if (vi.transition !== null) {
          var x = vi.transition;
          x._updatedFibers || (x._updatedFibers = /* @__PURE__ */ new Set()), x._updatedFibers.add(l);
        }
        return fS === Ni && (fS = eb()), fS;
      }
      var T = to();
      if (T !== Ni)
        return T;
      var F = vc();
      return F;
    }
    function EW(l) {
      var c = l.mode;
      return (c & _r) === An ? Jn : tb();
    }
    function oa(l, c, y) {
      KW();
      var x = pS(l, c);
      return x === null ? null : (Ac(x, c, y), (Wn & Va) !== wt && x === ka ? JW(l) : (Na && Zg(x, l, c), e8(l), x === ka && ((Wn & Va) === Gi && (Uv = Ln(Uv, c)), aa === Lv && vd(x, ia)), Lo(x, y), c === Jn && Wn === Gi && (l.mode & _r) === An && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !ul.isBatchingLegacy && (Gp(), uv())), x);
    }
    function CW(l, c, y) {
      var x = l.current;
      x.lanes = c, Ac(l, c, y), Lo(l, y);
    }
    function pS(l, c) {
      l.lanes = Ln(l.lanes, c);
      var y = l.alternate;
      y !== null && (y.lanes = Ln(y.lanes, c)), y === null && (l.flags & (We | Pt)) !== De && zI(l);
      for (var x = l, T = l.return; T !== null; )
        T.childLanes = Ln(T.childLanes, c), y = T.alternate, y !== null ? y.childLanes = Ln(y.childLanes, c) : (T.flags & (We | Pt)) !== De && zI(l), x = T, T = T.return;
      if (x.tag === N) {
        var F = x.stateNode;
        return F;
      } else
        return null;
    }
    function wI(l, c) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        ka !== null && (l.mode & _r) !== An && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (Wn & Va) === Gi
      );
    }
    function Lo(l, c) {
      var y = l.callbackNode;
      Q0(l, c);
      var x = mf(l, l === ka ? ia : wt);
      if (x === wt) {
        y !== null && HI(y), l.callbackNode = null, l.callbackPriority = Ni;
        return;
      }
      var T = Ms(x), F = l.callbackPriority;
      if (F === T && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(ul.current !== null && y !== s1)) {
        y == null && F !== Jn && d("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      y != null && HI(y);
      var k;
      if (T === Jn)
        l.tag === Ec ? (ul.isBatchingLegacy !== null && (ul.didScheduleLegacyUpdate = !0), sb(RI.bind(null, l))) : al(RI.bind(null, l)), Qn ? ul.current !== null ? ul.current.push(Ao) : wu(function() {
          Wn === Gi && Ao();
        }) : _S(Ic, Ao), k = null;
      else {
        var J;
        switch (ev(x)) {
          case Qo:
            J = Ic;
            break;
          case Zu:
            J = gf;
            break;
          case Qu:
            J = rl;
            break;
          case Ep:
            J = Ju;
            break;
          default:
            J = rl;
            break;
        }
        k = _S(J, MI.bind(null, l));
      }
      l.callbackPriority = T, l.callbackNode = k;
    }
    function MI(l, c) {
      if (F5(), Vv = Vr, fS = wt, (Wn & (Va | dl)) !== Gi)
        throw new Error("Should not already be working.");
      var y = l.callbackNode, x = Zl();
      if (x && l.callbackNode !== y)
        return null;
      var T = mf(l, l === ka ? ia : wt);
      if (T === wt)
        return null;
      var F = !Tc(l, T) && !J0(l, T) && !c, k = F ? zW(l, T) : yS(l, T);
      if (k !== Wc) {
        if (k === If) {
          var J = yp(l);
          J !== wt && (T = J, k = n1(l, J));
        }
        if (k === Nv) {
          var re = Fv;
          throw Lf(l, wt), vd(l, T), Lo(l, hi()), re;
        }
        if (k === Kw)
          vd(l, T);
        else {
          var me = !Tc(l, T), we = l.current.alternate;
          if (me && !MW(we)) {
            if (k = yS(l, T), k === If) {
              var qe = yp(l);
              qe !== wt && (T = qe, k = n1(l, qe));
            }
            if (k === Nv) {
              var at = Fv;
              throw Lf(l, wt), vd(l, T), Lo(l, hi()), at;
            }
          }
          l.finishedWork = we, l.finishedLanes = T, wW(l, k, T);
        }
      }
      return Lo(l, hi()), l.callbackNode === y ? MI.bind(null, l) : null;
    }
    function n1(l, c) {
      var y = zv;
      if ($l(l)) {
        var x = Lf(l, c);
        x.flags |= Ct, Ja(l.containerInfo);
      }
      var T = yS(l, c);
      if (T !== If) {
        var F = No;
        No = y, F !== null && TI(F);
      }
      return T;
    }
    function TI(l) {
      No === null ? No = l : No.push.apply(No, l);
    }
    function wW(l, c, y) {
      switch (c) {
        case Wc:
        case Nv:
          throw new Error("Root did not complete. This is a bug in React.");
        case If: {
          Ff(l, No);
          break;
        }
        case sS: {
          if (vd(l, y), Yg(y) && // do not delay if we're inside an act() scope
          !VI()) {
            var x = Qw + xI - hi();
            if (x > 10) {
              var T = mf(l, wt);
              if (T !== wt)
                break;
              var F = l.suspendedLanes;
              if (!Yu(F, y)) {
                oo(), rb(l, F);
                break;
              }
              l.timeoutHandle = Za(Ff.bind(null, l, No), x);
              break;
            }
          }
          Ff(l, No);
          break;
        }
        case Lv: {
          if (vd(l, y), Sp(y))
            break;
          if (!VI()) {
            var k = K0(l, y), J = k, re = hi() - J, me = YW(re) - re;
            if (me > 10) {
              l.timeoutHandle = Za(Ff.bind(null, l, No), me);
              break;
            }
          }
          Ff(l, No);
          break;
        }
        case _I: {
          Ff(l, No);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function MW(l) {
      for (var c = l; ; ) {
        if (c.flags & vn) {
          var y = c.updateQueue;
          if (y !== null) {
            var x = y.stores;
            if (x !== null)
              for (var T = 0; T < x.length; T++) {
                var F = x[T], k = F.getSnapshot, J = F.value;
                try {
                  if (!ro(k(), J))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var re = c.child;
        if (c.subtreeFlags & vn && re !== null) {
          re.return = c, c = re;
          continue;
        }
        if (c === l)
          return !0;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === l)
            return !0;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return !0;
    }
    function vd(l, c) {
      c = Rc(c, cS), c = Rc(c, Uv), nb(l, c);
    }
    function RI(l) {
      if (U5(), (Wn & (Va | dl)) !== Gi)
        throw new Error("Should not already be working.");
      Zl();
      var c = mf(l, wt);
      if (!fi(c, Jn))
        return Lo(l, hi()), null;
      var y = yS(l, c);
      if (l.tag !== Ec && y === If) {
        var x = yp(l);
        x !== wt && (c = x, y = n1(l, x));
      }
      if (y === Nv) {
        var T = Fv;
        throw Lf(l, wt), vd(l, c), Lo(l, hi()), T;
      }
      if (y === Kw)
        throw new Error("Root did not complete. This is a bug in React.");
      var F = l.current.alternate;
      return l.finishedWork = F, l.finishedLanes = c, Ff(l, No), Lo(l, hi()), null;
    }
    function TW(l, c) {
      c !== wt && (Pc(l, Ln(c, Jn)), Lo(l, hi()), (Wn & (Va | dl)) === Gi && (Gp(), Ao()));
    }
    function RW(l) {
      var c = to(), y = vi.transition;
      try {
        return vi.transition = null, Li(Qu), l();
      } finally {
        Li(c), vi.transition = y;
      }
    }
    function AW(l, c) {
      var y = Wn;
      Wn |= Yw;
      try {
        return l(c);
      } finally {
        Wn = y, Wn === Gi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !ul.isBatchingLegacy && (Gp(), uv());
      }
    }
    function OW(l, c, y, x, T) {
      var F = to(), k = vi.transition;
      try {
        return vi.transition = null, Li(Qo), l(c, y, x, T);
      } finally {
        Li(F), vi.transition = k, Wn === Gi && Gp();
      }
    }
    function mS(l) {
      jc !== null && jc.tag === Ec && (Wn & (Va | dl)) === Gi && Zl();
      var c = Wn;
      Wn |= Yw;
      var y = vi.transition, x = to();
      try {
        return vi.transition = null, Li(Qo), l ? l() : void 0;
      } finally {
        Li(x), vi.transition = y, Wn = c, (Wn & (Va | dl)) === Gi && Ao();
      }
    }
    function PW() {
      return (Wn & (Va | dl)) !== Gi;
    }
    function DW(l) {
      var c = Wn;
      Wn |= Yw;
      var y = vi.transition, x = to();
      try {
        vi.transition = null, Li(Qo), l();
      } finally {
        Li(x), vi.transition = y, Wn = c, Wn === Gi && (Gp(), Ao());
      }
    }
    function gS(l, c) {
      Tr(Zw, Kl, l), Kl = Ln(Kl, c);
    }
    function r1(l) {
      Kl = Zw.current, Di(Zw, l);
    }
    function Lf(l, c) {
      l.finishedWork = null, l.finishedLanes = wt;
      var y = l.timeoutHandle;
      if (y !== Wi && (l.timeoutHandle = Wi, Pi(y)), yi !== null)
        for (var x = yi.return; x !== null; ) {
          var T = x.alternate;
          ZD(T, x), x = x.return;
        }
      ka = l;
      var F = Uf(l.current, null);
      return yi = F, ia = Kl = c, aa = Wc, Fv = null, lS = wt, Uv = wt, cS = wt, zv = null, No = null, zr(), Oo.discardPendingWarnings(), F;
    }
    function AI(l, c) {
      do {
        var y = yi;
        try {
          if (m(), KP(), ta(), qw.current = null, y === null || y.return === null) {
            aa = Nv, Fv = c, yi = null;
            return;
          }
          if (P && y.mode & lr && Hb(y, !0), R)
            if (il(), c !== null && typeof c == "object" && typeof c.then == "function") {
              var x = c;
              Tp(y, x, ia);
            } else
              Hl(y, c, ia);
          k5(l, y.return, y, c, ia), II(y);
        } catch (T) {
          c = T, yi === y && y !== null ? (y = y.return, yi = y) : y = yi;
          continue;
        }
        return;
      } while (!0);
    }
    function OI() {
      var l = Xw.current;
      return Xw.current = Lb, l === null ? Lb : l;
    }
    function PI(l) {
      Xw.current = l;
    }
    function IW() {
      Qw = hi();
    }
    function vS(l) {
      lS = Ln(l, lS);
    }
    function NW() {
      aa === Wc && (aa = sS);
    }
    function i1() {
      (aa === Wc || aa === sS || aa === If) && (aa = Lv), ka !== null && (bp(lS) || bp(Uv)) && vd(ka, ia);
    }
    function LW(l) {
      aa !== Lv && (aa = If), zv === null ? zv = [l] : zv.push(l);
    }
    function FW() {
      return aa === Wc;
    }
    function yS(l, c) {
      var y = Wn;
      Wn |= Va;
      var x = OI();
      if (ka !== l || ia !== c) {
        if (Na) {
          var T = l.memoizedUpdaters;
          T.size > 0 && (kv(l, ia), T.clear()), Qg(l, c);
        }
        Lf(l, c);
      }
      Sf(c);
      do
        try {
          UW();
          break;
        } catch (F) {
          AI(l, F);
        }
      while (!0);
      if (m(), Wn = y, PI(x), yi !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ma(), ka = null, ia = wt, aa;
    }
    function UW() {
      for (; yi !== null; )
        DI(yi);
    }
    function zW(l, c) {
      var y = Wn;
      Wn |= Va;
      var x = OI();
      if (ka !== l || ia !== c) {
        if (Na) {
          var T = l.memoizedUpdaters;
          T.size > 0 && (kv(l, ia), T.clear()), Qg(l, c);
        }
        Gp(), Lf(l, c);
      }
      Sf(c);
      do
        try {
          BW();
          break;
        } catch (F) {
          AI(l, F);
        }
      while (!0);
      return m(), PI(x), Wn = y, yi !== null ? (Ap(), Wc) : (ma(), ka = null, ia = wt, aa);
    }
    function BW() {
      for (; yi !== null && !ob(); )
        DI(yi);
    }
    function DI(l) {
      var c = l.alternate;
      dr(l);
      var y;
      (l.mode & lr) !== An ? (Sw(l), y = a1(c, l, Kl), Hb(l, !0)) : y = a1(c, l, Kl), ta(), l.memoizedProps = l.pendingProps, y === null ? II(l) : yi = y, qw.current = null;
    }
    function II(l) {
      var c = l;
      do {
        var y = c.alternate, x = c.return;
        if ((c.flags & ge) === De) {
          dr(c);
          var T = void 0;
          if ((c.mode & lr) === An ? T = OD(y, c, Kl) : (Sw(c), T = OD(y, c, Kl), Hb(c, !1)), ta(), T !== null) {
            yi = T;
            return;
          }
        } else {
          var F = m6(y, c);
          if (F !== null) {
            F.flags &= cr, yi = F;
            return;
          }
          if ((c.mode & lr) !== An) {
            Hb(c, !1);
            for (var k = c.actualDuration, J = c.child; J !== null; )
              k += J.actualDuration, J = J.sibling;
            c.actualDuration = k;
          }
          if (x !== null)
            x.flags |= ge, x.subtreeFlags = De, x.deletions = null;
          else {
            aa = Kw, yi = null;
            return;
          }
        }
        var re = c.sibling;
        if (re !== null) {
          yi = re;
          return;
        }
        c = x, yi = c;
      } while (c !== null);
      aa === Wc && (aa = _I);
    }
    function Ff(l, c) {
      var y = to(), x = vi.transition;
      try {
        vi.transition = null, Li(Qo), HW(l, c, y);
      } finally {
        vi.transition = x, Li(y);
      }
      return null;
    }
    function HW(l, c, y) {
      do
        Zl();
      while (jc !== null);
      if (ZW(), (Wn & (Va | dl)) !== Gi)
        throw new Error("Should not already be working.");
      var x = l.finishedWork, T = l.finishedLanes;
      if (Fi(T), x === null)
        return td(), null;
      if (T === wt && d("root.finishedLanes should not be empty during a commit. This is a bug in React."), l.finishedWork = null, l.finishedLanes = wt, x === l.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      l.callbackNode = null, l.callbackPriority = Ni;
      var F = Ln(x.lanes, x.childLanes);
      Oc(l, F), l === ka && (ka = null, yi = null, ia = wt), ((x.subtreeFlags & It) !== De || (x.flags & It) !== De) && (Nf || (Nf = !0, _S(rl, function() {
        return Zl(), null;
      })));
      var k = (x.subtreeFlags & (pe | je | bt | It)) !== De, J = (x.flags & (pe | je | bt | It)) !== De;
      if (k || J) {
        var re = vi.transition;
        vi.transition = null;
        var me = to();
        Li(Qo);
        var we = Wn;
        Wn |= dl, qw.current = null, x6(l, x), _D(), z6(l, x, T), gr(l.containerInfo), l.current = x, Vl(T), k6(x, l, T), Rp(), wp(), Wn = we, Li(me), vi.transition = re;
      } else
        l.current = x, _D();
      var qe = Nf;
      if (Nf && (Nf = !1, jc = l, Bv = T), F = l.pendingLanes, F === wt && (Xp = null), qe || UI(l.current, !1), kn(x.stateNode, y), Na && l.memoizedUpdaters.clear(), mW(), Lo(l, hi()), c !== null)
        for (var at = l.onRecoverableError, dt = 0; dt < c.length; dt++) {
          var At = c[dt];
          at(At);
        }
      if (uS) {
        uS = !1;
        var Dt = Jw;
        throw Jw = null, Dt;
      }
      return fi(Bv, Jn) && l.tag !== Ec && Zl(), F = l.pendingLanes, fi(F, Jn) ? (L5(), l === t1 ? Hv++ : (Hv = 0, t1 = l)) : Hv = 0, Ao(), td(), null;
    }
    function Zl() {
      if (jc !== null) {
        var l = ev(Bv), c = bC(Qu, l), y = vi.transition, x = to();
        try {
          return vi.transition = null, Li(c), kW();
        } finally {
          Li(x), vi.transition = y;
        }
      }
      return !1;
    }
    function VW(l) {
      e1.push(l), Nf || (Nf = !0, _S(rl, function() {
        return Zl(), null;
      }));
    }
    function kW() {
      if (jc === null)
        return !1;
      var l = jc, c = Bv;
      if (jc = null, Bv = wt, (Wn & (Va | dl)) !== Gi)
        throw new Error("Cannot flush passive effects while already rendering.");
      bf(c);
      var y = Wn;
      Wn |= dl, Y6(l.current), j6(l, l.current);
      {
        var x = e1;
        e1 = [];
        for (var T = 0; T < x.length; T++) {
          var F = x[T];
          M6(l, F);
        }
      }
      lv(), UI(l.current, !0), Wn = y, Ao(), dS = jc === null ? 0 : dS + 1, Ci(l);
      {
        var k = l.current.stateNode;
        k.effectDuration = 0, k.passiveEffectDuration = 0;
      }
      return !0;
    }
    function NI(l) {
      return Xp !== null && Xp.has(l);
    }
    function $W(l) {
      Xp === null ? Xp = /* @__PURE__ */ new Set([l]) : Xp.add(l);
    }
    function WW(l) {
      uS || (uS = !0, Jw = l);
    }
    var jW = WW;
    function LI(l, c, y) {
      var x = Vb(y, c), T = ED(l, x, Jn);
      $n(l, T);
      var F = oo(), k = pS(l, Jn);
      k !== null && (Ac(k, Jn, F), Lo(k, F));
    }
    function Ta(l, c, y) {
      if (l.tag === N) {
        LI(l, l, y);
        return;
      }
      var x = null;
      for (x = c; x !== null; ) {
        if (x.tag === N) {
          LI(x, l, y);
          return;
        } else if (x.tag === U) {
          var T = x.type, F = x.stateNode;
          if (typeof T.getDerivedStateFromError == "function" || typeof F.componentDidCatch == "function" && !NI(F)) {
            var k = Vb(y, l), J = ww(x, k, Jn);
            $n(x, J);
            var re = oo(), me = pS(x, Jn);
            me !== null && (Ac(me, Jn, re), Lo(me, re));
            return;
          }
        }
        x = x.return;
      }
      d(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, y);
    }
    function GW(l, c, y) {
      var x = l.pingCache;
      x !== null && x.delete(c);
      var T = oo();
      rb(l, y), t8(l), ka === l && Yu(ia, y) && (aa === Lv || aa === sS && Yg(ia) && hi() - Qw < xI ? Lf(l, wt) : cS = Ln(cS, y)), Lo(l, T);
    }
    function FI(l, c) {
      c === Ni && (c = EW(l));
      var y = oo(), x = pS(l, c);
      x !== null && (Ac(x, c, y), Lo(x, y));
    }
    function XW(l) {
      var c = l.memoizedState, y = Ni;
      c !== null && (y = c.retryLane), FI(l, y);
    }
    function qW(l, c) {
      var y = Ni, x;
      switch (l.tag) {
        case V:
          x = l.stateNode;
          var T = l.memoizedState;
          T !== null && (y = T.retryLane);
          break;
        case he:
          x = l.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      x !== null && x.delete(c), FI(l, y);
    }
    function YW(l) {
      return l < 120 ? 120 : l < 480 ? 480 : l < 1080 ? 1080 : l < 1920 ? 1920 : l < 3e3 ? 3e3 : l < 4320 ? 4320 : bW(l / 1960) * 1960;
    }
    function KW() {
      if (Hv > _W)
        throw Hv = 0, t1 = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      dS > xW && (dS = 0, d("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function ZW() {
      Oo.flushLegacyContextWarning(), Oo.flushPendingUnsafeLifecycleWarnings();
    }
    function UI(l, c) {
      dr(l), bS(l, Ae, iW), c && bS(l, Ce, aW), bS(l, Ae, nW), c && bS(l, Ce, rW), ta();
    }
    function bS(l, c, y) {
      for (var x = l, T = null; x !== null; ) {
        var F = x.subtreeFlags & c;
        x !== T && x.child !== null && F !== De ? x = x.child : ((x.flags & c) !== De && y(x), x.sibling !== null ? x = x.sibling : x = T = x.return);
      }
    }
    var SS = null;
    function zI(l) {
      {
        if ((Wn & Va) !== Gi || !(l.mode & _r))
          return;
        var c = l.tag;
        if (c !== L && c !== N && c !== U && c !== I && c !== B && c !== q && c !== ne)
          return;
        var y = ue(l) || "ReactComponent";
        if (SS !== null) {
          if (SS.has(y))
            return;
          SS.add(y);
        } else
          SS = /* @__PURE__ */ new Set([y]);
        var x = io;
        try {
          dr(l), d("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          x ? dr(l) : ta();
        }
      }
    }
    var a1;
    {
      var QW = null;
      a1 = function(l, c, y) {
        var x = GI(QW, c);
        try {
          return KD(l, c, y);
        } catch (F) {
          if (F !== null && typeof F == "object" && typeof F.then == "function")
            throw F;
          if (m(), KP(), ZD(l, c), GI(c, x), c.mode & lr && Sw(c), eI(null, KD, null, l, c, y), y6()) {
            var T = tI();
            typeof T == "object" && T !== null && T._suppressLogging && typeof F == "object" && F !== null && !F._suppressLogging && (F._suppressLogging = !0);
          }
          throw F;
        }
      };
    }
    var BI = !1, o1;
    o1 = /* @__PURE__ */ new Set();
    function JW(l) {
      if (es && !D5())
        switch (l.tag) {
          case I:
          case B:
          case ne: {
            var c = yi && ue(yi) || "Unknown", y = c;
            if (!o1.has(y)) {
              o1.add(y);
              var x = ue(l) || "Unknown";
              d("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", x, c, c);
            }
            break;
          }
          case U: {
            BI || (d("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), BI = !0);
            break;
          }
        }
    }
    function kv(l, c) {
      if (Na) {
        var y = l.memoizedUpdaters;
        y.forEach(function(x) {
          Zg(l, x, c);
        });
      }
    }
    var s1 = {};
    function _S(l, c) {
      {
        var y = ul.current;
        return y !== null ? (y.push(c), s1) : tv(l, c);
      }
    }
    function HI(l) {
      if (l !== s1)
        return ab(l);
    }
    function VI() {
      return ul.current !== null;
    }
    function e8(l) {
      {
        if (l.mode & _r) {
          if (!SI())
            return;
        } else if (!yW() || Wn !== Gi || l.tag !== I && l.tag !== B && l.tag !== ne)
          return;
        if (ul.current === null) {
          var c = io;
          try {
            dr(l), d(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, ue(l));
          } finally {
            c ? dr(l) : ta();
          }
        }
      }
    }
    function t8(l) {
      l.tag !== Ec && SI() && ul.current === null && d(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var Us = null, qp = null, n8 = function(l) {
      Us = l;
    };
    function Yp(l) {
      {
        if (Us === null)
          return l;
        var c = Us(l);
        return c === void 0 ? l : c.current;
      }
    }
    function l1(l) {
      return Yp(l);
    }
    function c1(l) {
      {
        if (Us === null)
          return l;
        var c = Us(l);
        if (c === void 0) {
          if (l != null && typeof l.render == "function") {
            var y = Yp(l.render);
            if (l.render !== y) {
              var x = {
                $$typeof: $e,
                render: y
              };
              return l.displayName !== void 0 && (x.displayName = l.displayName), x;
            }
          }
          return l;
        }
        return c.current;
      }
    }
    function kI(l, c) {
      {
        if (Us === null)
          return !1;
        var y = l.elementType, x = c.type, T = !1, F = typeof x == "object" && x !== null ? x.$$typeof : null;
        switch (l.tag) {
          case U: {
            typeof x == "function" && (T = !0);
            break;
          }
          case I: {
            (typeof x == "function" || F === Oe) && (T = !0);
            break;
          }
          case B: {
            (F === $e || F === Oe) && (T = !0);
            break;
          }
          case q:
          case ne: {
            (F === Se || F === Oe) && (T = !0);
            break;
          }
          default:
            return !1;
        }
        if (T) {
          var k = Us(y);
          if (k !== void 0 && k === Us(x))
            return !0;
        }
        return !1;
      }
    }
    function $I(l) {
      {
        if (Us === null || typeof WeakSet != "function")
          return;
        qp === null && (qp = /* @__PURE__ */ new WeakSet()), qp.add(l);
      }
    }
    var r8 = function(l, c) {
      {
        if (Us === null)
          return;
        var y = c.staleFamilies, x = c.updatedFamilies;
        Zl(), mS(function() {
          u1(l.current, x, y);
        });
      }
    }, i8 = function(l, c) {
      {
        if (l.context !== ir)
          return;
        Zl(), mS(function() {
          YI(c, l, null, null);
        });
      }
    };
    function u1(l, c, y) {
      {
        var x = l.alternate, T = l.child, F = l.sibling, k = l.tag, J = l.type, re = null;
        switch (k) {
          case I:
          case ne:
          case U:
            re = J;
            break;
          case B:
            re = J.render;
            break;
        }
        if (Us === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var me = !1, we = !1;
        if (re !== null) {
          var qe = Us(re);
          qe !== void 0 && (y.has(qe) ? we = !0 : c.has(qe) && (k === U ? we = !0 : me = !0));
        }
        qp !== null && (qp.has(l) || x !== null && qp.has(x)) && (we = !0), we && (l._debugNeedsRemount = !0), (we || me) && oa(l, Jn, Vr), T !== null && !we && u1(T, c, y), F !== null && u1(F, c, y);
      }
    }
    var a8 = function(l, c) {
      {
        var y = /* @__PURE__ */ new Set(), x = new Set(c.map(function(T) {
          return T.current;
        }));
        return d1(l.current, x, y), y;
      }
    };
    function d1(l, c, y) {
      {
        var x = l.child, T = l.sibling, F = l.tag, k = l.type, J = null;
        switch (F) {
          case I:
          case ne:
          case U:
            J = k;
            break;
          case B:
            J = k.render;
            break;
        }
        var re = !1;
        J !== null && c.has(J) && (re = !0), re ? o8(l, y) : x !== null && d1(x, c, y), T !== null && d1(T, c, y);
      }
    }
    function o8(l, c) {
      {
        var y = s8(l, c);
        if (y)
          return;
        for (var x = l; ; ) {
          switch (x.tag) {
            case j:
              c.add(x.stateNode);
              return;
            case H:
              c.add(x.stateNode.containerInfo);
              return;
            case N:
              c.add(x.stateNode.containerInfo);
              return;
          }
          if (x.return === null)
            throw new Error("Expected to reach root first.");
          x = x.return;
        }
      }
    }
    function s8(l, c) {
      for (var y = l, x = !1; ; ) {
        if (y.tag === j)
          x = !0, c.add(y.stateNode);
        else if (y.child !== null) {
          y.child.return = y, y = y.child;
          continue;
        }
        if (y === l)
          return x;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === l)
            return x;
          y = y.return;
        }
        y.sibling.return = y.return, y = y.sibling;
      }
      return !1;
    }
    var f1;
    {
      f1 = !1;
      try {
        var WI = Object.preventExtensions({});
      } catch {
        f1 = !0;
      }
    }
    function l8(l, c, y, x) {
      this.tag = l, this.key = y, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = c, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = x, this.flags = De, this.subtreeFlags = De, this.deletions = null, this.lanes = wt, this.childLanes = wt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !f1 && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var ts = function(l, c, y, x) {
      return new l8(l, c, y, x);
    };
    function h1(l) {
      var c = l.prototype;
      return !!(c && c.isReactComponent);
    }
    function c8(l) {
      return typeof l == "function" && !h1(l) && l.defaultProps === void 0;
    }
    function u8(l) {
      if (typeof l == "function")
        return h1(l) ? U : I;
      if (l != null) {
        var c = l.$$typeof;
        if (c === $e)
          return B;
        if (c === Se)
          return q;
      }
      return L;
    }
    function Uf(l, c) {
      var y = l.alternate;
      y === null ? (y = ts(l.tag, c, l.key, l.mode), y.elementType = l.elementType, y.type = l.type, y.stateNode = l.stateNode, y._debugSource = l._debugSource, y._debugOwner = l._debugOwner, y._debugHookTypes = l._debugHookTypes, y.alternate = l, l.alternate = y) : (y.pendingProps = c, y.type = l.type, y.flags = De, y.subtreeFlags = De, y.deletions = null, y.actualDuration = 0, y.actualStartTime = -1), y.flags = l.flags & Lt, y.childLanes = l.childLanes, y.lanes = l.lanes, y.child = l.child, y.memoizedProps = l.memoizedProps, y.memoizedState = l.memoizedState, y.updateQueue = l.updateQueue;
      var x = l.dependencies;
      switch (y.dependencies = x === null ? null : {
        lanes: x.lanes,
        firstContext: x.firstContext
      }, y.sibling = l.sibling, y.index = l.index, y.ref = l.ref, y.selfBaseDuration = l.selfBaseDuration, y.treeBaseDuration = l.treeBaseDuration, y._debugNeedsRemount = l._debugNeedsRemount, y.tag) {
        case L:
        case I:
        case ne:
          y.type = Yp(l.type);
          break;
        case U:
          y.type = l1(l.type);
          break;
        case B:
          y.type = c1(l.type);
          break;
      }
      return y;
    }
    function d8(l, c) {
      l.flags &= Lt | We;
      var y = l.alternate;
      if (y === null)
        l.childLanes = wt, l.lanes = c, l.child = null, l.subtreeFlags = De, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null, l.selfBaseDuration = 0, l.treeBaseDuration = 0;
      else {
        l.childLanes = y.childLanes, l.lanes = y.lanes, l.child = y.child, l.subtreeFlags = De, l.deletions = null, l.memoizedProps = y.memoizedProps, l.memoizedState = y.memoizedState, l.updateQueue = y.updateQueue, l.type = y.type;
        var x = y.dependencies;
        l.dependencies = x === null ? null : {
          lanes: x.lanes,
          firstContext: x.firstContext
        }, l.selfBaseDuration = y.selfBaseDuration, l.treeBaseDuration = y.treeBaseDuration;
      }
      return l;
    }
    function f8(l, c, y) {
      var x;
      return l === Hg ? (x = _r, c === !0 && (x |= di, x |= Mo)) : x = An, Na && (x |= lr), ts(N, null, null, x);
    }
    function p1(l, c, y, x, T, F) {
      var k = L, J = l;
      if (typeof l == "function")
        h1(l) ? (k = U, J = l1(J)) : J = Yp(J);
      else if (typeof l == "string")
        k = j;
      else
        e: switch (l) {
          case se:
            return yd(y.children, T, F, c);
          case Ie:
            k = ae, T |= di, (T & _r) !== An && (T |= Mo);
            break;
          case be:
            return h8(y, T, F, c);
          case te:
            return p8(y, T, F, c);
          case Y:
            return m8(y, T, F, c);
          case Ze:
            return jI(y, T, F, c);
          case nt:
          case Pe:
          case ht:
          case pt:
          case Ve:
          default: {
            if (typeof l == "object" && l !== null)
              switch (l.$$typeof) {
                case et:
                  k = K;
                  break e;
                case Xe:
                  k = Z;
                  break e;
                case $e:
                  k = B, J = c1(J);
                  break e;
                case Se:
                  k = q;
                  break e;
                case Oe:
                  k = ce, J = null;
                  break e;
              }
            var re = "";
            {
              (l === void 0 || typeof l == "object" && l !== null && Object.keys(l).length === 0) && (re += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var me = x ? ue(x) : null;
              me && (re += `

Check the render method of \`` + me + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (l == null ? l : typeof l) + "." + re));
          }
        }
      var we = ts(k, y, c, T);
      return we.elementType = l, we.type = J, we.lanes = F, we._debugOwner = x, we;
    }
    function m1(l, c, y) {
      var x = null;
      x = l._owner;
      var T = l.type, F = l.key, k = l.props, J = p1(T, F, k, x, c, y);
      return J._debugSource = l._source, J._debugOwner = l._owner, J;
    }
    function yd(l, c, y, x) {
      var T = ts(X, l, x, c);
      return T.lanes = y, T;
    }
    function h8(l, c, y, x) {
      typeof l.id != "string" && d('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof l.id);
      var T = ts(Q, l, x, c | lr);
      return T.elementType = be, T.lanes = y, T.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, T;
    }
    function p8(l, c, y, x) {
      var T = ts(V, l, x, c);
      return T.elementType = te, T.lanes = y, T;
    }
    function m8(l, c, y, x) {
      var T = ts(he, l, x, c);
      return T.elementType = Y, T.lanes = y, T;
    }
    function jI(l, c, y, x) {
      var T = ts(ve, l, x, c);
      T.elementType = Ze, T.lanes = y;
      var F = {};
      return T.stateNode = F, T;
    }
    function g1(l, c, y) {
      var x = ts(G, l, null, c);
      return x.lanes = y, x;
    }
    function g8() {
      var l = ts(j, null, null, An);
      return l.elementType = "DELETED", l;
    }
    function v8(l) {
      var c = ts(oe, null, null, An);
      return c.stateNode = l, c;
    }
    function v1(l, c, y) {
      var x = l.children !== null ? l.children : [], T = ts(H, x, l.key, c);
      return T.lanes = y, T.stateNode = {
        containerInfo: l.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: l.implementation
      }, T;
    }
    function GI(l, c) {
      return l === null && (l = ts(L, null, null, An)), l.tag = c.tag, l.key = c.key, l.elementType = c.elementType, l.type = c.type, l.stateNode = c.stateNode, l.return = c.return, l.child = c.child, l.sibling = c.sibling, l.index = c.index, l.ref = c.ref, l.pendingProps = c.pendingProps, l.memoizedProps = c.memoizedProps, l.updateQueue = c.updateQueue, l.memoizedState = c.memoizedState, l.dependencies = c.dependencies, l.mode = c.mode, l.flags = c.flags, l.subtreeFlags = c.subtreeFlags, l.deletions = c.deletions, l.lanes = c.lanes, l.childLanes = c.childLanes, l.alternate = c.alternate, l.actualDuration = c.actualDuration, l.actualStartTime = c.actualStartTime, l.selfBaseDuration = c.selfBaseDuration, l.treeBaseDuration = c.treeBaseDuration, l._debugSource = c._debugSource, l._debugOwner = c._debugOwner, l._debugNeedsRemount = c._debugNeedsRemount, l._debugHookTypes = c._debugHookTypes, l;
    }
    function y8(l, c, y, x, T) {
      this.tag = c, this.containerInfo = l, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = Wi, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Ni, this.eventTimes = Ku(wt), this.expirationTimes = Ku(Vr), this.pendingLanes = wt, this.suspendedLanes = wt, this.pingedLanes = wt, this.expiredLanes = wt, this.mutableReadLanes = wt, this.finishedLanes = wt, this.entangledLanes = wt, this.entanglements = Ku(wt), this.identifierPrefix = x, this.onRecoverableError = T, ri && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var F = this.pendingUpdatersLaneMap = [], k = 0; k < uf; k++)
          F.push(/* @__PURE__ */ new Set());
      }
      switch (c) {
        case Hg:
          this._debugRootType = y ? "hydrateRoot()" : "createRoot()";
          break;
        case Ec:
          this._debugRootType = y ? "hydrate()" : "render()";
          break;
      }
    }
    function XI(l, c, y, x, T, F, k, J, re, me) {
      var we = new y8(l, c, y, J, re), qe = f8(c, F);
      we.current = qe, qe.stateNode = we;
      {
        var at = {
          element: x,
          isDehydrated: y,
          cache: null,
          // not enabled yet
          transitions: null
        };
        qe.memoizedState = at;
      }
      return dn(qe), we;
    }
    var b8 = "18.0.0-fc46dba67-20220329";
    function S8(l, c, y) {
      var x = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return EC(x), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Te,
        key: x == null ? null : "" + x,
        children: l,
        containerInfo: c,
        implementation: y
      };
    }
    var y1, b1;
    y1 = !1, b1 = {};
    function qI(l) {
      if (!l)
        return ir;
      var c = g(l), y = sp(c);
      if (c.tag === U) {
        var x = c.type;
        if (wo(x))
          return Ko(c, x, y);
      }
      return y;
    }
    function _8(l) {
      var c = g(l);
      if (c === void 0) {
        if (typeof l.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var y = Object.keys(l).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + y);
      }
      var x = Zn(c);
      return x === null ? null : x.stateNode;
    }
    function x8(l, c) {
      {
        var y = g(l);
        if (y === void 0) {
          if (typeof l.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var x = Object.keys(l).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + x);
        }
        var T = Zn(y);
        if (T === null)
          return null;
        if (T.mode & di) {
          var F = ue(y) || "Component";
          if (!b1[F]) {
            b1[F] = !0;
            var k = io;
            try {
              dr(T), y.mode & di ? d("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", c, c, F) : d("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", c, c, F);
            } finally {
              k ? dr(k) : ta();
            }
          }
        }
        return T.stateNode;
      }
    }
    function E8(l, c, y, x, T, F, k, J) {
      var re = !1, me = null;
      return XI(l, c, re, me, y, x, T, F, k);
    }
    function C8(l, c, y, x, T, F, k, J, re, me) {
      var we = !0, qe = XI(y, x, we, l, T, F, k, J, re);
      qe.context = qI(null);
      var at = qe.current, dt = oo(), At = gd(at), Dt = xn(dt, At);
      return Dt.callback = c ?? null, $n(at, Dt), CW(qe, At, dt), qe;
    }
    function YI(l, c, y, x) {
      pi(c, l);
      var T = c.current, F = oo(), k = gd(T);
      kl(k);
      var J = qI(y);
      c.context === null ? c.context = J : c.pendingContext = J, es && io !== null && !y1 && (y1 = !0, d(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, ue(io) || "Unknown"));
      var re = xn(F, k);
      re.payload = {
        element: l
      }, x = x === void 0 ? null : x, x !== null && (typeof x != "function" && d("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", x), re.callback = x), $n(T, re);
      var me = oa(T, k, F);
      return me !== null && mi(me, T, k), k;
    }
    function w8(l) {
      var c = l.current;
      if (!c.child)
        return null;
      switch (c.child.tag) {
        case j:
          return Xr(c.child.stateNode);
        default:
          return c.child.stateNode;
      }
    }
    function M8(l) {
      switch (l.tag) {
        case N:
          var c = l.stateNode;
          if ($l(c)) {
            var y = Xg(c);
            TW(c, y);
          }
          break;
        case V:
          var x = oo();
          mS(function() {
            return oa(l, Jn, x);
          });
          var T = Jn;
          S1(l, T);
          break;
      }
    }
    function KI(l, c) {
      var y = l.memoizedState;
      y !== null && y.dehydrated !== null && (y.retryLane = qt(y.retryLane, c));
    }
    function S1(l, c) {
      KI(l, c);
      var y = l.alternate;
      y && KI(y, c);
    }
    function T8(l) {
      if (l.tag === V) {
        var c = oo(), y = Ul;
        oa(l, y, c), S1(l, y);
      }
    }
    function R8(l) {
      if (l.tag === V) {
        var c = oo(), y = gd(l);
        oa(l, y, c), S1(l, y);
      }
    }
    function A8(l) {
      var c = Nt(l);
      return c === null ? null : c.stateNode;
    }
    var ZI = function(l) {
      return null;
    };
    function QI(l) {
      return ZI(l);
    }
    var JI = function(l) {
      return !1;
    };
    function eN(l) {
      return JI(l);
    }
    var tN = null, nN = null, rN = null, iN = null, aN = null, oN = null, sN = null, lN = null, cN = null;
    {
      var uN = function(l, c, y) {
        var x = c[y], T = Tn(l) ? l.slice() : p({}, l);
        return y + 1 === c.length ? (Tn(T) ? T.splice(x, 1) : delete T[x], T) : (T[x] = uN(l[x], c, y + 1), T);
      }, dN = function(l, c) {
        return uN(l, c, 0);
      }, fN = function(l, c, y, x) {
        var T = c[x], F = Tn(l) ? l.slice() : p({}, l);
        if (x + 1 === c.length) {
          var k = y[x];
          F[k] = F[T], Tn(F) ? F.splice(T, 1) : delete F[T];
        } else
          F[T] = fN(
            // $FlowFixMe number or string is fine here
            l[T],
            c,
            y,
            x + 1
          );
        return F;
      }, hN = function(l, c, y) {
        if (c.length !== y.length) {
          u("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var x = 0; x < y.length - 1; x++)
            if (c[x] !== y[x]) {
              u("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return fN(l, c, y, 0);
      }, pN = function(l, c, y, x) {
        if (y >= c.length)
          return x;
        var T = c[y], F = Tn(l) ? l.slice() : p({}, l);
        return F[T] = pN(l[T], c, y + 1, x), F;
      }, mN = function(l, c, y) {
        return pN(l, c, 0, y);
      }, _1 = function(l, c) {
        for (var y = l.memoizedState; y !== null && c > 0; )
          y = y.next, c--;
        return y;
      };
      tN = function(l, c, y, x) {
        var T = _1(l, c);
        if (T !== null) {
          var F = mN(T.memoizedState, y, x);
          T.memoizedState = F, T.baseState = F, l.memoizedProps = p({}, l.memoizedProps), oa(l, Jn, Vr);
        }
      }, nN = function(l, c, y) {
        var x = _1(l, c);
        if (x !== null) {
          var T = dN(x.memoizedState, y);
          x.memoizedState = T, x.baseState = T, l.memoizedProps = p({}, l.memoizedProps), oa(l, Jn, Vr);
        }
      }, rN = function(l, c, y, x) {
        var T = _1(l, c);
        if (T !== null) {
          var F = hN(T.memoizedState, y, x);
          T.memoizedState = F, T.baseState = F, l.memoizedProps = p({}, l.memoizedProps), oa(l, Jn, Vr);
        }
      }, iN = function(l, c, y) {
        l.pendingProps = mN(l.memoizedProps, c, y), l.alternate && (l.alternate.pendingProps = l.pendingProps), oa(l, Jn, Vr);
      }, aN = function(l, c) {
        l.pendingProps = dN(l.memoizedProps, c), l.alternate && (l.alternate.pendingProps = l.pendingProps), oa(l, Jn, Vr);
      }, oN = function(l, c, y) {
        l.pendingProps = hN(l.memoizedProps, c, y), l.alternate && (l.alternate.pendingProps = l.pendingProps), oa(l, Jn, Vr);
      }, sN = function(l) {
        oa(l, Jn, Vr);
      }, lN = function(l) {
        ZI = l;
      }, cN = function(l) {
        JI = l;
      };
    }
    function O8(l) {
      var c = Zn(l);
      return c === null ? null : c.stateNode;
    }
    function P8(l) {
      return null;
    }
    function D8() {
      return io;
    }
    function I8(l) {
      var c = l.findFiberByHostInstance, y = a.ReactCurrentDispatcher;
      return iv({
        bundleType: l.bundleType,
        version: l.version,
        rendererPackageName: l.rendererPackageName,
        rendererConfig: l.rendererConfig,
        overrideHookState: tN,
        overrideHookStateDeletePath: nN,
        overrideHookStateRenamePath: rN,
        overrideProps: iN,
        overridePropsDeletePath: aN,
        overridePropsRenamePath: oN,
        setErrorHandler: lN,
        setSuspenseHandler: cN,
        scheduleUpdate: sN,
        currentDispatcherRef: y,
        findHostInstanceByFiber: O8,
        findFiberByHostInstance: c || P8,
        // React Refresh
        findHostInstancesForRefresh: a8,
        scheduleRefresh: r8,
        scheduleRoot: i8,
        setRefreshHandler: n8,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: D8,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: b8
      });
    }
    return t.attemptContinuousHydration = T8, t.attemptHydrationAtCurrentPriority = R8, t.attemptSynchronousHydration = M8, t.batchedUpdates = AW, t.createComponentSelector = oW, t.createContainer = E8, t.createHasPseudoClassSelector = sW, t.createHydrationContainer = C8, t.createPortal = S8, t.createRoleSelector = lW, t.createTestNameSelector = uW, t.createTextSelector = cW, t.deferredUpdates = RW, t.discreteUpdates = OW, t.findAllNodes = aS, t.findBoundingRects = hW, t.findHostInstance = _8, t.findHostInstanceWithNoPortals = A8, t.findHostInstanceWithWarning = x8, t.flushControlled = DW, t.flushPassiveEffects = Zl, t.flushSync = mS, t.focusWithin = pW, t.getCurrentUpdatePriority = to, t.getFindAllNodesFailureDescription = fW, t.getPublicRootInstance = w8, t.injectIntoDevTools = I8, t.isAlreadyRendering = PW, t.observeVisibleRects = gW, t.registerMutableSourceForHydration = M5, t.runWithPriority = Jg, t.shouldError = QI, t.shouldSuspend = eN, t.updateContainer = YI, t;
  })), dT.exports;
}
Ee.env.NODE_ENV === "production" ? gA.exports = Ghe() : gA.exports = Xhe();
var qhe = gA.exports;
const Yhe = /* @__PURE__ */ y0(qhe);
var vA = { exports: {} }, fT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rU;
function Khe() {
  return rU || (rU = 1, function(n) {
    function e(B, Q) {
      var V = B.length;
      B.push(Q);
      e: for (; 0 < V; ) {
        var q = V - 1 >>> 1, ne = B[q];
        if (0 < i(ne, Q)) B[q] = Q, B[V] = ne, V = q;
        else break e;
      }
    }
    function t(B) {
      return B.length === 0 ? null : B[0];
    }
    function r(B) {
      if (B.length === 0) return null;
      var Q = B[0], V = B.pop();
      if (V !== Q) {
        B[0] = V;
        e: for (var q = 0, ne = B.length, ce = ne >>> 1; q < ce; ) {
          var ie = 2 * (q + 1) - 1, oe = B[ie], he = ie + 1, le = B[he];
          if (0 > i(oe, V)) he < ne && 0 > i(le, oe) ? (B[q] = le, B[he] = V, q = he) : (B[q] = oe, B[ie] = V, q = ie);
          else if (he < ne && 0 > i(le, V)) B[q] = le, B[he] = V, q = he;
          else break e;
        }
      }
      return Q;
    }
    function i(B, Q) {
      var V = B.sortIndex - Q.sortIndex;
      return V !== 0 ? V : B.id - Q.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var a = performance;
      n.unstable_now = function() {
        return a.now();
      };
    } else {
      var o = Date, s = o.now();
      n.unstable_now = function() {
        return o.now() - s;
      };
    }
    var u = [], d = [], f = 1, p = null, g = 3, v = !1, b = !1, E = !1, S = typeof setTimeout == "function" ? setTimeout : null, _ = typeof clearTimeout == "function" ? clearTimeout : null, w = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function C(B) {
      for (var Q = t(d); Q !== null; ) {
        if (Q.callback === null) r(d);
        else if (Q.startTime <= B) r(d), Q.sortIndex = Q.expirationTime, e(u, Q);
        else break;
        Q = t(d);
      }
    }
    function R(B) {
      if (E = !1, C(B), !b) if (t(u) !== null) b = !0, Z(P);
      else {
        var Q = t(d);
        Q !== null && K(R, Q.startTime - B);
      }
    }
    function P(B, Q) {
      b = !1, E && (E = !1, _(U), U = -1), v = !0;
      var V = g;
      try {
        for (C(Q), p = t(u); p !== null && (!(p.expirationTime > Q) || B && !H()); ) {
          var q = p.callback;
          if (typeof q == "function") {
            p.callback = null, g = p.priorityLevel;
            var ne = q(p.expirationTime <= Q);
            Q = n.unstable_now(), typeof ne == "function" ? p.callback = ne : p === t(u) && r(u), C(Q);
          } else r(u);
          p = t(u);
        }
        if (p !== null) var ce = !0;
        else {
          var ie = t(d);
          ie !== null && K(R, ie.startTime - Q), ce = !1;
        }
        return ce;
      } finally {
        p = null, g = V, v = !1;
      }
    }
    var D = !1, I = null, U = -1, L = 5, N = -1;
    function H() {
      return !(n.unstable_now() - N < L);
    }
    function j() {
      if (I !== null) {
        var B = n.unstable_now();
        N = B;
        var Q = !0;
        try {
          Q = I(!0, B);
        } finally {
          Q ? G() : (D = !1, I = null);
        }
      } else D = !1;
    }
    var G;
    if (typeof w == "function") G = function() {
      w(j);
    };
    else if (typeof MessageChannel < "u") {
      var X = new MessageChannel(), ae = X.port2;
      X.port1.onmessage = j, G = function() {
        ae.postMessage(null);
      };
    } else G = function() {
      S(j, 0);
    };
    function Z(B) {
      I = B, D || (D = !0, G());
    }
    function K(B, Q) {
      U = S(function() {
        B(n.unstable_now());
      }, Q);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(B) {
      B.callback = null;
    }, n.unstable_continueExecution = function() {
      b || v || (b = !0, Z(P));
    }, n.unstable_forceFrameRate = function(B) {
      0 > B || 125 < B ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : L = 0 < B ? Math.floor(1e3 / B) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return g;
    }, n.unstable_getFirstCallbackNode = function() {
      return t(u);
    }, n.unstable_next = function(B) {
      switch (g) {
        case 1:
        case 2:
        case 3:
          var Q = 3;
          break;
        default:
          Q = g;
      }
      var V = g;
      g = Q;
      try {
        return B();
      } finally {
        g = V;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(B, Q) {
      switch (B) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          B = 3;
      }
      var V = g;
      g = B;
      try {
        return Q();
      } finally {
        g = V;
      }
    }, n.unstable_scheduleCallback = function(B, Q, V) {
      var q = n.unstable_now();
      switch (typeof V == "object" && V !== null ? (V = V.delay, V = typeof V == "number" && 0 < V ? q + V : q) : V = q, B) {
        case 1:
          var ne = -1;
          break;
        case 2:
          ne = 250;
          break;
        case 5:
          ne = 1073741823;
          break;
        case 4:
          ne = 1e4;
          break;
        default:
          ne = 5e3;
      }
      return ne = V + ne, B = { id: f++, callback: Q, priorityLevel: B, startTime: V, expirationTime: ne, sortIndex: -1 }, V > q ? (B.sortIndex = V, e(d, B), t(u) === null && B === t(d) && (E ? (_(U), U = -1) : E = !0, K(R, V - q))) : (B.sortIndex = ne, e(u, B), b || v || (b = !0, Z(P))), B;
    }, n.unstable_shouldYield = H, n.unstable_wrapCallback = function(B) {
      var Q = g;
      return function() {
        var V = g;
        g = Q;
        try {
          return B.apply(this, arguments);
        } finally {
          g = V;
        }
      };
    };
  }(fT)), fT;
}
var hT = {}, iU;
function Zhe() {
  return iU || (iU = 1, function(n) {
    Ee.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function i(ye, Ue) {
        var Ye = ye.length;
        ye.push(Ue), s(ye, Ue, Ye);
      }
      function a(ye) {
        return ye.length === 0 ? null : ye[0];
      }
      function o(ye) {
        if (ye.length === 0)
          return null;
        var Ue = ye[0], Ye = ye.pop();
        return Ye !== Ue && (ye[0] = Ye, u(ye, Ye, 0)), Ue;
      }
      function s(ye, Ue, Ye) {
        for (var tt = Ye; tt > 0; ) {
          var st = tt - 1 >>> 1, Tt = ye[st];
          if (d(Tt, Ue) > 0)
            ye[st] = Ue, ye[tt] = Tt, tt = st;
          else
            return;
        }
      }
      function u(ye, Ue, Ye) {
        for (var tt = Ye, st = ye.length, Tt = st >>> 1; tt < Tt; ) {
          var Rt = (tt + 1) * 2 - 1, ue = ye[Rt], De = Rt + 1, Ge = ye[De];
          if (d(ue, Ue) < 0)
            De < st && d(Ge, ue) < 0 ? (ye[tt] = Ge, ye[De] = Ue, tt = De) : (ye[tt] = ue, ye[Rt] = Ue, tt = Rt);
          else if (De < st && d(Ge, Ue) < 0)
            ye[tt] = Ge, ye[De] = Ue, tt = De;
          else
            return;
        }
      }
      function d(ye, Ue) {
        var Ye = ye.sortIndex - Ue.sortIndex;
        return Ye !== 0 ? Ye : ye.id - Ue.id;
      }
      var f = 1, p = 2, g = 3, v = 4, b = 5;
      function E(ye, Ue) {
      }
      var S = typeof performance == "object" && typeof performance.now == "function";
      if (S) {
        var _ = performance;
        n.unstable_now = function() {
          return _.now();
        };
      } else {
        var w = Date, C = w.now();
        n.unstable_now = function() {
          return w.now() - C;
        };
      }
      var R = 1073741823, P = -1, D = 250, I = 5e3, U = 1e4, L = R, N = [], H = [], j = 1, G = null, X = g, ae = !1, Z = !1, K = !1, B = typeof setTimeout == "function" ? setTimeout : null, Q = typeof clearTimeout == "function" ? clearTimeout : null, V = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function q(ye) {
        for (var Ue = a(H); Ue !== null; ) {
          if (Ue.callback === null)
            o(H);
          else if (Ue.startTime <= ye)
            o(H), Ue.sortIndex = Ue.expirationTime, i(N, Ue);
          else
            return;
          Ue = a(H);
        }
      }
      function ne(ye) {
        if (K = !1, q(ye), !Z)
          if (a(N) !== null)
            Z = !0, Ze(ce);
          else {
            var Ue = a(H);
            Ue !== null && nt(ne, Ue.startTime - ye);
          }
      }
      function ce(ye, Ue) {
        Z = !1, K && (K = !1, ht()), ae = !0;
        var Ye = X;
        try {
          var tt;
          if (!t) return ie(ye, Ue);
        } finally {
          G = null, X = Ye, ae = !1;
        }
      }
      function ie(ye, Ue) {
        var Ye = Ue;
        for (q(Ye), G = a(N); G !== null && !e && !(G.expirationTime > Ye && (!ye || $e())); ) {
          var tt = G.callback;
          if (typeof tt == "function") {
            G.callback = null, X = G.priorityLevel;
            var st = G.expirationTime <= Ye, Tt = tt(st);
            Ye = n.unstable_now(), typeof Tt == "function" ? G.callback = Tt : G === a(N) && o(N), q(Ye);
          } else
            o(N);
          G = a(N);
        }
        if (G !== null)
          return !0;
        var Rt = a(H);
        return Rt !== null && nt(ne, Rt.startTime - Ye), !1;
      }
      function oe(ye, Ue) {
        switch (ye) {
          case f:
          case p:
          case g:
          case v:
          case b:
            break;
          default:
            ye = g;
        }
        var Ye = X;
        X = ye;
        try {
          return Ue();
        } finally {
          X = Ye;
        }
      }
      function he(ye) {
        var Ue;
        switch (X) {
          case f:
          case p:
          case g:
            Ue = g;
            break;
          default:
            Ue = X;
            break;
        }
        var Ye = X;
        X = Ue;
        try {
          return ye();
        } finally {
          X = Ye;
        }
      }
      function le(ye) {
        var Ue = X;
        return function() {
          var Ye = X;
          X = Ue;
          try {
            return ye.apply(this, arguments);
          } finally {
            X = Ye;
          }
        };
      }
      function ve(ye, Ue, Ye) {
        var tt = n.unstable_now(), st;
        if (typeof Ye == "object" && Ye !== null) {
          var Tt = Ye.delay;
          typeof Tt == "number" && Tt > 0 ? st = tt + Tt : st = tt;
        } else
          st = tt;
        var Rt;
        switch (ye) {
          case f:
            Rt = P;
            break;
          case p:
            Rt = D;
            break;
          case b:
            Rt = L;
            break;
          case v:
            Rt = U;
            break;
          case g:
          default:
            Rt = I;
            break;
        }
        var ue = st + Rt, De = {
          id: j++,
          callback: Ue,
          priorityLevel: ye,
          startTime: st,
          expirationTime: ue,
          sortIndex: -1
        };
        return st > tt ? (De.sortIndex = st, i(H, De), a(N) === null && De === a(H) && (K ? ht() : K = !0, nt(ne, st - tt))) : (De.sortIndex = ue, i(N, De), !Z && !ae && (Z = !0, Ze(ce))), De;
      }
      function Ne() {
      }
      function xe() {
        !Z && !ae && (Z = !0, Ze(ce));
      }
      function Me() {
        return a(N);
      }
      function $(ye) {
        ye.callback = null;
      }
      function Te() {
        return X;
      }
      var se = !1, Ie = null, be = -1, et = r, Xe = -1;
      function $e() {
        var ye = n.unstable_now() - Xe;
        return !(ye < et);
      }
      function te() {
      }
      function Y(ye) {
        if (ye < 0 || ye > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ye > 0 ? et = Math.floor(1e3 / ye) : et = r;
      }
      var Se = function() {
        if (Ie !== null) {
          var ye = n.unstable_now();
          Xe = ye;
          var Ue = !0, Ye = !0;
          try {
            Ye = Ie(Ue, ye);
          } finally {
            Ye ? Oe() : (se = !1, Ie = null);
          }
        } else
          se = !1;
      }, Oe;
      if (typeof V == "function")
        Oe = function() {
          V(Se);
        };
      else if (typeof MessageChannel < "u") {
        var Pe = new MessageChannel(), Ve = Pe.port2;
        Pe.port1.onmessage = Se, Oe = function() {
          Ve.postMessage(null);
        };
      } else
        Oe = function() {
          B(Se, 0);
        };
      function Ze(ye) {
        Ie = ye, se || (se = !0, Oe());
      }
      function nt(ye, Ue) {
        be = B(function() {
          ye(n.unstable_now());
        }, Ue);
      }
      function ht() {
        Q(be), be = -1;
      }
      var pt = te, Be = null;
      n.unstable_IdlePriority = b, n.unstable_ImmediatePriority = f, n.unstable_LowPriority = v, n.unstable_NormalPriority = g, n.unstable_Profiling = Be, n.unstable_UserBlockingPriority = p, n.unstable_cancelCallback = $, n.unstable_continueExecution = xe, n.unstable_forceFrameRate = Y, n.unstable_getCurrentPriorityLevel = Te, n.unstable_getFirstCallbackNode = Me, n.unstable_next = he, n.unstable_pauseExecution = Ne, n.unstable_requestPaint = pt, n.unstable_runWithPriority = oe, n.unstable_scheduleCallback = ve, n.unstable_shouldYield = $e, n.unstable_wrapCallback = le, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(hT)), hT;
}
Ee.env.NODE_ENV === "production" ? vA.exports = Khe() : vA.exports = Zhe();
var aU = vA.exports;
const xP = {}, F$ = (n) => void Object.assign(xP, n);
function Qhe(n, e) {
  function t(f, {
    args: p = [],
    attach: g,
    ...v
  }, b) {
    let E = `${f[0].toUpperCase()}${f.slice(1)}`, S;
    if (f === "primitive") {
      if (v.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const _ = v.object;
      S = Fm(_, {
        type: f,
        root: b,
        attach: g,
        primitive: !0
      });
    } else {
      const _ = xP[E];
      if (!_)
        throw new Error(`R3F: ${E} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(p)) throw new Error("R3F: The args prop must be an array!");
      S = Fm(new _(...p), {
        type: f,
        root: b,
        attach: g,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: p
        }
      });
    }
    return S.__r3f.attach === void 0 && (S instanceof Xn ? S.__r3f.attach = "geometry" : S instanceof Da && (S.__r3f.attach = "material")), E !== "inject" && gT(S, v), S;
  }
  function r(f, p) {
    let g = !1;
    if (p) {
      var v, b;
      (v = p.__r3f) != null && v.attach ? mT(f, p, p.__r3f.attach) : p.isObject3D && f.isObject3D && (f.add(p), g = !0), g || (b = f.__r3f) == null || b.objects.push(p), p.__r3f || Fm(p, {}), p.__r3f.parent = f, bA(p), Um(p);
    }
  }
  function i(f, p, g) {
    let v = !1;
    if (p) {
      var b, E;
      if ((b = p.__r3f) != null && b.attach)
        mT(f, p, p.__r3f.attach);
      else if (p.isObject3D && f.isObject3D) {
        p.parent = f, p.dispatchEvent({
          type: "added"
        }), f.dispatchEvent({
          type: "childadded",
          child: p
        });
        const S = f.children.filter((w) => w !== p), _ = S.indexOf(g);
        f.children = [...S.slice(0, _), p, ...S.slice(_)], v = !0;
      }
      v || (E = f.__r3f) == null || E.objects.push(p), p.__r3f || Fm(p, {}), p.__r3f.parent = f, bA(p), Um(p);
    }
  }
  function a(f, p, g = !1) {
    f && [...f].forEach((v) => o(p, v, g));
  }
  function o(f, p, g) {
    if (p) {
      var v, b, E;
      if (p.__r3f && (p.__r3f.parent = null), (v = f.__r3f) != null && v.objects && (f.__r3f.objects = f.__r3f.objects.filter((R) => R !== p)), (b = p.__r3f) != null && b.attach)
        uU(f, p, p.__r3f.attach);
      else if (p.isObject3D && f.isObject3D) {
        var S;
        f.remove(p), (S = p.__r3f) != null && S.root && ope(ox(p), p);
      }
      const w = (E = p.__r3f) == null ? void 0 : E.primitive, C = !w && (g === void 0 ? p.dispose !== null : g);
      if (!w) {
        var _;
        a((_ = p.__r3f) == null ? void 0 : _.objects, p, C), a(p.children, p, C);
      }
      if (delete p.__r3f, C && p.dispose && p.type !== "Scene") {
        const R = () => {
          try {
            p.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? aU.unstable_scheduleCallback(aU.unstable_IdlePriority, R) : R();
      }
      Um(f);
    }
  }
  function s(f, p, g, v) {
    var b;
    const E = (b = f.__r3f) == null ? void 0 : b.parent;
    if (!E) return;
    const S = t(p, g, f.__r3f.root);
    if (f.children) {
      for (const _ of f.children)
        _.__r3f && r(S, _);
      f.children = f.children.filter((_) => !_.__r3f);
    }
    f.__r3f.objects.forEach((_) => r(S, _)), f.__r3f.objects = [], f.__r3f.autoRemovedBeforeAppend || o(E, f), S.parent && (S.__r3f.autoRemovedBeforeAppend = !0), r(E, S), S.raycast && S.__r3f.eventCount && ox(S).getState().internal.interaction.push(S), [v, v.alternate].forEach((_) => {
      _ !== null && (_.stateNode = S, _.ref && (typeof _.ref == "function" ? _.ref(S) : _.ref.current = S));
    });
  }
  const u = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
  return {
    reconciler: Yhe({
      createInstance: t,
      removeChild: o,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (f, p) => {
        if (!p) return;
        const g = f.getState().scene;
        g.__r3f && (g.__r3f.root = f, r(g, p));
      },
      removeChildFromContainer: (f, p) => {
        p && o(f.getState().scene, p);
      },
      insertInContainerBefore: (f, p, g) => {
        if (!p || !g) return;
        const v = f.getState().scene;
        v.__r3f && i(v, p, g);
      },
      getRootHostContext: () => null,
      getChildHostContext: (f) => f,
      finalizeInitialChildren(f) {
        var p;
        return !!((p = f == null ? void 0 : f.__r3f) != null ? p : {}).handlers;
      },
      prepareUpdate(f, p, g, v) {
        var b;
        if (((b = f == null ? void 0 : f.__r3f) != null ? b : {}).primitive && v.object && v.object !== f)
          return [!0];
        {
          const {
            args: S = [],
            children: _,
            ...w
          } = v, {
            args: C = [],
            children: R,
            ...P
          } = g;
          if (!Array.isArray(S)) throw new Error("R3F: the args prop must be an array!");
          if (S.some((I, U) => I !== C[U])) return [!0];
          const D = $$(f, w, P, !0);
          return D.changes.length ? [!1, D] : null;
        }
      },
      commitUpdate(f, [p, g], v, b, E, S) {
        p ? s(f, v, E, S) : gT(f, g);
      },
      commitMount(f, p, g, v) {
        var b;
        const E = (b = f.__r3f) != null ? b : {};
        f.raycast && E.handlers && E.eventCount && ox(f).getState().internal.interaction.push(f);
      },
      getPublicInstance: (f) => f,
      prepareForCommit: () => null,
      preparePortalMount: (f) => Fm(f.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(f) {
        var p;
        const {
          attach: g,
          parent: v
        } = (p = f.__r3f) != null ? p : {};
        g && v && uU(v, f, g), f.isObject3D && (f.visible = !1), Um(f);
      },
      unhideInstance(f, p) {
        var g;
        const {
          attach: v,
          parent: b
        } = (g = f.__r3f) != null ? g : {};
        v && b && mT(b, f, v), (f.isObject3D && p.visible == null || p.visible) && (f.visible = !0), Um(f);
      },
      createTextInstance: u,
      hideTextInstance: u,
      unhideTextInstance: u,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-expect-error
      getCurrentEventPriority: () => e ? e() : Xm.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && si.fun(performance.now) ? performance.now : si.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: si.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: si.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: gT
  };
}
var oU, sU;
const pT = (n) => "colorSpace" in n || "outputColorSpace" in n, U$ = () => {
  var n;
  return (n = xP.ColorManagement) != null ? n : null;
}, z$ = (n) => n && n.isOrthographicCamera, Jhe = (n) => n && n.hasOwnProperty("current"), V0 = typeof window < "u" && ((oU = window.document) != null && oU.createElement || ((sU = window.navigator) == null ? void 0 : sU.product) === "ReactNative") ? O.useLayoutEffect : O.useEffect;
function B$(n) {
  const e = O.useRef(n);
  return V0(() => void (e.current = n), [n]), e;
}
function epe({
  set: n
}) {
  return V0(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class H$ extends O.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
H$.getDerivedStateFromError = () => ({
  error: !0
});
const V$ = "__default", lU = /* @__PURE__ */ new Map(), tpe = (n) => n && !!n.memoized && !!n.changes;
function k$(n) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const sy = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function ox(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const si = {
  obj: (n) => n === Object(n) && !si.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(n, e, {
    arrays: t = "shallow",
    objects: r = "reference",
    strict: i = !0
  } = {}) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (si.str(n) || si.num(n) || si.boo(n)) return n === e;
    const a = si.obj(n);
    if (a && r === "reference") return n === e;
    const o = si.arr(n);
    if (o && t === "reference") return n === e;
    if ((o || a) && n === e) return !0;
    let s;
    for (s in n) if (!(s in e)) return !1;
    if (a && t === "shallow" && r === "shallow") {
      for (s in i ? e : n) if (!si.equ(n[s], e[s], {
        strict: i,
        objects: "reference"
      })) return !1;
    } else
      for (s in i ? e : n) if (n[s] !== e[s]) return !1;
    if (si.und(s)) {
      if (o && n.length === 0 && e.length === 0 || a && Object.keys(n).length === 0 && Object.keys(e).length === 0) return !0;
      if (n !== e) return !1;
    }
    return !0;
  }
};
function npe(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n)
    e.dispose == null || e.dispose(), delete n[e];
}
function Fm(n, e) {
  const t = n;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, n;
}
function yA(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"), i = r.pop();
    return t = r.reduce((a, o) => a[o], n), {
      target: t,
      key: i
    };
  } else return {
    target: t,
    key: e
  };
}
const cU = /-\d+$/;
function mT(n, e, t) {
  if (si.str(t)) {
    if (cU.test(t)) {
      const a = t.replace(cU, ""), {
        target: o,
        key: s
      } = yA(n, a);
      Array.isArray(o[s]) || (o[s] = []);
    }
    const {
      target: r,
      key: i
    } = yA(n, t);
    e.__r3f.previousAttach = r[i], r[i] = e;
  } else e.__r3f.previousAttach = t(n, e);
}
function uU(n, e, t) {
  var r, i;
  if (si.str(t)) {
    const {
      target: a,
      key: o
    } = yA(n, t), s = e.__r3f.previousAttach;
    s === void 0 ? delete a[o] : a[o] = s;
  } else (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function $$(n, {
  children: e,
  key: t,
  ref: r,
  ...i
}, {
  children: a,
  key: o,
  ref: s,
  ...u
} = {}, d = !1) {
  const f = n.__r3f, p = Object.entries(i), g = [];
  if (d) {
    const b = Object.keys(u);
    for (let E = 0; E < b.length; E++)
      i.hasOwnProperty(b[E]) || p.unshift([b[E], V$ + "remove"]);
  }
  p.forEach(([b, E]) => {
    var S;
    if ((S = n.__r3f) != null && S.primitive && b === "object" || si.equ(E, u[b])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(b)) return g.push([b, E, !0, []]);
    let _ = [];
    b.includes("-") && (_ = b.split("-")), g.push([b, E, !1, _]);
    for (const w in i) {
      const C = i[w];
      w.startsWith(`${b}-`) && g.push([w, C, !1, w.split("-")]);
    }
  });
  const v = {
    ...i
  };
  return f != null && f.memoizedProps && f != null && f.memoizedProps.args && (v.args = f.memoizedProps.args), f != null && f.memoizedProps && f != null && f.memoizedProps.attach && (v.attach = f.memoizedProps.attach), {
    memoized: v,
    changes: g
  };
}
const rpe = typeof Ee < "u" && Ee.env.NODE_ENV !== "production";
function gT(n, e) {
  var t;
  const r = n.__r3f, i = r == null ? void 0 : r.root, a = i == null || i.getState == null ? void 0 : i.getState(), {
    memoized: o,
    changes: s
  } = tpe(e) ? e : $$(n, e), u = r == null ? void 0 : r.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = o);
  for (let f = 0; f < s.length; f++) {
    let [p, g, v, b] = s[f];
    if (pT(n)) {
      const w = "srgb", C = "srgb-linear";
      p === "encoding" ? (p = "colorSpace", g = g === 3001 ? w : C) : p === "outputEncoding" && (p = "outputColorSpace", g = g === 3001 ? w : C);
    }
    let E = n, S = E[p];
    if (b.length && (S = b.reduce((_, w) => _[w], n), !(S && S.set))) {
      const [_, ...w] = b.reverse();
      E = w.reverse().reduce((C, R) => C[R], n), p = _;
    }
    if (g === V$ + "remove")
      if (E.constructor) {
        let _ = lU.get(E.constructor);
        _ || (_ = new E.constructor(), lU.set(E.constructor, _)), g = _[p];
      } else
        g = 0;
    if (v && r)
      g ? r.handlers[p] = g : delete r.handlers[p], r.eventCount = Object.keys(r.handlers).length;
    else if (S && S.set && (S.copy || S instanceof wh)) {
      if (Array.isArray(g))
        S.fromArray ? S.fromArray(g) : S.set(...g);
      else if (S.copy && g && g.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (rpe ? S.constructor.name === g.constructor.name : S.constructor === g.constructor))
        S.copy(g);
      else if (g !== void 0) {
        const _ = S instanceof an;
        !_ && S.setScalar ? S.setScalar(g) : S instanceof wh && g instanceof wh ? S.mask = g.mask : S.set(g), !U$() && a && !a.linear && _ && S.convertSRGBToLinear();
      }
    } else if (E[p] = g, E[p] instanceof Ei && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
    E[p].format === Xa && E[p].type === Ml && a) {
      const _ = E[p];
      pT(_) && pT(a.gl) ? _.colorSpace = a.gl.outputColorSpace : _.encoding = a.gl.outputEncoding;
    }
    Um(n);
  }
  if (r && r.parent && n.raycast && u !== r.eventCount) {
    const f = ox(n).getState().internal, p = f.interaction.indexOf(n);
    p > -1 && f.interaction.splice(p, 1), r.eventCount && f.interaction.push(n);
  }
  return !(s.length === 1 && s[0][0] === "onUpdate") && s.length && (t = n.__r3f) != null && t.parent && bA(n), n;
}
function Um(n) {
  var e, t;
  const r = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function bA(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function ipe(n, e) {
  n.manual || (z$(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld());
}
function z_(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function ape() {
  var n;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e) return Xm.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Xm.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Xm.ContinuousEventPriority;
    default:
      return Xm.DefaultEventPriority;
  }
}
function W$(n, e, t, r) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function ope(n, e) {
  const {
    internal: t
  } = n.getState();
  t.interaction = t.interaction.filter((r) => r !== e), t.initialHits = t.initialHits.filter((r) => r !== e), t.hovered.forEach((r, i) => {
    (r.eventObject === e || r.object === e) && t.hovered.delete(i);
  }), t.capturedMap.forEach((r, i) => {
    W$(t.capturedMap, e, r, i);
  });
}
function spe(n) {
  function e(u) {
    const {
      internal: d
    } = n.getState(), f = u.offsetX - d.initialClick[0], p = u.offsetY - d.initialClick[1];
    return Math.round(Math.sqrt(f * f + p * p));
  }
  function t(u) {
    return u.filter((d) => ["Move", "Over", "Enter", "Out", "Leave"].some((f) => {
      var p;
      return (p = d.__r3f) == null ? void 0 : p.handlers["onPointer" + f];
    }));
  }
  function r(u, d) {
    const f = n.getState(), p = /* @__PURE__ */ new Set(), g = [], v = d ? d(f.internal.interaction) : f.internal.interaction;
    for (let _ = 0; _ < v.length; _++) {
      const w = sy(v[_]);
      w && (w.raycaster.camera = void 0);
    }
    f.previousRoot || f.events.compute == null || f.events.compute(u, f);
    function b(_) {
      const w = sy(_);
      if (!w || !w.events.enabled || w.raycaster.camera === null) return [];
      if (w.raycaster.camera === void 0) {
        var C;
        w.events.compute == null || w.events.compute(u, w, (C = w.previousRoot) == null ? void 0 : C.getState()), w.raycaster.camera === void 0 && (w.raycaster.camera = null);
      }
      return w.raycaster.camera ? w.raycaster.intersectObject(_, !0) : [];
    }
    let E = v.flatMap(b).sort((_, w) => {
      const C = sy(_.object), R = sy(w.object);
      return !C || !R ? _.distance - w.distance : R.events.priority - C.events.priority || _.distance - w.distance;
    }).filter((_) => {
      const w = z_(_);
      return p.has(w) ? !1 : (p.add(w), !0);
    });
    f.events.filter && (E = f.events.filter(E, f));
    for (const _ of E) {
      let w = _.object;
      for (; w; ) {
        var S;
        (S = w.__r3f) != null && S.eventCount && g.push({
          ..._,
          eventObject: w
        }), w = w.parent;
      }
    }
    if ("pointerId" in u && f.internal.capturedMap.has(u.pointerId))
      for (let _ of f.internal.capturedMap.get(u.pointerId).values())
        p.has(z_(_.intersection)) || g.push(_.intersection);
    return g;
  }
  function i(u, d, f, p) {
    const g = n.getState();
    if (u.length) {
      const v = {
        stopped: !1
      };
      for (const b of u) {
        const E = sy(b.object) || g, {
          raycaster: S,
          pointer: _,
          camera: w,
          internal: C
        } = E, R = new de(_.x, _.y, 0).unproject(w), P = (N) => {
          var H, j;
          return (H = (j = C.capturedMap.get(N)) == null ? void 0 : j.has(b.eventObject)) != null ? H : !1;
        }, D = (N) => {
          const H = {
            intersection: b,
            target: d.target
          };
          C.capturedMap.has(N) ? C.capturedMap.get(N).set(b.eventObject, H) : C.capturedMap.set(N, /* @__PURE__ */ new Map([[b.eventObject, H]])), d.target.setPointerCapture(N);
        }, I = (N) => {
          const H = C.capturedMap.get(N);
          H && W$(C.capturedMap, b.eventObject, H, N);
        };
        let U = {};
        for (let N in d) {
          let H = d[N];
          typeof H != "function" && (U[N] = H);
        }
        let L = {
          ...b,
          ...U,
          pointer: _,
          intersections: u,
          stopped: v.stopped,
          delta: f,
          unprojectedPoint: R,
          ray: S.ray,
          camera: w,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const N = "pointerId" in d && C.capturedMap.get(d.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!N || // ... or if the hit object is capturing the pointer
              N.has(b.eventObject)) && (L.stopped = v.stopped = !0, C.hovered.size && Array.from(C.hovered.values()).find((H) => H.eventObject === b.eventObject))
            ) {
              const H = u.slice(0, u.indexOf(b));
              a([...H, b]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: P,
            setPointerCapture: D,
            releasePointerCapture: I
          },
          currentTarget: {
            hasPointerCapture: P,
            setPointerCapture: D,
            releasePointerCapture: I
          },
          nativeEvent: d
        };
        if (p(L), v.stopped === !0) break;
      }
    }
    return u;
  }
  function a(u) {
    const {
      internal: d
    } = n.getState();
    for (const f of d.hovered.values())
      if (!u.length || !u.find((p) => p.object === f.object && p.index === f.index && p.instanceId === f.instanceId)) {
        const g = f.eventObject.__r3f, v = g == null ? void 0 : g.handlers;
        if (d.hovered.delete(z_(f)), g != null && g.eventCount) {
          const b = {
            ...f,
            intersections: u
          };
          v.onPointerOut == null || v.onPointerOut(b), v.onPointerLeave == null || v.onPointerLeave(b);
        }
      }
  }
  function o(u, d) {
    for (let f = 0; f < d.length; f++) {
      const p = d[f].__r3f;
      p == null || p.handlers.onPointerMissed == null || p.handlers.onPointerMissed(u);
    }
  }
  function s(u) {
    switch (u) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => a([]);
      case "onLostPointerCapture":
        return (d) => {
          const {
            internal: f
          } = n.getState();
          "pointerId" in d && f.capturedMap.has(d.pointerId) && requestAnimationFrame(() => {
            f.capturedMap.has(d.pointerId) && (f.capturedMap.delete(d.pointerId), a([]));
          });
        };
    }
    return function(f) {
      const {
        onPointerMissed: p,
        internal: g
      } = n.getState();
      g.lastEvent.current = f;
      const v = u === "onPointerMove", b = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick", S = r(f, v ? t : void 0), _ = b ? e(f) : 0;
      u === "onPointerDown" && (g.initialClick = [f.offsetX, f.offsetY], g.initialHits = S.map((C) => C.eventObject)), b && !S.length && _ <= 2 && (o(f, g.interaction), p && p(f)), v && a(S);
      function w(C) {
        const R = C.eventObject, P = R.__r3f, D = P == null ? void 0 : P.handlers;
        if (P != null && P.eventCount)
          if (v) {
            if (D.onPointerOver || D.onPointerEnter || D.onPointerOut || D.onPointerLeave) {
              const I = z_(C), U = g.hovered.get(I);
              U ? U.stopped && C.stopPropagation() : (g.hovered.set(I, C), D.onPointerOver == null || D.onPointerOver(C), D.onPointerEnter == null || D.onPointerEnter(C));
            }
            D.onPointerMove == null || D.onPointerMove(C);
          } else {
            const I = D[u];
            I ? (!b || g.initialHits.includes(R)) && (o(f, g.interaction.filter((U) => !g.initialHits.includes(U))), I(C)) : b && g.initialHits.includes(R) && o(f, g.interaction.filter((U) => !g.initialHits.includes(U)));
          }
      }
      i(S, f, _, w);
    };
  }
  return {
    handlePointer: s
  };
}
const j$ = (n) => !!(n != null && n.render), G$ = /* @__PURE__ */ O.createContext(null), lpe = (n, e) => {
  const t = $he((s, u) => {
    const d = new de(), f = new de(), p = new de();
    function g(_ = u().camera, w = f, C = u().size) {
      const {
        width: R,
        height: P,
        top: D,
        left: I
      } = C, U = R / P;
      w instanceof de ? p.copy(w) : p.set(...w);
      const L = _.getWorldPosition(d).distanceTo(p);
      if (z$(_))
        return {
          width: R / _.zoom,
          height: P / _.zoom,
          top: D,
          left: I,
          factor: 1,
          distance: L,
          aspect: U
        };
      {
        const N = _.fov * Math.PI / 180, H = 2 * Math.tan(N / 2) * L, j = H * (R / P);
        return {
          width: j,
          height: H,
          top: D,
          left: I,
          factor: R / j,
          distance: L,
          aspect: U
        };
      }
    }
    let v;
    const b = (_) => s((w) => ({
      performance: {
        ...w.performance,
        current: _
      }
    })), E = new St();
    return {
      set: s,
      get: u,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (_ = 1) => n(u(), _),
      advance: (_, w) => e(_, w, u()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new vP(),
      pointer: E,
      mouse: E,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const _ = u();
          v && clearTimeout(v), _.performance.current !== _.performance.min && b(_.performance.min), v = setTimeout(() => b(u().performance.max), _.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: g
      },
      setEvents: (_) => s((w) => ({
        ...w,
        events: {
          ...w.events,
          ..._
        }
      })),
      setSize: (_, w, C, R, P) => {
        const D = u().camera, I = {
          width: _,
          height: w,
          top: R || 0,
          left: P || 0,
          updateStyle: C
        };
        s((U) => ({
          size: I,
          viewport: {
            ...U.viewport,
            ...g(D, f, I)
          }
        }));
      },
      setDpr: (_) => s((w) => {
        const C = k$(_);
        return {
          viewport: {
            ...w.viewport,
            dpr: C,
            initialDpr: w.viewport.initialDpr || C
          }
        };
      }),
      setFrameloop: (_ = "always") => {
        const w = u().clock;
        w.stop(), w.elapsedTime = 0, _ !== "never" && (w.start(), w.elapsedTime = 0), s(() => ({
          frameloop: _
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ O.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (_, w, C) => {
          const R = u().internal;
          return R.priority = R.priority + (w > 0 ? 1 : 0), R.subscribers.push({
            ref: _,
            priority: w,
            store: C
          }), R.subscribers = R.subscribers.sort((P, D) => P.priority - D.priority), () => {
            const P = u().internal;
            P != null && P.subscribers && (P.priority = P.priority - (w > 0 ? 1 : 0), P.subscribers = P.subscribers.filter((D) => D.ref !== _));
          };
        }
      }
    };
  }), r = t.getState();
  let i = r.size, a = r.viewport.dpr, o = r.camera;
  return t.subscribe(() => {
    const {
      camera: s,
      size: u,
      viewport: d,
      gl: f,
      set: p
    } = t.getState();
    if (u.width !== i.width || u.height !== i.height || d.dpr !== a) {
      var g;
      i = u, a = d.dpr, ipe(s, u), f.setPixelRatio(d.dpr);
      const v = (g = u.updateStyle) != null ? g : typeof HTMLCanvasElement < "u" && f.domElement instanceof HTMLCanvasElement;
      f.setSize(u.width, u.height, v);
    }
    s !== o && (o = s, p((v) => ({
      viewport: {
        ...v.viewport,
        ...v.viewport.getCurrentViewport(s)
      }
    })));
  }), t.subscribe((s) => n(s)), t;
};
let B_, cpe = /* @__PURE__ */ new Set(), upe = /* @__PURE__ */ new Set(), dpe = /* @__PURE__ */ new Set();
function vT(n, e) {
  if (n.size)
    for (const {
      callback: t
    } of n.values())
      t(e);
}
function ly(n, e) {
  switch (n) {
    case "before":
      return vT(cpe, e);
    case "after":
      return vT(upe, e);
    case "tail":
      return vT(dpe, e);
  }
}
let yT, bT;
function ST(n, e, t) {
  let r = e.clock.getDelta();
  for (e.frameloop === "never" && typeof n == "number" && (r = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), yT = e.internal.subscribers, B_ = 0; B_ < yT.length; B_++)
    bT = yT[B_], bT.ref.current(bT.store.getState(), r, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function fpe(n) {
  let e = !1, t = !1, r, i, a;
  function o(d) {
    i = requestAnimationFrame(o), e = !0, r = 0, ly("before", d), t = !0;
    for (const p of n.values()) {
      var f;
      a = p.store.getState(), a.internal.active && (a.frameloop === "always" || a.internal.frames > 0) && !((f = a.gl.xr) != null && f.isPresenting) && (r += ST(d, a));
    }
    if (t = !1, ly("after", d), r === 0)
      return ly("tail", d), e = !1, cancelAnimationFrame(i);
  }
  function s(d, f = 1) {
    var p;
    if (!d) return n.forEach((g) => s(g.store.getState(), f));
    (p = d.gl.xr) != null && p.isPresenting || !d.internal.active || d.frameloop === "never" || (f > 1 ? d.internal.frames = Math.min(60, d.internal.frames + f) : t ? d.internal.frames = 2 : d.internal.frames = 1, e || (e = !0, requestAnimationFrame(o)));
  }
  function u(d, f = !0, p, g) {
    if (f && ly("before", d), p) ST(d, p, g);
    else for (const v of n.values()) ST(d, v.store.getState());
    f && ly("after", d);
  }
  return {
    loop: o,
    invalidate: s,
    advance: u
  };
}
function X$() {
  const n = O.useContext(G$);
  if (!n) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function tu(n = (t) => t, e) {
  return X$()(n, e);
}
function hpe(n, e = 0) {
  const t = X$(), r = t.getState().internal.subscribe, i = B$(n);
  return V0(() => r(i, e, t), [e, r, t]), null;
}
const fg = /* @__PURE__ */ new Map(), {
  invalidate: dU,
  advance: fU
} = fpe(fg), {
  reconciler: iE,
  applyProps: Am
} = Qhe(fg, ape), Om = {
  objects: "shallow",
  strict: !1
}, ppe = (n, e) => {
  const t = typeof n == "function" ? n(e) : n;
  return j$(t) ? t : new Hk({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...n
  });
};
function mpe(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: r,
      height: i,
      top: a,
      left: o,
      updateStyle: s = t
    } = e;
    return {
      width: r,
      height: i,
      top: a,
      left: o,
      updateStyle: s
    };
  } else if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
    const {
      width: r,
      height: i,
      top: a,
      left: o
    } = n.parentElement.getBoundingClientRect();
    return {
      width: r,
      height: i,
      top: a,
      left: o,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function gpe(n) {
  const e = fg.get(n), t = e == null ? void 0 : e.fiber, r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), a = r || lpe(dU, fU), o = t || iE.createContainer(a, Xm.ConcurrentRoot, null, !1, null, "", i, null);
  e || fg.set(n, {
    fiber: o,
    store: a
  });
  let s, u = !1, d;
  return {
    configure(f = {}) {
      let {
        gl: p,
        size: g,
        scene: v,
        events: b,
        onCreated: E,
        shadows: S = !1,
        linear: _ = !1,
        flat: w = !1,
        legacy: C = !1,
        orthographic: R = !1,
        frameloop: P = "always",
        dpr: D = [1, 2],
        performance: I,
        raycaster: U,
        camera: L,
        onPointerMissed: N
      } = f, H = a.getState(), j = H.gl;
      H.gl || H.set({
        gl: j = ppe(p, n)
      });
      let G = H.raycaster;
      G || H.set({
        raycaster: G = new _P()
      });
      const {
        params: X,
        ...ae
      } = U || {};
      if (si.equ(ae, G, Om) || Am(G, {
        ...ae
      }), si.equ(X, G.params, Om) || Am(G, {
        params: {
          ...G.params,
          ...X
        }
      }), !H.camera || H.camera === d && !si.equ(d, L, Om)) {
        d = L;
        const V = L instanceof D0, q = V ? L : R ? new L0(0, 0, 0, 0, 0.1, 1e3) : new sa(75, 0, 0.1, 1e3);
        V || (q.position.z = 5, L && (Am(q, L), ("aspect" in L || "left" in L || "right" in L || "bottom" in L || "top" in L) && (q.manual = !0, q.updateProjectionMatrix())), !H.camera && !(L != null && L.rotation) && q.lookAt(0, 0, 0)), H.set({
          camera: q
        }), G.camera = q;
      }
      if (!H.scene) {
        let V;
        v instanceof eE ? V = v : (V = new eE(), v && Am(V, v)), H.set({
          scene: Fm(V)
        });
      }
      if (!H.xr) {
        var Z;
        const V = (ce, ie) => {
          const oe = a.getState();
          oe.frameloop !== "never" && fU(ce, !0, oe, ie);
        }, q = () => {
          const ce = a.getState();
          ce.gl.xr.enabled = ce.gl.xr.isPresenting, ce.gl.xr.setAnimationLoop(ce.gl.xr.isPresenting ? V : null), ce.gl.xr.isPresenting || dU(ce);
        }, ne = {
          connect() {
            const ce = a.getState().gl;
            ce.xr.addEventListener("sessionstart", q), ce.xr.addEventListener("sessionend", q);
          },
          disconnect() {
            const ce = a.getState().gl;
            ce.xr.removeEventListener("sessionstart", q), ce.xr.removeEventListener("sessionend", q);
          }
        };
        typeof ((Z = j.xr) == null ? void 0 : Z.addEventListener) == "function" && ne.connect(), H.set({
          xr: ne
        });
      }
      if (j.shadowMap) {
        const V = j.shadowMap.enabled, q = j.shadowMap.type;
        if (j.shadowMap.enabled = !!S, si.boo(S))
          j.shadowMap.type = Ry;
        else if (si.str(S)) {
          var K;
          const ne = {
            basic: A4,
            percentage: UE,
            soft: Ry,
            variance: bl
          };
          j.shadowMap.type = (K = ne[S]) != null ? K : Ry;
        } else si.obj(S) && Object.assign(j.shadowMap, S);
        (V !== j.shadowMap.enabled || q !== j.shadowMap.type) && (j.shadowMap.needsUpdate = !0);
      }
      const B = U$();
      B && ("enabled" in B ? B.enabled = !C : "legacyMode" in B && (B.legacyMode = C)), u || Am(j, {
        outputEncoding: _ ? 3e3 : 3001,
        toneMapping: w ? lc : IO
      }), H.legacy !== C && H.set(() => ({
        legacy: C
      })), H.linear !== _ && H.set(() => ({
        linear: _
      })), H.flat !== w && H.set(() => ({
        flat: w
      })), p && !si.fun(p) && !j$(p) && !si.equ(p, j, Om) && Am(j, p), b && !H.events.handlers && H.set({
        events: b(a)
      });
      const Q = mpe(n, g);
      return si.equ(Q, H.size, Om) || H.setSize(Q.width, Q.height, Q.updateStyle, Q.top, Q.left), D && H.viewport.dpr !== k$(D) && H.setDpr(D), H.frameloop !== P && H.setFrameloop(P), H.onPointerMissed || H.set({
        onPointerMissed: N
      }), I && !si.equ(I, H.performance, Om) && H.set((V) => ({
        performance: {
          ...V.performance,
          ...I
        }
      })), s = E, u = !0, this;
    },
    render(f) {
      return u || this.configure(), iE.updateContainer(/* @__PURE__ */ zt.jsx(vpe, {
        store: a,
        children: f,
        onCreated: s,
        rootElement: n
      }), o, null, () => {
      }), a;
    },
    unmount() {
      q$(n);
    }
  };
}
function vpe({
  store: n,
  children: e,
  onCreated: t,
  rootElement: r
}) {
  return V0(() => {
    const i = n.getState();
    i.set((a) => ({
      internal: {
        ...a.internal,
        active: !0
      }
    })), t && t(i), n.getState().events.connected || i.events.connect == null || i.events.connect(r);
  }, []), /* @__PURE__ */ zt.jsx(G$.Provider, {
    value: n,
    children: e
  });
}
function q$(n, e) {
  const t = fg.get(n), r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1), iE.updateContainer(null, r, null, () => {
      i && setTimeout(() => {
        try {
          var a, o, s, u;
          i.events.disconnect == null || i.events.disconnect(), (a = i.gl) == null || (o = a.renderLists) == null || o.dispose == null || o.dispose(), (s = i.gl) == null || s.forceContextLoss == null || s.forceContextLoss(), (u = i.gl) != null && u.xr && i.xr.disconnect(), npe(i), fg.delete(n);
        } catch {
        }
      }, 500);
    });
  }
}
iE.injectIntoDevTools({
  bundleType: Ee.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: O.version
});
function SA(n, e, t) {
  var r, i, a, o, s;
  e == null && (e = 100);
  function u() {
    var f = Date.now() - o;
    f < e && f >= 0 ? r = setTimeout(u, e - f) : (r = null, t || (s = n.apply(a, i), a = i = null));
  }
  var d = function() {
    a = this, i = arguments, o = Date.now();
    var f = t && !r;
    return r || (r = setTimeout(u, e)), f && (s = n.apply(a, i), a = i = null), s;
  };
  return d.clear = function() {
    r && (clearTimeout(r), r = null);
  }, d.flush = function() {
    r && (s = n.apply(a, i), a = i = null, clearTimeout(r), r = null);
  }, d;
}
SA.debounce = SA;
var ype = SA;
const hU = /* @__PURE__ */ y0(ype);
function bpe(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: r,
    offsetSize: i
  } = n === void 0 ? {
    debounce: 0,
    scroll: !1,
    offsetSize: !1
  } : n;
  const a = r || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!a)
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [o, s] = Lr({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }), u = kt({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: o
  }), d = e ? typeof e == "number" ? e : e.scroll : null, f = e ? typeof e == "number" ? e : e.resize : null, p = kt(!1);
  In(() => (p.current = !0, () => void (p.current = !1)));
  const [g, v, b] = Mr(() => {
    const w = () => {
      if (!u.current.element) return;
      const {
        left: C,
        top: R,
        width: P,
        height: D,
        bottom: I,
        right: U,
        x: L,
        y: N
      } = u.current.element.getBoundingClientRect(), H = {
        left: C,
        top: R,
        width: P,
        height: D,
        bottom: I,
        right: U,
        x: L,
        y: N
      };
      u.current.element instanceof HTMLElement && i && (H.height = u.current.element.offsetHeight, H.width = u.current.element.offsetWidth), Object.freeze(H), p.current && !Epe(u.current.lastBounds, H) && s(u.current.lastBounds = H);
    };
    return [w, f ? hU(w, f) : w, d ? hU(w, d) : w];
  }, [s, i, d, f]);
  function E() {
    u.current.scrollContainers && (u.current.scrollContainers.forEach((w) => w.removeEventListener("scroll", b, !0)), u.current.scrollContainers = null), u.current.resizeObserver && (u.current.resizeObserver.disconnect(), u.current.resizeObserver = null);
  }
  function S() {
    u.current.element && (u.current.resizeObserver = new a(b), u.current.resizeObserver.observe(u.current.element), t && u.current.scrollContainers && u.current.scrollContainers.forEach((w) => w.addEventListener("scroll", b, {
      capture: !0,
      passive: !0
    })));
  }
  const _ = (w) => {
    !w || w === u.current.element || (E(), u.current.element = w, u.current.scrollContainers = Y$(w), S());
  };
  return _pe(b, !!t), Spe(v), In(() => {
    E(), S();
  }, [t, b, v]), In(() => E, []), [_, o, g];
}
function Spe(n) {
  In(() => {
    const e = n;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [n]);
}
function _pe(n, e) {
  In(() => {
    if (e) {
      const t = n;
      return window.addEventListener("scroll", t, {
        capture: !0,
        passive: !0
      }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [n, e]);
}
function Y$(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i
  } = window.getComputedStyle(n);
  return [t, r, i].some((a) => a === "auto" || a === "scroll") && e.push(n), [...e, ...Y$(n.parentElement)];
}
const xpe = ["x", "y", "top", "bottom", "left", "right", "width", "height"], Epe = (n, e) => xpe.every((t) => n[t] === e[t]);
var Cpe = Object.defineProperty, wpe = Object.defineProperties, Mpe = Object.getOwnPropertyDescriptors, pU = Object.getOwnPropertySymbols, Tpe = Object.prototype.hasOwnProperty, Rpe = Object.prototype.propertyIsEnumerable, mU = (n, e, t) => e in n ? Cpe(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, gU = (n, e) => {
  for (var t in e || (e = {}))
    Tpe.call(e, t) && mU(n, t, e[t]);
  if (pU)
    for (var t of pU(e))
      Rpe.call(e, t) && mU(n, t, e[t]);
  return n;
}, Ape = (n, e) => wpe(n, Mpe(e)), vU, yU;
typeof window < "u" && ((vU = window.document) != null && vU.createElement || ((yU = window.navigator) == null ? void 0 : yU.product) === "ReactNative") ? O.useLayoutEffect : O.useEffect;
function K$(n, e, t) {
  if (!n)
    return;
  if (t(n) === !0)
    return n;
  let r = n.child;
  for (; r; ) {
    const i = K$(r, e, t);
    if (i)
      return i;
    r = r.sibling;
  }
}
function Z$(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return n;
  }
}
const bU = console.error;
console.error = function() {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = bU;
    return;
  }
  return bU.apply(this, arguments);
};
const EP = Z$(O.createContext(null));
class Q$ extends O.Component {
  render() {
    return /* @__PURE__ */ O.createElement(EP.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
function Ope() {
  const n = O.useContext(EP);
  if (n === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = O.useId();
  return O.useMemo(() => {
    for (const r of [n, n == null ? void 0 : n.alternate]) {
      if (!r)
        continue;
      const i = K$(r, !1, (a) => {
        let o = a.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e)
            return !0;
          o = o.next;
        }
      });
      if (i)
        return i;
    }
  }, [n, e]);
}
function Ppe() {
  const n = Ope(), [e] = O.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      i && i !== EP && !e.has(i) && e.set(i, O.useContext(Z$(i)));
    }
    t = t.return;
  }
  return e;
}
function Dpe() {
  const n = Ppe();
  return O.useMemo(
    () => Array.from(n.keys()).reduce(
      (e, t) => (r) => /* @__PURE__ */ O.createElement(e, null, /* @__PURE__ */ O.createElement(t.Provider, Ape(gU({}, r), {
        value: n.get(t)
      }))),
      (e) => /* @__PURE__ */ O.createElement(Q$, gU({}, e))
    ),
    [n]
  );
}
const _T = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function Ipe(n) {
  const {
    handlePointer: e
  } = spe(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(t.offsetX / r.size.width * 2 - 1, -(t.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(_T).reduce((t, r) => ({
      ...t,
      [r]: e(r)
    }), {}),
    update: () => {
      var t;
      const {
        events: r,
        internal: i
      } = n.getState();
      (t = i.lastEvent) != null && t.current && r.handlers && r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const {
        set: i,
        events: a
      } = n.getState();
      a.disconnect == null || a.disconnect(), i((o) => ({
        events: {
          ...o.events,
          connected: t
        }
      })), Object.entries((r = a.handlers) != null ? r : []).forEach(([o, s]) => {
        const [u, d] = _T[o];
        t.addEventListener(u, s, {
          passive: d
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: r
      } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([a, o]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [s] = _T[a];
            r.connected.removeEventListener(s, o);
          }
        }), t((a) => ({
          events: {
            ...a.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
const Npe = /* @__PURE__ */ O.forwardRef(function({
  children: e,
  fallback: t,
  resize: r,
  style: i,
  gl: a,
  events: o = Ipe,
  eventSource: s,
  eventPrefix: u,
  shadows: d,
  linear: f,
  flat: p,
  legacy: g,
  orthographic: v,
  frameloop: b,
  dpr: E,
  performance: S,
  raycaster: _,
  camera: w,
  scene: C,
  onPointerMissed: R,
  onCreated: P,
  ...D
}, I) {
  O.useMemo(() => F$(zhe), []);
  const U = Dpe(), [L, N] = bpe({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...r
  }), H = O.useRef(null), j = O.useRef(null);
  O.useImperativeHandle(I, () => H.current);
  const G = B$(R), [X, ae] = O.useState(!1), [Z, K] = O.useState(!1);
  if (X) throw X;
  if (Z) throw Z;
  const B = O.useRef(null);
  V0(() => {
    const V = H.current;
    N.width > 0 && N.height > 0 && V && (B.current || (B.current = gpe(V)), B.current.configure({
      gl: a,
      events: o,
      shadows: d,
      linear: f,
      flat: p,
      legacy: g,
      orthographic: v,
      frameloop: b,
      dpr: E,
      performance: S,
      raycaster: _,
      camera: w,
      scene: C,
      size: N,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...q) => G.current == null ? void 0 : G.current(...q),
      onCreated: (q) => {
        q.events.connect == null || q.events.connect(s ? Jhe(s) ? s.current : s : j.current), u && q.setEvents({
          compute: (ne, ce) => {
            const ie = ne[u + "X"], oe = ne[u + "Y"];
            ce.pointer.set(ie / ce.size.width * 2 - 1, -(oe / ce.size.height) * 2 + 1), ce.raycaster.setFromCamera(ce.pointer, ce.camera);
          }
        }), P == null || P(q);
      }
    }), B.current.render(/* @__PURE__ */ zt.jsx(U, {
      children: /* @__PURE__ */ zt.jsx(H$, {
        set: K,
        children: /* @__PURE__ */ zt.jsx(O.Suspense, {
          fallback: /* @__PURE__ */ zt.jsx(epe, {
            set: ae
          }),
          children: e
        })
      })
    })));
  }), O.useEffect(() => {
    const V = H.current;
    if (V) return () => q$(V);
  }, []);
  const Q = s ? "none" : "auto";
  return /* @__PURE__ */ zt.jsx("div", {
    ref: j,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: Q,
      ...i
    },
    ...D,
    children: /* @__PURE__ */ zt.jsx("div", {
      ref: L,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ zt.jsx("canvas", {
        ref: H,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}), Lpe = /* @__PURE__ */ O.forwardRef(function(e, t) {
  return /* @__PURE__ */ zt.jsx(Q$, {
    children: /* @__PURE__ */ zt.jsx(Npe, {
      ...e,
      ref: t
    })
  });
});
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const _i = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, ft = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
}), Pm = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Zf(n) {
  return n.isPerspectiveCamera;
}
function Nd(n) {
  return n.isOrthographicCamera;
}
const Dm = Math.PI * 2, SU = Math.PI / 2, J$ = 1e-5, cy = Math.PI / 180;
function vl(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function Jr(n, e = J$) {
  return Math.abs(n) < e;
}
function Ir(n, e, t = J$) {
  return Jr(n - e, t);
}
function _U(n, e) {
  return Math.round(n / e) * e;
}
function uy(n) {
  return isFinite(n) ? n : n < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function dy(n) {
  return Math.abs(n) < Number.MAX_VALUE ? n : n * (1 / 0);
}
function H_(n, e, t, r, i = 1 / 0, a) {
  r = Math.max(1e-4, r);
  const o = 2 / r, s = o * a, u = 1 / (1 + s + 0.48 * s * s + 0.235 * s * s * s);
  let d = n - e;
  const f = e, p = i * r;
  d = vl(d, -p, p), e = n - d;
  const g = (t.value + o * d) * a;
  t.value = (t.value - o * g) * u;
  let v = e + (d + g) * u;
  return f - n > 0 == v > f && (v = f, t.value = (v - f) / a), v;
}
function xU(n, e, t, r, i = 1 / 0, a, o) {
  r = Math.max(1e-4, r);
  const s = 2 / r, u = s * a, d = 1 / (1 + u + 0.48 * u * u + 0.235 * u * u * u);
  let f = e.x, p = e.y, g = e.z, v = n.x - f, b = n.y - p, E = n.z - g;
  const S = f, _ = p, w = g, C = i * r, R = C * C, P = v * v + b * b + E * E;
  if (P > R) {
    const ae = Math.sqrt(P);
    v = v / ae * C, b = b / ae * C, E = E / ae * C;
  }
  f = n.x - v, p = n.y - b, g = n.z - E;
  const D = (t.x + s * v) * a, I = (t.y + s * b) * a, U = (t.z + s * E) * a;
  t.x = (t.x - s * D) * d, t.y = (t.y - s * I) * d, t.z = (t.z - s * U) * d, o.x = f + (v + D) * d, o.y = p + (b + I) * d, o.z = g + (E + U) * d;
  const L = S - n.x, N = _ - n.y, H = w - n.z, j = o.x - S, G = o.y - _, X = o.z - w;
  return L * j + N * G + H * X > 0 && (o.x = S, o.y = _, o.z = w, t.x = (o.x - S) / a, t.y = (o.y - _) / a, t.z = (o.z - w) / a), o;
}
function xT(n, e) {
  e.set(0, 0), n.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= n.length, e.y /= n.length;
}
function ET(n, e) {
  return Nd(n) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
}
class Fpe {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const i = this._listeners[e];
    if (i !== void 0) {
      const a = i.indexOf(t);
      a !== -1 && i.splice(a, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let a = 0, o = i.length; a < o; a++)
        i[a].call(this, e);
    }
  }
}
var CT;
const Upe = "2.8.5", V_ = 1 / 8, zpe = /Mac/.test((CT = globalThis == null ? void 0 : globalThis.navigator) === null || CT === void 0 ? void 0 : CT.platform);
let Dn, EU, k_, wT, Uo, jn, yr, Im, fy, Jl, ec, Qf, CU, wU, Ws, hy, Nm, MU, MT, TU, TT, RT, $_, AT = class _A extends Fpe {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    Dn = e.THREE, EU = Object.freeze(new Dn.Vector3(0, 0, 0)), k_ = Object.freeze(new Dn.Vector3(0, 1, 0)), wT = Object.freeze(new Dn.Vector3(0, 0, 1)), Uo = new Dn.Vector2(), jn = new Dn.Vector3(), yr = new Dn.Vector3(), Im = new Dn.Vector3(), fy = new Dn.Vector3(), Jl = new Dn.Vector3(), ec = new Dn.Vector3(), Qf = new Dn.Vector3(), CU = new Dn.Vector3(), wU = new Dn.Vector3(), Ws = new Dn.Spherical(), hy = new Dn.Spherical(), Nm = new Dn.Box3(), MU = new Dn.Box3(), MT = new Dn.Sphere(), TU = new Dn.Quaternion(), TT = new Dn.Quaternion(), RT = new Dn.Matrix4(), $_ = new Dn.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ft;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = ft.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = Pm.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new Dn.Vector3(), this._focalOffsetVelocity = new Dn.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (_, w, C) => {
      let R, P;
      if (Zf(this._camera)) {
        const D = jn.copy(this._camera.position).sub(this._target), I = this._camera.getEffectiveFOV() * cy, U = D.length() * Math.tan(I * 0.5);
        R = this.truckSpeed * _ * U / this._elementRect.height, P = this.truckSpeed * w * U / this._elementRect.height;
      } else if (Nd(this._camera)) {
        const D = this._camera;
        R = _ * (D.right - D.left) / D.zoom / this._elementRect.width, P = w * (D.top - D.bottom) / D.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (C ? this.setFocalOffset(this._focalOffsetEnd.x + R, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(R, 0, !0), this.forward(-P, !0)) : C ? this.setFocalOffset(this._focalOffsetEnd.x + R, this._focalOffsetEnd.y + P, this._focalOffsetEnd.z, !0) : this.truck(R, P, !0);
    }, this._rotateInternal = (_, w) => {
      const C = Dm * this.azimuthRotateSpeed * _ / this._elementRect.height, R = Dm * this.polarRotateSpeed * w / this._elementRect.height;
      this.rotate(C, R, !0);
    }, this._dollyInternal = (_, w, C) => {
      const R = Math.pow(0.95, -_ * this.dollySpeed), P = this._sphericalEnd.radius, D = this._sphericalEnd.radius * R, I = vl(D, this.minDistance, this.maxDistance), U = I - D;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(D, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(U, !0), this._dollyToNoClamp(I, !0)) : this._dollyToNoClamp(I, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? D : I) - P, this._dollyControlCoord.set(w, C)), this._lastDollyDirection = Math.sign(-_);
    }, this._zoomInternal = (_, w, C) => {
      const R = Math.pow(0.95, _ * this.dollySpeed), P = this._zoom, D = this._zoom * R;
      this.zoomTo(D, !0), this.dollyToCursor && (this._changedZoom += D - P, this._dollyControlCoord.set(w, C));
    }, typeof Dn > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new Dn.Quaternion().setFromUnitVectors(this._camera.up, k_), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = ft.NONE, this._target = new Dn.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new Dn.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new Dn.Spherical().setFromVector3(jn.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new Dn.Vector3(),
      new Dn.Vector3(),
      new Dn.Vector3(),
      new Dn.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new Dn.Box3(new Dn.Vector3(-1 / 0, -1 / 0, -1 / 0), new Dn.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new Dn.Vector2(), this.mouseButtons = {
      left: ft.ROTATE,
      middle: ft.DOLLY,
      right: ft.TRUCK,
      wheel: Zf(this._camera) ? ft.DOLLY : Nd(this._camera) ? ft.ZOOM : ft.NONE
    }, this.touches = {
      one: ft.TOUCH_ROTATE,
      two: Zf(this._camera) ? ft.TOUCH_DOLLY_TRUCK : Nd(this._camera) ? ft.TOUCH_ZOOM_TRUCK : ft.NONE,
      three: ft.TOUCH_TRUCK
    };
    const r = new Dn.Vector2(), i = new Dn.Vector2(), a = new Dn.Vector2(), o = (_) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const R = this._domElement.getBoundingClientRect(), P = _.clientX / R.width, D = _.clientY / R.height;
        if (P < this._interactiveArea.left || P > this._interactiveArea.right || D < this._interactiveArea.top || D > this._interactiveArea.bottom)
          return;
      }
      const w = _.pointerType !== "mouse" ? null : (_.buttons & _i.LEFT) === _i.LEFT ? _i.LEFT : (_.buttons & _i.MIDDLE) === _i.MIDDLE ? _i.MIDDLE : (_.buttons & _i.RIGHT) === _i.RIGHT ? _i.RIGHT : null;
      if (w !== null) {
        const R = this._findPointerByMouseButton(w);
        R && this._disposePointer(R);
      }
      if ((_.buttons & _i.LEFT) === _i.LEFT && this._lockedPointer)
        return;
      const C = {
        pointerId: _.pointerId,
        clientX: _.clientX,
        clientY: _.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: w
      };
      this._activePointers.push(C), this._domElement.ownerDocument.removeEventListener("pointermove", s, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.addEventListener("pointermove", s, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", u), this._isDragging = !0, g(_);
    }, s = (_) => {
      _.cancelable && _.preventDefault();
      const w = _.pointerId, C = this._lockedPointer || this._findPointerById(w);
      if (C) {
        if (C.clientX = _.clientX, C.clientY = _.clientY, C.deltaX = _.movementX, C.deltaY = _.movementY, this._state = 0, _.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (_.buttons & _i.LEFT) === _i.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (_.buttons & _i.MIDDLE) === _i.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (_.buttons & _i.RIGHT) === _i.RIGHT && (this._state = this._state | this.mouseButtons.right);
        v();
      }
    }, u = (_) => {
      const w = this._findPointerById(_.pointerId);
      if (!(w && w === this._lockedPointer)) {
        if (w && this._disposePointer(w), _.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = ft.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = ft.NONE;
        b();
      }
    };
    let d = -1;
    const f = (_) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === ft.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const D = this._domElement.getBoundingClientRect(), I = _.clientX / D.width, U = _.clientY / D.height;
        if (I < this._interactiveArea.left || I > this._interactiveArea.right || U < this._interactiveArea.top || U > this._interactiveArea.bottom)
          return;
      }
      if (_.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === ft.ROTATE || this.mouseButtons.wheel === ft.TRUCK) {
        const D = performance.now();
        d - D < 1e3 && this._getClientRect(this._elementRect), d = D;
      }
      const w = zpe ? -1 : -3, C = _.deltaMode === 1 ? _.deltaY / w : _.deltaY / (w * 10), R = this.dollyToCursor ? (_.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, P = this.dollyToCursor ? (_.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ft.ROTATE: {
          this._rotateInternal(_.deltaX, _.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case ft.TRUCK: {
          this._truckInternal(_.deltaX, _.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case ft.OFFSET: {
          this._truckInternal(_.deltaX, _.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case ft.DOLLY: {
          this._dollyInternal(-C, R, P), this._isUserControllingDolly = !0;
          break;
        }
        case ft.ZOOM: {
          this._zoomInternal(-C, R, P), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, p = (_) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _A.ACTION.NONE) {
          const w = _ instanceof PointerEvent ? _.pointerId : 0, C = this._findPointerById(w);
          C && this._disposePointer(C), this._domElement.ownerDocument.removeEventListener("pointermove", s, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u);
          return;
        }
        _.preventDefault();
      }
    }, g = (_) => {
      if (!this._enabled)
        return;
      if (xT(this._activePointers, Uo), this._getClientRect(this._elementRect), r.copy(Uo), i.copy(Uo), this._activePointers.length >= 2) {
        const C = Uo.x - this._activePointers[1].clientX, R = Uo.y - this._activePointers[1].clientY, P = Math.sqrt(C * C + R * R);
        a.set(0, P);
        const D = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, I = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(D, I);
      }
      if (this._state = 0, !_)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in _ && _.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (_.buttons & _i.LEFT) === _i.LEFT && (this._state = this._state | this.mouseButtons.left), (_.buttons & _i.MIDDLE) === _i.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (_.buttons & _i.RIGHT) === _i.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & ft.ROTATE) === ft.ROTATE || (this._state & ft.TOUCH_ROTATE) === ft.TOUCH_ROTATE || (this._state & ft.TOUCH_DOLLY_ROTATE) === ft.TOUCH_DOLLY_ROTATE || (this._state & ft.TOUCH_ZOOM_ROTATE) === ft.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & ft.TRUCK) === ft.TRUCK || (this._state & ft.TOUCH_TRUCK) === ft.TOUCH_TRUCK || (this._state & ft.TOUCH_DOLLY_TRUCK) === ft.TOUCH_DOLLY_TRUCK || (this._state & ft.TOUCH_ZOOM_TRUCK) === ft.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & ft.DOLLY) === ft.DOLLY || (this._state & ft.TOUCH_DOLLY) === ft.TOUCH_DOLLY || (this._state & ft.TOUCH_DOLLY_TRUCK) === ft.TOUCH_DOLLY_TRUCK || (this._state & ft.TOUCH_DOLLY_OFFSET) === ft.TOUCH_DOLLY_OFFSET || (this._state & ft.TOUCH_DOLLY_ROTATE) === ft.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & ft.ZOOM) === ft.ZOOM || (this._state & ft.TOUCH_ZOOM) === ft.TOUCH_ZOOM || (this._state & ft.TOUCH_ZOOM_TRUCK) === ft.TOUCH_ZOOM_TRUCK || (this._state & ft.TOUCH_ZOOM_OFFSET) === ft.TOUCH_ZOOM_OFFSET || (this._state & ft.TOUCH_ZOOM_ROTATE) === ft.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & ft.OFFSET) === ft.OFFSET || (this._state & ft.TOUCH_OFFSET) === ft.TOUCH_OFFSET || (this._state & ft.TOUCH_DOLLY_OFFSET) === ft.TOUCH_DOLLY_OFFSET || (this._state & ft.TOUCH_ZOOM_OFFSET) === ft.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, v = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = !1, xT(this._activePointers, Uo);
      const w = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, C = w ? -w.deltaX : i.x - Uo.x, R = w ? -w.deltaY : i.y - Uo.y;
      if (i.copy(Uo), ((this._state & ft.ROTATE) === ft.ROTATE || (this._state & ft.TOUCH_ROTATE) === ft.TOUCH_ROTATE || (this._state & ft.TOUCH_DOLLY_ROTATE) === ft.TOUCH_DOLLY_ROTATE || (this._state & ft.TOUCH_ZOOM_ROTATE) === ft.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(C, R), this._isUserControllingRotate = !0), (this._state & ft.DOLLY) === ft.DOLLY || (this._state & ft.ZOOM) === ft.ZOOM) {
        const P = this.dollyToCursor ? (r.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, D = this.dollyToCursor ? (r.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, I = this.dollyDragInverted ? -1 : 1;
        (this._state & ft.DOLLY) === ft.DOLLY ? (this._dollyInternal(I * R * V_, P, D), this._isUserControllingDolly = !0) : (this._zoomInternal(I * R * V_, P, D), this._isUserControllingZoom = !0);
      }
      if ((this._state & ft.TOUCH_DOLLY) === ft.TOUCH_DOLLY || (this._state & ft.TOUCH_ZOOM) === ft.TOUCH_ZOOM || (this._state & ft.TOUCH_DOLLY_TRUCK) === ft.TOUCH_DOLLY_TRUCK || (this._state & ft.TOUCH_ZOOM_TRUCK) === ft.TOUCH_ZOOM_TRUCK || (this._state & ft.TOUCH_DOLLY_OFFSET) === ft.TOUCH_DOLLY_OFFSET || (this._state & ft.TOUCH_ZOOM_OFFSET) === ft.TOUCH_ZOOM_OFFSET || (this._state & ft.TOUCH_DOLLY_ROTATE) === ft.TOUCH_DOLLY_ROTATE || (this._state & ft.TOUCH_ZOOM_ROTATE) === ft.TOUCH_ZOOM_ROTATE) {
        const P = Uo.x - this._activePointers[1].clientX, D = Uo.y - this._activePointers[1].clientY, I = Math.sqrt(P * P + D * D), U = a.y - I;
        a.set(0, I);
        const L = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, N = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & ft.TOUCH_DOLLY) === ft.TOUCH_DOLLY || (this._state & ft.TOUCH_DOLLY_ROTATE) === ft.TOUCH_DOLLY_ROTATE || (this._state & ft.TOUCH_DOLLY_TRUCK) === ft.TOUCH_DOLLY_TRUCK || (this._state & ft.TOUCH_DOLLY_OFFSET) === ft.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(U * V_, L, N), this._isUserControllingDolly = !0) : (this._zoomInternal(U * V_, L, N), this._isUserControllingZoom = !0);
      }
      ((this._state & ft.TRUCK) === ft.TRUCK || (this._state & ft.TOUCH_TRUCK) === ft.TOUCH_TRUCK || (this._state & ft.TOUCH_DOLLY_TRUCK) === ft.TOUCH_DOLLY_TRUCK || (this._state & ft.TOUCH_ZOOM_TRUCK) === ft.TOUCH_ZOOM_TRUCK) && (this._truckInternal(C, R, !1), this._isUserControllingTruck = !0), ((this._state & ft.OFFSET) === ft.OFFSET || (this._state & ft.TOUCH_OFFSET) === ft.TOUCH_OFFSET || (this._state & ft.TOUCH_DOLLY_OFFSET) === ft.TOUCH_DOLLY_OFFSET || (this._state & ft.TOUCH_ZOOM_OFFSET) === ft.TOUCH_ZOOM_OFFSET) && (this._truckInternal(C, R, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, b = () => {
      xT(this._activePointers, Uo), i.copy(Uo), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", s, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", s, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", E), this._domElement.ownerDocument.addEventListener("pointerlockerror", S), this._domElement.ownerDocument.addEventListener("pointermove", s, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", u), g());
    }, this.unlockPointer = () => {
      var _, w, C;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (_ = this._domElement) === null || _ === void 0 || _.ownerDocument.exitPointerLock(), (w = this._domElement) === null || w === void 0 || w.ownerDocument.removeEventListener("pointerlockchange", E), (C = this._domElement) === null || C === void 0 || C.ownerDocument.removeEventListener("pointerlockerror", S), this.cancel();
    };
    const E = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, S = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (_) => {
      this._domElement = _, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", o), this._domElement.addEventListener("pointercancel", u), this._domElement.addEventListener("wheel", f, { passive: !1 }), this._domElement.addEventListener("contextmenu", p);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", o), this._domElement.removeEventListener("pointercancel", u), this._domElement.removeEventListener("wheel", f, { passive: !1 }), this._domElement.removeEventListener("contextmenu", p), this._domElement.ownerDocument.removeEventListener("pointermove", s, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("pointerlockchange", E), this._domElement.ownerDocument.removeEventListener("pointerlockerror", S));
    }, this.cancel = () => {
      this._state !== ft.NONE && (this._state = ft.NONE, this._activePointers.length = 0, b());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = vl(e.width, 0, 1), this._interactiveArea.height = vl(e.height, 0, 1), this._interactiveArea.x = vl(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = vl(e.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, r = !1) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, r);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = !1) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, r = !1) {
    this._isUserControllingRotate = !1;
    const i = vl(e, this.minAzimuthAngle, this.maxAzimuthAngle), a = vl(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = a, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, r || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const o = !r || Ir(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ir(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = !1) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = Pm.NONE, this._changedDolly = 0, this._dollyToNoClamp(vl(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = !1) {
    const r = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const o = this._collisionTest(), s = Ir(o, this._spherical.radius);
      if (!(r > e) && s)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, o);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
    const a = !t || Ir(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(a);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = !1) {
    this._targetEnd.add(this._getCameraDirection(fy).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const r = !t || Ir(this._target.x, this._targetEnd.x, this.restThreshold) && Ir(this._target.y, this._targetEnd.y, this.restThreshold) && Ir(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = !1) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = vl(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
    const r = !t || Ir(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(r);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, r = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, r);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, r = !1) {
    this._camera.updateMatrix(), Jl.setFromMatrixColumn(this._camera.matrix, 0), ec.setFromMatrixColumn(this._camera.matrix, 1), Jl.multiplyScalar(e), ec.multiplyScalar(-t);
    const i = jn.copy(Jl).add(ec), a = yr.copy(this._targetEnd).add(i);
    return this.moveTo(a.x, a.y, a.z, r);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = !1) {
    jn.setFromMatrixColumn(this._camera.matrix, 0), jn.crossVectors(this._camera.up, jn), jn.multiplyScalar(e);
    const r = yr.copy(this._targetEnd).add(jn);
    return this.moveTo(r.x, r.y, r.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = !1) {
    return jn.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + jn.x, this._targetEnd.y + jn.y, this._targetEnd.z + jn.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, r, i = !1) {
    this._isUserControllingTruck = !1;
    const a = jn.set(e, t, r).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, a, this.boundaryFriction), this._needsUpdate = !0, i || this._target.copy(this._targetEnd);
    const o = !i || Ir(this._target.x, this._targetEnd.x, this.restThreshold) && Ir(this._target.y, this._targetEnd.y, this.restThreshold) && Ir(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, r, i = !1) {
    const s = jn.set(e, t, r).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(s.x, s.y, s.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: r = !1, paddingLeft: i = 0, paddingRight: a = 0, paddingBottom: o = 0, paddingTop: s = 0 } = {}) {
    const u = [], d = e.isBox3 ? Nm.copy(e) : Nm.setFromObject(e);
    d.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const f = _U(this._sphericalEnd.theta, SU), p = _U(this._sphericalEnd.phi, SU);
    u.push(this.rotateTo(f, p, t));
    const g = jn.setFromSpherical(this._sphericalEnd).normalize(), v = TU.setFromUnitVectors(g, wT), b = Ir(Math.abs(g.y), 1);
    b && v.multiply(TT.setFromAxisAngle(k_, f)), v.multiply(this._yAxisUpSpaceInverse);
    const E = MU.makeEmpty();
    yr.copy(d.min).applyQuaternion(v), E.expandByPoint(yr), yr.copy(d.min).setX(d.max.x).applyQuaternion(v), E.expandByPoint(yr), yr.copy(d.min).setY(d.max.y).applyQuaternion(v), E.expandByPoint(yr), yr.copy(d.max).setZ(d.min.z).applyQuaternion(v), E.expandByPoint(yr), yr.copy(d.min).setZ(d.max.z).applyQuaternion(v), E.expandByPoint(yr), yr.copy(d.max).setY(d.min.y).applyQuaternion(v), E.expandByPoint(yr), yr.copy(d.max).setX(d.min.x).applyQuaternion(v), E.expandByPoint(yr), yr.copy(d.max).applyQuaternion(v), E.expandByPoint(yr), E.min.x -= i, E.min.y -= o, E.max.x += a, E.max.y += s, v.setFromUnitVectors(wT, g), b && v.premultiply(TT.invert()), v.premultiply(this._yAxisUpSpace);
    const S = E.getSize(jn), _ = E.getCenter(yr).applyQuaternion(v);
    if (Zf(this._camera)) {
      const w = this.getDistanceToFitBox(S.x, S.y, S.z, r);
      u.push(this.moveTo(_.x, _.y, _.z, t)), u.push(this.dollyTo(w, t)), u.push(this.setFocalOffset(0, 0, 0, t));
    } else if (Nd(this._camera)) {
      const w = this._camera, C = w.right - w.left, R = w.top - w.bottom, P = r ? Math.max(C / S.x, R / S.y) : Math.min(C / S.x, R / S.y);
      u.push(this.moveTo(_.x, _.y, _.z, t)), u.push(this.zoomTo(P, t)), u.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(u);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const r = [], a = "isObject3D" in e ? _A.createBoundingSphere(e, MT) : MT.copy(e);
    if (r.push(this.moveTo(a.center.x, a.center.y, a.center.z, t)), Zf(this._camera)) {
      const o = this.getDistanceToFitSphere(a.radius);
      r.push(this.dollyTo(o, t));
    } else if (Nd(this._camera)) {
      const o = this._camera.right - this._camera.left, s = this._camera.top - this._camera.bottom, u = 2 * a.radius, d = Math.min(o / u, s / u);
      r.push(this.zoomTo(d, t));
    }
    return r.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(r);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, r, i, a, o, s = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Pm.NONE, this._changedDolly = 0;
    const u = yr.set(i, a, o), d = jn.set(e, t, r);
    this._targetEnd.copy(u), this._sphericalEnd.setFromVector3(d.sub(u).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, s || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const f = !s || Ir(this._target.x, this._targetEnd.x, this.restThreshold) && Ir(this._target.y, this._targetEnd.y, this.restThreshold) && Ir(this._target.z, this._targetEnd.z, this.restThreshold) && Ir(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ir(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Ir(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(f);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, r, i, a, o, s, u, d, f, p, g, v, b = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Pm.NONE, this._changedDolly = 0;
    const E = jn.set(i, a, o), S = yr.set(e, t, r);
    Ws.setFromVector3(S.sub(E).applyQuaternion(this._yAxisUpSpace));
    const _ = Im.set(f, p, g), w = yr.set(s, u, d);
    hy.setFromVector3(w.sub(_).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(E.lerp(_, v));
    const C = hy.theta - Ws.theta, R = hy.phi - Ws.phi, P = hy.radius - Ws.radius;
    this._sphericalEnd.set(Ws.radius + P * v, Ws.phi + R * v, Ws.theta + C * v), this.normalizeRotations(), this._needsUpdate = !0, b || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const D = !b || Ir(this._target.x, this._targetEnd.x, this.restThreshold) && Ir(this._target.y, this._targetEnd.y, this.restThreshold) && Ir(this._target.z, this._targetEnd.z, this.restThreshold) && Ir(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ir(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Ir(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(D);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, r, i = !1) {
    return this.setLookAt(e, t, r, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, r, i = !1) {
    const a = this.getPosition(jn), o = this.setLookAt(a.x, a.y, a.z, e, t, r, i);
    return this._sphericalEnd.phi = vl(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, r, i = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, r), this._needsUpdate = !0, i || this._focalOffset.copy(this._focalOffsetEnd);
    const a = !i || Ir(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && Ir(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && Ir(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(a);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, r) {
    this._camera.updateMatrixWorld(), Jl.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), ec.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Qf.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = jn.set(e, t, r), a = i.distanceTo(this._camera.position), o = i.sub(this._camera.position);
    Jl.multiplyScalar(o.x), ec.multiplyScalar(o.y), Qf.multiplyScalar(o.z), jn.copy(Jl).add(ec).add(Qf), jn.z = jn.z + a, this.dollyTo(a, !1), this.setFocalOffset(-jn.x, jn.y, -jn.z, !1), this.moveTo(e, t, r, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, r, i) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new Dn.Vector4(), typeof e == "number" ? this._viewport.set(e, t, r, i) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, r, i = !1) {
    if (ET(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const a = e / t, o = this._camera.getEffectiveFOV() * cy, s = this._camera.aspect;
    return ((i ? a > s : a < s) ? t : e / s) * 0.5 / Math.tan(o * 0.5) + r * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (ET(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * cy, r = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? t : r;
    return e / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = !0) {
    return (e && e.isVector3 ? e : new Dn.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = !0) {
    return (e && e.isVector3 ? e : new Dn.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = !0) {
    return (e || new Dn.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = !0) {
    return (e && e.isVector3 ? e : new Dn.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Dm, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Dm), this._spherical.theta += Dm * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Dm);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = !1) {
    if (!Ir(this._camera.up.x, this._cameraUp0.x) || !Ir(this._camera.up.y, this._cameraUp0.y) || !Ir(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const r = this.getPosition(jn);
      this.updateCameraUp(), this.setPosition(r.x, r.y, r.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, k_), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = jn.subVectors(this._target, this._camera.position).normalize(), t = yr.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
    const r = this.getPosition(jn);
    this.updateCameraUp(), this.setPosition(r.x, r.y, r.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, r = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, a = CU.subVectors(this._targetEnd, this._target), o = wU.subVectors(this._focalOffsetEnd, this._focalOffset), s = this._zoomEnd - this._zoom;
    if (Jr(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const p = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = H_(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, p, 1 / 0, e), this._needsUpdate = !0;
    }
    if (Jr(r))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const p = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = H_(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, p, 1 / 0, e), this._needsUpdate = !0;
    }
    if (Jr(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const p = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = H_(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, p, this.maxSpeed, e), this._needsUpdate = !0;
    }
    if (Jr(a.x) && Jr(a.y) && Jr(a.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const p = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      xU(this._target, this._targetEnd, this._targetVelocity, p, this.maxSpeed, e, this._target), this._needsUpdate = !0;
    }
    if (Jr(o.x) && Jr(o.y) && Jr(o.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const p = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      xU(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, p, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
    }
    if (Jr(s))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const p = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = H_(this._zoom, this._zoomEnd, this._zoomVelocity, p, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (Zf(this._camera) && this._changedDolly !== 0) {
        const p = this._spherical.radius - this._lastDistance, g = this._camera, v = this._getCameraDirection(fy), b = jn.copy(v).cross(g.up).normalize();
        b.lengthSq() === 0 && (b.x = 1);
        const E = yr.crossVectors(b, v), S = this._sphericalEnd.radius * Math.tan(g.getEffectiveFOV() * cy * 0.5), w = (this._sphericalEnd.radius - p - this._sphericalEnd.radius) / this._sphericalEnd.radius, C = Im.copy(this._targetEnd).add(b.multiplyScalar(this._dollyControlCoord.x * S * g.aspect)).add(E.multiplyScalar(this._dollyControlCoord.y * S)), R = jn.copy(this._targetEnd).lerp(C, w), P = this._lastDollyDirection === Pm.IN && this._spherical.radius <= this.minDistance, D = this._lastDollyDirection === Pm.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (P || D)) {
          this._sphericalEnd.radius -= p, this._spherical.radius -= p;
          const U = yr.copy(v).multiplyScalar(-p);
          R.add(U);
        }
        this._boundary.clampPoint(R, R);
        const I = yr.subVectors(R, this._targetEnd);
        this._targetEnd.copy(R), this._target.add(I), this._changedDolly -= p, Jr(this._changedDolly) && (this._changedDolly = 0);
      } else if (Nd(this._camera) && this._changedZoom !== 0) {
        const p = this._zoom - this._lastZoom, g = this._camera, v = jn.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (g.near + g.far) / (g.near - g.far)).unproject(g), b = yr.set(0, 0, -1).applyQuaternion(g.quaternion), E = Im.copy(v).add(b.multiplyScalar(-v.dot(g.up))), _ = -(this._zoom - p - this._zoom) / this._zoom, w = this._getCameraDirection(fy), C = this._targetEnd.dot(w), R = jn.copy(this._targetEnd).lerp(E, _), P = R.dot(w), D = w.multiplyScalar(P - C);
        R.sub(D), this._boundary.clampPoint(R, R);
        const I = yr.subVectors(R, this._targetEnd);
        this._targetEnd.copy(R), this._target.add(I), this._changedZoom -= p, Jr(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
    const u = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, u), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Jr(this._focalOffset.x) || !Jr(this._focalOffset.y) || !Jr(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Jl.setFromMatrixColumn(this._camera.matrix, 0), ec.setFromMatrixColumn(this._camera.matrix, 1), Qf.setFromMatrixColumn(this._camera.matrix, 2), Jl.multiplyScalar(this._focalOffset.x), ec.multiplyScalar(-this._focalOffset.y), Qf.multiplyScalar(this._focalOffset.z), jn.copy(Jl).add(ec).add(Qf), this._camera.position.add(jn)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), jn.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const f = this._needsUpdate;
    return f && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : f ? (this.dispatchEvent({ type: "update" }), Jr(t, this.restThreshold) && Jr(r, this.restThreshold) && Jr(i, this.restThreshold) && Jr(a.x, this.restThreshold) && Jr(a.y, this.restThreshold) && Jr(a.z, this.restThreshold) && Jr(o.x, this.restThreshold) && Jr(o.y, this.restThreshold) && Jr(o.z, this.restThreshold) && Jr(s, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !f && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = f, this._needsUpdate = !1, f;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: uy(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: uy(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: uy(this.maxPolarAngle),
      minAzimuthAngle: uy(this.minAzimuthAngle),
      maxAzimuthAngle: uy(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: jn.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = !1) {
    const r = JSON.parse(e);
    this.enabled = r.enabled, this.minDistance = r.minDistance, this.maxDistance = dy(r.maxDistance), this.minZoom = r.minZoom, this.maxZoom = dy(r.maxZoom), this.minPolarAngle = r.minPolarAngle, this.maxPolarAngle = dy(r.maxPolarAngle), this.minAzimuthAngle = dy(r.minAzimuthAngle), this.maxAzimuthAngle = dy(r.maxAzimuthAngle), this.smoothTime = r.smoothTime, this.draggingSmoothTime = r.draggingSmoothTime, this.dollySpeed = r.dollySpeed, this.truckSpeed = r.truckSpeed, this.dollyToCursor = r.dollyToCursor, this.verticalDragToForward = r.verticalDragToForward, this._target0.fromArray(r.target0), this._position0.fromArray(r.position0), this._zoom0 = r.zoom0, this._focalOffset0.fromArray(r.focalOffset0), this.moveTo(r.target[0], r.target[1], r.target[2], t), Ws.setFromVector3(jn.fromArray(r.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(Ws.theta, Ws.phi, t), this.dollyTo(Ws.radius, t), this.zoomTo(r.zoom, t), this.setFocalOffset(r.focalOffset[0], r.focalOffset[1], r.focalOffset[2], t), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", Upe), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, r) {
    const i = t.lengthSq();
    if (i === 0)
      return e;
    const a = yr.copy(t).add(e), s = this._boundary.clampPoint(a, Im).sub(a), u = s.lengthSq();
    if (u === 0)
      return e.add(t);
    if (u === i)
      return e;
    if (r === 0)
      return e.add(t).add(s);
    {
      const d = 1 + r * u / t.dot(s);
      return e.add(yr.copy(t).multiplyScalar(d)).add(s.multiplyScalar(1 - r));
    }
  }
  _updateNearPlaneCorners() {
    if (Zf(this._camera)) {
      const e = this._camera, t = e.near, r = e.getEffectiveFOV() * cy, i = Math.tan(r * 0.5) * t, a = i * e.aspect;
      this._nearPlaneCorners[0].set(-a, -i, 0), this._nearPlaneCorners[1].set(a, -i, 0), this._nearPlaneCorners[2].set(a, i, 0), this._nearPlaneCorners[3].set(-a, i, 0);
    } else if (Nd(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, r = e.left * t, i = e.right * t, a = e.top * t, o = e.bottom * t;
      this._nearPlaneCorners[0].set(r, a, 0), this._nearPlaneCorners[1].set(i, a, 0), this._nearPlaneCorners[2].set(i, o, 0), this._nearPlaneCorners[3].set(r, o, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || ET(this._camera, "_collisionTest"))
      return e;
    const r = this._getTargetDirection(fy);
    RT.lookAt(EU, r, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const a = yr.copy(this._nearPlaneCorners[i]);
      a.applyMatrix4(RT);
      const o = Im.addVectors(this._target, a);
      $_.set(o, r), $_.far = this._spherical.radius + 1;
      const s = $_.intersectObjects(this.colliderMeshes);
      s.length !== 0 && s[0].distance < e && (e = s[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const r = () => {
        this.removeEventListener("rest", r), t();
      };
      this.addEventListener("rest", r);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new Dn.Sphere()) {
    const r = t, i = r.center;
    Nm.makeEmpty(), e.traverseVisible((o) => {
      o.isMesh && Nm.expandByObject(o);
    }), Nm.getCenter(i);
    let a = 0;
    return e.traverseVisible((o) => {
      if (!o.isMesh)
        return;
      const s = o, u = s.geometry.clone();
      u.applyMatrix4(s.matrixWorld);
      const f = u.attributes.position;
      for (let p = 0, g = f.count; p < g; p++)
        jn.fromBufferAttribute(f, p), a = Math.max(a, i.distanceToSquared(jn));
    }), r.radius = Math.sqrt(a), r;
  }
};
const Bpe = /* @__PURE__ */ Al((n, e) => {
  Mr(() => {
    const P = {
      Box3: qa,
      MathUtils: {
        clamp: Ek.clamp
      },
      Matrix4: wn,
      Quaternion: po,
      Raycaster: _P,
      Sphere: Pa,
      Spherical: I$,
      Vector2: St,
      Vector3: de,
      Vector4: wr
    };
    AT.install({
      THREE: P
    }), F$({
      CameraControlsImpl: AT
    });
  }, []);
  const {
    camera: t,
    domElement: r,
    makeDefault: i,
    onStart: a,
    onEnd: o,
    onChange: s,
    regress: u,
    ...d
  } = n, f = tu((P) => P.camera), p = tu((P) => P.gl), g = tu((P) => P.invalidate), v = tu((P) => P.events), b = tu((P) => P.setEvents), E = tu((P) => P.set), S = tu((P) => P.get), _ = tu((P) => P.performance), w = t || f, C = r || v.connected || p.domElement, R = Mr(() => new AT(w), [w]);
  return hpe((P, D) => {
    R.enabled && R.update(D);
  }, -1), In(() => (R.connect(C), () => void R.disconnect()), [C, R]), In(() => {
    const P = (U) => {
      g(), u && _.regress(), s && s(U);
    }, D = (U) => {
      a && a(U);
    }, I = (U) => {
      o && o(U);
    };
    return R.addEventListener("update", P), R.addEventListener("controlstart", D), R.addEventListener("controlend", I), R.addEventListener("control", P), R.addEventListener("transitionstart", P), R.addEventListener("wake", P), () => {
      R.removeEventListener("update", P), R.removeEventListener("controlstart", D), R.removeEventListener("controlend", I), R.removeEventListener("control", P), R.removeEventListener("transitionstart", P), R.removeEventListener("wake", P);
    };
  }, [R, a, o, g, b, u, s]), In(() => {
    if (i) {
      const P = S().controls;
      return E({
        controls: R
      }), () => E({
        controls: P
      });
    }
  }, [i, R]), /* @__PURE__ */ O.createElement("primitive", gn({
    ref: e,
    object: R
  }, d));
}), Hpe = Ai.div`
  width: 100%;
  height: 100%;
`, Vpe = (n) => {
  const e = kt(null), t = M4(e), {
    containerSize: r = t,
    isHidden: i = !1,
    cameraPosition: a = nre,
    canvas3DRef: o,
    children: s
  } = n;
  return /* @__PURE__ */ zt.jsx(zt.Fragment, { children: /* @__PURE__ */ zt.jsx(
    Hpe,
    {
      ref: e,
      style: i ? {
        opacity: 0,
        position: "absolute",
        zIndex: -10,
        top: 0,
        overflow: "hidden"
      } : void 0,
      children: /* @__PURE__ */ zt.jsx(
        Lpe,
        {
          style: {
            width: r.width,
            height: r.height
          },
          resize: { offsetSize: !0 },
          camera: { position: a, fov: 50 },
          gl: { preserveDrawingBuffer: !0 },
          ref: o,
          children: /* @__PURE__ */ zt.jsx(kpe, { children: s })
        }
      )
    }
  ) });
}, kpe = (n) => {
  const e = kt(null), { children: t } = n;
  return /* @__PURE__ */ zt.jsxs("group", { "position-y": -1.3, children: [
    /* @__PURE__ */ zt.jsx(
      Bpe,
      {
        ref: e,
        minDistance: 1,
        maxDistance: 20,
        smoothTime: 0
      }
    ),
    t
  ] });
}, RU = (n) => {
  const { floorData: e, onClick: t } = n, {
    frameLength: r,
    frameWidth: i,
    adjustedThicknessOfWooden: a,
    frameThickness: o,
    endHeightOfWooden: s,
    startX: u,
    color: d = "black",
    positionZ: f
  } = e, p = new uu();
  p.moveTo(0, 0), p.lineTo(r, 0), p.lineTo(r, i), p.lineTo(0, i), p.lineTo(0, 0);
  const g = {
    depth: a,
    bevelEnabled: !1
  }, v = new Tg(p, g), b = u - o, E = s;
  return /* @__PURE__ */ zt.jsx(
    "mesh",
    {
      geometry: v,
      position: [b, E, f],
      rotation: [Math.PI / 2, 0, 0],
      onClick: (S) => {
        S.stopPropagation(), t && t();
      },
      children: /* @__PURE__ */ zt.jsx("meshBasicMaterial", { attach: "material", color: d })
    }
  );
}, $pe = (n, e, t, r) => [
  new St(n, e),
  new St(n, r),
  new St(t, r),
  new St(t, e)
], Wpe = ({ points: n, depth: e }) => {
  const t = new uu(n), r = { depth: e, bevelEnabled: !0 };
  return new Tg(t, r);
}, jpe = (n) => {
  const { woodenPoints: e, colorWooden: t, onClick: r } = n;
  return /* @__PURE__ */ zt.jsx(zt.Fragment, { children: e.map((i, a) => /* @__PURE__ */ zt.jsx(
    "mesh",
    {
      geometry: Wpe(i),
      onClick: (o) => {
        o.stopPropagation(), r && r();
      },
      children: /* @__PURE__ */ zt.jsx("lineBasicMaterial", { attach: "material", color: t })
    },
    a
  )) });
}, Gpe = (n) => {
  const { columnsData: e, onClick: t } = n, {
    startX: r = 0,
    startY: i = 0,
    columnCount: a = 2,
    frameLength: o = 0,
    frameWidth: s = 0,
    adjustedThicknessOfColumn: u = 0,
    adjustedThicknessOfWooden: d = 0,
    adjustedHeightOfColumn: f = 0,
    color: p = "black"
  } = e, g = [], v = new Cu(
    u,
    f,
    u
  );
  for (let b = 0; b < a; b++) {
    const E = b / (a - 1), S = (o - d * 2) * E;
    g.push({
      posX: S,
      posY: 0
    }), g.push({
      posX: S,
      posY: s - d * 2
    });
  }
  return /* @__PURE__ */ zt.jsx(zt.Fragment, { children: g.map((b, E) => /* @__PURE__ */ zt.jsx(
    "mesh",
    {
      geometry: v,
      position: [
        b.posX,
        f / 2 + i,
        b.posY
      ],
      onClick: t,
      children: /* @__PURE__ */ zt.jsx("meshBasicMaterial", { attach: "material", color: p })
    },
    E
  )) });
}, Xpe = (n) => {
  const { columnsData: e, onClick: t } = n, {
    startX: r = 0,
    startY: i = 0,
    columnCount: a = 2,
    frameLength: o = 0,
    frameWidth: s = 0,
    adjustedThicknessOfColumn: u = 0,
    adjustedThicknessOfWooden: d = 0,
    adjustedHeightOfColumn: f = 0,
    color: p = "black"
  } = e, g = [], v = new Cu(
    u,
    f,
    u
  );
  for (let b = 0; b < a; b++) {
    const E = b / (a - 1), S = i + s * E;
    g.push({
      posX: r,
      posY: S
    }), g.push({
      posX: r + o - d * 2,
      posY: S
    });
  }
  return /* @__PURE__ */ zt.jsx(zt.Fragment, { children: g.map((b, E) => /* @__PURE__ */ zt.jsx(
    "mesh",
    {
      geometry: v,
      position: [b.posX, f / 2, b.posY],
      onClick: t,
      children: /* @__PURE__ */ zt.jsx("meshBasicMaterial", { attach: "material", color: p })
    },
    E
  )) });
}, qpe = (n) => {
  var ne, ce, ie, oe, he, le;
  const { woodDeckData: e, onClick: t } = n, {
    lengthOfWooden: r,
    thicknessOfWooden: i,
    widthOfWooden: a,
    colorWooden: o,
    countWooden: s,
    gapSpacingWooden: u,
    heightOfColumn: d,
    columnCount: f = 2,
    thicknessOfColumn: p,
    startX: g = 0,
    startY: v = 0,
    startZ: b = 0,
    startPointOfLShape: E = 0,
    lengthOfLWooden: S,
    isLShape: _ = !1,
    countLColumn: w = 2
  } = e, C = r * Jf, R = i * Jf, P = a * Jf, D = u * Jf, I = d * Jf, U = p * Jf, L = S ? S * Jf : 0, N = [], H = I + v, j = H + R;
  for (let ve = 0; ve < s; ve++) {
    const Ne = g + ve * (P + D), xe = Ne + P, Me = $pe(
      Ne,
      H,
      xe,
      j
    );
    _ && ve >= E ? N.push({ points: Me, depth: L }) : N.push({ points: Me, depth: C });
  }
  const G = R, X = N == null ? void 0 : N[N.length - 1], Z = (((ie = (ce = X == null ? void 0 : X.points) == null ? void 0 : ce[((ne = X == null ? void 0 : X.points) == null ? void 0 : ne.length) - 1]) == null ? void 0 : ie.x) ?? 0) - g + G * 2, K = C + R * 2, B = N == null ? void 0 : N[E - 1], Q = ((le = (he = B == null ? void 0 : B.points) == null ? void 0 : he[((oe = X == null ? void 0 : X.points) == null ? void 0 : oe.length) - 1]) == null ? void 0 : le.x) ?? 0, V = Z - Q + g - D, q = L - C;
  return /* @__PURE__ */ zt.jsxs("group", { position: [0, 0, b], children: [
    /* @__PURE__ */ zt.jsx(
      jpe,
      {
        woodenPoints: N,
        colorWooden: o,
        onClick: t
      }
    ),
    /* @__PURE__ */ zt.jsx(
      RU,
      {
        floorData: {
          frameLength: Z,
          frameWidth: K,
          adjustedThicknessOfWooden: R,
          frameThickness: G,
          endHeightOfWooden: j,
          startX: g,
          positionZ: -R
        },
        onClick: t
      }
    ),
    _ && /* @__PURE__ */ zt.jsx(
      RU,
      {
        floorData: {
          frameLength: V,
          frameWidth: q,
          adjustedThicknessOfWooden: R,
          frameThickness: G,
          endHeightOfWooden: j,
          startX: Q + D,
          positionZ: C + R
        },
        onClick: t
      }
    ),
    /* @__PURE__ */ zt.jsx(
      Gpe,
      {
        columnsData: {
          startX: g,
          startY: v,
          adjustedThicknessOfColumn: U,
          columnCount: f,
          adjustedThicknessOfWooden: R,
          frameLength: Z,
          frameWidth: K,
          adjustedHeightOfColumn: I
        },
        onClick: t
      }
    ),
    _ && /* @__PURE__ */ zt.jsx(
      Xpe,
      {
        columnsData: {
          startX: Q + D,
          startY: C,
          adjustedThicknessOfColumn: U,
          columnCount: w,
          adjustedThicknessOfWooden: R,
          frameLength: V,
          frameWidth: q,
          adjustedHeightOfColumn: I
        },
        onClick: t
      }
    )
  ] });
}, Ype = 1 / 100, Jf = 0.1, Kpe = (n) => {
  const { woodDeckData: e, position: t, onClick: r } = n;
  return /* @__PURE__ */ zt.jsx("group", { scale: Ype, position: t || [0, 0, 0], children: /* @__PURE__ */ zt.jsx(qpe, { woodDeckData: e, onClick: r }) });
}, e5 = Al((n, e) => {
  const { position: t, data: r, triggerExport: i, onExportComplete: a } = n, { scene: o } = tu(), s = Mh(() => {
    try {
      const u = o.toJSON();
      return JSON.stringify(u, null, 2);
    } catch (u) {
      return console.error("Error exporting scene to JSON:", u), null;
    }
  }, [o]);
  return aE(e, () => ({
    exportJSONCallback: s
  })), In(() => {
    if (i) {
      const u = s();
      console.log("====>json", u), a && a(u);
    }
  }, [i, s, a]), /* @__PURE__ */ zt.jsx(zt.Fragment, { children: /* @__PURE__ */ zt.jsx(Kpe, { position: t, woodDeckData: r }) });
});
e5.displayName = "PainterScene";
const ome = (n) => {
  const { onDrop: e, wdData: t } = n, r = kt(null), i = M4(r), a = w4, [o, s] = Lr(
    t
  ), u = kt(null), [d, f] = Lr(null), p = Mh(() => new Promise((b) => {
    f(() => b);
  }), []), g = Mh(
    (b) => {
      d && (d(b), s(null)), f(null);
    },
    [d]
  );
  In(() => {
    t && s(t);
  }, [t]);
  const [, v] = yae({
    accept: ["WOOD_DECK", "L_WOOD_DECK"],
    drop: (b, E) => {
      a.getDialogParameter(b);
      const S = b.onParameterChanged(p());
      s(rre(b.objectTypeId === "L_WOOD_DECK")), S.then((I) => {
        I && e(b, I);
      });
      const { x: _, y: w } = E.getClientOffset(), C = new sa(
        75,
        i.width / i.height,
        0.1,
        1e3
      );
      C.position.z = 5;
      const R = new de(
        _ / window.innerWidth * 2 - 1,
        -(w / window.innerHeight) * 2 + 1,
        0.5
      );
      R.unproject(C);
      const P = R.sub(C.position).normalize(), D = -C.position.z / P.z;
      C.position.clone().add(P.multiplyScalar(D));
    }
  });
  return /* @__PURE__ */ zt.jsx(Lae, { ref: r, children: /* @__PURE__ */ zt.jsx(
    Vpe,
    {
      canvas3DRef: v,
      isHidden: !!o,
      children: o ? /* @__PURE__ */ zt.jsx(
        e5,
        {
          data: o,
          ref: u,
          triggerExport: !!d,
          onExportComplete: g
        }
      ) : null
    }
  ) });
}, sme = { DndContext: bae, DraggableItem: E4 }, lme = { RectangleModelDialog: ire, LModalDialog: are };
export {
  ome as ObjectModel,
  nme as PanelView,
  lme as PlugInDialog,
  sme as PluginDnd
};
